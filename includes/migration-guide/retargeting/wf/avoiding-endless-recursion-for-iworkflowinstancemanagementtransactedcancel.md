### <a name="avoiding-endless-recursion-for-iworkflowinstancemanagementtransactedcancel-and-iworkflowinstancemanagementtransactedterminate"></a>Evitando a recursão infinita para IWorkflowInstanceManagement.TransactedCancel e IWorkflowInstanceManagement.TransactedTerminate

|   |   |
|---|---|
|Detalhes|Em algumas circunstâncias, ao usar as APIs <xref:System.ServiceModel.Activities.IWorkflowInstanceManagement.TransactedCancel%2A?displayProperty=nameWithType> ou <xref:System.ServiceModel.Activities.IWorkflowInstanceManagement.TransactedTerminate%2A?displayProperty=nameWithType> para cancelar ou terminar uma instância de serviço de fluxo de trabalho, a instância de fluxo de trabalho pode encontrar um excedente de pilha devido à recursão infinita quando o tempo de execução do <code>Workflow</code> tenta persistir a instância de serviço como parte do processamento da solicitação. O problema ocorre quando a instância de fluxo de trabalho está em um estado em que está esperando a conclusão de outras solicitações do WCF pendentes para outro serviço. As operações <code>TransactedCancel</code> e <code>TransactedTerminate</code> criam itens de trabalho que são colocados na fila para a instância de serviço de fluxo de trabalho. Esses itens de trabalho não são executados como parte do processamento da solicitação <code>TransactedCancel/TransactedTerminate</code>. Como a instância de serviço do fluxo de trabalho está ocupada esperando a conclusão da outra solicitação do WCF pendente, o item de trabalho criado permanece na fila. A operação <code>TransactedCancel/TransactedTerminate</code> é concluída e o controle é retornado ao cliente. Quando a transação associada à operação <code>TransactedCancel/TransactedTerminate</code> tenta ser confirmada, ela precisa persistir o estado da instância de serviço do fluxo de trabalho. Mas como há uma solicitação de <code>WCF</code> pendente para a instância, o tempo de execução do fluxo de trabalho não consegue persistir a instância de serviço do fluxo de trabalho e um loop de recursão infinita causa o excedente de pilha. Como <code>TransactedCancel</code> e <code>TransactedTerminate</code> apenas criam um item de trabalho na memória, o fato de que existe uma transação não tem nenhum efeito. Uma reversão da transação não descarta o item de trabalho. Para resolver esse problema, começando com o .NET Framework 4.7.2, foi introduzido um <code>AppSetting</code> que pode ser adicionado ao serviço de fluxo de trabalho <code>web.config/app.config</code> para solicitar que as transações de <code>TransactedCancel</code> e <code>TransactedTerminate</code> sejam ignoradas. Isso permite que a transação seja confirmada sem esperar que a instância de fluxo de trabalho persista. A AppSetting para esse recurso é chamada de <code>microsoft:WorkflowServices:IgnoreTransactionsForTransactedCancelAndTransactedTerminate</code>. O valor <code>true</code> indica que a transação deve ser ignorada, evitando o excedente de pilha. O valor padrão dessa AppSetting é <code>false</code>, portanto, as instâncias de serviço do fluxo de trabalho existentes não são afetadas.|
|Sugestão|Se você estiver usando o AppFabric ou outro cliente <xref:System.ServiceModel.Activities.IWorkflowInstanceManagement> e encontrar um excedente de pilha na instância de serviço do fluxo de trabalho durante a tentativa de cancelar ou terminar uma instância de fluxo de trabalho, você poderá adicionar o seguinte à seção <code>&lt;appSettings&gt;</code> do arquivo web.config/app.config para o serviço de fluxo de trabalho:<pre><code class="lang-xml">&lt;add key=&quot;microsoft:WorkflowServices:IgnoreTransactionsForTransactedCancelAndTransactedTerminate&quot; value=&quot;true&quot;/&gt;&#13;&#10;</code></pre>Se o problema não ocorrer, não será necessário fazer isso.|
|Escopo|Microsoft Edge|
|Versão|4.7.2|
|Tipo|Redirecionando|

