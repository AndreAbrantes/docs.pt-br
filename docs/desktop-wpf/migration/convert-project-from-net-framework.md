---
title: Migrando aplicativos do WPF para o .NET Core 3,0
description: Saiba como migrar um aplicativo Windows Presentation Foundation (WPF) para o .NET Core 3,0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071307"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="7dbf3-103">Migrando aplicativos do WPF para o .NET Core</span><span class="sxs-lookup"><span data-stu-id="7dbf3-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="7dbf3-104">Este artigo aborda as etapas necessárias para migrar um aplicativo Windows Presentation Foundation (WPF) do .NET Framework para o .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="7dbf3-105">Se você não tiver um aplicativo WPF disponível para a porta, mas quiser experimentar o processo, poderá usar o aplicativo de exemplo do **Bean de Trader** disponível no [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="7dbf3-106">O aplicativo original (direcionamento .NET Framework 4.7.2) está disponível na pasta NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="7dbf3-107">Primeiro, explicaremos as etapas necessárias para a porta de aplicativos em geral e, em seguida, percorreremos as alterações específicas que se aplicam ao exemplo do **Bean de Trader** .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="7dbf3-108">Para migrar para o .NET Core, você deve primeiro:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="7dbf3-109">Entenda e atualize as dependências do NuGet:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="7dbf3-110">Atualize as dependências do NuGet `<PackageReference>` para usar o formato.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="7dbf3-111">Examine as dependências do NuGet de nível superior para o .NET Core ou a compatibilidade .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="7dbf3-112">Atualize os pacotes NuGet para versões mais recentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="7dbf3-113">Use o [.net Portability Analyzer](../../standard/analyzers/portability-analyzer.md) para entender as dependências do .net.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="7dbf3-114">Migre o arquivo de projeto para o novo formato de estilo de SDK:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="7dbf3-115">Escolha se deseja direcionar tanto o .NET Core quanto o .NET Framework ou somente o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="7dbf3-116">Copie as propriedades e os itens de arquivo de projeto relevantes para o novo arquivo de projeto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="7dbf3-117">Corrigir problemas de compilação:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-117">Fix build issues:</span></span>

    01. <span data-ttu-id="7dbf3-118">Adicione uma referência ao pacote [Microsoft. Windows. Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="7dbf3-119">Encontre e corrija diferenças no nível da API.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="7dbf3-120">Remova as seções *app. config* que `appSettings` não `connectionStrings`sejam ou.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="7dbf3-121">Gere novamente o código gerado, se necessário.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="7dbf3-122">Teste de tempo de execução:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-122">Runtime testing:</span></span>

    01. <span data-ttu-id="7dbf3-123">Confirme se o aplicativo portado funciona conforme o esperado.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="7dbf3-124">Cuidado com <xref:System.NotSupportedException> exceções.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="7dbf3-125">Sobre o exemplo</span><span class="sxs-lookup"><span data-stu-id="7dbf3-125">About the sample</span></span>

<span data-ttu-id="7dbf3-126">Este artigo faz referência ao [aplicativo de exemplo do Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) porque ele usa uma variedade de dependências semelhantes àquelas que os aplicativos do WPF do mundo real podem ter.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="7dbf3-127">O aplicativo não é grande, mas deve ser um Step up de ' Olá, Mundo ' em termos de complexidade.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="7dbf3-128">O aplicativo demonstra alguns problemas que os usuários podem encontrar ao portar aplicativos reais.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="7dbf3-129">O aplicativo se comunica com um serviço WCF, portanto, para que ele seja executado corretamente, você também precisará executar o projeto BeanTraderServer (disponível no mesmo repositório GitHub) e verificar se a configuração do BeanTraderClient aponta para o ponto de extremidade correto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="7dbf3-130">(Por padrão, o exemplo supõe que o servidor esteja em execução no mesmo computador *http://localhost:8090*em, que será verdadeiro se você iniciar o BeanTraderServer localmente.)</span><span class="sxs-lookup"><span data-stu-id="7dbf3-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="7dbf3-131">Tenha em mente que este aplicativo de exemplo destina-se a demonstrar os desafios e as soluções de portabilidade do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="7dbf3-132">Não se destina a demonstrar as práticas recomendadas do WPF.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="7dbf3-133">Na verdade, ele inclui deliberadamente alguns antipadrões para garantir que você se deparasse com pelo menos alguns desafios interessantes ao portar.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="7dbf3-134">Preparando-se</span><span class="sxs-lookup"><span data-stu-id="7dbf3-134">Getting ready</span></span>

<span data-ttu-id="7dbf3-135">O principal desafio de migrar um aplicativo .NET Framework para o .NET Core é que suas dependências podem funcionar de maneira diferente ou não.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="7dbf3-136">A migração é muito mais fácil do que costumava ser; muitos pacotes NuGet agora têm como destino .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="7dbf3-137">A partir do .NET Core 2,0, as áreas de superfície .NET Framework e .NET Core se tornaram semelhantes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="7dbf3-138">Mesmo assim, algumas diferenças (tanto no suporte de pacotes NuGet quanto em APIs .NET disponíveis) permanecem.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="7dbf3-139">A primeira etapa da migração é revisar as dependências do aplicativo e verificar se as referências estão em um formato que é facilmente migrado para o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="7dbf3-140">Atualizar para `<PackageReference>` referências do NuGet</span><span class="sxs-lookup"><span data-stu-id="7dbf3-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="7dbf3-141">Os projetos .NET Framework mais antigos normalmente listam suas dependências do NuGet em um arquivo *Packages. config* .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="7dbf3-142">O novo formato de arquivo de projeto no estilo SDK referencia pacotes [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) NuGet como elementos no próprio arquivo csproj em vez de em um arquivo de configuração separado.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="7dbf3-143">Ao migrar, há duas vantagens em relação `<PackageReference>`ao uso de referências de estilo:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="7dbf3-144">Esse é o estilo da referência do NuGet que é necessário para o novo arquivo de projeto do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="7dbf3-145">Se você já estiver usando `<PackageReference>`o, os elementos do arquivo de projeto poderão ser copiados e colados diretamente no novo projeto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="7dbf3-146">Ao contrário de um arquivo Packages `<PackageReference>` . config, os elementos referem-se apenas às dependências de nível superior das quais seu projeto depende diretamente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="7dbf3-147">Todos os outros pacotes NuGet transitivos serão determinados no momento da restauração e registrados no arquivo obj\project.assets.JSON gerado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="7dbf3-148">Isso torna muito mais fácil determinar quais dependências seu projeto tem, o que é útil ao determinar se as dependências necessárias funcionarão no .NET Core ou não.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="7dbf3-149">A primeira etapa para migrar um aplicativo .NET Framework para o .NET Core é atualizá- `<PackageReference>` lo para usar referências do NuGet.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="7dbf3-150">O Visual Studio torna isso simples.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="7dbf3-151">Basta clicar com o botão direito do mouse no arquivo *Packages. config* do projeto no **Gerenciador de soluções**do Visual Studio e selecionar **Migrate Packages. config para PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Atualizando para o PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="7dbf3-153">Uma caixa de diálogo é exibida mostrando dependências do NuGet de nível superior calculadas e perguntando quais outros pacotes NuGet devem ser promovidos para o nível superior.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="7dbf3-154">Nenhum desses outros pacotes precisa ser de nível superior para o exemplo do bean de Trader, para que você possa desmarcar todas essas caixas.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="7dbf3-155">Em seguida, clique em **OK** e o arquivo *Packages. config* é removido e `<PackageReference>` os elementos são adicionados ao arquivo do projeto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="7dbf3-156">`<PackageReference>`-as referências de estilo não armazenam pacotes NuGet localmente em uma pasta de pacotes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="7dbf3-157">Em vez disso, eles são armazenados globalmente como uma otimização.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="7dbf3-158">Após a conclusão da migração, edite o arquivo csproj e remova `<Analyzer>` todos os elementos referentes aos analisadores que vieram anteriormente do *.. diretório \Packages*</span><span class="sxs-lookup"><span data-stu-id="7dbf3-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="7dbf3-159">Não se preocupe; como você ainda tem as referências do pacote NuGet, os analisadores serão incluídos no projeto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="7dbf3-160">Você só precisa limpar os elementos antigos Packages. config-Style `<Analyzer>` .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="7dbf3-161">Examinar pacotes NuGet</span><span class="sxs-lookup"><span data-stu-id="7dbf3-161">Review NuGet packages</span></span>

<span data-ttu-id="7dbf3-162">Agora que você pode ver os pacotes NuGet de nível superior dos quais o projeto depende, é possível examinar se esses pacotes estão disponíveis no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="7dbf3-163">Você pode determinar se um pacote dá suporte ao .NET Core examinando suas dependências em [NuGet.org](https://www.nuget.org/). O site [fuget.org](https://www.fuget.org/) criado pela Comunidade mostra essas informações em destaque na parte superior da página de informações do pacote.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="7dbf3-164">Ao direcionar o .NET Core 3,0, todos os pacotes destinados ao .NET Core ou .NET Standard devem funcionar (já que o .NET Core implementa a área de superfície de .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="7dbf3-165">Em alguns casos, a versão específica de um pacote que é usada não é direcionada ao .NET Core ou .NET Standard, mas as versões mais recentes vão.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="7dbf3-166">Nesse caso, você deve considerar a atualização para a versão mais recente do pacote.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="7dbf3-167">Você também pode usar pacotes destinados a .NET Framework, mas isso apresenta algum risco.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="7dbf3-168">O .NET Core para .NET Framework dependências é permitido porque as áreas de superfície do .NET Core e .NET Framework são semelhantes o suficiente para que essas dependências funcionem *frequentemente* .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="7dbf3-169">No entanto, se o pacote tentar usar uma API do .NET que não esteja presente no .NET Core, você encontrará uma exceção de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="7dbf3-170">Por isso, você só deve referenciar .NET Framework pacotes quando nenhuma outra opção estiver disponível e entender que isso gerará uma carga de teste.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="7dbf3-171">Se houver pacotes referenciados que não se destinam ao .NET Core ou .NET Standard, você terá que pensar em outras alternativas:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="7dbf3-172">Há outros pacotes semelhantes que podem ser usados em vez disso?</span><span class="sxs-lookup"><span data-stu-id="7dbf3-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="7dbf3-173">Às vezes, os autores do NuGet publicam ' separados '. Core ' versões de suas bibliotecas especificamente direcionadas ao .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="7dbf3-174">Os pacotes da Enterprise Library são um exemplo da publicação da Comunidade ". NetCore "alternativas.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="7dbf3-175">Em outros casos, os SDKs mais recentes para um serviço específico (às vezes com nomes de pacote diferentes) estão disponíveis para .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="7dbf3-176">Se não houver nenhuma alternativa disponível, você poderá continuar usando os pacotes direcionados .NET Framework, tendo em mente que precisará testá-los completamente uma vez em execução no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="7dbf3-177">O exemplo do bean de Trader tem as seguintes dependências de NuGet de nível superior:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="7dbf3-178">**Castle. Windsor, versão 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="7dbf3-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="7dbf3-179">Este pacote se destina .NET Standard 1,6, então funciona no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="7dbf3-180">**Microsoft. CodeAnalysis. FxCopAnalyzers, versão 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="7dbf3-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="7dbf3-181">Esse é um meta-Package, portanto, não é imediatamente óbvio quais plataformas ele suporta, mas a [documentação](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indica que sua versão mais recente (2.9.2) funcionará tanto para .NET Framework quanto para o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="7dbf3-182">**Nito. AsyncEx, versão 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="7dbf3-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="7dbf3-183">Este pacote não tem como alvo o .NET Core, mas a versão 5,0 mais recente faz.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="7dbf3-184">Isso é comum ao migrar porque muitos pacotes NuGet adicionaram .NET Standard suporte recentemente, mas versões mais antigas do projeto só serão direcionadas .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="7dbf3-185">Se a diferença de versão for apenas uma diferença de versão secundária, geralmente será fácil atualizar para a versão mais recente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="7dbf3-186">Como essa é uma alteração de versão principal, você precisa ter cuidado ao atualizar, pois pode haver alterações significativas no pacote.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="7dbf3-187">Há um caminho para frente, no entanto, que é bom.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="7dbf3-188">**MahApps. metro, versão 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="7dbf3-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="7dbf3-189">Esse pacote também não tem como alvo o .NET Core, mas tem um pré-lançamento (2,0-Alpha) mais recente que o faz.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="7dbf3-190">Novamente, você precisa procurar alterações significativas, mas o pacote mais recente está incentivando.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="7dbf3-191">As dependências do NuGet de exemplo do bean de Trader são todas direcionadas .NET Standard/. NET Core ou têm versões mais recentes que, portanto, é improvável que haja problemas de bloqueio aqui.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="7dbf3-192">Atualizar pacotes NuGet</span><span class="sxs-lookup"><span data-stu-id="7dbf3-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="7dbf3-193">Se possível, seria bom atualizar as versões de todos os pacotes que só visam o .NET Core ou .NET Standard com versões mais recentes neste momento (com o projeto ainda destinado a .NET Framework) para descobrir e resolver quaisquer alterações significativas no início.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="7dbf3-194">Se você preferir não fazer nenhuma alteração de material na versão de .NET Framework existente do aplicativo, isso poderá esperar até que você tenha um novo arquivo de projeto direcionado ao .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="7dbf3-195">No entanto, atualizar os pacotes NuGet para versões compatíveis com o .NET Core antecipadamente torna o processo de migração ainda mais fácil depois de criar o novo arquivo de projeto e reduz o número de diferenças entre as versões .NET Framework e .NET Core do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="7dbf3-196">Com o exemplo do bean de Trader, todas as atualizações necessárias podem ser feitas facilmente (usando o Gerenciador de pacotes NuGet do Visual Studio) com uma exceção: a atualização de **MahApps. metro 1.6.5** para **2,0** revela alterações significativas relacionadas às APIs de gerenciamento de tema e de ênfase.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="7dbf3-197">O ideal é que o aplicativo fosse atualizado para usar a versão mais recente do pacote (já que isso é mais provável de funcionar no .NET Core).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="7dbf3-198">No entanto, em alguns casos, isso pode não ser viável.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="7dbf3-199">Nesses casos, não atualize o **MahApps. metro** porque as alterações necessárias não são triviais e este tutorial se concentra na migração para o .NET Core 3, não para o **MahApps. metro 2.**</span><span class="sxs-lookup"><span data-stu-id="7dbf3-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="7dbf3-200">Além disso, essa é uma dependência .NET Framework de baixo risco porque o aplicativo do bean de Trader só exercita uma pequena parte do **MahApps. metro**.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="7dbf3-201">É claro que você precisará fazer testes para garantir que tudo esteja funcionando quando a migração for concluída.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="7dbf3-202">Se esse fosse um cenário do mundo real, seria bom arquivar um problema para acompanhar o trabalho para migrar para o **MahApps. metro** versão 2,0 já que não fazer a migração agora deixa por trás de uma dívida técnica.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="7dbf3-203">Depois que os pacotes NuGet são atualizados para versões recentes, `<PackageReference>` o grupo de itens no arquivo de projeto de exemplo do bean de Trader deve ter esta aparência.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="7dbf3-204">Análise de portabilidade .NET Framework</span><span class="sxs-lookup"><span data-stu-id="7dbf3-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="7dbf3-205">Depois de entender o estado das dependências do NuGet do seu projeto, a próxima coisa a considerar é .NET Framework dependências de API.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="7dbf3-206">A ferramenta do [analisador de portabilidade .net](../../standard/analyzers/portability-analyzer.md) é útil para entender quais das APIs .NET que seu projeto usa estão disponíveis em outras plataformas .net.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="7dbf3-207">A ferramenta é fornecida como um [plug-in do Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), uma [ferramenta de linha de comando](https://github.com/Microsoft/dotnet-apiport/releases)ou encapsulado em uma [GUI simples](https://github.com/Microsoft/dotnet-apiport-ui), o que simplifica suas opções.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="7dbf3-208">Você pode ler mais sobre como usar o analisador de portabilidade .NET (porta de API) usando a GUI na postagem de blog [portando aplicativos da área de trabalho para o .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="7dbf3-209">Se você preferir usar a linha de comando, as etapas necessárias serão:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="7dbf3-210">Baixe o [analisador de portabilidade do .net](https://github.com/Microsoft/dotnet-apiport/releases) se você ainda não o tiver.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="7dbf3-211">Certifique-se de que o aplicativo .NET Framework que será compilado com êxito (essa é uma boa ideia antes da migração, independentemente).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="7dbf3-212">Execute a porta de API com uma linha de comando como esta.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="7dbf3-213">O `-f` argumento especifica o caminho que contém os binários a serem analisados.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="7dbf3-214">O `-r` argumento especifica qual formato de arquivo de saída você deseja.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="7dbf3-215">O `-t` argumento especifica em qual plataforma .net analisar o uso da API.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="7dbf3-216">Nesse caso, você deseja o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="7dbf3-217">Quando você abrir o relatório HTML, a primeira seção listará todos os binários analisados e qual será a porcentagem das APIs do .NET que eles usam estão disponíveis na plataforma de destino.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="7dbf3-218">O percentual não é significativo por si só.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="7dbf3-219">O que é mais útil é ver as APIs específicas que estão faltando.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="7dbf3-220">Para fazer isso, selecione um nome de assembly ou role para baixo até os relatórios para assemblies individuais.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="7dbf3-221">Concentre-se nos assemblies dos quais você possui o código-fonte.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="7dbf3-222">No relatório ApiPort do bean de Trader, por exemplo, há muitos binários listados, mas a maioria deles pertence a pacotes NuGet.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="7dbf3-223">`Castle.Windsor`mostra que depende de algumas APIs System. Web que estão ausentes no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="7dbf3-224">Isso não é uma preocupação porque você verificou `Castle.Windsor` anteriormente que dá suporte ao .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="7dbf3-225">É comum que os pacotes NuGet tenham binários diferentes para uso com diferentes plataformas .NET, portanto, se a versão .NET Framework `Castle.Windsor` do usa APIs System. Web ou não é irrelevante, desde que o pacote também tenha como alvo .net Standard ou o .NET Core (o que ele faz).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="7dbf3-226">Com o exemplo do bean de Trader, o único binário que você precisa considerar é **BeanTraderClient** e o relatório mostra que apenas duas APIs .net estão `System.ServiceModel.ClientBase<T>.Close` ausentes: e `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Relatório de portabilidade BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="7dbf3-228">É improvável que esses problemas sejam bloqueados porque as APIs de cliente do WCF são (principalmente) com suporte no .NET Core, portanto, deve haver alternativas disponíveis para essas APIs centrais.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="7dbf3-229">Na verdade, olhando para `System.ServiceModel`a área de superfície do .NET Core <https://apisof.net>(usando), você vê que há alternativas assíncronas no .NET Core em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="7dbf3-230">Com base nesse relatório e na análise de dependência do NuGet anterior, parece que não deve haver problemas importantes ao migrar o exemplo do bean de Trader para o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="7dbf3-231">Você está pronto para a próxima etapa em que, na verdade, iniciará a migração.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="7dbf3-232">Migrando o arquivo de projeto</span><span class="sxs-lookup"><span data-stu-id="7dbf3-232">Migrating the project file</span></span>

<span data-ttu-id="7dbf3-233">Se seu aplicativo não estiver usando o novo [formato de arquivo de projeto no estilo SDK](../../core/tools/csproj.md), você precisará de um novo arquivo de projeto para o .NET Core de destino.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="7dbf3-234">Você pode substituir o arquivo csproj existente ou, se preferir manter o projeto existente inalterado em seu estado atual, você pode adicionar um novo arquivo csproj destinado ao .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="7dbf3-235">Você pode criar versões do aplicativo para o .NET Framework e o .NET Core com um único arquivo de projeto em estilo SDK com [vários](../../standard/library-guidance/cross-platform-targeting.md) destinos (especificando `<TargetFrameworks>` várias metas).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="7dbf3-236">Para criar o novo arquivo de projeto, você pode criar um novo projeto do WPF no Visual Studio ou `dotnet new wpf` usar o comando em um diretório temporário para gerar o arquivo de projeto e, em seguida, copiá-lo/renomeá-lo para o local correto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="7dbf3-237">Também há uma ferramenta criada pela Comunidade, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), que pode automatizar parte da migração de arquivos do projeto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="7dbf3-238">A ferramenta é útil, mas ainda precisa de um humano para revisar os resultados para garantir que todos os detalhes da migração estejam corretos.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="7dbf3-239">Uma área específica que a ferramenta não trata de forma ideal é migrar pacotes NuGet de arquivos *Packages. config* .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="7dbf3-240">Se a ferramenta for executada em um arquivo de projeto que ainda usa um arquivo *Packages. config* para referenciar os pacotes do `<PackageReference>` NuGet, ele migrará para `<PackageReference>` os elementos automaticamente, mas adicionará elementos para *todos* os pacotes em vez de apenas os de nível superior.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="7dbf3-241">Se você já migrou para`<PackageReference>` elementos com o Visual Studio (como fez neste exemplo), a ferramenta pode ajudar com o restante da conversão.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="7dbf3-242">Como Scott Hanselman recomenda em [sua postagem de blog sobre migração de arquivos csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), a portabilidade por mão é educativa e fornecerá melhores resultados se você tiver apenas alguns projetos para portar.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="7dbf3-243">Mas se você estiver portando dezenas ou centenas de arquivos de projeto, uma ferramenta como [CsprojToVs2017] pode ser uma ajuda.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="7dbf3-244">Para criar um novo arquivo de projeto para o exemplo do bean de `dotnet new wpf` Trader, execute em um diretório temporário e mova o arquivo *. csproj* gerado para a pasta *BeanTraderClient* e renomeie-o **BeanTraderClient. Core. csproj**.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="7dbf3-245">Como o novo formato de arquivo de projeto inclui automaticamente arquivos C#, arquivos *resx* e arquivos XAML que ele encontra em ou sob seu diretório, o arquivo de projeto já está quase concluído!</span><span class="sxs-lookup"><span data-stu-id="7dbf3-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="7dbf3-246">Para concluir a migração, abra os arquivos de projeto novos e antigos lado a lado e examine o antigo para ver se alguma informação que ele contém precisa ser migrada.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="7dbf3-247">No caso de exemplo do bean de Trader, os seguintes itens devem ser copiados para o novo projeto:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="7dbf3-248">As `<RootNamespace>`propriedades `<AssemblyName>`, e `<ApplicationIcon>` devem ser todas copiadas.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="7dbf3-249">Você também precisa adicionar uma `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` Propriedade ao novo arquivo de projeto, já que o exemplo do bean de Trader inclui atributos de `[AssemblyTitle]`nível de assembly (como) em um arquivo AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="7dbf3-250">Por padrão, os novos projetos no estilo SDK gerarão automaticamente esses atributos com base nas propriedades do arquivo csproj.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="7dbf3-251">Como você não quer que isso aconteça nesse caso (os atributos gerados automaticamente entrarão em conflito com aqueles de AssemblyInfo.cs), você desabilita os atributos gerados automaticamente `<GenerateAssemblyInfo>`com.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="7dbf3-252">Embora os arquivos *resx* sejam incluídos automaticamente como recursos incorporados `<Resource>` , outros itens, como imagens, não são.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="7dbf3-253">Portanto, copie os `<Resource>` elementos para inserir arquivos de ícone e imagem.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="7dbf3-254">Você pode simplificar as referências de png para uma única linha usando o suporte do novo formato de arquivo de projeto para `<Resource Include="**\*.png" />`padrões de mascaramento:.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="7dbf3-255">Da mesma `<None>` forma, os itens são incluídos automaticamente, mas não são copiados para o diretório de saída, por padrão.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="7dbf3-256">Como o `<None>` projeto do bean de Trader inclui um item que *é* copiado para o `PreserveNewest` diretório de saída (usando comportamentos), você precisa `<None>` atualizar o item preenchido automaticamente para esse arquivo, desta forma.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="7dbf3-257">O exemplo do bean de Trader inclui um arquivo XAML (default. sotaque. `Content` XAML) como (e `Page`não como um) porque os temas e acentos definidos nesse arquivo são carregados a partir do XAML do arquivo em tempo de execução, em vez de serem inseridos no próprio aplicativo.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="7dbf3-258">O novo sistema de projeto inclui automaticamente esse arquivo como `<Page>`um, no entanto, uma vez que é um arquivo XAML.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="7dbf3-259">Portanto, você precisa remover o arquivo XAML como uma página (`<Page Remove="**\Default.Accent.xaml" />`) e adicioná-lo como conteúdo.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="7dbf3-260">Por fim, adicione referências do NuGet copiando o `<ItemGroup>` com `<PackageReference>` todos os elementos.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="7dbf3-261">Se você não tiver atualizado anteriormente os pacotes do NuGet para versões compatíveis com o .NET Core, poderá fazer isso agora que as referências de pacote estão em um projeto específico do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="7dbf3-262">Neste ponto, deve ser possível adicionar o novo projeto à solução BeanTrader e abri-lo no Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="7dbf3-263">O projeto deve parecer correto em **Gerenciador de soluções**e `dotnet restore BeanTraderClient.Core.csproj` deve restaurar os pacotes com êxito (com dois avisos esperados relacionados à versão MahApps. metro que você está usando para .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="7dbf3-264">Embora seja possível manter ambos os arquivos de projeto lado a lado (e pode até mesmo ser desejável se você quiser continuar criando o projeto antigo exatamente como era), isso complica o processo de migração (os dois projetos tentarão usar as mesmas pastas bin e obj) e geralmente não é necessário.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="7dbf3-265">Se você quiser compilar tanto o .NET Core quanto os destinos do .NET Framework, poderá substituir a `<TargetFramework>netcoreapp3.0</TargetFramework>` Propriedade no novo arquivo de projeto por `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="7dbf3-266">Para o exemplo do bean de Trader, exclua o arquivo de projeto antigo (BeanTraderClient. csproj), pois ele não é mais necessário.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="7dbf3-267">Se você preferir manter ambos os arquivos de projeto, certifique-se de que eles sejam criados para caminhos de saída intermediário e de saída diferentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="7dbf3-268">Corrigir problemas de compilação</span><span class="sxs-lookup"><span data-stu-id="7dbf3-268">Fix build issues</span></span>

<span data-ttu-id="7dbf3-269">A terceira etapa do processo de portabilidade é obter o projeto para compilar.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="7dbf3-270">Alguns aplicativos já serão compilados com êxito depois que o arquivo de projeto for convertido em um projeto em estilo SDK.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="7dbf3-271">Se esse for o caso para seu aplicativo, parabéns!</span><span class="sxs-lookup"><span data-stu-id="7dbf3-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="7dbf3-272">Você pode ir para a etapa 4.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-272">You can go on to Step 4.</span></span> <span data-ttu-id="7dbf3-273">Outros aplicativos precisarão de algumas atualizações para que sejam compiladas para o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="7dbf3-274">Se você tentar executar `dotnet build` no projeto de exemplo do Bean Trader agora, por exemplo, (ou compilá-lo no Visual Studio), haverá muitos erros, mas você os obterá corrigidos rapidamente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="7dbf3-275">Referências de System. ServiceModel e Microsoft. Windows. Compatibility</span><span class="sxs-lookup"><span data-stu-id="7dbf3-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="7dbf3-276">Uma fonte comum de erros está faltando referências para APIs que estão disponíveis para o .NET Core, mas não são incluídas automaticamente no metapacote do aplicativo .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="7dbf3-277">Para resolver isso, você deve fazer referência `Microsoft.Windows.Compatibility` ao pacote.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="7dbf3-278">O pacote de compatibilidade inclui um amplo conjunto de APIs que são comuns em aplicativos de área de trabalho do Windows, como WCF Client, serviços de diretório, registro, configuração, APIs de ACLs e muito mais.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="7dbf3-279">Com o exemplo do bean de Trader, a maioria dos erros de compilação se <xref:System.ServiceModel> deve a tipos ausentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="7dbf3-280">Eles podem ser resolvidos referenciando os pacotes do WCF NuGet necessários.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="7dbf3-281">As APIs de cliente do `Microsoft.Windows.Compatibility` WCF estão entre elas presentes no pacote, mas, portanto, fazer referência ao pacote de compatibilidade é uma solução ainda melhor (já que ela também resolve quaisquer problemas relacionados a APIs, bem como soluções para os problemas do WCF disponibilizados pelo pacote de compatibilidade).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="7dbf3-282">O `Microsoft.Windows.Compatibility` pacote ajuda na maioria dos cenários de portabilidade do WPF e WinForms do .net Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="7dbf3-283">Depois de adicionar a referência do `Microsoft.Windows.Compatibility`NuGet a, somente um erro de compilação permanece!</span><span class="sxs-lookup"><span data-stu-id="7dbf3-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="7dbf3-284">Limpando arquivos não utilizados</span><span class="sxs-lookup"><span data-stu-id="7dbf3-284">Cleaning up unused files</span></span>

<span data-ttu-id="7dbf3-285">Um tipo de problema de migração que surge com freqüência é relacionado aos arquivos C# e XAML que não foram incluídos anteriormente no Build sendo coletados pelos novos projetos no estilo SDK que incluem *todas as* fontes automaticamente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="7dbf3-286">O próximo erro de compilação que você vê no exemplo do bean de Trader se refere a uma implementação de interface inadequada em *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="7dbf3-287">O nome do arquivo é uma dica, mas, na inspeção, você descobrirá que esse arquivo de origem está incorreto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="7dbf3-288">Isso não causava problemas anteriormente porque não foi incluído no projeto de .NET Framework original.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="7dbf3-289">Os arquivos de origem que estavam presentes no disco, mas não incluídos no *csproj* antigo, são incluídos automaticamente agora.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="7dbf3-290">Para problemas únicos como esse, é fácil comparar com o *csproj* anterior para confirmar que o arquivo não é necessário e, em seguida `<Compile Remove="" />` , ou, se o arquivo de origem não for mais necessário em qualquer lugar, exclua-o.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="7dbf3-291">Nesse caso, é seguro excluir apenas *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="7dbf3-292">Se você tiver muitos arquivos de origem que precisariam ser excluídos dessa forma, você poderá desabilitar a inclusão automática de arquivos C# definindo a `<EnableDefaultCompileItems>` Propriedade como false no arquivo de projeto.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="7dbf3-293">Em seguida, você pode `<Compile Include>` copiar itens do arquivo de projeto antigo para o novo a fim de Compilar apenas as fontes que pretende incluir.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="7dbf3-294">Da mesma `<EnableDefaultPageItems>` forma, pode ser usado para desativar a inclusão automática de páginas XAML `<EnableDefaultItems>` e pode controlar ambas com uma única propriedade.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="7dbf3-295">Um breve lado sobre compiladores com várias passagens</span><span class="sxs-lookup"><span data-stu-id="7dbf3-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="7dbf3-296">Depois de remover o arquivo transgressor do exemplo do bean de Trader, você pode recompilar e receberá quatro erros.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="7dbf3-297">Você não tinha um antes?</span><span class="sxs-lookup"><span data-stu-id="7dbf3-297">Didn't you have one before?</span></span> <span data-ttu-id="7dbf3-298">Por que o número de erros foi ativado?</span><span class="sxs-lookup"><span data-stu-id="7dbf3-298">Why did the number of errors go up?</span></span> <span data-ttu-id="7dbf3-299">O compilador C# é um [compilador com várias passagens](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="7dbf3-300">Isso significa que ele passa por cada arquivo de origem duas vezes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="7dbf3-301">Primeiro, o compilador apenas examina os metadados e as declarações em cada arquivo de origem e identifica quaisquer problemas no nível de declaração.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="7dbf3-302">Esses são os erros que você corrigiu.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="7dbf3-303">Em seguida, ele passa pelo código novamente para criar a origem do C# no IL; Esses são o segundo conjunto de erros que você está vendo agora.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="7dbf3-304">O compilador C# faz [mais do que apenas duas passagens](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), mas o resultado final é que erros de compilador para grandes alterações de código como essa tendem a chegar em duas ondas.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="7dbf3-305">Correções de dependências de terceiros (Castle. Windsor)</span><span class="sxs-lookup"><span data-stu-id="7dbf3-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="7dbf3-306">Outra classe de problema que surge em alguns cenários de migração são as diferenças de API entre .NET Framework e as versões de dependências do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="7dbf3-307">Mesmo que um pacote NuGet tenha como alvo .NET Framework e .NET Standard ou .NET Core, pode haver diferentes bibliotecas para uso com destinos .NET diferentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="7dbf3-308">Isso permite que os pacotes ofereçam suporte a várias plataformas .NET diferentes, o que pode exigir implementações diferentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="7dbf3-309">Isso também significa que pode haver pequenas diferenças de API nas bibliotecas ao direcionar diferentes plataformas .NET.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="7dbf3-310">O próximo conjunto de erros que você verá no exemplo do bean de Trader está `Castle.Windsor` relacionado a APIs.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="7dbf3-311">O projeto do Bean do .NET Core Traders usa a `Castle.Windsor` mesma versão do que o projeto de .NET Framework direcionado (4.1.1), mas as implementações dessas duas plataformas são um pouco diferentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="7dbf3-312">Nesse caso, você verá os seguintes problemas que precisam ser corrigidos:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="7dbf3-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`Não está disponível no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="7dbf3-314">Há, no entanto, a API `Classes.FromAssemblyContaining` semelhante disponível, portanto, podemos substituir ambos os `Classes.FromThisAssembly()` usos de com `Classes.FromAssemblyContaining(t)`chamadas para `t` , em que é o tipo que faz a chamada.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="7dbf3-315">Da mesma forma *Bootstrapper.cs*, em `Castle.Windsor.Installer.FromAssembly`bootstrapper.cs,. Isso não está disponível no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="7dbf3-316">Em vez disso, essa chamada pode ser `FromAssembly.Containing(typeof(Bootstrapper))`substituída por.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="7dbf3-317">Atualizando o uso do cliente WCF</span><span class="sxs-lookup"><span data-stu-id="7dbf3-317">Updating WCF client usage</span></span>

<span data-ttu-id="7dbf3-318">Depois de corrigir `Castle.Windsor` as diferenças, o último erro de compilação restante no projeto do Bean do .NET Core `BeanTraderServiceClient` Traders é que ( `DuplexClientBase`derivado de) não `Open` tem um método.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="7dbf3-319">Isso não é surpreendente, pois essa é uma API que foi realçada pelo .NET Portability Analyzer no início deste processo de migração.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="7dbf3-320">No `BeanTraderServiceClient` entanto, examinar o desenha nossa atenção para um problema maior.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="7dbf3-321">Este cliente WCF foi gerado automaticamente pela ferramenta [svcutil. exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) .</span><span class="sxs-lookup"><span data-stu-id="7dbf3-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="7dbf3-322">**Os clientes WCF gerados por SvcUtil são destinados para uso em .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="7dbf3-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="7dbf3-323">As soluções que usam clientes WCF gerados por SvcUtil precisarão regenerar clientes compatíveis com .NET Standard para uso com o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="7dbf3-324">Um dos principais motivos pelos quais os clientes antigos não funcionarão é que eles dependem da configuração do aplicativo para definir associações e pontos de extremidade do WCF.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="7dbf3-325">Como .NET Standard APIs do WCF podem trabalhar em plataforma cruzada (onde as APIs de sistema. de configuração não estão disponíveis), os clientes WCF para .NET Core e cenários de .NET Standard devem definir associações e pontos de extremidade programaticamente em vez de na configuração.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="7dbf3-326">Na verdade, qualquer uso de cliente WCF que dependa `<system.serviceModel>` da seção app. config (seja criado com SvcUtil ou manualmente) precisará ser alterado para funcionar no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="7dbf3-327">Há duas maneiras de gerar automaticamente clientes WCF compatíveis com .NET Standard:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="7dbf3-328">A `dotnet-svcutil` ferramenta é uma ferramenta .NET que gera clientes WCF de uma maneira semelhante a como o SvcUtil funcionou anteriormente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="7dbf3-329">O Visual Studio pode gerar clientes WCF usando a opção de [referência de serviço Web do WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) de seu recurso de serviços conectados.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="7dbf3-330">Qualquer uma das abordagens funciona bem.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-330">Either approach works well.</span></span> <span data-ttu-id="7dbf3-331">Como alternativa, é claro que você pode escrever o código do cliente WCF por conta própria.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="7dbf3-332">Para este exemplo, optei por usar o recurso serviço conectado do Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="7dbf3-333">Para fazer isso, clique com o botão direito do mouse no projeto *BeanTraderClient. Core* no Gerenciador de soluções do Visual Studio e selecione **Adicionar** > **serviço conectado**.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="7dbf3-334">Em seguida, escolha o provedor de referência do serviço Web WCF.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="7dbf3-335">Isso abrirá uma caixa de diálogo onde você pode especificar o endereço do serviço Web do bean de back`localhost:8080` -end (se você estiver executando o servidor localmente) e o namespace que gerou os tipos deve usar (**BeanTrader. Service**, por exemplo).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Caixa de diálogo serviço conectado de referência do serviço Web WCF](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="7dbf3-337">Depois de selecionar o botão **concluir** , um novo nó serviços conectados é adicionado ao projeto e um arquivo Reference.cs é adicionado sob esse nó que contém o novo cliente WCF .net Standard para acessar o serviço do Bean do Trader.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="7dbf3-338">Se você examinar os métodos `GetEndpointAddress` ou `GetBindingForEndpoint` nesse arquivo, verá que as associações e os pontos de extremidade agora são gerados programaticamente (em vez de por meio da configuração do aplicativo).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="7dbf3-339">O recurso ' Adicionar serviços conectados ' também pode adicionar referências a alguns pacotes System. ServiceModel no arquivo de projeto, o que não é necessário, pois todos os pacotes WCF necessários estão incluídos por meio de Microsoft. Windows. Compatibility.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="7dbf3-340">Verifique o csproj para ver se algum item do System. `<PackageReference>` ServiceModel extra foi adicionado e, nesse caso, remova-os.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="7dbf3-341">Nosso projeto tem novas classes de cliente WCF agora (em *Reference.cs*), mas ainda tem as antigas (em BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="7dbf3-342">Há duas opções neste ponto:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-342">There are two options at this point:</span></span>

- <span data-ttu-id="7dbf3-343">Se você quiser poder criar o projeto de .NET Framework original (juntamente com o novo .NET Core-Targeted One), poderá usar um `<Compile Remove="BeanTrader.cs" />` item no arquivo csproj do projeto do .NET Core para que as versões .NET Framework e .NET Core do aplicativo usem diferentes clientes WCF.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="7dbf3-344">Isso tem a vantagem de deixar o projeto de .NET Framework existente inalterado, mas tem a desvantagem de que o código que usa os clientes WCF gerados pode precisar ser um pouco diferente no caso do .NET Core do que era no projeto de .NET Framework, portanto, você provavelmente precisará usar `#if` diretivas para compilar condicionalmente algum uso de cliente do WCF (criar clientes, por exemplo) para trabalhar de uma maneira quando criado para o .NET Core e outra forma quando criado para .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="7dbf3-345">Se, por outro lado, alguma variação de código no projeto de .NET Framework existente for aceitável, você poderá remover *BeanTrader.cs* todos juntos.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="7dbf3-346">Como o novo cliente WCF foi criado para .NET Standard, ele funcionará em cenários do .NET Core e .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="7dbf3-347">Se você estiver criando para .NET Framework além do .NET Core (por vários destinos ou tendo dois arquivos csproj), poderá usar esse novo arquivo *Reference.cs* para ambos os destinos.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="7dbf3-348">Essa abordagem tem a vantagem de que o código não precisará bifurcar para dar suporte a dois clientes WCF diferentes; o mesmo código será usado em todos os lugares.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="7dbf3-349">A desvantagem é que ela envolve a alteração do projeto de .NET Framework (supostamente estável) do.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="7dbf3-350">No caso do exemplo do bean de Trader, você pode fazer pequenas alterações no projeto original se ele facilitar a migração. portanto, siga estas etapas para reconciliar o uso do cliente WCF:</span><span class="sxs-lookup"><span data-stu-id="7dbf3-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="7dbf3-351">Adicione o novo arquivo Reference.cs ao projeto .NET Framework *BeanTraderClient. csproj* usando o menu de contexto ' Adicionar item existente ' do Gerenciador de soluções.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="7dbf3-352">Certifique-se de adicionar ' as link ' para que o mesmo arquivo seja usado por ambos os projetos (em vez de copiar o arquivo C#).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="7dbf3-353">Se você estiver compilando o .NET Core e .NET Framework com um único csproj (usando vários destinos), essa etapa não será necessária.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="7dbf3-354">Exclua *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="7dbf3-355">O novo cliente WCF é semelhante ao antigo, mas vários namespaces no código gerado são diferentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="7dbf3-356">Por isso, é necessário atualizar o projeto para que os tipos de cliente do WCF sejam usados em BeanTrader. Service (ou em qualquer nome de namespace escolhido) em vez de BeanTrader. Model ou sem um namespace.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="7dbf3-357">A criação de *BeanTraderClient. Core. csproj* ajudará a identificar onde essas alterações precisam ser feitas.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="7dbf3-358">Correções serão necessárias tanto no C# quanto nos arquivos de origem XAML.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="7dbf3-359">Por fim, você descobrirá que há um erro em *BeanTraderServiceClientFactory.cs* porque os construtores disponíveis para o `BeanTraderServiceClient` tipo foram alterados.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="7dbf3-360">Costumava ser possível fornecer um `InstanceContext` argumento (que foi criado usando um `CallbackHandler` do contêiner `Castle.Windsor` IOC).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="7dbf3-361">Os novos construtores criam novos `CallbackHandler`s.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="7dbf3-362">No entanto, há construtores no `BeanTraderServiceClient`tipo base do que correspondem ao que você deseja.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="7dbf3-363">Como o código do cliente WCF gerado automaticamente existe em classes parciais, você pode estendê-lo facilmente.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="7dbf3-364">Para fazer isso, crie um novo arquivo chamado *BeanTraderServiceClient.cs* e, em seguida, crie uma classe parcial com esse mesmo nome (usando o namespace BeanTrader. Service).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="7dbf3-365">Em seguida, adicione um construtor ao tipo parcial, conforme mostrado aqui.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="7dbf3-366">Com essas alterações feitas, o exemplo do bean de Trader agora estará usando um novo cliente WCF compatível com .NET Standard e você poderá fazer a correção final de `Open` alterar a chamada em *TradingService.cs* para usar `await OpenAsync` em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="7dbf3-367">Com os problemas do WCF abordados, a versão do .NET Core do exemplo do bean de Traders agora é compilada de forma limpa!</span><span class="sxs-lookup"><span data-stu-id="7dbf3-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="7dbf3-368">Testes em tempo de execução</span><span class="sxs-lookup"><span data-stu-id="7dbf3-368">Runtime testing</span></span>

<span data-ttu-id="7dbf3-369">É fácil esquecer que o trabalho de migração não é feito assim que o projeto é compilado corretamente no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="7dbf3-370">É importante deixar tempo para testar o aplicativo portado também.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="7dbf3-371">Depois que as coisas forem compiladas com êxito, verifique se o aplicativo é executado e funciona conforme o esperado, especialmente se você estiver usando qualquer pacote destinado a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="7dbf3-372">Vamos tentar iniciar o aplicativo de beans de portador e ver o que acontece.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="7dbf3-373">O aplicativo não fica muito antes de falhar com a exceção a seguir.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="7dbf3-374">Isso faz sentido, é claro.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-374">This makes sense, of course.</span></span> <span data-ttu-id="7dbf3-375">Lembre-se de que o WCF não usa mais a configuração de aplicativo, portanto, a seção System. serviceModel antiga do arquivo app. config precisa ser removida.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="7dbf3-376">O cliente atualizado do WCF inclui todas as mesmas informações em seu código, portanto, a seção de configuração não é mais necessária.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="7dbf3-377">Se você quisesse que o ponto de extremidade do WCF fosse configurável no app. config, poderá adicioná-lo como uma configuração de aplicativo e atualizar o código do cliente WCF para recuperar o ponto de extremidade do serviço WCF da configuração.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="7dbf3-378">Depois de remover a seção System. serviceModel de *app. config*, o aplicativo é iniciado, mas falha com outra exceção quando um usuário entra.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="7dbf3-379">A API sem suporte é `Func<T>.BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="7dbf3-380">Conforme explicado em [dotnet/corefx # 5940](https://github.com/dotnet/corefx/issues/5940), o `BeginInvoke` .NET Core não dá `EndInvoke` suporte aos métodos e em tipos delegados devido a dependências de comunicação remota subjacentes.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="7dbf3-381">Esse problema e sua correção são explicados mais detalhadamente na postagem de [chamadas delegate. BeginInvoke para](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) o blog do .NET Core, mas o `BeginInvoke` principal `EndInvoke` é que e as chamadas `Task.Run` devem ser substituídas por (ou por alternativas assíncronas, se possível).</span><span class="sxs-lookup"><span data-stu-id="7dbf3-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="7dbf3-382">Aplicando a solução geral aqui, `BeginInvoke` a chamada pode ser substituída `Invoke` por uma chamada `Task.Run`iniciada pelo.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="7dbf3-383">Depois de remover `BeginInvoke` o uso, o aplicativo do Beans Trader é executado com êxito no .NET Core!</span><span class="sxs-lookup"><span data-stu-id="7dbf3-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean de Trader em execução no .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="7dbf3-385">Todos os aplicativos são diferentes, portanto, as etapas específicas necessárias para migrar seus próprios aplicativos para o .NET Core irão variar.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="7dbf3-386">Mas, espero que o exemplo do bean de um dos traders demonstre o fluxo de trabalho geral e os tipos de problemas que podem ser esperados.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="7dbf3-387">E, apesar do comprimento do artigo, as alterações reais necessárias no exemplo do bean de Trader para fazê-lo funcionar no .NET Core eram bastante limitadas.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="7dbf3-388">Muitos aplicativos migram para o .NET Core da mesma maneira; com alterações limitadas ou até mesmo nenhuma alteração de código necessária.</span><span class="sxs-lookup"><span data-stu-id="7dbf3-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
