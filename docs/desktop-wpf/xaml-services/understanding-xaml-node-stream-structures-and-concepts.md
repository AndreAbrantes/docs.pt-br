---
title: Noções básicas sobre estruturas e conceitos do fluxo de nó XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/27/2020
ms.locfileid: "82071615"
---
# <a name="xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="f8fef-102">Estruturas e conceitos de fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-102">XAML node stream structures and concepts</span></span>

<span data-ttu-id="f8fef-103">Leitores XAML e escritores XAML implementados no .NET XAML Services são baseados no conceito de design de um fluxo de nós XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-103">XAML readers and XAML writers as implemented in .NET XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="f8fef-104">O fluxo de nó XAML é uma conceituação de um conjunto de nodes XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="f8fef-105">Nesta conceituação, um processador XAML percorre a estrutura das relações de nó no XAML um de cada vez.</span><span class="sxs-lookup"><span data-stu-id="f8fef-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="f8fef-106">A qualquer momento, apenas um registro atual ou posição atual existe em um fluxo de nó XAML aberto, e muitos aspectos da API relatam apenas as informações disponíveis a partir dessa posição.</span><span class="sxs-lookup"><span data-stu-id="f8fef-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="f8fef-107">O nó atual em um fluxo de nó XAML pode ser descrito como sendo um objeto, um membro ou um valor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="f8fef-108">Ao tratar o XAML como um fluxo de nó XAML, os leitores XAML podem se comunicar com escritores XAML e permitir que um programa visualize, interaja ou altere o conteúdo de um fluxo de nó XAML durante um caminho de carga ou uma operação de caminho de salvamento que envolva XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="f8fef-109">O design da API do leitor e escritor XAML e o conceito de fluxo de nó XAML são semelhantes <xref:System.Xml.XmlReader> aos <xref:System.Xml.XmlWriter> projetos e conceitos de leitores e escritores anteriores relacionados, como o XML Document Object Model (DOM) e as classes e e.</span><span class="sxs-lookup"><span data-stu-id="f8fef-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="f8fef-110">Este tópico discute conceitos de fluxo de nó XAML e descreve como você pode escrever rotinas que interagem com representações XAML no nível do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="f8fef-111">Carregando XAML em um leitor XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="f8fef-112">A <xref:System.Xaml.XamlReader> classe base não declara uma técnica específica para carregar o XAML inicial em um leitor XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="f8fef-113">Em vez disso, uma classe derivada declara e implementa a técnica de carregamento, incluindo as características gerais e restrições de sua fonte de entrada para XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="f8fef-114">Por exemplo, <xref:System.Xaml.XamlObjectReader> um lê um gráfico de objetos, a partir da fonte de entrada de um único objeto que representa a raiz ou base.</span><span class="sxs-lookup"><span data-stu-id="f8fef-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="f8fef-115">Em <xref:System.Xaml.XamlObjectReader> seguida, produz um fluxo de nó XAML a partir do gráfico do objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="f8fef-116">A subclasse mais proeminente do <xref:System.Xaml.XamlReader> .NET <xref:System.Xaml.XamlXmlReader>XAML Services-defined é .</span><span class="sxs-lookup"><span data-stu-id="f8fef-116">The most prominent .NET XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="f8fef-117"><xref:System.Xaml.XamlXmlReader>carrega o XAML inicial, seja carregando um arquivo de texto diretamente através de um fluxo <xref:System.IO.TextReader>ou caminho de arquivo, ou indiretamente através de uma classe de leitor relacionada, como .</span><span class="sxs-lookup"><span data-stu-id="f8fef-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="f8fef-118">O <xref:System.Xaml.XamlReader> pode ser pensado como contendo a totalidade da fonte de entrada XAML depois de carregado.</span><span class="sxs-lookup"><span data-stu-id="f8fef-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="f8fef-119">No entanto, a <xref:System.Xaml.XamlReader> API base foi projetada para que o leitor esteja interagindo com um único nó do XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="f8fef-120">Quando carregado pela primeira vez, o primeiro nó único que você encontra é a raiz do XAML, e seu objeto inicial.</span><span class="sxs-lookup"><span data-stu-id="f8fef-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="f8fef-121">O Conceito de Fluxo de Nó XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="f8fef-122">Se você está mais familiarizado com uma abordagem baseada em DOM, uma imagem de árvore ou uma abordagem baseada em consultas para acessar tecnologias baseadas em XML, uma maneira útil de conceituar um fluxo de nós XAML é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="f8fef-122">If you are more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="f8fef-123">Imagine que o XAML carregado é um DOM ou uma árvore onde todos os nós possíveis são expandidos todo o caminho, e então apresentados linearmente.</span><span class="sxs-lookup"><span data-stu-id="f8fef-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="f8fef-124">À medida que você avança através dos nós, você pode estar atravessando "dentro" ou "fora" de níveis que seriam relevantes para um DOM, mas o fluxo de nós XAML não acompanha explicitamente porque esses conceitos de nível não são relevantes para um fluxo de nós.</span><span class="sxs-lookup"><span data-stu-id="f8fef-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="f8fef-125">O fluxo de nó tem uma posição "atual", mas a menos que você tenha armazenado outras partes do fluxo você mesmo como referências, todos os aspectos do fluxo de nó que não a posição atual do nó estão fora de vista.</span><span class="sxs-lookup"><span data-stu-id="f8fef-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="f8fef-126">O conceito de fluxo de nó XAML tem a notável vantagem de que, se você passar por todo o fluxo de nós, você tem certeza de que processou toda a representação XAML; você não precisa se preocupar que uma consulta, uma operação DOM ou alguma outra abordagem não linear para processar informações tenha perdido alguma parte da representação XAML completa.</span><span class="sxs-lookup"><span data-stu-id="f8fef-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="f8fef-127">Por essa razão, a representação do fluxo de nós XAML é ideal tanto para conectar leitores XAML e escritores XAML, quanto para fornecer um sistema onde você pode inserir seu próprio processo que atua entre as fases de leitura e gravação de uma operação de processamento XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="f8fef-128">Em muitos casos, a encomenda de nós no fluxo de nós XAML é deliberadamente otimizada ou reordenada por leitores XAML versus como a ordem pode aparecer no texto de origem, binário ou gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="f8fef-129">Esse comportamento visa impor uma arquitetura de processamento XAML pela qual os escritores XAML nunca estão em uma posição onde eles têm que ir "de volta" no fluxo de nós.</span><span class="sxs-lookup"><span data-stu-id="f8fef-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="f8fef-130">Idealmente, todas as operações de gravação XAML devem ser capazes de agir com base no contexto do esquema mais a posição atual do fluxo de nós.</span><span class="sxs-lookup"><span data-stu-id="f8fef-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="f8fef-131">Um loop de nó de leitura básico</span><span class="sxs-lookup"><span data-stu-id="f8fef-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="f8fef-132">Um loop de nó de leitura básico para examinar um fluxo de nó XAML consiste nos seguintes conceitos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="f8fef-133">Para fins de loops de nó como discutido neste tópico, suponha que você está lendo <xref:System.Xaml.XamlXmlReader>um arquivo XAML baseado em texto e legível por humanos usando .</span><span class="sxs-lookup"><span data-stu-id="f8fef-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="f8fef-134">Os links nesta seção referem-se à API <xref:System.Xaml.XamlXmlReader>de loop de nó XAML em particular implementada por .</span><span class="sxs-lookup"><span data-stu-id="f8fef-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="f8fef-135">Certifique-se de que você não está no final do <xref:System.Xaml.XamlXmlReader.IsEof%2A>fluxo de <xref:System.Xaml.XamlXmlReader.Read%2A> nós XAML (verifique ou use o valor de retorno).</span><span class="sxs-lookup"><span data-stu-id="f8fef-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="f8fef-136">Se você estiver no final do fluxo, não há nó atual e você deve sair.</span><span class="sxs-lookup"><span data-stu-id="f8fef-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="f8fef-137">Verifique que tipo de nó o fluxo de nó XAML expõe atualmente chamando <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8fef-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="f8fef-138">Se você tem um escritor de objetos XAML <xref:System.Xaml.XamlWriter.WriteNode%2A> associado que está conectado diretamente, você geralmente chama neste momento.</span><span class="sxs-lookup"><span data-stu-id="f8fef-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="f8fef-139">Com base <xref:System.Xaml.XamlNodeType> no que é relatado como o nó atual ou registro atual, ligue para um dos seguintes dados para obter informações sobre o conteúdo do nó:</span><span class="sxs-lookup"><span data-stu-id="f8fef-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="f8fef-140">Para <xref:System.Xaml.XamlXmlReader.NodeType%2A> um <xref:System.Xaml.XamlNodeType.StartMember> <xref:System.Xaml.XamlNodeType.EndMember>ou <xref:System.Xaml.XamlXmlReader.Member%2A> , <xref:System.Xaml.XamlMember> ligue para obter informações sobre um membro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="f8fef-141">O membro pode <xref:System.Xaml.XamlDirective>ser um , e, portanto, pode não ser necessariamente um membro convencional definido do objeto anterior.</span><span class="sxs-lookup"><span data-stu-id="f8fef-141">The member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="f8fef-142">`x:Name` Por exemplo, aplicado a um objeto aparece como <xref:System.Xaml.XamlMember.IsDirective%2A> um membro <xref:System.Xaml.XamlMember.Name%2A> XAML `Name`onde é verdadeiro e o do membro é, com outras propriedades indicando que esta diretiva está sob o espaço de nome XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="f8fef-143">Para <xref:System.Xaml.XamlXmlReader.NodeType%2A> um <xref:System.Xaml.XamlNodeType.StartObject> <xref:System.Xaml.XamlNodeType.EndObject>ou <xref:System.Xaml.XamlXmlReader.Type%2A> , <xref:System.Xaml.XamlType> ligue para obter informações sobre um objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="f8fef-144">Para <xref:System.Xaml.XamlXmlReader.NodeType%2A> um <xref:System.Xaml.XamlNodeType.Value>de <xref:System.Xaml.XamlXmlReader.Value%2A>, chamada .</span><span class="sxs-lookup"><span data-stu-id="f8fef-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="f8fef-145">Um nó é um valor apenas se for a expressão mais simples de um valor para um membro, ou o texto de inicialização de um objeto (no entanto, você deve estar ciente do comportamento de conversão de tipo documentado em uma próxima seção deste tópico).</span><span class="sxs-lookup"><span data-stu-id="f8fef-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="f8fef-146">Para <xref:System.Xaml.XamlXmlReader.NodeType%2A> um <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>de, chamada <xref:System.Xaml.XamlXmlReader.Namespace%2A> para obter informações de namespace para um nó de namespace.</span><span class="sxs-lookup"><span data-stu-id="f8fef-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="f8fef-147">Ligue <xref:System.Xaml.XamlXmlReader.Read%2A> para avançar o leitor XAML para o próximo nó no fluxo de nó XAML e repita os passos novamente.</span><span class="sxs-lookup"><span data-stu-id="f8fef-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="f8fef-148">O fluxo de nós XAML fornecido pelos leitores XAML Do .NET Services XAML sempre fornece uma travessia completa e profunda de todos os nós possíveis.</span><span class="sxs-lookup"><span data-stu-id="f8fef-148">The XAML node stream provided by .NET XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="f8fef-149">Técnicas típicas de controle de fluxo para um `while (reader.Read())`loop de nó <xref:System.Xaml.XamlXmlReader.NodeType%2A> XAML incluem definir um corpo dentro e ligar em cada ponto de nó no loop do nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="f8fef-150">Se o fluxo de nó estiver no final do arquivo, o nó atual será nulo.</span><span class="sxs-lookup"><span data-stu-id="f8fef-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="f8fef-151">O loop mais simples que usa um leitor e um escritor se assemelha ao exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f8fef-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="f8fef-152">Este exemplo básico de um loop de nó XAML de caminho de carga conecta de forma transparente <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>o leitor XAML e o escritor XAML, não fazendo nada diferente do que se você tivesse usado .</span><span class="sxs-lookup"><span data-stu-id="f8fef-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f8fef-153">Mas essa estrutura básica é então expandida para aplicar ao seu cenário de leitura ou escrita.</span><span class="sxs-lookup"><span data-stu-id="f8fef-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="f8fef-154">Alguns cenários possíveis são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="f8fef-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="f8fef-155">Ligar <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8fef-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="f8fef-156">Realize diferentes ações dependendo de qual tipo de nó está sendo lido.</span><span class="sxs-lookup"><span data-stu-id="f8fef-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="f8fef-157">Não ligue <xref:System.Xaml.XamlWriter.WriteNode%2A> em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="f8fef-158">Só <xref:System.Xaml.XamlWriter.WriteNode%2A> ligue <xref:System.Xaml.XamlXmlReader.NodeType%2A> em alguns casos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="f8fef-159">Dentro da lógica para um tipo de nó particular, analise as especificidades desse nó e aja sobre eles.</span><span class="sxs-lookup"><span data-stu-id="f8fef-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="f8fef-160">Por exemplo, você só poderia escrever objetos que vêm de um espaço de nome XAML específico e, em seguida, soltar ou adiar quaisquer objetos que não sejam desse espaço de nome XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-160">For example, you could only write objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="f8fef-161">Ou você pode soltar ou reprocessar qualquer diretiva XAML que seu sistema XAML não suporta como parte do processamento do seu membro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="f8fef-162">Defina <xref:System.Xaml.XamlObjectWriter> um costume `Write*` que substitui os métodos, possivelmente realizando mapeamento de tipo que contorna o contexto do esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="f8fef-163">Construa <xref:System.Xaml.XamlXmlReader> o para usar um contexto de esquema XAML não padrão, de modo que as diferenças personalizadas no comportamento XAML sejam usadas tanto pelo leitor quanto pelo escritor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="f8fef-164">Acessando xaml além do conceito de loop de nó</span><span class="sxs-lookup"><span data-stu-id="f8fef-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="f8fef-165">Existem potencialmente outras maneiras de trabalhar com uma representação XAML diferente de um loop de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="f8fef-166">Por exemplo, pode existir um leitor XAML que pode ler um nó indexado, ou em particular acessar os nós diretamente por `x:Name`, por `x:Uid`, ou através de outros identificadores.</span><span class="sxs-lookup"><span data-stu-id="f8fef-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="f8fef-167">.NET Os serviços XAML não fornecem uma implementação completa, mas fornecem um padrão sugerido através de serviços e tipos de suporte.</span><span class="sxs-lookup"><span data-stu-id="f8fef-167">.NET XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="f8fef-168">Para obter mais informações, consulte <xref:System.Xaml.IXamlIndexingReader> e <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="f8fef-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

## <a name="working-with-the-current-node"></a><span data-ttu-id="f8fef-169">Trabalhando com o Nó Atual</span><span class="sxs-lookup"><span data-stu-id="f8fef-169">Working with the Current Node</span></span>

<span data-ttu-id="f8fef-170">A maioria dos cenários que usam um loop de nó XAML não só lê em cima.</span><span class="sxs-lookup"><span data-stu-id="f8fef-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="f8fef-171">A maioria dos cenários processa os nós atuais <xref:System.Xaml.XamlWriter>e passa cada nó um de cada vez para uma implementação de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="f8fef-172">No cenário típico do <xref:System.Xaml.XamlXmlReader> caminho de carga, um produz um fluxo de nó XAML; os nós XAML são processados de acordo com sua lógica e contexto de esquema XAML; e os nós são passados para um <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="f8fef-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="f8fef-173">Em seguida, você integra o gráfico de objeto resultante em sua aplicação ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="f8fef-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="f8fef-174">Em um cenário típico <xref:System.Xaml.XamlObjectReader> de salvar caminho, um lê o gráfico de objetos, nós XAML individuais são processados e uma <xref:System.Xaml.XamlXmlWriter> saída do resultado serializado como um arquivo de texto XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="f8fef-175">A chave é que ambos os caminhos e cenários envolvem trabalhar exatamente com um nó XAML de cada vez, e os nós XAML estão disponíveis para tratamento de forma padronizada que é definida pelo sistema do tipo XAML e the.NET APIs de Serviços XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="f8fef-176">Quadros e Escopo</span><span class="sxs-lookup"><span data-stu-id="f8fef-176">Frames and Scope</span></span>

<span data-ttu-id="f8fef-177">Um loop de nó XAML caminha através de um fluxo de nó XAML de forma linear.</span><span class="sxs-lookup"><span data-stu-id="f8fef-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="f8fef-178">O fluxo de nó atravessa objetos, em membros que contêm outros objetos, e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="f8fef-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="f8fef-179">Muitas vezes é útil manter o controle do escopo dentro do fluxo de nó XAML implementando um conceito de quadro e pilha.</span><span class="sxs-lookup"><span data-stu-id="f8fef-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="f8fef-180">Isso é particularmente verdadeiro se você estiver ajustando ativamente o fluxo de nó enquanto estiver nele.</span><span class="sxs-lookup"><span data-stu-id="f8fef-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="f8fef-181">O suporte de quadro e pilha que você implementa `StartObject` como `GetObject`parte `EndObject` de sua lógica de loop de nó pode contar (ou ) e escopos à medida que você desce em uma estrutura de nó XAML se a estrutura for pensada a partir de uma perspectiva DOM.</span><span class="sxs-lookup"><span data-stu-id="f8fef-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="f8fef-182">Transando e inserindo áldenos de objetos</span><span class="sxs-lookup"><span data-stu-id="f8fef-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="f8fef-183">O primeiro nó em um fluxo de nó quando é aberto por um leitor XAML é o nó de objeto inicial do objeto raiz.</span><span class="sxs-lookup"><span data-stu-id="f8fef-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="f8fef-184">Por definição, este objeto é sempre um nó de objeto único e não tem pares.</span><span class="sxs-lookup"><span data-stu-id="f8fef-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="f8fef-185">Em qualquer exemplo xaml do mundo real, o objeto raiz é definido para ter uma ou mais propriedades que contêm mais objetos, e essas propriedades têm nós de membros.</span><span class="sxs-lookup"><span data-stu-id="f8fef-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="f8fef-186">Os nós membros, então, têm um ou mais nós de objeto, ou também podem terminar em um nó de valor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="f8fef-187">O objeto raiz normalmente define namescopes XAML, que são sintáticamente atribuídos como atributos `Namescope` na marcação de texto XAML, mas mapeiam para um tipo de nó na representação do fluxo de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="f8fef-188">Considere o seguinte exemplo XAML (este é xaml arbitrário, não apoiado por tipos existentes em .NET).</span><span class="sxs-lookup"><span data-stu-id="f8fef-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in .NET).</span></span> <span data-ttu-id="f8fef-189">Suponha que neste `FavorCollection` `List<T>` modelo `Favor` `Balloon` de `NoiseMaker` objeto, é `Favor`de `Balloon.Color` , e `Color` são atribuídos a , a propriedade é `Color` apoiada por um objeto semelhante à forma como o WPF define cores como nomes de cores conhecidos, e suporta um conversor de tipo para sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8fef-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="f8fef-190">Marcação XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-190">XAML markup</span></span>|<span data-ttu-id="f8fef-191">Fluxo de nó XAML resultante</span><span class="sxs-lookup"><span data-stu-id="f8fef-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="f8fef-192">`Namespace`nó para`Party`</span><span class="sxs-lookup"><span data-stu-id="f8fef-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="f8fef-193">`StartObject`nó para`Party`</span><span class="sxs-lookup"><span data-stu-id="f8fef-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="f8fef-194">`StartMember`nó para`Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="f8fef-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="f8fef-195">`StartObject`nó para implícito`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="f8fef-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="f8fef-196">`StartMember`nó para `FavorCollection` propriedade de itens implícitos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="f8fef-197">`StartObject`nó para`Balloon`</span><span class="sxs-lookup"><span data-stu-id="f8fef-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="f8fef-198">`StartMember`nó para`Color`</span><span class="sxs-lookup"><span data-stu-id="f8fef-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="f8fef-199">`Value`nó para a seqüência de valor de atributo`"Red"`</span><span class="sxs-lookup"><span data-stu-id="f8fef-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="f8fef-200">`EndMember` para `Color`</span><span class="sxs-lookup"><span data-stu-id="f8fef-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="f8fef-201">`StartMember`nó para`HasHelium`</span><span class="sxs-lookup"><span data-stu-id="f8fef-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="f8fef-202">`Value`nó para a seqüência de valor de atributo`"True"`</span><span class="sxs-lookup"><span data-stu-id="f8fef-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="f8fef-203">`EndMember` para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="f8fef-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="f8fef-204">`EndObject` para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="f8fef-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="f8fef-205">`StartObject`nó para`NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="f8fef-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="f8fef-206">`StartMember`nó para`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="f8fef-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="f8fef-207">`Value`nó para a seqüência de valor de inicialização`"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="f8fef-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="f8fef-208">`EndMember`nó para`_Initialization`</span><span class="sxs-lookup"><span data-stu-id="f8fef-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="f8fef-209">`EndObject` para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="f8fef-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="f8fef-210">`EndMember`nó para `FavorCollection` propriedade de itens implícitos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="f8fef-211">`EndObject`nó para implícito`FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="f8fef-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="f8fef-212">`EndMember` para `Favors`</span><span class="sxs-lookup"><span data-stu-id="f8fef-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="f8fef-213">`EndObject` para `Party`</span><span class="sxs-lookup"><span data-stu-id="f8fef-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="f8fef-214">No fluxo de nó XAML, você pode confiar no seguinte comportamento:</span><span class="sxs-lookup"><span data-stu-id="f8fef-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="f8fef-215">Se `Namespace` existir um nó, ele é adicionado ao `StartObject` fluxo imediatamente antes do que `xmlns`declarou o namespace XAML com .</span><span class="sxs-lookup"><span data-stu-id="f8fef-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="f8fef-216">Olhe para a tabela anterior com o XAML e exemplo fluxo de nó novamente.</span><span class="sxs-lookup"><span data-stu-id="f8fef-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="f8fef-217">Observe como `StartObject` `Namespace` os nós e nós parecem ser transpostos em comparação com suas posições de declaração na marcação de texto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="f8fef-218">Este é o representante do comportamento onde os nós namespace sempre aparecem à frente do nó a que se aplicam no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="f8fef-219">O objetivo deste projeto é que as informações do namespace são vitais para os escritores de objetos e devem ser conhecidas antes que o autor do objeto tente realizar o mapeamento do tipo ou processar o objeto de outra forma.</span><span class="sxs-lookup"><span data-stu-id="f8fef-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="f8fef-220">Colocar as informações de namespace xaml à frente de seu escopo de aplicação no fluxo torna mais simples processar sempre o fluxo de nó em sua ordem apresentada.</span><span class="sxs-lookup"><span data-stu-id="f8fef-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="f8fef-221">Por causa da consideração acima, `Namespace` é um ou mais nós que você lê primeiro na maioria dos casos `StartObject` de marcação do mundo real ao atravessar nós desde o início, não o da raiz.</span><span class="sxs-lookup"><span data-stu-id="f8fef-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="f8fef-222">Um `StartObject` nó pode ser `StartMember` `Value`seguido por `EndObject`, ou um imediato .</span><span class="sxs-lookup"><span data-stu-id="f8fef-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="f8fef-223">Nunca é seguido imediatamente `StartObject`por outro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="f8fef-224">A `StartMember` pode ser `StartObject`seguido `Value`por um `EndMember`, ou um imediato .</span><span class="sxs-lookup"><span data-stu-id="f8fef-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="f8fef-225">Ele pode ser `GetObject`seguido por , para membros onde o valor é suposto vir `StartObject` de um valor existente do objeto pai em vez de um que instanciar um novo valor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="f8fef-226">Ele também pode ser `Namespace` seguido por um nó, `StartObject`que se aplica a um próximo .</span><span class="sxs-lookup"><span data-stu-id="f8fef-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="f8fef-227">Nunca é seguido imediatamente `StartMember`por outro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="f8fef-228">Um `Value` nó representa o valor em si; não há "EndValue".</span><span class="sxs-lookup"><span data-stu-id="f8fef-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="f8fef-229">Ele só pode ser `EndMember`seguido por um .</span><span class="sxs-lookup"><span data-stu-id="f8fef-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="f8fef-230">O texto de inicialização XAML do objeto como pode ser usado pela construção não resulta em uma estrutura Objeto-Valor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="f8fef-231">Em vez disso, um nó de `_Initialization` membro dedicado para um membro chamado é criado.</span><span class="sxs-lookup"><span data-stu-id="f8fef-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="f8fef-232">e esse nó de membro contém a seqüência de valor de inicialização.</span><span class="sxs-lookup"><span data-stu-id="f8fef-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="f8fef-233">Se existe, `_Initialization` é sempre `StartMember`o primeiro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="f8fef-234">`_Initialization`pode ser qualificado em algumas representações de serviços XAML com o `_Initialization` namescope xaml da linguagem XAML, para esclarecer que não é uma propriedade definida em tipos de backup.</span><span class="sxs-lookup"><span data-stu-id="f8fef-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="f8fef-235">Uma combinação Valor-membro representa uma configuração de atributo do valor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="f8fef-236">Pode eventualmente haver um conversor de valor envolvido no processamento deste valor, e o valor é uma seqüência simples.</span><span class="sxs-lookup"><span data-stu-id="f8fef-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="f8fef-237">No entanto, isso não é avaliado até que um escritor de objetos XAML processe esse fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="f8fef-238">O escritor de objetos XAML possui o contexto de esquema XAML necessário, mapeamento do sistema de tipo e outros suportes necessários para conversões de valor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="f8fef-239">Um `EndMember` nó pode ser `StartMember` seguido por um nó para `EndObject` um membro subseqüente, ou por um nó para o proprietário do membro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="f8fef-240">Um `EndObject` nó pode ser `EndMember` seguido por um nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="f8fef-241">Ele também pode ser `StartObject` seguido por um nó para casos em que os objetos são pares nos itens de uma coleção.</span><span class="sxs-lookup"><span data-stu-id="f8fef-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="f8fef-242">Ou pode ser seguido `Namespace` por um nó, que `StartObject`se aplica a um próximo .</span><span class="sxs-lookup"><span data-stu-id="f8fef-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="f8fef-243">Para o caso único de fechamento de `EndObject` todo o fluxo de nó, a raiz não é seguida por nada; o leitor agora é o fim <xref:System.Xaml.XamlReader.Read%2A> `false`do arquivo, e retorna .</span><span class="sxs-lookup"><span data-stu-id="f8fef-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="f8fef-244">Conversores de valor e o fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="f8fef-245">Um conversor de valor é um termo geral para uma extensão de marcação, um conversor de tipo (incluindo serializadores de valor) ou outra classe dedicada que é relatada como um conversor de valor através do sistema do tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="f8fef-246">No fluxo de nó XAML, um uso de conversor de tipo e um uso de extensão de marcação têm representações muito diferentes.</span><span class="sxs-lookup"><span data-stu-id="f8fef-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="f8fef-247">Tipo conversores no fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="f8fef-248">Um conjunto de atributos que eventualmente resulta em um uso de conversor de tipo é relatado no fluxo de nó XAML como um valor de um membro.</span><span class="sxs-lookup"><span data-stu-id="f8fef-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="f8fef-249">O fluxo de nó XAML não tenta produzir um objeto de instância de conversor de tipo e passar o valor para ele.</span><span class="sxs-lookup"><span data-stu-id="f8fef-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="f8fef-250">O uso da implementação de conversão de um conversor de tipo requer invocar o contexto do esquema XAML e usá-lo para mapeamento de tipos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="f8fef-251">Mesmo determinando qual classe de conversor de tipo deve ser usada para processar o valor requer indiretamente o contexto do esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="f8fef-252">Quando você usa o contexto padrão do esquema XAML, essas informações estão disponíveis no sistema do tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="f8fef-253">Se você precisar das informações da classe tipo conversor no nível de fluxo do nó XAML antes da conexão com um escritor XAML, você pode obtê-la a <xref:System.Xaml.XamlMember> partir das informações do membro que está sendo definido.</span><span class="sxs-lookup"><span data-stu-id="f8fef-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="f8fef-254">Mas, caso contrário, a entrada do conversor de tipo deve ser preservada no fluxo de nó XAML como um valor simples até que o restante das operações que requerem o sistema de mapeamento de tipo e o contexto do esquema XAML sejam realizadas, por exemplo, a criação do objeto por um escritor de objetos XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type-mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="f8fef-255">Por exemplo, considere o seguinte esboço de definição de classe e o uso de XAML para ele:</span><span class="sxs-lookup"><span data-stu-id="f8fef-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="f8fef-256">Uma representação de texto do fluxo de nó XAML para este uso poderia ser expressa da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="f8fef-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="f8fef-257">`StartObject`com <xref:System.Xaml.XamlType> a representação`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="f8fef-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="f8fef-258">`StartMember`com <xref:System.Xaml.XamlMember> a representação`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="f8fef-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="f8fef-259">`Value`nó, com seqüência de texto "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="f8fef-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="f8fef-260">`EndMember`Corresponde`BoardSize`</span><span class="sxs-lookup"><span data-stu-id="f8fef-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="f8fef-261">`EndObject`Corresponde`GameBoard`</span><span class="sxs-lookup"><span data-stu-id="f8fef-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="f8fef-262">Observe que não há nenhuma instância de conversor de tipo neste fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="f8fef-263">Mas você pode obter informações <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> do <xref:System.Xaml.XamlMember> `BoardSize`conversor de tipo ligando para o for .</span><span class="sxs-lookup"><span data-stu-id="f8fef-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="f8fef-264">Se você tiver um contexto de esquema XAML válido, você também pode <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>invocar os métodos de conversor obtendo uma instância de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="f8fef-265">Extensões de marcação no fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="f8fef-266">Um uso de extensão de marcação é relatado no fluxo de nó XAML como um nó de objeto dentro de um membro, onde o objeto representa uma instância de extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="f8fef-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="f8fef-267">Assim, um uso de extensão de marcação é apresentado mais explicitamente na representação do fluxo de nó do que um uso de conversor de tipo e carrega mais informações.</span><span class="sxs-lookup"><span data-stu-id="f8fef-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="f8fef-268"><xref:System.Xaml.XamlMember>informações não poderiam ter dito nada sobre a extensão de marcação, pois o uso é situacional e varia em cada caso de marcação possível; não é dedicado e implícito por tipo ou membro, como é o caso dos conversores de tipo.</span><span class="sxs-lookup"><span data-stu-id="f8fef-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="f8fef-269">A representação do fluxo de nó das extensões de marcação como nó de objeto é o caso mesmo se o uso da extensão de marcação foi feito na forma de atributo na marcação de texto XAML (o que muitas vezes é o caso).</span><span class="sxs-lookup"><span data-stu-id="f8fef-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="f8fef-270">Os usos de extensão de marcação que usaram uma forma de elemento de objeto explícito são tratados da mesma maneira.</span><span class="sxs-lookup"><span data-stu-id="f8fef-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="f8fef-271">Dentro de um nó de objeto de extensão de marcação, pode haver membros dessa extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="f8fef-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="f8fef-272">A representação do fluxo de nó XAML preserva o uso dessa extensão de marcação, seja um uso de parâmetro posicional ou um uso com parâmetros nomeados explícitos.</span><span class="sxs-lookup"><span data-stu-id="f8fef-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="f8fef-273">Para um uso de parâmetro posicional, o fluxo de nó XAML contém uma propriedade `_PositionalParameters` definida em linguagem XAML que registra o uso.</span><span class="sxs-lookup"><span data-stu-id="f8fef-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="f8fef-274">Esta propriedade é <xref:System.Collections.Generic.List%601> <xref:System.Object> um genérico com restrição.</span><span class="sxs-lookup"><span data-stu-id="f8fef-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="f8fef-275">A restrição é objeto e não string porque, concebivelmente, um uso de parâmetro posicional pode conter usos aninhados de extensão de marcação dentro dele.</span><span class="sxs-lookup"><span data-stu-id="f8fef-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="f8fef-276">Para acessar os parâmetros posicionais do uso, você pode iterar através da lista e usar os indexadores para valores de lista individuais.</span><span class="sxs-lookup"><span data-stu-id="f8fef-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="f8fef-277">Para um uso de parâmetro nomeado, cada parâmetro nomeado é representado como um nó membro desse nome no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="f8fef-278">Os valores do membro não são necessariamente strings, porque pode haver um uso de extensão de marcação aninhado.</span><span class="sxs-lookup"><span data-stu-id="f8fef-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="f8fef-279">`ProvideValue`a partir da extensão de marcação ainda não é invocada.</span><span class="sxs-lookup"><span data-stu-id="f8fef-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="f8fef-280">No entanto, ele é invocado se você conectar um leitor `WriteEndObject` XAML e um escritor XAML de modo que é invocado no nó de extensão de marcação quando você examiná-lo no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="f8fef-281">Por esta razão, você geralmente precisa do mesmo contexto de esquema XAML disponível como seria usado para formar o gráfico de objetos no caminho de carga.</span><span class="sxs-lookup"><span data-stu-id="f8fef-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="f8fef-282">Caso contrário, `ProvideValue` de qualquer extensão de marcação pode lançar exceções aqui, porque não tem serviços esperados disponíveis.</span><span class="sxs-lookup"><span data-stu-id="f8fef-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="f8fef-283">Membros definidos em linguagem XAML e XML no fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="f8fef-284">Certos membros são introduzidos a um fluxo de nó XAML por causa de interpretações <xref:System.Xaml.XamlMember> e convenções de um leitor XAML, em vez de através de uma pesquisa ou construção explícita.</span><span class="sxs-lookup"><span data-stu-id="f8fef-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="f8fef-285">Muitas vezes, esses membros são diretivas XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="f8fef-286">Em alguns casos, é o ato de ler o XAML que introduz a diretiva no fluxo de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="f8fef-287">Em outras palavras, o texto XAML de entrada original não especificava explicitamente a diretiva do membro, mas o leitor XAML insere a diretiva para satisfazer uma convenção XAML estrutural e relatar informações no fluxo de nó XAML antes que essas informações se percam.</span><span class="sxs-lookup"><span data-stu-id="f8fef-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="f8fef-288">A lista a seguir observa todos os casos em que um leitor XAML deverá introduzir um nó de membro XAML diretiva e como esse nó de membro é identificado nas implementações do .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="f8fef-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in .NET XAML Services implementations.</span></span>

- <span data-ttu-id="f8fef-289">**Texto de inicialização para um nó de objeto:** O nome deste nó `_Initialization`membro é , ele representa uma diretiva XAML, e é definido no espaço de nome XAML idioma XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="f8fef-290">Você pode obter uma entidade <xref:System.Xaml.XamlLanguage.Initialization%2A>estática para ele de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="f8fef-291">**Parâmetros posicionais para uma extensão de marcação:** O nome deste nó `_PositionalParameters`membro é , e é definido no espaço de nome XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="f8fef-292">Ele sempre contém uma lista genérica de objetos, cada um dos quais `,` é um parâmetro posicional pré-separado dividindo-se no caractere delimitador como fornecido na entrada XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="f8fef-293">Você pode obter uma entidade estática <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>para a diretiva de parâmetros posicionais de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="f8fef-294">**Conteúdo desconhecido:** O nome deste nó `_UnknownContent`membro é .</span><span class="sxs-lookup"><span data-stu-id="f8fef-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="f8fef-295">Estritamente falando, <xref:System.Xaml.XamlDirective>é um , e é definido no espaço de nome XAML linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="f8fef-296">Esta diretiva é usada como sentinela para casos em que um elemento de objeto XAML contém conteúdo na fonte XAML, mas nenhuma propriedade de conteúdo pode ser determinada sob o contexto de esquema XAML atualmente disponível.</span><span class="sxs-lookup"><span data-stu-id="f8fef-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="f8fef-297">Você pode detectar este caso em um fluxo de nó `_UnknownContent`XAML verificando se há membros nomeados .</span><span class="sxs-lookup"><span data-stu-id="f8fef-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="f8fef-298">Se nenhuma outra ação for tomada em um fluxo de <xref:System.Xaml.XamlObjectWriter> nó XAML de caminho de carga, o padrão será acionado quando `WriteEndObject` ele encontrar o `_UnknownContent` membro em qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="f8fef-299">O <xref:System.Xaml.XamlXmlWriter> padrão não joga, e trata o membro como implícito.</span><span class="sxs-lookup"><span data-stu-id="f8fef-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="f8fef-300">Você pode obter uma `_UnknownContent` <xref:System.Xaml.XamlLanguage.UnknownContent%2A>entidade estática para de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="f8fef-301">**Propriedade de coleção de uma coleção:** Embora o tipo CLR de suporte de uma classe de coleção que é usado para XAML geralmente tenha uma propriedade nomeada dedicada que detém os itens de coleção, essa propriedade não é conhecida por um sistema tipo XAML antes da resolução do tipo de suporte.</span><span class="sxs-lookup"><span data-stu-id="f8fef-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="f8fef-302">Em vez disso, o fluxo de `Items` nó XAML introduz um espaço reservado como membro do tipo XAML da coleção.</span><span class="sxs-lookup"><span data-stu-id="f8fef-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="f8fef-303">Na implementação do .NET XAML Services, o nome desta `_Items`diretiva ou membro no fluxo de nó é .</span><span class="sxs-lookup"><span data-stu-id="f8fef-303">In .NET XAML Services implementation, the name of this directive or member in the node stream is `_Items`.</span></span> <span data-ttu-id="f8fef-304">Uma constante para esta diretiva <xref:System.Xaml.XamlLanguage.Items%2A>pode ser obtida a partir de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="f8fef-305">Observe que um fluxo de nó XAML pode conter uma propriedade Items com itens que acabam por não ser parsáveis com base na resolução do tipo de apoio e no contexto do esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="f8fef-306">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="f8fef-306">For example,</span></span>

- <span data-ttu-id="f8fef-307">**Membros definidos pelo XML:** As diretivas `xml:base`xml definidas `xml:lang` e `xml:space` membros são `base`relatadas como diretivas XAML nomeadas `lang`, e `space` em implementações de Serviços XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="f8fef-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in .NET XAML Services implementations.</span></span> <span data-ttu-id="f8fef-308">O namespace para estes é `http://www.w3.org/XML/1998/namespace`o namespace XML .</span><span class="sxs-lookup"><span data-stu-id="f8fef-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="f8fef-309">As constantes para cada uma <xref:System.Xaml.XamlLanguage>delas podem ser obtidas a partir de .</span><span class="sxs-lookup"><span data-stu-id="f8fef-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="f8fef-310">Ordem do Nó</span><span class="sxs-lookup"><span data-stu-id="f8fef-310">Node Order</span></span>

<span data-ttu-id="f8fef-311">Em alguns <xref:System.Xaml.XamlXmlReader> casos, altera a ordem dos nós XAML no fluxo de nós XAML, em comparação com a ordem em que os nós aparecem se visualizados na marcação ou se processados como XML.</span><span class="sxs-lookup"><span data-stu-id="f8fef-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="f8fef-312">Isso é feito para ordenar os nódulos <xref:System.Xaml.XamlObjectWriter> de modo que um pode processar o fluxo de nó de forma apenas para a frente.</span><span class="sxs-lookup"><span data-stu-id="f8fef-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="f8fef-313">Nos Serviços XAML .NET, o leitor XAML reordena os álos em vez de deixar essa tarefa para o escritor XAML, como uma otimização de desempenho para os consumidores de escritores de objetos XAML do fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="f8fef-313">In .NET XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="f8fef-314">Certas diretivas destinam-se especificamente a fornecer mais informações para a criação de um objeto a partir de um elemento objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="f8fef-315">Estas diretivas `Initialization` `PositionalParameters`são: `FactoryMethod` `Arguments`, , `TypeArguments`, . .</span><span class="sxs-lookup"><span data-stu-id="f8fef-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="f8fef-316">Os leitores XAML do .NET XAML tentam colocar essas diretivas como os `StartObject`primeiros membros no fluxo de nós seguindo o de um objeto, por razões que são explicadas na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="f8fef-316">.NET XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="f8fef-317">Comportamento e ordem de nó do XamlObjectWriter</span><span class="sxs-lookup"><span data-stu-id="f8fef-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="f8fef-318">`StartObject`a <xref:System.Xaml.XamlObjectWriter> a não é necessariamente um sinal para o escritor de objetos XAML para construir imediatamente a instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="f8fef-319">XAML inclui vários recursos de idioma que tornam possível inicializar um objeto com entrada adicional, e não depender inteiramente da invocação de um construtor sem parâmetros para produzir o objeto inicial e, somente então, definir propriedades.</span><span class="sxs-lookup"><span data-stu-id="f8fef-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="f8fef-320">Essas características <xref:System.Windows.Markup.XamlDeferLoadAttribute>incluem: ; texto de inicialização; [x:TypeArguments;](xtypearguments-directive.md) parâmetros posicionais de uma extensão de marcação; métodos de fábrica e [os nodos x:argumentos](xarguments-directive.md) associados (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="f8fef-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](xtypearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="f8fef-321">Cada um desses casos atrasa a construção real do objeto, e como o fluxo de nó é reordenado, o autor de objetos XAML pode confiar em um comportamento de realmente construir a instância sempre que um membro inicial é encontrado que não é especificamente uma diretiva de construção para esse tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-321">Each of these cases delays the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="f8fef-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="f8fef-322">GetObject</span></span>

<span data-ttu-id="f8fef-323">`GetObject`representa um nó XAML onde, em vez de construir um novo objeto, um escritor de objetos XAML deve, em vez disso, obter o valor da propriedade contendo o objeto.</span><span class="sxs-lookup"><span data-stu-id="f8fef-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="f8fef-324">Um caso típico `GetObject` em que um nó é encontrado em um fluxo de nó XAML é para um objeto de coleta ou um objeto de dicionário, quando a propriedade que contém é deliberadamente lida apenas no modelo de objeto do tipo de backup.</span><span class="sxs-lookup"><span data-stu-id="f8fef-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="f8fef-325">Nesse cenário, o acervo ou dicionário muitas vezes é criado e inicializado (geralmente vazio) pela lógica de inicialização de um tipo de possuidor.</span><span class="sxs-lookup"><span data-stu-id="f8fef-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="f8fef-326">Confira também</span><span class="sxs-lookup"><span data-stu-id="f8fef-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="f8fef-327">Serviços XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="f8fef-328">Namespaces XAML</span><span class="sxs-lookup"><span data-stu-id="f8fef-328">XAML Namespaces</span></span>](namespaces.md)
