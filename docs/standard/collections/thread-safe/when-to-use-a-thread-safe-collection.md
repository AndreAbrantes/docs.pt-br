---
title: Quando usar uma coleção thread-safe
description: Saiba quando usar uma coleção thread-safe no .NET. Há cinco tipos de coleção que são especialmente projetados para dar suporte a operações de adição & de multithread.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 499af6d7b8de1decbcffefe0a3b1420cc548488a
ms.sourcegitcommit: dc2feef0794cf41dbac1451a13b8183258566c0e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/24/2020
ms.locfileid: "85326044"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="ad872-104">Quando usar uma coleção thread-safe</span><span class="sxs-lookup"><span data-stu-id="ad872-104">When to use a thread-safe collection</span></span>

<span data-ttu-id="ad872-105">.NET Framework 4 introduziu cinco tipos de coleção que são especialmente projetados para dar suporte a operações de adição e remoção com vários threads.</span><span class="sxs-lookup"><span data-stu-id="ad872-105">.NET Framework 4 introduced five collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="ad872-106">Para obter a segurança de threads, esses tipos usam vários tipos de mecanismos de bloqueio e de sincronização sem bloqueio eficientes.</span><span class="sxs-lookup"><span data-stu-id="ad872-106">To achieve thread-safety, these types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="ad872-107">A sincronização adiciona sobrecarga a uma operação.</span><span class="sxs-lookup"><span data-stu-id="ad872-107">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="ad872-108">A quantidade de sobrecarga depende do tipo de sincronização usado, os tipos de operações que são executadas e outros fatores, como o número de threads que estão tentando acessar a coleção simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="ad872-108">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="ad872-109">Em alguns cenários, a sobrecarga de sincronização é insignificante e permite que o tipo com multithread funcione significativamente mais rápido e ajuste a escala muito melhor do que seu equivalente não thread-safe quando protegido por um bloqueio externo.</span><span class="sxs-lookup"><span data-stu-id="ad872-109">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="ad872-110">Em outros cenários, a sobrecarga pode fazer com o tipo thread-safe funcione e ajuste a escala na mesma velocidade ou até mais lentamente do que a versão bloqueada externamente não thread-safe do tipo.</span><span class="sxs-lookup"><span data-stu-id="ad872-110">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="ad872-111">As seções a seguir fornecem diretrizes gerais sobre quando usar uma coleção thread-safe versus sua equivalente não thread-safe que tem um bloqueio fornecido pelo usuário em torno de suas operações de leitura e gravação.</span><span class="sxs-lookup"><span data-stu-id="ad872-111">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="ad872-112">Como o desempenho pode variar dependendo de vários fatores, as diretrizes não são específicas e não são necessariamente válidas em todas as circunstâncias.</span><span class="sxs-lookup"><span data-stu-id="ad872-112">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="ad872-113">Se o desempenho for muito importante, a melhor maneira de determinar que tipo de coleção usar é medir o desempenho com base em cargas e configurações de computador representativas.</span><span class="sxs-lookup"><span data-stu-id="ad872-113">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="ad872-114">Este documento usa os seguintes termos:</span><span class="sxs-lookup"><span data-stu-id="ad872-114">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="ad872-115">*Produtor puro – cenário de consumidor*</span><span class="sxs-lookup"><span data-stu-id="ad872-115">*Pure producer-consumer scenario*</span></span>\
 <span data-ttu-id="ad872-116">Um determinado thread está adicionando ou removendo elementos, mas não executando as duas ações.</span><span class="sxs-lookup"><span data-stu-id="ad872-116">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="ad872-117">*Produtor misto – cenário de consumidor*</span><span class="sxs-lookup"><span data-stu-id="ad872-117">*Mixed producer-consumer scenario*</span></span>\
 <span data-ttu-id="ad872-118">Um determinado thread está tanto adicionando quanto removendo elementos.</span><span class="sxs-lookup"><span data-stu-id="ad872-118">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="ad872-119">*Velocidade*</span><span class="sxs-lookup"><span data-stu-id="ad872-119">*Speedup*</span></span>\
 <span data-ttu-id="ad872-120">Desempenho algorítmico mais rápido em relação a outro tipo no mesmo cenário.</span><span class="sxs-lookup"><span data-stu-id="ad872-120">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="ad872-121">*Escalabilidade*</span><span class="sxs-lookup"><span data-stu-id="ad872-121">*Scalability*</span></span>\
 <span data-ttu-id="ad872-122">O aumento no desempenho que é proporcional ao número de núcleos no computador.</span><span class="sxs-lookup"><span data-stu-id="ad872-122">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="ad872-123">Um algoritmo que ajusta a escala tem um desempenho mais rápido em oito núcleos do que em dois núcleos.</span><span class="sxs-lookup"><span data-stu-id="ad872-123">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="ad872-124">ConcurrentQueue (T) vs. fila (T)</span><span class="sxs-lookup"><span data-stu-id="ad872-124">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="ad872-125">Em cenários de produtor-consumidor puros, em que o tempo de processamento para cada elemento é muito pequeno (poucas instruções), <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> pode oferecer benefícios de desempenho modestos em relação a um <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> que tem um bloqueio externo.</span><span class="sxs-lookup"><span data-stu-id="ad872-125">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="ad872-126">Nesse cenário, <xref:System.Collections.Concurrent.ConcurrentQueue%601> funciona melhor quando um thread dedicado está enfileirando e um está retirando da fila.</span><span class="sxs-lookup"><span data-stu-id="ad872-126">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="ad872-127">Se você não impuser essa regra, <xref:System.Collections.Generic.Queue%601> poderá até mesmo funcionar um pouco mais rápido do que <xref:System.Collections.Concurrent.ConcurrentQueue%601> em computadores com vários núcleos.</span><span class="sxs-lookup"><span data-stu-id="ad872-127">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="ad872-128">Quando o tempo de processamento é em torno de 500 FLOPS (operações em ponto flutuante) ou mais, a regra de dois threads não se aplica a <xref:System.Collections.Concurrent.ConcurrentQueue%601>, que tem a escalabilidade muito boa.</span><span class="sxs-lookup"><span data-stu-id="ad872-128">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="ad872-129"><xref:System.Collections.Generic.Queue%601> não ajusta a escala bem nesse cenário.</span><span class="sxs-lookup"><span data-stu-id="ad872-129"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="ad872-130">Em cenários de produtor-consumidor mistos, quando o tempo de processamento é muito pequeno, um <xref:System.Collections.Generic.Queue%601> que tem um bloqueio externo ajusta a escala melhor do que <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span><span class="sxs-lookup"><span data-stu-id="ad872-130">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="ad872-131">No entanto, quando o tempo de processamento é em torno de 500 FLOPS ou mais, o <xref:System.Collections.Concurrent.ConcurrentQueue%601> ajusta a escala melhor.</span><span class="sxs-lookup"><span data-stu-id="ad872-131">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="ad872-132">ConcurrentStack vs. pilha</span><span class="sxs-lookup"><span data-stu-id="ad872-132">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="ad872-133">Em cenários de produtor-consumidor puros, quando o tempo de processamento é muito pequeno, <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> que tenham um bloqueio externo provavelmente funcionarão praticamente da mesma forma com um thread de colocação dedicado e um thread de retirada dedicado.</span><span class="sxs-lookup"><span data-stu-id="ad872-133">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="ad872-134">No entanto, conforme o número de threads aumenta, os dois tipos ficam mais lentos devido ao aumento da contenção e <xref:System.Collections.Generic.Stack%601> pode funcionar melhor do que <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="ad872-134">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="ad872-135">Quando o tempo de processamento é em torno de 500 FLOPS ou mais, os dois tipos ajustam a escala aproximadamente na mesma taxa.</span><span class="sxs-lookup"><span data-stu-id="ad872-135">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="ad872-136">Em cenários de produtor-consumidor mistos, <xref:System.Collections.Concurrent.ConcurrentStack%601> é mais rápido para cargas de trabalho grandes e pequenas.</span><span class="sxs-lookup"><span data-stu-id="ad872-136">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="ad872-137">O uso de <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> e <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> pode acelerar muito os tempos de acesso.</span><span class="sxs-lookup"><span data-stu-id="ad872-137">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="ad872-138">ConcurrentDictionary vs. dicionário</span><span class="sxs-lookup"><span data-stu-id="ad872-138">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="ad872-139">Em geral, use uma <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> em qualquer cenário em que estiver adicionando ou atualizando chaves ou valores simultaneamente de vários threads.</span><span class="sxs-lookup"><span data-stu-id="ad872-139">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="ad872-140">Em cenários que envolvem atualizações frequentes e relativamente poucas leituras, o <xref:System.Collections.Concurrent.ConcurrentDictionary%602> geralmente oferece benefícios modestos.</span><span class="sxs-lookup"><span data-stu-id="ad872-140">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="ad872-141">Em cenários que envolvem muitas leituras e muitas atualizações, o <xref:System.Collections.Concurrent.ConcurrentDictionary%602> geralmente é significativamente mais rápido em computadores que têm qualquer número de núcleos.</span><span class="sxs-lookup"><span data-stu-id="ad872-141">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="ad872-142">Em cenários que envolvem atualizações frequentes, você pode aumentar o nível de simultaneidade no <xref:System.Collections.Concurrent.ConcurrentDictionary%602> e, depois, medir para ver se o desempenho aumenta em computadores que têm mais núcleos.</span><span class="sxs-lookup"><span data-stu-id="ad872-142">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="ad872-143">Se você alterar o nível de simultaneidade, evite operações globais o máximo possível.</span><span class="sxs-lookup"><span data-stu-id="ad872-143">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="ad872-144">Se você só estiver lendo chave ou valores, o <xref:System.Collections.Generic.Dictionary%602> será mais rápido porque nenhuma sincronização será necessária se o dicionário não estiver sendo modificado por nenhum thread.</span><span class="sxs-lookup"><span data-stu-id="ad872-144">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="ad872-145">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="ad872-145">ConcurrentBag</span></span>  
 <span data-ttu-id="ad872-146">Em cenários de produtor-consumidor puros, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> provavelmente funcionará mais lentamente do que os outros tipos de coleção simultâneas.</span><span class="sxs-lookup"><span data-stu-id="ad872-146">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="ad872-147">Em cenários produtor-consumidor mistos, <xref:System.Collections.Concurrent.ConcurrentBag%601> geralmente é muito mais rápido e mais escalonável do que qualquer outro tipo de coleção simultânea para cargas de trabalho grandes e pequenas.</span><span class="sxs-lookup"><span data-stu-id="ad872-147">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="ad872-148">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="ad872-148">BlockingCollection</span></span>  
 <span data-ttu-id="ad872-149">Quando forem necessárias semânticas de delimitação e bloqueio, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> provavelmente funcionará mais rápido do que qualquer implementação personalizada.</span><span class="sxs-lookup"><span data-stu-id="ad872-149">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="ad872-150">Ele também dá suporte ao cancelamento, enumeração e tratamento de exceções avançados.</span><span class="sxs-lookup"><span data-stu-id="ad872-150">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ad872-151">Veja também</span><span class="sxs-lookup"><span data-stu-id="ad872-151">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="ad872-152">Coleções com segurança de thread</span><span class="sxs-lookup"><span data-stu-id="ad872-152">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="ad872-153">Programação paralela</span><span class="sxs-lookup"><span data-stu-id="ad872-153">Parallel Programming</span></span>](../../parallel-programming/index.md)
