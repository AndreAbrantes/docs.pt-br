---
title: "Comunicação em uma arquitetura de microsserviço"
description: "Arquitetura de Microservices .NET para aplicativos .NET em contêineres | Comunicação em um arquiteturas de arquitetura de microsserviço"
keywords: "Docker, Microsserviços, ASP.NET, Contêiner"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="3b2f8-104">Comunicação em uma arquitetura de microsserviço</span><span class="sxs-lookup"><span data-stu-id="3b2f8-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="3b2f8-105">Em um aplicativo monolítico em execução em um único processo, componentes de chamar outro usando o método de nível de linguagem ou chamadas de função.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="3b2f8-106">Esses podem ser fortemente acoplados se você estiver criando objetos com o código de (por exemplo, `new ClassName()`), ou pode ser invocado de forma separada, se você estiver usando a injeção de dependência referenciando abstrações em vez de instâncias de objeto concreto.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="3b2f8-107">De qualquer forma, os objetos estão sendo executados no mesmo processo.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="3b2f8-108">O maior desafio durante a alteração de um aplicativo monolítico para um aplicativo baseado em microservices é alterar o mecanismo de comunicação.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="3b2f8-109">Uma conversão direta de chamadas de método em processo em chamadas RPC para serviços fará com que um verborrágica e ambientes distribuídos de comunicação não eficiente que não executará bem no.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="3b2f8-110">Desafios de criação de sistema distribuído corretamente bem conhecidos que ainda há um canon conhecido como o [fallacies de computação distribuída](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) que lista as suposições que os desenvolvedores geralmente fazem quando movendo de monolítico designs distribuído.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="3b2f8-111">Não há não é uma solução, mas várias.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-111">There is not one solution, but several.</span></span> <span data-ttu-id="3b2f8-112">Uma solução envolve isolar o microservices de negócios tanto quanto possível.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="3b2f8-113">Você, em seguida, usa a comunicação assíncrona entre o microservices interno e substitua refinada comunicação típica na comunicação entre processos entre objetos com a comunicação mais rústico.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="3b2f8-114">Você pode fazer isso com o agrupamento de chamadas e retornando dados que agrega os resultados de várias chamadas internos, para o cliente.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="3b2f8-115">Um aplicativo baseado em microservices é um sistema distribuído em execução em vários processos ou serviços, geralmente, até mesmo em vários servidores ou hosts.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="3b2f8-116">Cada instância de serviço geralmente é um processo.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-116">Each service instance is typically a process.</span></span> <span data-ttu-id="3b2f8-117">Portanto, os serviços devem interagir usando um protocolo de comunicação entre processos, como HTTP, AMQP ou um protocolo binário, como TCP, dependendo da natureza de cada serviço.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="3b2f8-118">A comunidade de microsserviço promove a filosofia de "[inteligentes pontos de extremidade e pipes tolos](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)."</span><span class="sxs-lookup"><span data-stu-id="3b2f8-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="3b2f8-119">Este slogan incentiva um design que é separada possível entre microservices e como coesa possível dentro de um único microsserviço.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="3b2f8-120">Conforme explicado anteriormente, cada microsserviço possui sua própria lógica do domínio e seus próprios dados.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="3b2f8-121">Mas as composição de um aplicativo de ponta a ponta de microservices são geralmente simplesmente coreografados usando comunicações REST em vez de protocolos complexos, como WS -\* e comunicações flexíveis controlada por evento, em vez de centralizado processo orchestrators Business.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="3b2f8-122">Os dois protocolos usados são de solicitação/resposta HTTP com recurso de APIs (quando a consulta de tudo), e mensagens assíncronas leve, ao se comunicar atualizações em vários microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="3b2f8-123">Essas são explicadas em mais detalhes nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="3b2f8-124">Tipos de comunicação</span><span class="sxs-lookup"><span data-stu-id="3b2f8-124">Communication types</span></span>

<span data-ttu-id="3b2f8-125">Serviços de cliente e podem se comunicar por meio de vários tipos diferentes de comunicação, cada um deles direcionando um cenário diferente e metas.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="3b2f8-126">Inicialmente, esses tipos de comunicação podem ser classificados em dois eixos.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="3b2f8-127">O primeiro eixo é definir se o protocolo é síncrona ou assíncrona:</span><span class="sxs-lookup"><span data-stu-id="3b2f8-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="3b2f8-128">Protocolo síncrono.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-128">Synchronous protocol.</span></span> <span data-ttu-id="3b2f8-129">HTTP é um protocolo síncrono.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="3b2f8-130">O cliente envia uma solicitação e aguarda uma resposta do serviço.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="3b2f8-131">Que é independente da execução de código do cliente que pode ser síncrona (o thread está bloqueado) ou assíncrona (thread não está bloqueado e a resposta alcançará eventualmente um retorno de chamada).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="3b2f8-132">O ponto importante aqui é que o protocolo (HTTP/HTTPS) é síncrono e o código de cliente só pode continuar sua tarefa quando ele recebe a resposta do servidor HTTP.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="3b2f8-133">Protocolo assíncrono.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-133">Asynchronous protocol.</span></span> <span data-ttu-id="3b2f8-134">Outros protocolos, como o AMQP (um protocolo com suporte por vários sistemas operacionais e ambientes de nuvem) usam mensagens assíncronas.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="3b2f8-135">O remetente da mensagem ou código de cliente geralmente não aguarda uma resposta.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="3b2f8-136">Ele apenas envia a mensagem como quando enviar uma mensagem para uma fila de RabbitMQ ou qualquer outro agente de mensagens.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="3b2f8-137">O segundo eixo é definir se a comunicação com um único destinatário ou vários destinatários:</span><span class="sxs-lookup"><span data-stu-id="3b2f8-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="3b2f8-138">Único destinatário.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-138">Single receiver.</span></span> <span data-ttu-id="3b2f8-139">Cada solicitação deve ser processada pelo exatamente um destinatário ou serviço.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="3b2f8-140">Um exemplo de como essa comunicação é o [padrão de comando](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="3b2f8-141">Vários destinatários.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-141">Multiple receivers.</span></span> <span data-ttu-id="3b2f8-142">Cada solicitação pode ser processada por zero para vários destinatários.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="3b2f8-143">Esse tipo de comunicação deve ser assíncrono.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="3b2f8-144">Um exemplo é o [de publicação/assinatura](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mecanismo usado em padrões como [arquitetura orientada a eventos](http://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="3b2f8-145">Isso se baseia em um agente de mensagem ou interface de barramento de evento ao propagar atualizações de dados entre vários microservices por meio de eventos; Ele geralmente é implementado por meio de um barramento de serviço ou artefato semelhante como [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) usando [tópicos e assinaturas](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="3b2f8-146">Um aplicativo baseado em microsserviço geralmente usará uma combinação desses estilos de comunicação.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="3b2f8-147">O tipo mais comum é o único destinatário comunicação com um protocolo síncrona como HTTP/HTTPS ao invocar um serviço da Web API HTTP regular.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="3b2f8-148">Microservices também geralmente usam protocolos de mensagens para comunicação assíncrona entre microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="3b2f8-149">Esses eixos serão boas conhecer para ter maior clareza os mecanismos de comunicação possíveis, mas eles não são as questões importantes ao criar microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="3b2f8-150">A natureza assíncrona de execução de thread de cliente nem a natureza assíncrona do protocolo selecionado são os pontos importantes ao integrar microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="3b2f8-151">O que *é* importante é ser capaz de integrar seu microservices assincronamente, mantendo a independência de microservices, conforme explicado na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="3b2f8-152">Integração de microsserviço assíncrona impõe a autonomia do microsserviço</span><span class="sxs-lookup"><span data-stu-id="3b2f8-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="3b2f8-153">Conforme mencionado, o ponto importante ao criar um aplicativo baseado em microservices é a maneira como você integrar seu microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="3b2f8-154">Idealmente, você deve tentar minimizar a comunicação entre o microservices interno.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="3b2f8-155">O menor comunicações entre microservices, melhor.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="3b2f8-156">Mas é claro que, em muitos casos você terá alguma forma integrar o microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="3b2f8-157">Quando você precisar fazer isso, a regra crítica aqui é que a comunicação entre o microservices deve ser assíncrona.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="3b2f8-158">Isso não significa que você precisa usar um protocolo específico (por exemplo, sistema de mensagens assíncronas versus HTTP síncrona).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="3b2f8-159">Isso significa apenas que a comunicação entre microservices deve ser feito apenas pelo propagar dados de forma assíncrona, mas não dependem de outros microservices interno como parte da operação de solicitação/resposta HTTP do serviço inicial.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="3b2f8-160">Se possível, nunca dependem síncrona (solicitação/resposta) de comunicação entre vários microservices, nem mesmo para consultas.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="3b2f8-161">O objetivo de cada microsserviço é ser autônoma e disponível para o consumidor de cliente, mesmo que outros serviços que fazem parte do aplicativo ponta a ponta para baixo ou não íntegro.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="3b2f8-162">Se você acha que você precisa fazer uma chamada de um microsserviço para outros microservices (como executar uma solicitação HTTP para uma consulta de dados) para ser capaz de fornecer uma resposta a um aplicativo cliente, você tem uma arquitetura que não devem ser resiliente quando alguns microservices falhar.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="3b2f8-163">Além disso, ter dependências HTTP entre microservices, como ao criar longos ciclos de solicitação/resposta HTTP solicitarem cadeias, conforme mostrado na primeira parte da Figura 4-15, não apenas faz com que seu microservices não autônomo, mas também o seu desempenho é Assim que um dos serviços nessa cadeia não está executando também um impacto.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="3b2f8-164">Quanto mais você adicionar dependências síncronas entre microservices, como solicitações de consulta, pior o tempo de resposta geral é para os aplicativos cliente.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="3b2f8-165">**Figura 4-15**.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-165">**Figure 4-15**.</span></span> <span data-ttu-id="3b2f8-166">Padrões e padrões de comunicação entre microservices</span><span class="sxs-lookup"><span data-stu-id="3b2f8-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="3b2f8-167">Se seu microsserviço precisar gerar uma ação adicional em outro microsserviço, se possível, não execute essa ação síncrona e como parte da operação original microsserviço solicitação e resposta.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="3b2f8-168">Em vez disso, fazer isso de maneira assíncrona (usando o serviço de mensagens assíncrono ou eventos de integração, filas, etc.).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="3b2f8-169">No entanto, tanto quanto possível, não chamar a ação de forma síncrona como parte da operação de solicitação e resposta síncrona original.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="3b2f8-170">E, finalmente, (e isso é onde a maioria dos problemas podem surgir durante a criação de microservices), se o microsserviço inicial precisa de dados que é originalmente pertencentes a outros microservices, não confie em síncrona solicitar que os dados.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="3b2f8-171">Em vez disso, replicar ou para a propagação de dados (somente os atributos necessários) no banco de dados do serviço inicial usando consistência eventual (normalmente com eventos de integração, conforme explicado nas seções futuras).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="3b2f8-172">Conforme observado anteriormente na seção [identificar limites de modelo de domínio para cada microsserviço](#identifying-domain-model-boundaries-for-each-microservice), duplicação de alguns dados em vários microservices não é um design incorreto, ao contrário, quando disso, você pode converter os dados na linguagem específica ou termos desse domínio adicional ou contexto associado.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="3b2f8-173">Por exemplo, no [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) aplicativo tiver um microsserviço chamado identity.api que é responsável pela maioria dos dados do usuário com uma entidade chamada do usuário.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="3b2f8-174">No entanto, quando você precisar armazenar dados sobre o usuário dentro do microsserviço ordenação, você armazená-lo como uma entidade diferente denominada comprador.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="3b2f8-175">A entidade de comprador compartilha a mesma identidade com a entidade de usuário original, mas ele pode ter apenas alguns atributos necessários para o domínio de ordenação e não o perfil de usuário inteiro.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="3b2f8-176">Você pode usar qualquer protocolo de comunicação e propagado dados assincronamente microservices para ter consistência eventual.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="3b2f8-177">Conforme mencionado, você pode usar eventos de integração usando um barramento de evento ou mensagem de agente, ou você pode até usar HTTP consultando os outros serviços em vez disso.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="3b2f8-178">Não importa.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-178">It does not matter.</span></span> <span data-ttu-id="3b2f8-179">A regra importante é não criar síncronas dependências entre seu microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="3b2f8-180">As seções a seguir explicam os vários estilos de comunicação que você pode considerar o uso de um aplicativo baseado em microsserviço.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="3b2f8-181">Estilos de comunicação</span><span class="sxs-lookup"><span data-stu-id="3b2f8-181">Communication styles</span></span>

<span data-ttu-id="3b2f8-182">Há muitos protocolos e as opções que você pode usar para comunicação, dependendo do tipo de comunicação que você deseja usar.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="3b2f8-183">Se você estiver usando um mecanismo de comunicação baseada em solicitação/resposta síncrona, protocolos como HTTP e REST abordagens são as mais comuns, especialmente se você estiver publicando seus serviços fora do cluster de host ou microsserviço do Docker.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="3b2f8-184">Se você está se comunicando entre serviços internamente (no seu cluster de host ou microservices Docker) você também poderá usar os mecanismos de comunicação do formato binário (como remoting Service Fabric ou WCF usando TCP e o formato binário).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="3b2f8-185">Como alternativa, você pode usar mecanismos de comunicação assíncrona, com base em mensagem, como o AMQP.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="3b2f8-186">Também há vários formatos de mensagem como JSON ou XML, ou até mesmo binários formatos, que podem ser mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="3b2f8-187">Se o formato binário escolhido não é um padrão, ele provavelmente não é uma boa ideia publicamente publicar seus serviços usando esse formato.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="3b2f8-188">Você pode usar um formato diferente do padrão para comunicação interna entre o microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="3b2f8-189">Você pode fazer isso ao se comunicar entre microservices no Docker host ou microsserviço cluster (orchestrators Docker ou do Azure Service Fabric) ou para aplicativos cliente proprietárias que falar com o microservices.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="3b2f8-190">Comunicação de solicitação/resposta com HTTP e REST</span><span class="sxs-lookup"><span data-stu-id="3b2f8-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="3b2f8-191">Quando um cliente usa a comunicação de solicitação/resposta, ele envia uma solicitação para um serviço, em seguida, o serviço processa a solicitação e envia uma resposta.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="3b2f8-192">Comunicação de solicitação/resposta é especialmente adequada para consultar dados de uma interface de usuário em tempo real (uma interface do usuário em tempo real) dos aplicativos cliente.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="3b2f8-193">Portanto, em uma arquitetura de microsserviço você provavelmente usará esse mecanismo de comunicação para a maioria das consultas, conforme mostrado na Figura 4-16.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="3b2f8-194">**Figura 4-16**.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-194">**Figure 4-16**.</span></span> <span data-ttu-id="3b2f8-195">Usando a comunicação de solicitação/resposta HTTP (síncrona ou assíncrona)</span><span class="sxs-lookup"><span data-stu-id="3b2f8-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="3b2f8-196">Quando um cliente usa a comunicação de solicitação/resposta, ele pressupõe que a resposta chegarão em um curto período de tempo, geralmente menos de um segundo ou alguns segundos no máximo.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="3b2f8-197">Para obter respostas atrasadas, você precisa implementar a comunicação assíncrona com base em [padrões de mensagens](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) e [mensagens tecnologias](https://en.wikipedia.org/wiki/Message-oriented_middleware), que é uma abordagem diferente explicamos na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="3b2f8-198">Um estilo popular de arquitetura para comunicação de solicitação/resposta é [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="3b2f8-199">Essa abordagem é baseada e rigidamente acoplada, o [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocolo, adotando verbos HTTP como GET, POST e colocar.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="3b2f8-200">REST é a abordagem de arquitetura de comunicação mais comumente usadas durante a criação de serviços.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="3b2f8-201">Você pode implementar serviços REST ao desenvolver serviços de API da Web do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="3b2f8-202">Há valor adicional ao usar serviços REST de HTTP como linguagem de definição de interface.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="3b2f8-203">Por exemplo, se você usar [Swagger metadados](http://swagger.io/) para descrever sua API de serviço, você pode usar ferramentas que geram stubs de cliente que podem descobrir e consumir seus serviços diretamente.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="3b2f8-204">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="3b2f8-204">Additional resources</span></span>

-   <span data-ttu-id="3b2f8-205">**Martin Fowler. Modelo de maturidade Richardson.**</span><span class="sxs-lookup"><span data-stu-id="3b2f8-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="3b2f8-206">Uma descrição do modelo de REST.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-206">A description of the REST model.</span></span>
    [<span data-ttu-id="3b2f8-207">*http://martinfowler.com/articles/richardsonMaturityModel.HTML*</span><span class="sxs-lookup"><span data-stu-id="3b2f8-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="3b2f8-208">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="3b2f8-208">**Swagger.**</span></span> <span data-ttu-id="3b2f8-209">O site oficial.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-209">The official site.</span></span>
    [<span data-ttu-id="3b2f8-210">*http://swagger.IO/*</span><span class="sxs-lookup"><span data-stu-id="3b2f8-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="3b2f8-211">Envio e comunicação em tempo real com base em HTTP</span><span class="sxs-lookup"><span data-stu-id="3b2f8-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="3b2f8-212">Outra possibilidade (geralmente para finalidades diferentes REST) é uma comunicação em tempo real e um-para-muitos com estruturas de nível mais alto, como [ASP.NET SignalR](https://www.asp.net/signalr) e protocolos como [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="3b2f8-213">Como mostra a Figura 4-17, a comunicação HTTP em tempo real significa que você pode ter o código de servidor Publicando conteúdo para clientes conectados, como os dados se torna disponíveis, em vez de ter o servidor espera para um cliente solicitar novos dados.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="3b2f8-214">**Figura 4-17**.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-214">**Figure 4-17**.</span></span> <span data-ttu-id="3b2f8-215">Comunicação de um para um mensagem assíncrona em tempo real</span><span class="sxs-lookup"><span data-stu-id="3b2f8-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="3b2f8-216">Como a comunicação em tempo real, os aplicativos cliente mostram as alterações quase instantaneamente.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="3b2f8-217">Geralmente, isso é tratado por um protocolo como WebSockets, usando várias conexões WebSocket (um por cliente).</span><span class="sxs-lookup"><span data-stu-id="3b2f8-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="3b2f8-218">Um exemplo típico é quando um serviço comunica-se uma alteração na partição de um jogo de esportes para muitos aplicativos de web do cliente simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="3b2f8-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="3b2f8-219">[Anterior] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Avançar] (assíncrona-mensagem-com base-communication.md)</span><span class="sxs-lookup"><span data-stu-id="3b2f8-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
