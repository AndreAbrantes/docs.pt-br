---
title: "Estratégias para lidar com falhas parciais"
description: "Arquitetura de Microservices .NET para aplicativos .NET em contêineres | Estratégias para lidar com falhas parciais"
keywords: "Docker, Microsserviços, ASP.NET, Contêiner"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ff3bed530b13a9b1822c7cccf5a4d47df6fc6239
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="5d6ab-104">Estratégias para lidar com falhas parciais</span><span class="sxs-lookup"><span data-stu-id="5d6ab-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="5d6ab-105">Estratégias para lidar com falhas parciais incluem o seguinte.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="5d6ab-106">**Usar a comunicação assíncrona (por exemplo, comunicação baseada em mensagens) em microservices interno**.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="5d6ab-107">É altamente recomendável não criar longas cadeias de chamadas síncronas de HTTP entre o microservices interno porque esse design incorreto eventualmente se tornará a principal causa de interrupções incorretas.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="5d6ab-108">Ao contrário, exceto para as front-end comunicações entre os aplicativos cliente e o primeiro nível de microservices ou refinada Gateways de API, é recomendável usar apenas (com base em mensagem) comunicação assíncrona uma vez após a solicitação inicial / ciclo de resposta, entre o microservices interno.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="5d6ab-109">Consistência eventual e arquiteturas orientadas por eventos ajudarão para minimizar os efeitos em cascata.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="5d6ab-110">Essas abordagens impõem um nível mais alto de microsserviço autonomia e, portanto, evitar o problema mencionado aqui.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="5d6ab-111">**Use as repetições com retirada exponencial**.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="5d6ab-112">Essa técnica ajuda a evitar curto e tentativas de falhas intermitentes realizando a chamada de um determinado número de vezes, caso o serviço não estava disponível apenas por um curto período.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="5d6ab-113">Isso pode ocorrer devido a problemas de rede intermitente ou quando um contêiner de microsserviço/é movido para outro nó em um cluster.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="5d6ab-114">No entanto, se essas tentativas não foram projetadas corretamente com disjuntores, ele pode aggravate o efeito de ondulação, causando, por fim, até mesmo um [dos (negação de serviço)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="5d6ab-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="5d6ab-115">**Solução alternativa tempos limite de rede**.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-115">**Work around network timeouts**.</span></span> <span data-ttu-id="5d6ab-116">Em geral, os clientes devem ser criados para não ser bloqueado indefinidamente e para sempre usar tempos limite ao aguardar uma resposta.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="5d6ab-117">Usando tempos limites garante que recursos nunca são associados indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="5d6ab-118">**Use o padrão de disjuntor**.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="5d6ab-119">Nessa abordagem, o processo de cliente rastreia o número de solicitações com falha.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="5d6ab-120">Se a taxa de erros exceder um limite configurado, um viagens "disjuntor" para que outras tentativas falham imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="5d6ab-121">(Se um grande número de solicitações estiverem falhando, que sugere o serviço está indisponível e enviar solicitações é inútil.) Após um período de tempo limite, o cliente deve tentar novamente e se as novas solicitações forem bem-sucedidas, feche o disjuntor.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="5d6ab-122">**Fornecer fallbacks**.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-122">**Provide fallbacks**.</span></span> <span data-ttu-id="5d6ab-123">Nessa abordagem, o processo de cliente executa a lógica de fallback quando uma solicitação falhar, como retornar dados armazenados em cache ou um valor padrão.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="5d6ab-124">Isso é uma abordagem adequada para consultas e é mais complexo para as atualizações ou comandos.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="5d6ab-125">**Limitar o número de solicitações em fila**.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="5d6ab-126">Os clientes também devem impor um limite superior no número de solicitações pendentes que microsserviço um cliente pode enviar para um serviço específico.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="5d6ab-127">Se o limite for atingido, ele provavelmente será ineficaz fazer solicitações adicionais e as tentativas devem falhar imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="5d6ab-128">Em termos de implementação, a Polly [Bulkhead isolamento](https://github.com/App-vNext/Polly/wiki/Bulkhead) política pode ser usada para atenderem a esse requisito.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="5d6ab-129">Essa abordagem é essencialmente um acelerador de paralelização com [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) como a implementação.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="5d6ab-130">Ele também permite que uma "fila" fora de bulkhead.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="5d6ab-131">Você proativamente pode lançar uma carga excessiva, mesmo antes da execução (por exemplo, porque a capacidade é considerada completa).</span><span class="sxs-lookup"><span data-stu-id="5d6ab-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="5d6ab-132">Isso torna sua resposta a determinados cenários de falha mais rápido do que um disjuntor seria, desde que o disjuntor aguarda até que as falhas.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="5d6ab-133">O objeto BulkheadPolicy Polly expõe quanto o bulkhead fila, e são ofertas eventos no estouro assim também podem ser usados para a unidade de escala horizontal automatizada.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="5d6ab-134">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="5d6ab-134">Additional resources</span></span>

-   <span data-ttu-id="5d6ab-135">**Padrões de resiliência**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="5d6ab-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="5d6ab-136">**Adição de resiliência e otimizar o desempenho**
    [*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="5d6ab-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="5d6ab-137">**Bulkhead.**</span><span class="sxs-lookup"><span data-stu-id="5d6ab-137">**Bulkhead.**</span></span> <span data-ttu-id="5d6ab-138">Repositório do GitHub.</span><span class="sxs-lookup"><span data-stu-id="5d6ab-138">GitHub repo.</span></span> <span data-ttu-id="5d6ab-139">Implementação de política Polly. \\</span><span class="sxs-lookup"><span data-stu-id="5d6ab-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="5d6ab-140">*https://GitHub.com/App-vNext/Polly/wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="5d6ab-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="5d6ab-141">**Desenvolvendo aplicativos resilientes do Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="5d6ab-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="5d6ab-142">**Tratamento de falhas transitórias**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="5d6ab-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="5d6ab-143">[Anterior] (identificador-parcial-failure.md) [Avançar] (implementar-tentativas-exponencial-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="5d6ab-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
