---
title: Estratégias para tratar falhas parciais
description: Conheça várias estratégias para tratar falhas parciais normalmente.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/16/2018
ms.openlocfilehash: ad45e357c1656b9346b7bdb5f324bde5fa76eaba
ms.sourcegitcommit: 542aa405b295955eb055765f33723cb8b588d0d0
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/17/2019
ms.locfileid: "54362763"
---
# <a name="strategies-to-handle-partial-failure"></a><span data-ttu-id="7a5fc-103">Estratégias para tratar falhas parciais</span><span class="sxs-lookup"><span data-stu-id="7a5fc-103">Strategies to handle partial failure</span></span>

<span data-ttu-id="7a5fc-104">As estratégias para lidar com falhas parciais incluem o seguinte.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="7a5fc-105">**Usar a comunicação assíncrona (por exemplo, comunicação baseada em mensagens) entre microsserviços internos**.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="7a5fc-106">É altamente recomendado não criar cadeias longas de chamadas HTTP síncronas entre os microsserviços internos, porque esse design incorreto poderá se tornar a principal causa de interrupções incorretas.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-106">It's highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="7a5fc-107">Pelo contrário, exceto pelas comunicações de front-end entre os aplicativos cliente e o primeiro nível de microsserviços ou Gateways de API refinados, é recomendado usar apenas a comunicação assíncrona (com base em mensagem) uma vez após o ciclo inicial de resposta/solicitação, entre os microsserviços internos.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it's recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="7a5fc-108">Consistência eventual e arquiteturas orientadas a eventos ajudarão a minimizar os efeitos de ondulação.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="7a5fc-109">Essas abordagens impõem um nível mais alto de autonomia do microsserviço e, portanto, previnem contra o problema observado aqui.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="7a5fc-110">**Usar novas tentativas com retirada exponencial**.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="7a5fc-111">Essa técnica ajuda a evitar falhas curtas e intermitentes executando novas tentativas de chamada um determinado número de vezes, caso o serviço não tivesse estado disponível apenas por um curto período de tempo.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="7a5fc-112">Isso pode ocorrer devido a problemas de rede intermitentes ou quando um microsserviço/contêiner é movido para um nó diferente em um cluster.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="7a5fc-113">No entanto, se essas novas tentativas não foram criadas corretamente com disjuntores, os efeitos de ondulação poderão ser agravados e, em último caso, poderá até haver uma [DoS (Negação de Serviço)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="7a5fc-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="7a5fc-114">**Solução alternativa para tempos limite de rede**.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-114">**Work around network timeouts**.</span></span> <span data-ttu-id="7a5fc-115">Em geral, os clientes devem ser criados para não serem bloqueados indefinidamente e para sempre usar tempos limite ao aguardar uma resposta.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="7a5fc-116">Usar tempos limite garante que os recursos nunca fiquem bloqueados indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="7a5fc-117">**Usar o padrão de disjuntor**.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="7a5fc-118">Nessa abordagem, o processo do cliente rastreia o número de solicitações com falha.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="7a5fc-119">Se a taxa de erro exceder um limite configurado, um "disjuntor" viajará para que outras tentativas falhem imediatamente.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="7a5fc-120">(Se um alto número de solicitações estão apresentando falha, isso sugere que o serviço não está disponível e que enviar solicitações é inútil.) Após um período de tempo limite, o cliente deverá tentar novamente e, se as novas solicitações forem bem-sucedidas, feche o disjuntor.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="7a5fc-121">**Fornecer fallbacks**.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-121">**Provide fallbacks**.</span></span> <span data-ttu-id="7a5fc-122">Nessa abordagem, o processo de cliente executa a lógica de fallback quando uma solicitação falha, como retornar dados armazenados em cache ou um valor padrão.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="7a5fc-123">Essa é uma abordagem adequada para consultas e é mais complexa para atualizações ou comandos.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="7a5fc-124">**Limitar o número de solicitações na fila**.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="7a5fc-125">Os clientes também devem impor um limite superior no número de solicitações pendentes que um microsserviço cliente pode enviar para um serviço específico.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="7a5fc-126">Se o limite for atingido, provavelmente será ineficaz fazer mais solicitações. As tentativas falharão imediatamente.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-126">If the limit has been reached, it's probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="7a5fc-127">Em termos de implementação, a política [Isolamento do bulkhead](https://github.com/App-vNext/Polly/wiki/Bulkhead) da Polly pode ser usada para atender a esse requisito.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="7a5fc-128">Essa abordagem é essencialmente uma restrição de paralelização com <xref:System.Threading.SemaphoreSlim> como a implementação.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="7a5fc-129">Ela também permite uma "fila" fora do bulkhead.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="7a5fc-130">É possível lançar proativamente uma carga excessiva mesmo antes da execução (por exemplo, devido à capacidade ser considerada cheia).</span><span class="sxs-lookup"><span data-stu-id="7a5fc-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="7a5fc-131">Isso torna sua resposta a determinados cenários de falha mais rápida do que um disjuntor seria, uma vez que o disjuntor aguarda as falhas.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="7a5fc-132">O objeto BulkheadPolicy na [Polly](http://www.thepollyproject.org/) expõe se o bulkhead e a fila estão cheios e oferece eventos em estouro, portanto, ele também pode ser usado para permitir a escala horizontal automatizada.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-132">The BulkheadPolicy object in [Polly](http://www.thepollyproject.org/) exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="7a5fc-133">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="7a5fc-133">Additional resources</span></span>

- <span data-ttu-id="7a5fc-134">**Padrões de resiliência**\\</span><span class="sxs-lookup"><span data-stu-id="7a5fc-134">**Resiliency patterns**\\</span></span>
  [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](/azure/architecture/patterns/category/resiliency)

- <span data-ttu-id="7a5fc-135">**Adicionando resiliência e otimizando o desempenho**\\</span><span class="sxs-lookup"><span data-stu-id="7a5fc-135">**Adding Resilience and Optimizing Performance**\\</span></span>
  [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)

- <span data-ttu-id="7a5fc-136">**Bulkhead.**</span><span class="sxs-lookup"><span data-stu-id="7a5fc-136">**Bulkhead.**</span></span> <span data-ttu-id="7a5fc-137">Repositório do GitHub.</span><span class="sxs-lookup"><span data-stu-id="7a5fc-137">GitHub repo.</span></span> <span data-ttu-id="7a5fc-138">Implementação com a política Polly.\\</span><span class="sxs-lookup"><span data-stu-id="7a5fc-138">Implementation with Polly policy.\\</span></span>
  [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

- <span data-ttu-id="7a5fc-139">**Projetando aplicativos resilientes para o Azure**\\</span><span class="sxs-lookup"><span data-stu-id="7a5fc-139">**Designing resilient applications for Azure**\\</span></span>
  [*https://docs.microsoft.com/azure/architecture/resiliency/*](/azure/architecture/resiliency/)

- <span data-ttu-id="7a5fc-140">**Tratamento de falhas transitórias**\\</span><span class="sxs-lookup"><span data-stu-id="7a5fc-140">**Transient fault handling**\\</span></span>
  [*https://docs.microsoft.com/azure/architecture/best-practices/transient-faults*](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
><span data-ttu-id="7a5fc-141">[Anterior](handle-partial-failure.md)
>[Próximo](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="7a5fc-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>