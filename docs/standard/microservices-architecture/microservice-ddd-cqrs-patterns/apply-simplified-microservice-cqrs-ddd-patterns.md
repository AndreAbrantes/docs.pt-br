---
title: Aplicando padrões CQRS e DDD simplificados em um microsserviço
description: Arquitetura de microsserviços do .NET para aplicativos .NET em contêineres | Entender a relação geral entre os padrões CQRS e DDD.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/08/2018
ms.openlocfilehash: ef3260143c91c2500becd7c8c1a6cd0b81dbf3d2
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/10/2018
ms.locfileid: "53148061"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="86a12-103">Aplicar padrões CQRS e DDD simplificados em um microsserviço</span><span class="sxs-lookup"><span data-stu-id="86a12-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="86a12-104">O CQRS é um padrão de arquitetura que separa os modelos para ler e gravar dados.</span><span class="sxs-lookup"><span data-stu-id="86a12-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="86a12-105">O termo relacionado [CQS (Separação de Comando-Consulta)](https://martinfowler.com/bliki/CommandQuerySeparation.html) foi originalmente definido por Bertrand Meyer em seu livro *Object Oriented Software Construction* (Construção de software orientada a objeto).</span><span class="sxs-lookup"><span data-stu-id="86a12-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="86a12-106">A ideia básica é que você pode dividir operações de um sistema em duas categorias nitidamente separadas:</span><span class="sxs-lookup"><span data-stu-id="86a12-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="86a12-107">Consultas.</span><span class="sxs-lookup"><span data-stu-id="86a12-107">Queries.</span></span> <span data-ttu-id="86a12-108">Essas retornam um resultado, não alteram o estado do sistema e são livres de efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="86a12-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="86a12-109">Comandos.</span><span class="sxs-lookup"><span data-stu-id="86a12-109">Commands.</span></span> <span data-ttu-id="86a12-110">Esses alteram o estado de um sistema.</span><span class="sxs-lookup"><span data-stu-id="86a12-110">These change the state of a system.</span></span>

<span data-ttu-id="86a12-111">O CQS é um conceito simples — trata-se de métodos dentro do mesmo objeto sendo consultas ou comandos.</span><span class="sxs-lookup"><span data-stu-id="86a12-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="86a12-112">Cada método retorna um estado ou muda um estado, mas não ambos.</span><span class="sxs-lookup"><span data-stu-id="86a12-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="86a12-113">Até mesmo um único objeto de padrão de repositório pode estar em conformidade com o CQS.</span><span class="sxs-lookup"><span data-stu-id="86a12-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="86a12-114">O CQS pode ser considerado um princípio fundamental para o CQRS.</span><span class="sxs-lookup"><span data-stu-id="86a12-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="86a12-115">O [CQRS (Segregação de Responsabilidade de Consulta e Comando)](https://martinfowler.com/bliki/CQRS.html) foi introduzido por Greg Young e altamente promovido por Udi Dahan e outros.</span><span class="sxs-lookup"><span data-stu-id="86a12-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="86a12-116">Ele se baseia no princípio do CQS, embora seja mais detalhado.</span><span class="sxs-lookup"><span data-stu-id="86a12-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="86a12-117">Ele pode ser considerado um padrão com base em comandos e eventos, além de ser opcional em mensagens assíncronas.</span><span class="sxs-lookup"><span data-stu-id="86a12-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="86a12-118">Em muitos casos, o CQRS está relacionado a cenários mais avançados, como ter um banco de dados físico para leituras (consultas) diferente do banco de dados para gravações (atualizações).</span><span class="sxs-lookup"><span data-stu-id="86a12-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="86a12-119">Além disso, um sistema CQRS mais evoluído pode implementar [ES (fonte de eventos)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) em seu banco de dados de atualizações. Assim, você deve apenas armazenar eventos no modelo de domínio, em vez de armazenar os dados do estado atual.</span><span class="sxs-lookup"><span data-stu-id="86a12-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="86a12-120">No entanto, essa não é a abordagem usada neste guia; estamos usando a abordagem mais simples de CQRS, que consiste em separar apenas as consultas dos comandos.</span><span class="sxs-lookup"><span data-stu-id="86a12-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="86a12-121">O aspecto de separação do CQRS é obtido pelo agrupamento de operações de consulta em uma camada e comandos em outra camada.</span><span class="sxs-lookup"><span data-stu-id="86a12-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="86a12-122">Cada camada tem seu próprio modelo de dados (observe que dizemos modelo, não necessariamente um banco de dados diferente) e é criada usando sua própria combinação de padrões e tecnologias.</span><span class="sxs-lookup"><span data-stu-id="86a12-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="86a12-123">Além disso, as duas camadas podem estar dentro do mesmo nível ou microsserviço, como no exemplo (microsserviço de ordenação) usado para este guia.</span><span class="sxs-lookup"><span data-stu-id="86a12-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="86a12-124">Ou elas podem ser implementadas em diferentes microsserviços ou processos para que possam ser otimizadas e expandidas separadamente sem afetar umas às outras.</span><span class="sxs-lookup"><span data-stu-id="86a12-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="86a12-125">CQRS significa ter dois objetos para uma operação de leitura/gravação, em que, em outros, há um.</span><span class="sxs-lookup"><span data-stu-id="86a12-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="86a12-126">Há motivos para ter um banco de dados de leitura desnormalizado, sobre o qual você pode aprender na literatura sobre CQRS mais avançada.</span><span class="sxs-lookup"><span data-stu-id="86a12-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="86a12-127">Mas não estamos usando essa abordagem aqui, em que a meta é ter mais flexibilidade nas consultas, em vez de limitá-las com restrições de padrões DDD como agregações.</span><span class="sxs-lookup"><span data-stu-id="86a12-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="86a12-128">Um exemplo desse tipo de serviço é o microsserviço de ordenação do aplicativo eShopOnContainers de referência.</span><span class="sxs-lookup"><span data-stu-id="86a12-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="86a12-129">Este serviço implementa um microsserviço com base em uma abordagem CQRS simplificada.</span><span class="sxs-lookup"><span data-stu-id="86a12-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="86a12-130">Ele usa uma única fonte de dados ou banco de dados, mas dois modelos lógicos, além de padrões DDD para o domínio transacional, conforme mostrado na Figura 7-2.</span><span class="sxs-lookup"><span data-stu-id="86a12-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![O microsserviço Pedidos lógico inclui o banco de dados do Pedidos, que pode estar ou não no mesmo host do Docker.](./media/image2.png)

<span data-ttu-id="86a12-133">**Figura 7-2**.</span><span class="sxs-lookup"><span data-stu-id="86a12-133">**Figure 7-2**.</span></span> <span data-ttu-id="86a12-134">Microsserviço baseado em CQRS e DDD simplificado</span><span class="sxs-lookup"><span data-stu-id="86a12-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="86a12-135">A camada de aplicativo pode ser a própria API Web.</span><span class="sxs-lookup"><span data-stu-id="86a12-135">The application layer can be the Web API itself.</span></span> <span data-ttu-id="86a12-136">O aspecto de design importante aqui é que o microsserviço dividiu as consultas e ViewModels (modelos de dados criados especialmente para os aplicativos cliente) dos comandos, do modelo de domínio e das transações que seguem o padrão CQRS.</span><span class="sxs-lookup"><span data-stu-id="86a12-136">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="86a12-137">Essa abordagem mantém as consultas independentes de restrições provenientes de padrões DDD que só fazem sentido para transações e atualizações, conforme explicado nas seções posteriores.</span><span class="sxs-lookup"><span data-stu-id="86a12-137">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="86a12-138">[Anterior](index.md)
>[Próximo](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="86a12-138">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>