---
title: "Criar um microsserviço orientado DDD"
description: "Arquitetura de Microservices .NET para aplicativos .NET em contêineres | Criar um microsserviço orientado DDD"
keywords: "Docker, Microsserviços, ASP.NET, Contêiner"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="a68c1-104">Criar um microsserviço orientado DDD</span><span class="sxs-lookup"><span data-stu-id="a68c1-104">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="a68c1-105">Design orientado a domínio (DDD) advogados modelagem com base em realidade dos negócios como relevantes para seus casos de uso.</span><span class="sxs-lookup"><span data-stu-id="a68c1-105">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="a68c1-106">No contexto da criação de aplicativos, DDD fala sobre problemas de domínios.</span><span class="sxs-lookup"><span data-stu-id="a68c1-106">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="a68c1-107">Ele descreve as áreas de problema independente como contextos limitada (cada contexto limitado se correlaciona com um microsserviço) e enfatizar uma linguagem comum para falar sobre esses problemas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-107">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="a68c1-108">Também sugere muitos conceitos técnicos e padrões, como entidades de domínio com modelos avançados (nenhum [modelo de domínio anêmica](https://martinfowler.com/bliki/AnemicDomainModel.html)), regras de valor objetos, agregações e raiz de agregação (ou entidade raiz) para dar suporte à implementação interna.</span><span class="sxs-lookup"><span data-stu-id="a68c1-108">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="a68c1-109">Esta seção apresenta o design e a implementação desses padrões internos.</span><span class="sxs-lookup"><span data-stu-id="a68c1-109">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="a68c1-110">Às vezes, esses padrões e regras de técnicas de DDD são consideradas obstáculos que têm uma curva de aprendizado acentuada para implementar DDD abordagens.</span><span class="sxs-lookup"><span data-stu-id="a68c1-110">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="a68c1-111">Mas a parte importante é não os padrões, mas organizar o código para que ele será alinhado para os problemas de negócios e usando os mesmos termos de negócios (onipresente language).</span><span class="sxs-lookup"><span data-stu-id="a68c1-111">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="a68c1-112">Além disso, as abordagens DDD devem ser aplicadas somente se você estiver implementando microservices complexas com regras de negócio significativas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-112">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="a68c1-113">Responsabilidades mais simples, como um serviço CRUD, podem ser gerenciadas com abordagens mais simples.</span><span class="sxs-lookup"><span data-stu-id="a68c1-113">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="a68c1-114">Onde desenhar os limites é a chave ao criar e definir um microsserviço.</span><span class="sxs-lookup"><span data-stu-id="a68c1-114">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="a68c1-115">Padrões DDD ajudam a compreender a complexidade do domínio.</span><span class="sxs-lookup"><span data-stu-id="a68c1-115">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="a68c1-116">Para o modelo de domínio para cada contexto limitado, você pode identificar e define agregações que seu domínio de modelo, entidades e objetos de valor.</span><span class="sxs-lookup"><span data-stu-id="a68c1-116">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="a68c1-117">Criar e refinar um modelo de domínio que está contido dentro de um limite que define o contexto.</span><span class="sxs-lookup"><span data-stu-id="a68c1-117">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="a68c1-118">E isso é bastante explícito na forma de um microsserviço.</span><span class="sxs-lookup"><span data-stu-id="a68c1-118">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="a68c1-119">Os componentes dentro desses limites acabam sendo sua microservices, embora em alguns casos, uma continuidade de negócios ou microservices de negócios pode ser composto de vários serviços físicos.</span><span class="sxs-lookup"><span data-stu-id="a68c1-119">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="a68c1-120">DDD é sobre limites e então são microservices.</span><span class="sxs-lookup"><span data-stu-id="a68c1-120">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="a68c1-121">Manter o microsserviço limites de contexto relativamente pequeno</span><span class="sxs-lookup"><span data-stu-id="a68c1-121">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="a68c1-122">Determinar onde colocar os limites entre contextos limitada equilibra a dois objetivos concorrentes.</span><span class="sxs-lookup"><span data-stu-id="a68c1-122">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="a68c1-123">Primeiro, você deseja criar inicialmente o menor possível microservices, embora isso não deve ser o principal driver; Você deve criar um limite de itens que precisam coesão.</span><span class="sxs-lookup"><span data-stu-id="a68c1-123">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="a68c1-124">Em seguida, você deseja evitar a comunicação verborrágica entre microservices.</span><span class="sxs-lookup"><span data-stu-id="a68c1-124">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="a68c1-125">Essas metas podem entrar em uma da outra.</span><span class="sxs-lookup"><span data-stu-id="a68c1-125">These goals can contradict one another.</span></span> <span data-ttu-id="a68c1-126">Você deve equilibrá-los por Decomposição do sistema em quantos microservices pequenos pode até que você veja os limites da comunicação crescendo rapidamente com cada tentativa adicional para separar um novo contexto associado.</span><span class="sxs-lookup"><span data-stu-id="a68c1-126">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="a68c1-127">Coesão é a chave em um único contexto associado.</span><span class="sxs-lookup"><span data-stu-id="a68c1-127">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="a68c1-128">É semelhante do [cheiro de código intimidade inadequada](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) durante a implementação de classes.</span><span class="sxs-lookup"><span data-stu-id="a68c1-128">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="a68c1-129">Se dois microservices precisam colaborar muito entre si, eles devem ser provavelmente o mesmo microsserviço.</span><span class="sxs-lookup"><span data-stu-id="a68c1-129">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="a68c1-130">Outra forma de encarar isso é autonomia.</span><span class="sxs-lookup"><span data-stu-id="a68c1-130">Another way to look at this is autonomy.</span></span> <span data-ttu-id="a68c1-131">Se um microsserviço deve confiar em outro serviço para uma solicitação de serviço diretamente, não é realmente autônomo.</span><span class="sxs-lookup"><span data-stu-id="a68c1-131">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="a68c1-132">Camadas no DDD microservices</span><span class="sxs-lookup"><span data-stu-id="a68c1-132">Layers in DDD microservices</span></span>

<span data-ttu-id="a68c1-133">A maioria dos aplicativos empresariais com significativos para os negócios e a complexidade técnica são definidos por várias camadas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-133">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="a68c1-134">As camadas são um artefato lógico e não estão relacionadas à implantação do serviço.</span><span class="sxs-lookup"><span data-stu-id="a68c1-134">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="a68c1-135">Elas existem para ajudar os desenvolvedores a gerenciar a complexidade no código.</span><span class="sxs-lookup"><span data-stu-id="a68c1-135">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="a68c1-136">Camadas diferentes (como a camada de modelo de domínio versus a camada de apresentação, etc.) podem ter tipos diferentes, que exige conversões entre esses tipos.</span><span class="sxs-lookup"><span data-stu-id="a68c1-136">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="a68c1-137">Por exemplo, uma entidade pode ser carregada do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="a68c1-137">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="a68c1-138">Em seguida, parte de informações ou uma agregação de informações, incluindo dados adicionais de outras entidades, pode ser enviado para o cliente da interface do usuário por meio de uma API da Web REST.</span><span class="sxs-lookup"><span data-stu-id="a68c1-138">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="a68c1-139">O ponto aqui é que a entidade de domínio está contida na camada de modelo de domínio e não deve ser propagada para outras áreas que ele não pertence, como para a camada de apresentação.</span><span class="sxs-lookup"><span data-stu-id="a68c1-139">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="a68c1-140">Além disso, você precisa ter entidades sempre válido (consulte a [criar validações na camada de modelo de domínio](#designing-validations-in-the-domain-model-layer) seção) controlado pelo raízes agregadas (entidades de raiz).</span><span class="sxs-lookup"><span data-stu-id="a68c1-140">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="a68c1-141">Portanto, entidades não devem ser associadas aos modos de exibição do cliente, porque o nível de interface do usuário alguns dados podem não ser validados.</span><span class="sxs-lookup"><span data-stu-id="a68c1-141">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="a68c1-142">Isso é o que é o ViewModel para.</span><span class="sxs-lookup"><span data-stu-id="a68c1-142">This is what the ViewModel is for.</span></span> <span data-ttu-id="a68c1-143">O ViewModel é um modelo de dados exclusivamente para necessidades de camada de apresentação.</span><span class="sxs-lookup"><span data-stu-id="a68c1-143">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="a68c1-144">As entidades de domínio não pertencem diretamente ao ViewModel.</span><span class="sxs-lookup"><span data-stu-id="a68c1-144">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="a68c1-145">Em vez disso, você precisa converter entre entidades ViewModels e domínio e vice-versa.</span><span class="sxs-lookup"><span data-stu-id="a68c1-145">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="a68c1-146">Quando lidando com complexidade, é importante ter um modelo de domínio controlado pelo raízes agregadas (entrarmos em isso em mais detalhes posteriormente) Certifique-se de que todas as constantes e regras relacionam a esse grupo de entidades (agregação) são executadas por meio de uma única entrada ponto de saída ou entrada, a raiz de agregação.</span><span class="sxs-lookup"><span data-stu-id="a68c1-146">When tackling complexity, it is important to have a domain model controlled by aggregate roots (we go into this in more detail later) that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry point or gate, the aggregate root.</span></span>

<span data-ttu-id="a68c1-147">Figura 9-5 mostra como um design em camadas é implementado no aplicativo eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="a68c1-147">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="a68c1-148">**Figura 9-5**.</span><span class="sxs-lookup"><span data-stu-id="a68c1-148">**Figure 9-5**.</span></span> <span data-ttu-id="a68c1-149">Camadas DDD a ordenação microsserviço em eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="a68c1-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="a68c1-150">Você deseja criar o sistema de forma que cada camada se comunica apenas com determinados outras camadas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-150">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="a68c1-151">Que pode ser mais fácil para impor se camadas são implementadas como bibliotecas de classes diferentes, porque você pode identificar claramente que dependências são definidas entre bibliotecas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-151">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="a68c1-152">Por exemplo, a camada de modelo de domínio não deve receber uma dependência em qualquer outra camada (as classes de modelo de domínio devem ser Plain Old CLR Objects, ou [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span><span class="sxs-lookup"><span data-stu-id="a68c1-152">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="a68c1-153">Conforme mostrado na Figura 9-6, o **Ordering.Domain** biblioteca camada tem dependências somente em bibliotecas do .NET Core, mas não em qualquer outra biblioteca personalizada de (biblioteca de dados, a biblioteca de persistência, etc.).</span><span class="sxs-lookup"><span data-stu-id="a68c1-153">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries but not on any other custom library (data library, persistence library, etc.).</span></span>

![](./media/image7.PNG)

<span data-ttu-id="a68c1-154">**Figura 9-6**.</span><span class="sxs-lookup"><span data-stu-id="a68c1-154">**Figure 9-6**.</span></span> <span data-ttu-id="a68c1-155">Implementado conforme bibliotecas permitem melhor controle de dependências entre as camadas de camadas</span><span class="sxs-lookup"><span data-stu-id="a68c1-155">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="a68c1-156">A camada de modelo de domínio</span><span class="sxs-lookup"><span data-stu-id="a68c1-156">The domain model layer</span></span>

<span data-ttu-id="a68c1-157">Catálogo excelente de Eric Evans [Design controlado por domínio](http://domainlanguage.com/ddd/) diz o seguinte sobre a camada de modelo de domínio e a camada de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a68c1-157">Eric Evans's excellent book [Domain Driven Design](http://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="a68c1-158">**Camada de modelo de domínio**: responsável para representar conceitos de negócios, informações sobre a situação de negócios e as regras de negócio.</span><span class="sxs-lookup"><span data-stu-id="a68c1-158">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="a68c1-159">Estado que reflete a situação de negócios é controlado e usado aqui, embora os detalhes técnicos de fazê-lo são delegados para a infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="a68c1-159">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="a68c1-160">Essa camada é a essência do software de negócios.</span><span class="sxs-lookup"><span data-stu-id="a68c1-160">This layer is the heart of business software.</span></span>

<span data-ttu-id="a68c1-161">A camada de modelo de domínio é onde os negócios é expresso.</span><span class="sxs-lookup"><span data-stu-id="a68c1-161">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="a68c1-162">Quando você implementa uma camada de modelo de domínio de microsserviço no .NET, a camada é codificada como uma biblioteca de classes com as entidades de domínio que capturam dados mais comportamento (métodos com lógica).</span><span class="sxs-lookup"><span data-stu-id="a68c1-162">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="a68c1-163">Seguindo o [ignorância de persistência](http://deviq.com/persistence-ignorance/) e [infraestrutura ignorância](https://ayende.com/blog/3137/infrastructure-ignorance) princípios, essa camada completamente devem ignorar os detalhes de persistência de dados.</span><span class="sxs-lookup"><span data-stu-id="a68c1-163">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="a68c1-164">Essas tarefas de persistência devem ser executadas pela camada de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="a68c1-164">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="a68c1-165">Portanto, essa camada não deveria receber dependências diretas na infraestrutura, o que significa que uma regra importante é que suas classes de entidade do modelo de domínio devem ser [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span><span class="sxs-lookup"><span data-stu-id="a68c1-165">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="a68c1-166">Entidades de domínio não devem ter nenhuma dependência direta (como derivando uma classe base) em qualquer estrutura de infraestrutura de acesso de dados como o Entity Framework ou NHibernate.</span><span class="sxs-lookup"><span data-stu-id="a68c1-166">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="a68c1-167">Idealmente, suas entidades de domínio não devem derivar de ou implementar qualquer tipo definido em qualquer estrutura de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="a68c1-167">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="a68c1-168">Mais modernas estruturas ORM como Entity Framework Core permitem essa abordagem, de modo que suas classes de modelo de domínio não estão ligadas à infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="a68c1-168">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="a68c1-169">No entanto, com as entidades POCO nem sempre é possível ao usar determinados bancos de dados NoSQL e estruturas, como atores e coleções confiável no Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="a68c1-169">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="a68c1-170">Mesmo quando é importante seguir o princípio de ignorância de persistência para o modelo de domínio, você não deve ignorar preocupações de persistência.</span><span class="sxs-lookup"><span data-stu-id="a68c1-170">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="a68c1-171">Ainda é muito importante entender o modelo de dados físicos e como ele mapeia para o modelo de objeto de entidade.</span><span class="sxs-lookup"><span data-stu-id="a68c1-171">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="a68c1-172">Caso contrário, você pode criar designs impossíveis.</span><span class="sxs-lookup"><span data-stu-id="a68c1-172">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="a68c1-173">Além disso, isso não significa que pode levar a um modelo criado para um banco de dados relacional e diretamente movê-lo para um banco de dados orientado por documentos ou o NoSQL.</span><span class="sxs-lookup"><span data-stu-id="a68c1-173">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="a68c1-174">Em alguns modelos de entidade, poderá ajustar o modelo, mas geralmente não.</span><span class="sxs-lookup"><span data-stu-id="a68c1-174">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="a68c1-175">Ainda há restrições que o modelo de entidade deve cumprir, baseadas na tecnologia de armazenamento e tecnologia ORM.</span><span class="sxs-lookup"><span data-stu-id="a68c1-175">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="a68c1-176">A camada de aplicativo</span><span class="sxs-lookup"><span data-stu-id="a68c1-176">The application layer</span></span>

<span data-ttu-id="a68c1-177">Passar para a camada de aplicativo, estamos novamente pode citar o catálogo de Eric Evans [Design controlado por domínio](http://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="a68c1-177">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](http://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="a68c1-178">**Camada de aplicativo:** define os trabalhos que o software deve para fazer e direciona os objetos de domínio expressivas para resolver problemas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-178">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="a68c1-179">As tarefas por que nesta camada é responsável são significativos para os negócios ou necessárias para a interação com as camadas do aplicativo de outros sistemas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-179">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="a68c1-180">Essa camada é mantida dinâmico.</span><span class="sxs-lookup"><span data-stu-id="a68c1-180">This layer is kept thin.</span></span> <span data-ttu-id="a68c1-181">Ele não contém regras de negócio ou dados de Conhecimento, mas apenas tarefas de coordenadas e delegados funcionam para colaborações de objetos de domínio na próxima camada para baixo.</span><span class="sxs-lookup"><span data-stu-id="a68c1-181">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="a68c1-182">Ele não tem estado refletir a situação de negócios, mas pode ter um estado que reflete o progresso de uma tarefa para o usuário ou o programa.</span><span class="sxs-lookup"><span data-stu-id="a68c1-182">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="a68c1-183">Normalmente, a camada de aplicativo do microsserviço no .NET é codificada como um projeto de API da Web do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="a68c1-183">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="a68c1-184">O projeto implementa interação do microsserviço, acesso remoto à rede e as APIs da Web externo usado nos aplicativos de interface do usuário ou cliente.</span><span class="sxs-lookup"><span data-stu-id="a68c1-184">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="a68c1-185">Ele inclui consultas se aproximar usando um CQRS, comandos aceitos pelo microsserviço e até mesmo a comunicação controlada por evento entre microservices (eventos de integração).</span><span class="sxs-lookup"><span data-stu-id="a68c1-185">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="a68c1-186">A API Web do ASP.NET Core que representa a camada de aplicativo não deve conter as regras de negócio ou conhecimento do domínio (especialmente regras de domínio para transações ou atualizações); eles devem ser de propriedade pela biblioteca de classe de modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="a68c1-186">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="a68c1-187">A coordenada do aplicativo camada deve apenas tarefas e não deve conter ou definir qualquer estado de domínio (modelo de domínio).</span><span class="sxs-lookup"><span data-stu-id="a68c1-187">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="a68c1-188">Ela delega a execução de regras de negócio para as domínio modelo próprias classes (raízes agregadas e entidades de domínio), que, por fim, atualizará os dados dentro dessas entidades de domínio.</span><span class="sxs-lookup"><span data-stu-id="a68c1-188">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="a68c1-189">Basicamente, a lógica do aplicativo é onde você pode implementar todos os casos de uso que dependem de um determinado front-end.</span><span class="sxs-lookup"><span data-stu-id="a68c1-189">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="a68c1-190">Por exemplo, a implementação relacionada a um serviço de API da Web.</span><span class="sxs-lookup"><span data-stu-id="a68c1-190">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="a68c1-191">O objetivo é que a lógica do domínio na camada de modelo de domínio, seus invariáveis, o modelo de dados e regras de negócio relacionadas deve ser completamente independente entre as camadas de apresentação e de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a68c1-191">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="a68c1-192">Mais de tudo, a camada de modelo de domínio deve não depende diretamente qualquer estrutura de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="a68c1-192">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="a68c1-193">A camada de infraestrutura</span><span class="sxs-lookup"><span data-stu-id="a68c1-193">The infrastructure layer</span></span>

<span data-ttu-id="a68c1-194">A camada de infraestrutura é como os dados que inicialmente são mantidos em entidades de domínio (em memória) são mantidos em bancos de dados ou outro repositório persistente.</span><span class="sxs-lookup"><span data-stu-id="a68c1-194">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="a68c1-195">Um exemplo é usar o código do Entity Framework Core para implementar as classes de padrão de repositório que usa um DBContext para manter dados em um banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="a68c1-195">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="a68c1-196">Conforme mencionado anteriormente [ignorância de persistência](http://deviq.com/persistence-ignorance/) e [infraestrutura ignorância](https://ayende.com/blog/3137/infrastructure-ignorance) princípios, a camada de infraestrutura devem não "contaminarem" a camada de modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="a68c1-196">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="a68c1-197">Você deve manter o independente de classes de entidade do domínio modelo da infraestrutura de que você usa para manter dados (EF ou qualquer outra estrutura) não Obtendo dependências de disco rígidas em estruturas.</span><span class="sxs-lookup"><span data-stu-id="a68c1-197">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="a68c1-198">A biblioteca de classes de camada de modelo de domínio deve ter somente o código de domínio, apenas [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entidade classes Implementando a essência do seu software e completamente separada de tecnologias de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="a68c1-198">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="a68c1-199">Assim, suas camadas ou bibliotecas de classes e projetos, por fim, depende de sua camada de modelo de domínio (biblioteca), não vice-versa, conforme mostrado na Figura 9-7.</span><span class="sxs-lookup"><span data-stu-id="a68c1-199">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="a68c1-200">**Figura 9-7**.</span><span class="sxs-lookup"><span data-stu-id="a68c1-200">**Figure 9-7**.</span></span> <span data-ttu-id="a68c1-201">Dependências entre camadas em DDD</span><span class="sxs-lookup"><span data-stu-id="a68c1-201">Dependencies between layers in DDD</span></span>

<span data-ttu-id="a68c1-202">Esse design de camada deve ser independente para cada microsserviço.</span><span class="sxs-lookup"><span data-stu-id="a68c1-202">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="a68c1-203">Conforme observado anteriormente, você pode implementar o microservices mais complexo (CRUD simple em uma única camada) microservices seguintes padrões DDD, durante a implementação mais simples controlada por dados de forma mais simples.</span><span class="sxs-lookup"><span data-stu-id="a68c1-203">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="a68c1-204">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="a68c1-204">Additional resources</span></span>

-   <span data-ttu-id="a68c1-205">**DevIQ. Princípio de ignorância de persistência**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="a68c1-205">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="a68c1-206">**Oren Eini. Infraestrutura ignorância**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="a68c1-206">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="a68c1-207">**Anjo Lopez. Em camadas de arquitetura no Design controlado por domínio**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="a68c1-207">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="a68c1-208">[Anterior] (cqrs-microsserviço-reads.md) [Avançar] (microsserviço-domínio-model.md)</span><span class="sxs-lookup"><span data-stu-id="a68c1-208">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>
