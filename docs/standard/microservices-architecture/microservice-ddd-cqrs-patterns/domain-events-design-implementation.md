---
title: Eventos de domínio. design e implementação
description: Arquitetura de microsserviços do .NET para aplicativos .NET em contêineres | Eventos de domínio, design e implementação
keywords: Docker, Microsserviços, ASP.NET, Contêiner
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 12/11/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: af6a6b73c790577cebf301075f2ff7e90960ea62
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/28/2018
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="32f20-105">Eventos de domínio: design e implementação</span><span class="sxs-lookup"><span data-stu-id="32f20-105">Domain events: design and implementation</span></span>

<span data-ttu-id="32f20-106">Use eventos de domínio para implementar explicitamente os efeitos colaterais de alterações em seu domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="32f20-107">Em outras palavras, e usando terminologia DDD, use eventos de domínio para implementar explicitamente efeitos colaterais entre várias agregações.</span><span class="sxs-lookup"><span data-stu-id="32f20-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="32f20-108">Opcionalmente, para melhor escalabilidade e menor impacto em bloqueios de banco de dados, use consistência eventual entre agregações dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="32f20-109">O que é um evento de domínio?</span><span class="sxs-lookup"><span data-stu-id="32f20-109">What is a domain event?</span></span>

<span data-ttu-id="32f20-110">Um evento é algo que ocorreu no passado.</span><span class="sxs-lookup"><span data-stu-id="32f20-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="32f20-111">Um evento de domínio é, logicamente, algo que ocorreu em um domínio específico e algo que você deseja que as outras partes do mesmo domínio (em processo) tenham ciência e tenham a possibilidade de reagir.</span><span class="sxs-lookup"><span data-stu-id="32f20-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="32f20-112">Uma vantagem importante dos eventos de domínio é que, os efeitos colaterais de algo que ocorreu em um domínio, podem ser expressos explicitamente em vez de implicitamente.</span><span class="sxs-lookup"><span data-stu-id="32f20-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="32f20-113">Esses efeitos colaterais devem ser consistentes para que todas as operações relacionadas à tarefa de negócios ocorram, ou para que nenhuma delas ocorra.</span><span class="sxs-lookup"><span data-stu-id="32f20-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="32f20-114">Além disso, os eventos de domínio permitem uma melhor separação de interesses entre classes dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="32f20-115">Por exemplo, suponha que você está usando apenas o Entity Framework e entidades ou até mesmo agregações. Se tiver que ocorrer efeitos colaterais provocados por um caso de uso, eles serão implementados como um conceito implícito no código acoplado depois que algo ocorrer.</span><span class="sxs-lookup"><span data-stu-id="32f20-115">For example, if you're just using Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="32f20-116">No entanto, apenas olhando para o código talvez não seja possível saber se esse código (o efeito colateral) faz parte da operação principal ou se ele é realmente um efeito colateral.</span><span class="sxs-lookup"><span data-stu-id="32f20-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="32f20-117">Por outro lado, o uso de eventos de domínio faz com que o conceito se torne explícito e parte da linguagem ubíqua.</span><span class="sxs-lookup"><span data-stu-id="32f20-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="32f20-118">Por exemplo, no aplicativo eShopOnContainers, a criação de um pedido não tem a ver somente com o pedido; ele atualiza ou cria uma agregação de comprador com base no usuário original, porque o usuário não é um comprador até que haja um pedido em vigor.</span><span class="sxs-lookup"><span data-stu-id="32f20-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="32f20-119">Se você usa eventos de domínio, você pode expressar explicitamente essa regra de domínio com base na linguagem ubíqua fornecida pelos especialistas de domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="32f20-120">Os eventos de domínio são mais ou menos parecidos com eventos do estilo de mensagens, com uma diferença importante.</span><span class="sxs-lookup"><span data-stu-id="32f20-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="32f20-121">Com sistema de mensagens real, enfileiramento de mensagens, agentes de mensagens ou com um barramento de serviço que use AMPQ, a mensagem é sempre enviada de forma assíncrona e é comunicada entre processos e computadores.</span><span class="sxs-lookup"><span data-stu-id="32f20-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="32f20-122">Isso é útil para a integração de vários contextos delimitados, microsserviços ou até mesmo aplicativos diferentes.</span><span class="sxs-lookup"><span data-stu-id="32f20-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="32f20-123">No entanto, com os eventos de domínio, ao acionar um evento na operação de domínio em execução no momento, você deseja que os efeitos colaterais ocorram dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="32f20-124">Os eventos de domínio e seus efeitos colaterais (as ações disparadas depois que são gerenciadas por manipuladores de eventos) devem ocorrer quase imediatamente, geralmente em processo, e dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="32f20-125">Assim, os eventos de domínio podem ser síncronos ou assíncronos.</span><span class="sxs-lookup"><span data-stu-id="32f20-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="32f20-126">Os eventos de integração, no entanto, devem sempre ser assíncronos.</span><span class="sxs-lookup"><span data-stu-id="32f20-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="32f20-127">Eventos de domínio versus eventos de integração</span><span class="sxs-lookup"><span data-stu-id="32f20-127">Domain events versus integration events</span></span>

<span data-ttu-id="32f20-128">Semanticamente, os eventos de integração e de domínio são a mesma coisa: notificações sobre algo que acabou de ocorrer.</span><span class="sxs-lookup"><span data-stu-id="32f20-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="32f20-129">No entanto, a implementação deles deve ser diferente.</span><span class="sxs-lookup"><span data-stu-id="32f20-129">However, their implementation must be different.</span></span> <span data-ttu-id="32f20-130">Os eventos de domínio são apenas mensagens enviadas por push para um dispatcher de evento de domínio, que pode ser implementado como um mediador na memória, com base em um contêiner de IoC ou qualquer outro método.</span><span class="sxs-lookup"><span data-stu-id="32f20-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="32f20-131">Por outro lado, a finalidade dos eventos de integração é a propagação de transações e atualizações confirmadas para outros subsistemas, independentemente de serem outros microsserviços, contextos delimitados ou, até mesmo, aplicativos externos.</span><span class="sxs-lookup"><span data-stu-id="32f20-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="32f20-132">Assim, eles deverão ocorrer somente se a entidade for persistida com êxito, pois, em muitos cenários, se isso falhar, toda a operação efetivamente nunca acontecerá.</span><span class="sxs-lookup"><span data-stu-id="32f20-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="32f20-133">Além disso, e conforme o que foi mencionado, os eventos de integração devem ser baseados em comunicação assíncrona entre vários microsserviços (outros contextos delimitados) ou mesmo aplicativos/sistemas externos.</span><span class="sxs-lookup"><span data-stu-id="32f20-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="32f20-134">Assim, a interface do barramento de eventos precisa de alguma infraestrutura que permita a comunicação entre processos e distribuída entre serviços potencialmente remotos.</span><span class="sxs-lookup"><span data-stu-id="32f20-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="32f20-135">Ela pode ser baseada em um barramento de serviço comercial, em filas, em um banco de dados compartilhado usado como uma caixa de correio ou em qualquer outro sistema de mensagens distribuídas e, idealmente, baseado em push.</span><span class="sxs-lookup"><span data-stu-id="32f20-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="32f20-136">Eventos de domínio como uma maneira preferencial para disparar efeitos colaterais entre várias agregações dentro do mesmo domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="32f20-137">Se a execução de um comando relacionado a uma instância de agregação exigir regras de domínio adicionais para ser executado em uma ou mais agregações, você deverá projetar e implementar esses efeitos colaterais para que sejam disparados por eventos de domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="32f20-138">Conforme mostrado na Figura 9-14, e como um dos mais importantes casos de uso, um evento de domínio deve ser usado para propagar alterações de estado entre várias agregações dentro do mesmo modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="32f20-139">**Figura 9-14**.</span><span class="sxs-lookup"><span data-stu-id="32f20-139">**Figure 9-14**.</span></span> <span data-ttu-id="32f20-140">Eventos de domínio para impor consistência entre várias agregações dentro do mesmo domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="32f20-141">Na figura, quando o usuário dá início a um pedido, o evento de domínio OrderStarted dispara a criação de um objeto Comprador no microsserviço de pedidos, com base nas informações do usuário original, obtidas do microsserviço de identidade (com as informações fornecidas no comando CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="32f20-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="32f20-142">O evento de domínio é gerado pela agregação do pedido quando ela é criada pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="32f20-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="32f20-143">Como alternativa, você pode fazer com que a raiz da agregação assine eventos acionado pelos membros de suas respectivas agregações (entidades filho).</span><span class="sxs-lookup"><span data-stu-id="32f20-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="32f20-144">Por exemplo, cada entidade filho OrderItem poderá acionar um evento quando o preço do item for maior que um valor específico, ou quando a quantidade de itens do produto for muito alta.</span><span class="sxs-lookup"><span data-stu-id="32f20-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="32f20-145">Assim, a raiz de agregação poderá receber esses eventos e executar um cálculo global ou uma agregação.</span><span class="sxs-lookup"><span data-stu-id="32f20-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="32f20-146">É importante entender que essa comunicação baseada em eventos não é implementada diretamente nas agregações; você precisa implementar manipuladores de eventos de domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="32f20-147">A manipulação de eventos de domínio é um interesse do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="32f20-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="32f20-148">A camada do modelo de domínio deve se concentrar apenas na lógica do domínio, algo que um especialista em domínio entende, e não na infraestrutura do aplicativo, como manipuladores e ações de persistência de efeito colateral com o uso de repositórios.</span><span class="sxs-lookup"><span data-stu-id="32f20-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="32f20-149">Portanto, o nível de camada de aplicativo é o local em que você deve ter manipuladores de eventos de domínio disparando ações quando um evento de domínio é acionado.</span><span class="sxs-lookup"><span data-stu-id="32f20-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="32f20-150">Os eventos de domínio também podem ser usados para disparar um grande número de ações de aplicativo e, o mais importante, devem estar abertos para aumentar esse número no futuro de maneira separada.</span><span class="sxs-lookup"><span data-stu-id="32f20-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="32f20-151">Por exemplo, quando o pedido é iniciado, você publica um evento de domínio para propagar essas informações para outras agregações ou, até mesmo, para gerar ações de aplicativo, como notificações.</span><span class="sxs-lookup"><span data-stu-id="32f20-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="32f20-152">O ponto-chave é o número indefinido de ações a serem executadas quando ocorre um evento de domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="32f20-153">As ações e regras do domínio e do aplicativo vão, eventualmente, aumentar.</span><span class="sxs-lookup"><span data-stu-id="32f20-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="32f20-154">A complexidade ou o número de ações de efeito colateral que ocorre aumentará, mas se o seu código estiver acoplado com "associação" (ou seja, instanciando objetos apenas com a palavra-chave new, em C\#), então, sempre que for necessário adicionar uma nova ação você terá que alterar o código original.</span><span class="sxs-lookup"><span data-stu-id="32f20-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="32f20-155">Isso poderá resultar em novos bugs, pois será necessário alterar o fluxo do código original sempre que houver novo requisito.</span><span class="sxs-lookup"><span data-stu-id="32f20-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="32f20-156">Isso vai contra o [princípio Aberto/Fechado](https://en.wikipedia.org/wiki/Open/closed_principle) do [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="32f20-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="32f20-157">E não se trata apenas disso, pois a classe original que estava orquestrando as operações cresceria sem parar, o que vai contra o [SRP (princípio de responsabilidade única)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="32f20-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="32f20-158">Por outro lado, se você usa eventos de domínio, você pode criar uma implementação refinada e desacoplada por meio da segregação de responsabilidades, usando essa abordagem:</span><span class="sxs-lookup"><span data-stu-id="32f20-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="32f20-159">Enviar um comando (por exemplo, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="32f20-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="32f20-160">Receber o comando em um manipulador de comandos.</span><span class="sxs-lookup"><span data-stu-id="32f20-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="32f20-161">Executar a transação de uma única agregação.</span><span class="sxs-lookup"><span data-stu-id="32f20-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="32f20-162">(Opcional) Acionar eventos de domínio para efeitos colaterais (por exemplo, OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="32f20-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
1.  <span data-ttu-id="32f20-163">Manipular eventos de domínio (dentro do processo atual) que executarão um número indefinido de efeitos colaterais em várias agregações ou ações de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="32f20-163">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="32f20-164">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="32f20-164">For example:</span></span>
    -   <span data-ttu-id="32f20-165">Verificar ou criar o comprador e a forma de pagamento.</span><span class="sxs-lookup"><span data-stu-id="32f20-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="32f20-166">Criar e enviar um evento de integração relacionado ao barramento de eventos a fim de propagar estados entre microsserviços ou disparar ações externas, como o envio de um email para o comprador.</span><span class="sxs-lookup"><span data-stu-id="32f20-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="32f20-167">Manipular outros efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="32f20-167">Handle other side effects.</span></span>

<span data-ttu-id="32f20-168">Conforme mostrado na Figura 9-15, começando pelo mesmo evento de domínio, você pode manipular várias ações relacionadas a outras agregações do domínio, ou ações de aplicativos adicionais que você precisa realizar entre microsserviços que se conectam com eventos de integração e o barramento de eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="32f20-169">**Figura 9-15**.</span><span class="sxs-lookup"><span data-stu-id="32f20-169">**Figure 9-15**.</span></span> <span data-ttu-id="32f20-170">Manipulando várias ações por domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="32f20-171">Os manipuladores de eventos normalmente ficam na camada de aplicativo, porque você usará objetos de infraestrutura, como repositórios, ou uma API de aplicativo para o comportamento do microsserviço.</span><span class="sxs-lookup"><span data-stu-id="32f20-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="32f20-172">Nesse sentido, os manipuladores de eventos são semelhantes aos manipuladores de comandos, portanto, ambos fazem parte da camada de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="32f20-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="32f20-173">A diferença importante é que um comando deve ser processado apenas uma vez.</span><span class="sxs-lookup"><span data-stu-id="32f20-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="32f20-174">Um evento de domínio pode ser processado zero ou *n* vezes, porque ele pode ser recebido por vários destinatários ou manipuladores de eventos, com uma finalidade diferente para cada manipulador.</span><span class="sxs-lookup"><span data-stu-id="32f20-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="32f20-175">A possibilidade de um número indefinido de manipuladores por evento de domínio permite que você adicione muitas outras regras de domínio sem afetar seu código atual.</span><span class="sxs-lookup"><span data-stu-id="32f20-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="32f20-176">Por exemplo, a implementação da seguinte regra de negócios, que deve ocorrer logo após um evento, poderá ser tão fácil quanto adicionar alguns manipuladores de eventos (ou apenas um):</span><span class="sxs-lookup"><span data-stu-id="32f20-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="32f20-177">Quando o valor total comprado por um cliente na loja, em qualquer número de pedidos, excede US$ 6.000, aplicar 10% de desconto para cada novo pedido e notificar o cliente com um email, informando sobre esse desconto para pedidos futuros.</span><span class="sxs-lookup"><span data-stu-id="32f20-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="32f20-178">Implementando eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-178">Implementing domain events</span></span>

<span data-ttu-id="32f20-179">No C#, um evento de domínio é simplesmente uma classe ou estrutura de retenção de dados, como um DTO, com todas as informações relacionadas ao que acabou de ocorrer no domínio, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="32f20-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="32f20-180">Essa é essencialmente uma classe que retém todos os dados relacionados ao evento OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="32f20-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="32f20-181">Nos termos da linguagem ubíqua do domínio, como um evento é algo que ocorreu no passado, o nome de classe do evento deverá ser representado como um verbo no passado, como OrderStartedDomainEvent ou OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="32f20-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="32f20-182">É assim que o evento de domínio é implementado no microsserviço de pedidos no eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="32f20-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="32f20-183">Conforme observado anteriormente, uma característica importante de eventos é que, como um evento é algo que ocorreu no passado, ele não deve ser alterado.</span><span class="sxs-lookup"><span data-stu-id="32f20-183">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="32f20-184">Portanto, ele deve ser uma classe imutável.</span><span class="sxs-lookup"><span data-stu-id="32f20-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="32f20-185">Observe no código anterior que as propriedades são somente leitura de fora do objeto.</span><span class="sxs-lookup"><span data-stu-id="32f20-185">You can see in the previous code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="32f20-186">A única maneira de atualizar o objeto é por meio do construtor, quando você cria o objeto de evento.</span><span class="sxs-lookup"><span data-stu-id="32f20-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="32f20-187">Acionando eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-187">Raising domain events</span></span>

<span data-ttu-id="32f20-188">A próxima pergunta é: como acionar um evento de domínio para que ele alcance os respectivos manipuladores de eventos?</span><span class="sxs-lookup"><span data-stu-id="32f20-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="32f20-189">Você pode usar várias abordagens.</span><span class="sxs-lookup"><span data-stu-id="32f20-189">You can use multiple approaches.</span></span>

<span data-ttu-id="32f20-190">Udi Dahan originalmente propôs (em várias postagens relacionadas, como, [Domain Events – Take 2 (Eventos de domínio – tomada 2)](http://udidahan.com/2008/08/25/domain-events-take-2/)) o uso de uma classe estática para gerenciar e acionar eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="32f20-191">Isso incluiria uma classe estática chamada DomainEvents, que geraria eventos de domínio assim que fosse chamada, usando uma sintaxe como: DomainEvents.Raise(Event myEvent).</span><span class="sxs-lookup"><span data-stu-id="32f20-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="32f20-192">Jimmy Bogard escreveu uma postagem no blog ([Strengthening your domain: Domain Events (Fortalecendo seu domínio: eventos de domínio)](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) que recomenda uma abordagem semelhante.</span><span class="sxs-lookup"><span data-stu-id="32f20-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="32f20-193">No entanto, quando a classe dos eventos de domínio é estática, ela também faz a expedição imediata aos manipuladores.</span><span class="sxs-lookup"><span data-stu-id="32f20-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="32f20-194">Isso torna o teste e a depuração mais difíceis, pois os manipuladores de eventos com a lógica de efeitos colaterais são executados imediatamente após o evento ser acionado.</span><span class="sxs-lookup"><span data-stu-id="32f20-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="32f20-195">Ao testar e depurar, você quer se concentrar somente no que está acontecendo nas classes de agregação atuais; você não deseja ser redirecionado repentinamente para outros manipuladores de eventos de efeitos colaterais relacionados a outras agregações ou lógica de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="32f20-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="32f20-196">É por isso as outras abordagens evoluíram, conforme explicado na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="32f20-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="32f20-197">A abordagem adiada para acionar e expedir eventos</span><span class="sxs-lookup"><span data-stu-id="32f20-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="32f20-198">Em vez de expedir imediatamente para um manipulador de eventos de domínio, uma abordagem melhor é adicionar os eventos de domínio a uma coleção e, em seguida, expedir esses eventos de domínio *logo antes* ou *logo* *depois* da confirmação da transação (como acontece com SaveChanges no EF).</span><span class="sxs-lookup"><span data-stu-id="32f20-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="32f20-199">(Essa abordagem foi descrita por Jimmy Bogard nesta postagem [A better domain events pattern (Um padrão de eventos de domínio melhor)](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)).</span><span class="sxs-lookup"><span data-stu-id="32f20-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="32f20-200">A decisão de enviar os eventos de domínio logo antes ou logo após a confirmação da transação é importante, pois determinará se você vai incluir os efeitos colaterais como parte da mesma transação ou em transações diferentes.</span><span class="sxs-lookup"><span data-stu-id="32f20-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="32f20-201">No último caso, você precisará lidar com a consistência eventual entre várias agregações.</span><span class="sxs-lookup"><span data-stu-id="32f20-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="32f20-202">Este tópico será abordado na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="32f20-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="32f20-203">A abordagem adiada é que o eShopOnContainers usa.</span><span class="sxs-lookup"><span data-stu-id="32f20-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="32f20-204">Primeiro, você adiciona os eventos que estão ocorrendo nas suas entidades a uma coleção ou uma lista de eventos por entidade.</span><span class="sxs-lookup"><span data-stu-id="32f20-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="32f20-205">Essa lista deve fazer parte do objeto de entidade, ou, melhor ainda, parte de sua classe de entidade base, conforme mostrado no seguinte exemplo da classe base Entity:</span><span class="sxs-lookup"><span data-stu-id="32f20-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //... 
    private List<INotification> _domainEvents;
    public List<INotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<INotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(INotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="32f20-206">Quando você deseja acionar um evento, basta adicioná-lo à coleção de eventos através do código em qualquer método de entidade raiz de agregação.</span><span class="sxs-lookup"><span data-stu-id="32f20-206">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="32f20-207">O código a seguir, que faz parte do [Raiz de agregação de pedido no eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), mostra um exemplo:</span><span class="sxs-lookup"><span data-stu-id="32f20-207">The following code, part of the [Order agregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="32f20-208">Observe que a única coisa que o método AddDomainEvent está fazendo é a adição de um evento à lista.</span><span class="sxs-lookup"><span data-stu-id="32f20-208">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="32f20-209">Nenhum evento foi expedido, e nenhum manipulador de eventos foi invocado ainda.</span><span class="sxs-lookup"><span data-stu-id="32f20-209">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="32f20-210">Na verdade, você deseja expedir os eventos mais tarde, ao confirmar a transação no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="32f20-210">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="32f20-211">Se você estiver usando o Entity Framework Core, isso será realizado no método SaveChanges do DbContext do EF, como no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="32f20-211">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.        
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="32f20-212">Com esse código, você expede os eventos de entidade aos respectivos manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-212">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="32f20-213">O resultado geral é que você desacoplou o acionamento de um evento de domínio (uma simples adição a uma lista na memória) da expedição dele para um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-213">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="32f20-214">Além disso, dependendo do tipo de dispatcher que você está usando, é possível expedir os eventos de forma síncrona ou assíncrona.</span><span class="sxs-lookup"><span data-stu-id="32f20-214">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="32f20-215">Lembre-se que os limites transacionais desempenham funções significativas aqui.</span><span class="sxs-lookup"><span data-stu-id="32f20-215">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="32f20-216">Se for possível sua unidade de trabalho e transação alcançar mais de uma agregação (como ao usar o EF Core e um banco de dados relacional), isso poderá funcionar bem.</span><span class="sxs-lookup"><span data-stu-id="32f20-216">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="32f20-217">Mas se a transação não puder alcançar agregações, como ao usar um banco de dados NoSQL, como o Azure DocumentDB, você precisará implementar etapas adicionais para obter consistência.</span><span class="sxs-lookup"><span data-stu-id="32f20-217">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="32f20-218">Essa é outra razão por que a ignorância de persistência não é universal; ela depende do sistema de armazenamento que é usado.</span><span class="sxs-lookup"><span data-stu-id="32f20-218">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="32f20-219">Transação única entre agregações versus consistência eventual entre agregações</span><span class="sxs-lookup"><span data-stu-id="32f20-219">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="32f20-220">Executar uma única transação entre agregações em vez de depender de consistência eventual entre essas agregações é uma questão controversa.</span><span class="sxs-lookup"><span data-stu-id="32f20-220">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="32f20-221">Muitos autores de DDD, como Eric Evans e Vaughn Vernon, defendem a regra de que uma transação = uma agregação e, portanto, defendem a consistência eventual entre agregações.</span><span class="sxs-lookup"><span data-stu-id="32f20-221">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="32f20-222">Por exemplo, em seu livro *Domain-Driven Design*, Eric Evans diz:</span><span class="sxs-lookup"><span data-stu-id="32f20-222">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="32f20-223">Não é esperado que toda regra que abrange Agregações esteja atualizada em todos os momentos.</span><span class="sxs-lookup"><span data-stu-id="32f20-223">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="32f20-224">Por meio de processamento de eventos, processamento em lote ou de outros mecanismos de atualização, outras dependências podem ser resolvidas dentro de um período específico.</span><span class="sxs-lookup"><span data-stu-id="32f20-224">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="32f20-225">(página 128)</span><span class="sxs-lookup"><span data-stu-id="32f20-225">(page 128)</span></span>

<span data-ttu-id="32f20-226">Vaughn Vernon diz o seguinte no [Effective Aggregate Design. Part II: Making Aggregates Work Together (Design de agregação eficaz, parte 2: fazer com que agregações trabalhem em conjunto)](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="32f20-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="32f20-227">Portanto, se a execução de um comando em uma instância de agregação exigir que as regras de negócio adicionais sejam executadas em uma ou mais agregações, use consistência eventual \[...\] Há uma maneira prática para dar suporte à consistência eventual em um modelo de DDD.</span><span class="sxs-lookup"><span data-stu-id="32f20-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="32f20-228">Um método de agregação publica um evento de domínio que é entregue no momento exato a um ou mais assinantes assíncronos.</span><span class="sxs-lookup"><span data-stu-id="32f20-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="32f20-229">Essa lógica é baseada na adoção de transações refinadas em vez de transações que abrangem muitas agregações ou entidades.</span><span class="sxs-lookup"><span data-stu-id="32f20-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="32f20-230">A ideia é que, no segundo caso, o número de bloqueios de banco de dados será significativo em aplicativos de larga escala com necessidades de alta escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="32f20-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="32f20-231">Aceitar o fato de que aplicativos altamente escalonáveis não precisam de consistência transacional instantânea entre várias agregações ajuda a aceitar o conceito de consistência eventual.</span><span class="sxs-lookup"><span data-stu-id="32f20-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="32f20-232">Geralmente, as mudanças atômicas não são necessárias aos negócios e, em todo caso, é da responsabilidade dos especialistas de domínio dizer se operações específicas precisam ou não de transações atômicas.</span><span class="sxs-lookup"><span data-stu-id="32f20-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="32f20-233">Se uma operação sempre precisar de uma transação atômica entre várias agregações, você poderá questionar se a agregação deveria ser maior ou se não foi corretamente projetada.</span><span class="sxs-lookup"><span data-stu-id="32f20-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="32f20-234">No entanto, outros desenvolvedores e arquitetos, como Jimmy Bogard, estão de acordo com a abrangência de uma única transação entre várias agregações, mas somente quando essas agregações adicionais forem relacionadas a efeitos colaterais do mesmo comando original.</span><span class="sxs-lookup"><span data-stu-id="32f20-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="32f20-235">Por exemplo, em [A better domain events pattern (Um padrão melhor de eventos de domínio)](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard diz:</span><span class="sxs-lookup"><span data-stu-id="32f20-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="32f20-236">Normalmente, desejo que os efeitos colaterais de um evento de domínio ocorram dentro da mesma transação lógica, mas não necessariamente no mesmo escopo de acionamento do evento de domínio \[...\] Imediatamente antes de confirmarmos nossa transação, expedimos nossos eventos para seus respectivos manipuladores.</span><span class="sxs-lookup"><span data-stu-id="32f20-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="32f20-237">Se você expedir os eventos de domínio imediatamente *antes* da confirmação da transação original, será porque você deseja que os efeitos colaterais desses eventos sejam incluídos na mesma transação.</span><span class="sxs-lookup"><span data-stu-id="32f20-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="32f20-238">Por exemplo, se o método SaveChanges do DbContext do EF falhar, a transação reverterá todas as alterações, incluindo o resultado de qualquer operação de efeito colateral implementada pelos manipuladores de eventos de domínio relacionados.</span><span class="sxs-lookup"><span data-stu-id="32f20-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="32f20-239">Isso ocorre porque o escopo de vida do DbContext é, por padrão, definido como "com escopo".</span><span class="sxs-lookup"><span data-stu-id="32f20-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="32f20-240">Portanto, o objeto DbContext é compartilhado entre vários objetos de repositório que estão sendo instanciados dentro do mesmo escopo ou objeto graph.</span><span class="sxs-lookup"><span data-stu-id="32f20-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="32f20-241">Isso coincide com o escopo de HttpRequest ao desenvolver aplicativos da API Web ou do MVC.</span><span class="sxs-lookup"><span data-stu-id="32f20-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="32f20-242">Na realidade, as duas abordagens (transação atômica única e consistência eventual) podem ser corretas.</span><span class="sxs-lookup"><span data-stu-id="32f20-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="32f20-243">Isso realmente dependerá dos seus requisitos de negócios ou do domínio e o que os especialistas de domínio lhe indicarem.</span><span class="sxs-lookup"><span data-stu-id="32f20-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="32f20-244">Também dependerá da escalabilidade necessária para o serviço (transações mais granulares tem menos impacto em relação aos bloqueios de banco de dados).</span><span class="sxs-lookup"><span data-stu-id="32f20-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="32f20-245">E dependerá de quanto você está disposto a investir em seu código, pois a consistência eventual exige um código mais complexo, para detectar possíveis inconsistências entre agregações, e a necessidade de implementar ações compensatórias.</span><span class="sxs-lookup"><span data-stu-id="32f20-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="32f20-246">Considere que, se você confirmar as alterações à agregação original e posteriormente, quando os eventos estiverem sendo expedidos, houver um problema e os manipuladores de eventos não puderem confirmar os efeitos colaterais, você terá inconsistências entre agregações.</span><span class="sxs-lookup"><span data-stu-id="32f20-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="32f20-247">Uma forma de permitir ações compensatórias seria armazenar os eventos de domínio em tabelas de banco de dados adicionais para que eles possam fazer parte da transação original.</span><span class="sxs-lookup"><span data-stu-id="32f20-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="32f20-248">Posteriormente, você poderia ter um processo em lote para detectar inconsistências e executar ações compensatórias por meio da comparação da lista de eventos com o estado atual das agregações.</span><span class="sxs-lookup"><span data-stu-id="32f20-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="32f20-249">As ações compensatórias fazem parte de um tópico complexo que exigirá uma análise detalhada, incluindo discuti-las com o usuário empresarial e com os especialistas de domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="32f20-250">De qualquer maneira, você pode optar pela abordagem que seja necessária.</span><span class="sxs-lookup"><span data-stu-id="32f20-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="32f20-251">Mas a abordagem adiada inicial — disparar os eventos antes da confirmação, de forma a usar uma única transação – é a abordagem mais simples ao usar o EF Core e um banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="32f20-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="32f20-252">Ela é mais fácil de implementar e é válida em muitos casos de negócio.</span><span class="sxs-lookup"><span data-stu-id="32f20-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="32f20-253">Ela também é a abordagem usada no microsserviço de pedidos no eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="32f20-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="32f20-254">Mas, de que maneira você realmente envia esses eventos aos respectivos manipuladores de eventos?</span><span class="sxs-lookup"><span data-stu-id="32f20-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="32f20-255">O que é o objeto \_mediator que você viu no exemplo anterior?</span><span class="sxs-lookup"><span data-stu-id="32f20-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="32f20-256">Isso tem a ver com as técnicas e artefatos que você pode usar para mapear entre eventos e os respectivos manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="32f20-257">O dispatcher de evento de domínio: mapeamento de eventos a manipuladores de eventos</span><span class="sxs-lookup"><span data-stu-id="32f20-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="32f20-258">Assim que estiver pronto para expedir ou publicar os eventos, você precisará de algum tipo de artefato que publicará o evento, para que cada manipulador relacionado possa obtê-lo e processar os efeitos colaterais com base nesse evento.</span><span class="sxs-lookup"><span data-stu-id="32f20-258">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="32f20-259">Uma abordagem é um sistema de mensagens real ou até mesmo um barramento de eventos, possivelmente baseado em um barramento de serviço, em vez de eventos na memória.</span><span class="sxs-lookup"><span data-stu-id="32f20-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="32f20-260">No entanto, no primeiro caso, os sistema de mensagens real seria um exagero para processar eventos de domínio, pois você só precisa processar esses eventos dentro do mesmo processo (ou seja, no mesmo domínio e na mesma camada de aplicativo).</span><span class="sxs-lookup"><span data-stu-id="32f20-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="32f20-261">Outra maneira de mapear eventos para vários manipuladores de eventos é o uso de registro de tipos em um contêiner de IoC para que você possa inferir dinamicamente o local para expedir os eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="32f20-262">Em outras palavras, você precisa saber quais manipuladores de eventos precisam obter um evento específico.</span><span class="sxs-lookup"><span data-stu-id="32f20-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="32f20-263">A figura 9-16 mostra um método simplificado para fazer isso.</span><span class="sxs-lookup"><span data-stu-id="32f20-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="32f20-264">**Figura 9-16**.</span><span class="sxs-lookup"><span data-stu-id="32f20-264">**Figure 9-16**.</span></span> <span data-ttu-id="32f20-265">Dispatcher de evento de domínio usando IoC</span><span class="sxs-lookup"><span data-stu-id="32f20-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="32f20-266">Você pode criar todos os detalhes técnicos e artefatos para implementar essa abordagem por si só.</span><span class="sxs-lookup"><span data-stu-id="32f20-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="32f20-267">No entanto, você também pode usar as bibliotecas disponíveis, como a [MediatR](https://github.com/jbogard/MediatR), que usa seu contêiner de IoC nos bastidores.</span><span class="sxs-lookup"><span data-stu-id="32f20-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoC container.</span></span> <span data-ttu-id="32f20-268">Portanto, você pode usar diretamente as interfaces predefinidas e métodos de expedição/publicação do objeto mediador.</span><span class="sxs-lookup"><span data-stu-id="32f20-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="32f20-269">No código, primeiro você precisa registrar os tipos de manipulador de eventos no contêiner de IoC, conforme mostrado no seguinte exemplo no [microsserviço de pedidos eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="32f20-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="32f20-270">Primeiro, o código identifica o assembly que contém os manipuladores de eventos do domínio ao localizar o assembly que contém qualquer um dos manipuladores (usando typeof(ValidateOrAddBuyerAggregateWhenXxxx), mas você poderia escolher qualquer outro manipulador de eventos para localizar o assembly).</span><span class="sxs-lookup"><span data-stu-id="32f20-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="32f20-271">Como todos os manipuladores de eventos implementam a interface IAsyncNotificationHandler, então o código pesquisas apenas esses tipos e registra todos os manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="32f20-272">Como assinar eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-272">How to subscribe to domain events</span></span>

<span data-ttu-id="32f20-273">Quando você usa o MediatR, cada manipulador de eventos deve usar um tipo de evento que é fornecido no parâmetro genérico da interface INotificationHandler, como pode ser visto no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="32f20-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="32f20-274">Com base na relação entre o evento e o manipulador de eventos, que pode ser considerada a assinatura, o artefato do MediatR consegue descobrir todos os manipuladores de eventos de cada evento e disparar cada um desses manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="32f20-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="32f20-275">Como manipular eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-275">How to handle domain events</span></span>

<span data-ttu-id="32f20-276">Por fim, o manipulador de eventos geralmente implementa o código da camada de aplicativo, que usa os repositórios de infraestrutura para obter as agregações adicionais necessárias e executar a lógica de domínio do efeito colateral.</span><span class="sxs-lookup"><span data-stu-id="32f20-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="32f20-277">O seguinte [código de manipulador de eventos de domínio em eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), mostra um exemplo de implementação.</span><span class="sxs-lookup"><span data-stu-id="32f20-277">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;        
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) 
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="32f20-278">O código de manipulador de eventos de domínio anterior é considerado um código da camada de aplicativo porque ele usa repositórios de infraestrutura, conforme explicado na próxima seção sobre a camada de persistência de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="32f20-278">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="32f20-279">Os manipuladores de eventos também podem usar outros componentes de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="32f20-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="32f20-280">Eventos de domínio podem gerar eventos de integração para serem publicados fora dos limites do microsserviço</span><span class="sxs-lookup"><span data-stu-id="32f20-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="32f20-281">Por fim, é importante mencionar que, às vezes, convém propagar eventos entre vários microsserviços.</span><span class="sxs-lookup"><span data-stu-id="32f20-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="32f20-282">Isso é considerado um evento de integração e ele pode ser publicado por meio de um barramento de eventos proveniente de qualquer manipulador de eventos de domínio específico.</span><span class="sxs-lookup"><span data-stu-id="32f20-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="32f20-283">Conclusões sobre eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="32f20-283">Conclusions on domain events</span></span>

<span data-ttu-id="32f20-284">Conforme mencionado, use eventos de domínio para implementar explicitamente os efeitos colaterais de alterações em seu domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="32f20-285">Para usar a terminologia DDD, use eventos de domínio para implementar explicitamente efeitos colaterais entre uma ou várias agregações.</span><span class="sxs-lookup"><span data-stu-id="32f20-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="32f20-286">Além disso e para melhor escalabilidade e menor impacto em bloqueios de banco de dados, use consistência eventual entre agregações dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="32f20-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="32f20-287">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="32f20-287">Additional resources</span></span>

-   <span data-ttu-id="32f20-288">**Greg Young. O que é um Evento de domínio?**
    [*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="32f20-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="32f20-289">**Jan Stenberg. Eventos de domínio e Consistência eventual**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="32f20-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="32f20-290">**Jimmy Bogard. Um padrão de eventos de domínio melhor**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="32f20-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="32f20-291">**Vaughn Vernon. Design de agregação efetivo parte II: fazendo agregações trabalharem juntas**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="32f20-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="32f20-292">**Jimmy Bogard. Reforçando seu domínio: eventos de domínio**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span><span class="sxs-lookup"><span data-stu-id="32f20-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="32f20-293">**Tony Truong. Exemplo de padrão de eventos de domínio**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="32f20-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="32f20-294">**Udi Dahan. Como criar modelos de domínio totalmente encapsulados**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="32f20-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="32f20-295">**Udi Dahan. Eventos de domínio – 2º ato**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="32f20-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="32f20-296">**Udi Dahan. Eventos de domínio – salvação**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="32f20-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="32f20-297">**Jan Kronquist. Não publique eventos de domínio, devolva-os!**
    [*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="32f20-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="32f20-298">**Cesar de la Torre. Domain Events vs. Eventos de integração em DDD e arquiteturas de microsserviços**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="32f20-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="32f20-299">[Anterior] (client-side-validation.md) [Próximo] (infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="32f20-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
