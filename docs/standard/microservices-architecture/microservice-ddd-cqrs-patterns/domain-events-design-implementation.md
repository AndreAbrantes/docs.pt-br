---
title: "Eventos de domínio. Design e implementação"
description: "Arquitetura de Microservices .NET para aplicativos .NET em contêineres | Eventos de domínio, design e implementação"
keywords: "Docker, Microsserviços, ASP.NET, Contêiner"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 2d98b302be4ee72d8225526944fc3e41cbadcb5f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="bdb51-105">Eventos de domínio: design e implementação</span><span class="sxs-lookup"><span data-stu-id="bdb51-105">Domain events: design and implementation</span></span>

<span data-ttu-id="bdb51-106">Use eventos de domínio para implementar explicitamente os efeitos colaterais de alterações em seu domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="bdb51-107">Em outras palavras e usando terminologia DDD, use eventos de domínio para implementar explicitamente efeitos colaterais em várias agregações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="bdb51-108">Opcionalmente, para melhor desempenho e menos impacto em bloqueios de banco de dados, use consistência eventual entre agregações dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="bdb51-109">O que é um evento de domínio?</span><span class="sxs-lookup"><span data-stu-id="bdb51-109">What is a domain event?</span></span>

<span data-ttu-id="bdb51-110">Um evento é algo que tenha ocorrido no passado.</span><span class="sxs-lookup"><span data-stu-id="bdb51-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="bdb51-111">Um evento de domínio é, logicamente, algo que ocorreram em um domínio específico, e algo que você deseja que outras partes do mesmo domínio (em processo) para ficar atento e potencialmente reagir a.</span><span class="sxs-lookup"><span data-stu-id="bdb51-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="bdb51-112">Uma vantagem importante dos eventos de domínio é que os efeitos colaterais depois algo aconteceu em um domínio podem ser expressos explicitamente em vez de implicitamente.</span><span class="sxs-lookup"><span data-stu-id="bdb51-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="bdb51-113">Esses efeitos devem ser consistentes para acontecem a todas as operações relacionadas à tarefa de negócios de lado, ou nenhum deles.</span><span class="sxs-lookup"><span data-stu-id="bdb51-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="bdb51-114">Além disso, os eventos de domínio permitem uma melhor separação de preocupações entre classes dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="bdb51-115">Por exemplo, se você estiver usando apenas apenas do Entity Framework e entidades ou até mesmo agregações, se deve haver efeitos colaterais provoked por um caso de uso, aqueles serão implementados como um conceito implícito no código acoplado depois algo aconteceu.</span><span class="sxs-lookup"><span data-stu-id="bdb51-115">For example, if you are just using just Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="bdb51-116">No entanto, se você apenas vê esse código, você poderá não saber se esse código (o efeito colateral) é parte da operação de principal ou se ela é realmente um efeito colateral.</span><span class="sxs-lookup"><span data-stu-id="bdb51-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="bdb51-117">Por outro lado, usando os eventos de domínio torna o conceito explícita e faz parte da linguagem onipresente.</span><span class="sxs-lookup"><span data-stu-id="bdb51-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="bdb51-118">Por exemplo, no aplicativo eShopOnContainers, criar uma ordem não é praticamente a ordem; ela atualiza ou cria um comprador de agregação com base no usuário original, porque o usuário não é um comprador até que haja um pedido em vigor.</span><span class="sxs-lookup"><span data-stu-id="bdb51-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="bdb51-119">Se você usar eventos de domínio, você pode expressar explicitamente essa regra de domínio com base no idioma onipresente fornecido pelos especialistas de domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="bdb51-120">Eventos de domínio são um pouco semelhantes a eventos do estilo de mensagens, com uma diferença importante.</span><span class="sxs-lookup"><span data-stu-id="bdb51-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="bdb51-121">Com a mensagem real, enfileiramento de mensagens, os agentes de mensagens ou um barramento de serviço usando AMPQ, uma mensagem é sempre enviada de forma assíncrona e comunicação entre processos e máquinas.</span><span class="sxs-lookup"><span data-stu-id="bdb51-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="bdb51-122">Isso é útil para a integração de vários contextos limitada, microservices ou até mesmo diferentes aplicativos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="bdb51-123">No entanto, com os eventos de domínio, você deseja gerar um evento da operação de domínio em execução no momento, mas você deseja efeitos colaterais ocorrer dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="bdb51-124">Os eventos de domínio e seus efeitos colaterais (as ações disparadas depois que são gerenciados pelo manipuladores de eventos) deve ocorrer quase imediatamente, geralmente em processo e dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="bdb51-125">Assim, os eventos de domínio podem ser síncronas ou assíncronas.</span><span class="sxs-lookup"><span data-stu-id="bdb51-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="bdb51-126">Eventos de integração, no entanto, devem sempre ser assíncronos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="bdb51-127">Eventos de domínio em vez de eventos de integração</span><span class="sxs-lookup"><span data-stu-id="bdb51-127">Domain events versus integration events</span></span>

<span data-ttu-id="bdb51-128">Semanticamente, eventos de integração e de domínio são a mesma coisa: notificações sobre algo que acabou.</span><span class="sxs-lookup"><span data-stu-id="bdb51-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="bdb51-129">No entanto, sua implementação deve ser diferente.</span><span class="sxs-lookup"><span data-stu-id="bdb51-129">However, their implementation must be different.</span></span> <span data-ttu-id="bdb51-130">Eventos de domínio são apenas mensagens enviadas por push para um dispatcher de evento de domínio, que pode ser implementado como um mediador na memória com base em um contêiner IoC ou qualquer outro método.</span><span class="sxs-lookup"><span data-stu-id="bdb51-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="bdb51-131">Por outro lado, a finalidade de eventos de integração é a propagação de transações confirmadas e atualizações para outros subsistemas, independentemente de estarem outros microservices, contextos limitada ou aplicativos externos mesmo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="bdb51-132">Portanto, eles devem ocorrer somente se a entidade é persistente com êxito, pois em muitos cenários se isso falhar, toda a operação efetivamente nunca aconteceu.</span><span class="sxs-lookup"><span data-stu-id="bdb51-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="bdb51-133">Além disso e como mencionada, integração eventos devem ser baseados em comunicação assíncrona entre vários microservices (outros contextos limitada) ou aplicativos/sistemas externamente.</span><span class="sxs-lookup"><span data-stu-id="bdb51-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="bdb51-134">Assim, a interface de barramento do evento precisa de alguma infraestrutura que permite que o processo entre e distribuídas comunicação entre serviços potencialmente remotos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="bdb51-135">Ele pode ser baseada em um barramento de serviço comercial, filas, um banco de dados compartilhado usado como uma caixa de correio ou qualquer outro distribuídas e push idealmente o sistema de mensagens de baseado em.</span><span class="sxs-lookup"><span data-stu-id="bdb51-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="bdb51-136">Eventos de domínio como uma maneira preferida para disparar efeitos colaterais em várias agregações dentro do mesmo domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="bdb51-137">Se executar um comando relacionado a uma instância de agregação requer regras de domínio adicionais para ser executado em uma ou mais agregações adicionais, deve criar e implementar os efeitos colaterais deve ser disparada por eventos de domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="bdb51-138">Conforme mostrado na Figura 9-14 e como um dos mais importantes casos de uso, um evento de domínio deve ser usado para propagar alterações de estado entre várias agregações dentro do mesmo modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="bdb51-139">**Figura 9-14**.</span><span class="sxs-lookup"><span data-stu-id="bdb51-139">**Figure 9-14**.</span></span> <span data-ttu-id="bdb51-140">Eventos de domínio para impor a consistência entre várias agregações dentro do mesmo domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="bdb51-141">Na figura, quando o usuário inicia uma ordem, o evento de domínio OrderStarted dispara a criação de um objeto de compradores de microsserviço ordenação, com base nas informações de usuário original de microsserviço a identidade (com as informações fornecidas no comando CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="bdb51-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="bdb51-142">O evento de domínio é gerado pela agregação ordem quando ele é criado em primeiro lugar.</span><span class="sxs-lookup"><span data-stu-id="bdb51-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="bdb51-143">Como alternativa, você pode ter raiz agregada assinada para eventos gerados pelos membros de suas agregações (entidades filho).</span><span class="sxs-lookup"><span data-stu-id="bdb51-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="bdb51-144">Por exemplo, cada entidade de filho ItemPedido pode gerar um evento quando o preço de item é maior do que um valor específico, ou quando o valor do item de produto é muito alto.</span><span class="sxs-lookup"><span data-stu-id="bdb51-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="bdb51-145">A raiz de agregação, em seguida, pode receber os eventos e executar um cálculo global ou agregação.</span><span class="sxs-lookup"><span data-stu-id="bdb51-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="bdb51-146">É importante entender que essa comunicação baseada em evento não é implementada diretamente dentro de agregações; Você precisa implementar manipuladores de eventos do domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="bdb51-147">Manipular eventos de domínio é um problema de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="bdb51-148">A camada de modelo de domínio só deve se concentrar na lógica do domínio — que possa entender um especialista em domínio, não a infraestrutura de aplicativo como manipuladores e ações de persistência de efeito colateral usando repositórios.</span><span class="sxs-lookup"><span data-stu-id="bdb51-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="bdb51-149">Portanto, o nível de camada de aplicativo é onde você deve ter manipuladores de eventos de domínio disparar ações quando ocorre um evento de domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="bdb51-150">Eventos de domínio também podem ser usados para acionar qualquer número de ações do aplicativo e o que é mais importante, deve estar aberta para aumentar esse número no futuro de maneira separada.</span><span class="sxs-lookup"><span data-stu-id="bdb51-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="bdb51-151">Por exemplo, quando a ordem é iniciada, você deseja publicar um evento de domínio para propagar essas informações para outras agregações ou até mesmo gerar ações do aplicativo como as notificações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="bdb51-152">O ponto-chave é o número de open de ações a serem executadas quando ocorre um evento de domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="bdb51-153">Por fim, as ações e regras do domínio e o aplicativo aumentará.</span><span class="sxs-lookup"><span data-stu-id="bdb51-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="bdb51-154">A complexidade ou o número de ações de efeito colateral quando acontecer algo crescerá, mas se o seu código foram juntamente com "colar" (ou seja, apenas instanciando objetos com a nova palavra-chave em C\#), e em seguida, sempre que necessário para adicionar uma nova ação seria necessário Altere o código original.</span><span class="sxs-lookup"><span data-stu-id="bdb51-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="bdb51-155">Isso pode resultar em novos bugs, pois cada novo requisito, será necessário alterar o fluxo do código original.</span><span class="sxs-lookup"><span data-stu-id="bdb51-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="bdb51-156">Isso vai contra o [abrir/fechado princípio](https://en.wikipedia.org/wiki/Open/closed_principle) de [sólido](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="bdb51-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="bdb51-157">Não só que, a classe original que foi orquestrar as operações de crescimento e crescem, que vai contra o [princípio de responsabilidade única (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="bdb51-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="bdb51-158">Por outro lado, se você usar eventos de domínio, você pode criar uma implementação refinada e desacoplada Segregando responsabilidades usando essa abordagem:</span><span class="sxs-lookup"><span data-stu-id="bdb51-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="bdb51-159">Envie um comando (por exemplo, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="bdb51-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="bdb51-160">Receba o comando em um manipulador de comando.</span><span class="sxs-lookup"><span data-stu-id="bdb51-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="bdb51-161">Execute a transação de uma agregação único.</span><span class="sxs-lookup"><span data-stu-id="bdb51-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="bdb51-162">(Opcional) Disparar eventos de domínio para efeitos colaterais (por exemplo, OrderStartedDomainDvent).</span><span class="sxs-lookup"><span data-stu-id="bdb51-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainDvent).</span></span>
1.  <span data-ttu-id="bdb51-163">Thast de eventos (dentro do processo atual) do identificador de domínio será executado um número aberto de efeitos colaterais em várias agregações ou ações do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-163">Handle domain events (within the current process) thast will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="bdb51-164">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="bdb51-164">For example:</span></span>
    -   <span data-ttu-id="bdb51-165">Verificar ou criar um método de pagamento e compradores.</span><span class="sxs-lookup"><span data-stu-id="bdb51-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="bdb51-166">Criar e enviar um evento relacionado a integração do barramento de evento seja propagado estados microservices ou gatilho ações externas como enviar um email para o comprador para.</span><span class="sxs-lookup"><span data-stu-id="bdb51-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="bdb51-167">Lidar com outros efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="bdb51-167">Handle other side effects.</span></span>

<span data-ttu-id="bdb51-168">Conforme mostrado na Figura 9-15, a partir do mesmo evento de domínio, você pode manipular várias ações relacionadas a outras agregações no domínio ou ações de aplicativos adicionais, que você precisa realizar em microservices conectar-se com o barramento de evento e eventos de integração.</span><span class="sxs-lookup"><span data-stu-id="bdb51-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="bdb51-169">**Figura 9-15**.</span><span class="sxs-lookup"><span data-stu-id="bdb51-169">**Figure 9-15**.</span></span> <span data-ttu-id="bdb51-170">Manipulando várias ações por domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="bdb51-171">Os manipuladores de eventos são normalmente na camada de aplicativo, porque você usará os objetos de infra-estrutura como repositórios ou uma API de aplicativo para o comportamento do microsserviço.</span><span class="sxs-lookup"><span data-stu-id="bdb51-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="bdb51-172">Nesse sentido, manipuladores de eventos são semelhantes aos manipuladores de comandos, portanto, ambos são parte da camada de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="bdb51-173">A diferença importante é que um comando deve ser processado apenas uma vez.</span><span class="sxs-lookup"><span data-stu-id="bdb51-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="bdb51-174">Um evento de domínio pode ser processada zero ou  *n*  vezes, porque se pode ser recebido por vários receptores ou manipuladores de eventos com uma finalidade diferente para cada manipulador.</span><span class="sxs-lookup"><span data-stu-id="bdb51-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="bdb51-175">A possibilidade de um número aberto de manipuladores por eventos de domínio permite que você adicionar várias regras de domínio mais sem afetar seu código atual.</span><span class="sxs-lookup"><span data-stu-id="bdb51-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="bdb51-176">Por exemplo, implementar a seguinte regra de negócios que deve ocorrer direita após um evento pode ser tão fácil quanto adicionar alguns manipuladores de eventos (ou até mesmo uma):</span><span class="sxs-lookup"><span data-stu-id="bdb51-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="bdb51-177">Quando a quantidade total comprada por um cliente no armazenamento, em qualquer número de pedidos, excede r $6.000, aplicar um 10% de desconto desconto para cada nova ordem e notificar o cliente com um email sobre esse desconto para pedidos futuros.</span><span class="sxs-lookup"><span data-stu-id="bdb51-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="bdb51-178">Implementar eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-178">Implementing domain events</span></span>

<span data-ttu-id="bdb51-179">No c#, um evento de domínio é simplesmente uma retenção de dados de classe ou estrutura, como um DTO, com todas as informações relacionadas à ocorrência no domínio, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="bdb51-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : IAsyncNotification
{
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
        int cardTypeId, string cardNumber,
        string cardSecurityNumber, string cardHolderName,
        DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="bdb51-180">Isso é essencialmente uma classe que contém todos os dados relacionados ao evento OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="bdb51-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="bdb51-181">Em termos de linguagem onipresente do domínio, como um evento é algo que ocorreram no passado, o nome da classe do evento deve ser representado como um verbo pretérito, como OrderStartedDomainEvent ou OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="bdb51-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="bdb51-182">Isso é como o evento de domínio é implementado no ordenação microsserviço em eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="bdb51-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="bdb51-183">Como já observamos, uma característica importante de eventos é que uma vez que um evento é algo que ocorreram no passado, ele não deve ser alterada.</span><span class="sxs-lookup"><span data-stu-id="bdb51-183">As we have noted, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="bdb51-184">Portanto, ele deve ser uma classe imutável.</span><span class="sxs-lookup"><span data-stu-id="bdb51-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="bdb51-185">Você pode ver no código anterior, que as propriedades são somente leitura de fora do objeto.</span><span class="sxs-lookup"><span data-stu-id="bdb51-185">You can see in the preceding code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="bdb51-186">A única maneira de atualizar o objeto é por meio do construtor quando você cria o objeto de evento.</span><span class="sxs-lookup"><span data-stu-id="bdb51-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="bdb51-187">Gerando eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-187">Raising domain events</span></span>

<span data-ttu-id="bdb51-188">A próxima pergunta é como gerar um evento de domínio para alcançar seus manipuladores de eventos relacionados.</span><span class="sxs-lookup"><span data-stu-id="bdb51-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="bdb51-189">Você pode usar várias abordagens.</span><span class="sxs-lookup"><span data-stu-id="bdb51-189">You can use multiple approaches.</span></span>

<span data-ttu-id="bdb51-190">Udi Dahan originalmente proposta (por exemplo, em vários relacionadas, como postagens, [eventos de domínio – demorar 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) usando uma classe estática para gerenciar e gerando eventos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="bdb51-191">Isso pode incluir uma classe estática chamado DomainEvents que deve gerar eventos de domínio imediatamente quando ele é chamado, usando uma sintaxe semelhante DomainEvents.Raise (evento myEvent).</span><span class="sxs-lookup"><span data-stu-id="bdb51-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="bdb51-192">Jimmy Bogard escreveu uma postagem de blog ([fortalecendo a seu domínio: eventos de domínio](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) que recomenda uma abordagem semelhante.</span><span class="sxs-lookup"><span data-stu-id="bdb51-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="bdb51-193">No entanto, quando a classe de eventos de domínio é estática, ele também envia aos manipuladores imediatamente.</span><span class="sxs-lookup"><span data-stu-id="bdb51-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="bdb51-194">Isso torna teste e depuração mais difícil, pois os manipuladores de eventos com a lógica de efeitos colaterais são executados imediatamente após o evento é gerado.</span><span class="sxs-lookup"><span data-stu-id="bdb51-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="bdb51-195">Quando você está testando e depurando, deseja enfocam e apenas o que está acontecendo em classes de agregação atuais; Você não deseja repentinamente ser redirecionado para outros manipuladores de eventos para efeitos colaterais relacionados a outras agregações ou lógica do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="bdb51-196">É por isso evoluíram outras abordagens, conforme explicado na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="bdb51-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="bdb51-197">A abordagem adiada para gerar e envio de eventos</span><span class="sxs-lookup"><span data-stu-id="bdb51-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="bdb51-198">Em vez de expedição imediatamente para um manipulador de eventos de domínio, uma abordagem melhor é adicionar os eventos de domínio a uma coleção e, em seguida, os eventos de domínio de expedição *antes de* ou *direita*  *Depois de* confirmar a transação (como acontece com SaveChanges no EF).</span><span class="sxs-lookup"><span data-stu-id="bdb51-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="bdb51-199">(Essa abordagem descrita por Jimmy Bogard nesta postagem [um padrão de eventos de domínio melhor](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="bdb51-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="bdb51-200">Decidir se você enviar os eventos de domínio logo antes de ou para a direita após confirmar a transação é importante, pois ela determina se você incluirá os efeitos colaterais como parte da mesma transação ou em transações diferentes.</span><span class="sxs-lookup"><span data-stu-id="bdb51-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="bdb51-201">No último caso, você precisa lidar com consistência eventual entre várias agregações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="bdb51-202">Este tópico é abordado na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="bdb51-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="bdb51-203">A abordagem adiada é que eShopOnContainers usa.</span><span class="sxs-lookup"><span data-stu-id="bdb51-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="bdb51-204">Primeiro, adicione os eventos que ocorrem nas suas entidades em uma coleção ou uma lista de eventos por entidade.</span><span class="sxs-lookup"><span data-stu-id="bdb51-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="bdb51-205">Essa lista deve ser parte do objeto de entidade, ou melhor ainda, parte de sua classe de entidade base, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="bdb51-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example:</span></span>

```csharp
public abstract class Entity
{
    private List<IAsyncNotification> _domainEvents;

    public List<IAsyncNotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(IAsyncNotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<IAsyncNotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(IAsyncNotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="bdb51-206">Quando você quiser gerar um evento, você apenas adicioná-lo à coleção de eventos sejam colocados dentro de um método de agregação de entidade, como mostra o seguinte código:</span><span class="sxs-lookup"><span data-stu-id="bdb51-206">When you want to raise an event, you just add it to the event collection to be placed within an aggregate entity method, as the following code shows:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
    cardTypeId,
    cardNumber,
    cardSecurityNumber,
    cardHolderName,
    cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="bdb51-207">Observe que a única coisa que o método AddDomainEvent está fazendo é adicionar um evento à lista.</span><span class="sxs-lookup"><span data-stu-id="bdb51-207">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="bdb51-208">Nenhum evento é gerado ainda, e nenhum manipulador de eventos é invocado ainda.</span><span class="sxs-lookup"><span data-stu-id="bdb51-208">No event is raised yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="bdb51-209">Você realmente deseja os eventos de expedição posterior no, quando você confirma a transação no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="bdb51-209">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="bdb51-210">Se você estiver usando o Entity Framework Core, que significa no método SaveChanges do seu EF DbContext, como no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="bdb51-210">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<int> SaveEntitiesAsync()
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);
        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="bdb51-211">Com esse código, você enviar os eventos de entidade para seus manipuladores de eventos do respectivos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-211">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="bdb51-212">O resultado geral é que você tenha desacoplado aumento de um evento de domínio (adição de um simples em uma lista na memória) de expedição-lo para um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-212">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="bdb51-213">Além disso, dependendo de qual tipo de dispatcher usando, você pôde expedir os eventos de forma síncrona ou assíncrona.</span><span class="sxs-lookup"><span data-stu-id="bdb51-213">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="bdb51-214">Lembre-se de que transacional limites entram em significativa brincar aqui.</span><span class="sxs-lookup"><span data-stu-id="bdb51-214">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="bdb51-215">Se sua unidade de trabalho e a transação pode abranger mais de uma agregação (como ao usar o EF principal e um banco de dados relacional), isso pode funcionar bem.</span><span class="sxs-lookup"><span data-stu-id="bdb51-215">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="bdb51-216">Mas se a transação não pode abranger agregações, como quando você estiver usando um banco de dados NoSQL como documentos do Azure, você precisa implementar etapas adicionais para obter consistência.</span><span class="sxs-lookup"><span data-stu-id="bdb51-216">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="bdb51-217">Essa é outra razão por que não é universal; ignorância de persistência depende do sistema de armazenamento usado.</span><span class="sxs-lookup"><span data-stu-id="bdb51-217">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="bdb51-218">Única transação em agregações versus consistência eventual em agregações</span><span class="sxs-lookup"><span data-stu-id="bdb51-218">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="bdb51-219">Se executar uma única transação em agregações em vez de depender de consistência eventual entre essas agregações é controverso.</span><span class="sxs-lookup"><span data-stu-id="bdb51-219">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="bdb51-220">Muitos autores DDD como Eric Evans e Vaughn Vernon defendem a regra que uma transação = uma agregação e discutir, portanto, a consistência eventual em agregações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-220">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="bdb51-221">Por exemplo, em seu livro *Domain-Driven Design*, Eric Evans diz:</span><span class="sxs-lookup"><span data-stu-id="bdb51-221">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="bdb51-222">Qualquer regra que abrange as agregações não deverá ser atualizado em todos os momentos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-222">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="bdb51-223">Por meio do processamento de eventos, o processamento em lotes ou outros mecanismos de atualização, outras dependências podem ser resolvidas em um momento específico.</span><span class="sxs-lookup"><span data-stu-id="bdb51-223">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="bdb51-224">(pg.</span><span class="sxs-lookup"><span data-stu-id="bdb51-224">(pg.</span></span> <span data-ttu-id="bdb51-225">128)</span><span class="sxs-lookup"><span data-stu-id="bdb51-225">128)</span></span>

<span data-ttu-id="bdb51-226">Vaughn Vernon diz o seguinte no [efetivo de Design de agregação. Parte II: Fazer agrega trabalho juntos](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="bdb51-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="bdb51-227">Portanto, se executar um comando em uma instância de agregação requer que as regras de negócio adicionais executar em uma ou mais agregações, use consistência eventual \[...\] Há uma maneira prática para dar suporte a consistência eventual em um modelo DDD.</span><span class="sxs-lookup"><span data-stu-id="bdb51-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="bdb51-228">Um método de agregação publica um evento de domínio que está na hora entregue a um ou mais assinantes assíncronos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="bdb51-229">Essa lógica é baseada nos adotando refinadas transações em vez de transações muitas agregações ou entidades.</span><span class="sxs-lookup"><span data-stu-id="bdb51-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="bdb51-230">A ideia é que no segundo caso, o número de bloqueios de banco de dados será significativo em aplicativos em larga escala com necessidades de alta escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="bdb51-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="bdb51-231">Adotar o fato de que precisam de aplicativos escalonáveis de alto não tem instantânea consistência transacional entre várias agregações ajuda a aceitar o conceito de consistência eventual.</span><span class="sxs-lookup"><span data-stu-id="bdb51-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="bdb51-232">Mudanças atômicas geralmente não são necessárias aos negócios, e em qualquer caso a responsabilidade de especialistas de domínio para dizer se operações específicas necessário transações atômicas ou não.</span><span class="sxs-lookup"><span data-stu-id="bdb51-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="bdb51-233">Se uma operação sempre precisa de uma transação atômica entre várias agregações, você pode perguntar se a agregação deve ser maior ou não foi criada corretamente.</span><span class="sxs-lookup"><span data-stu-id="bdb51-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="bdb51-234">No entanto, outros desenvolvedores e arquitetos como Jimmy Bogard são okey com a abrangência de uma única transação em várias agregações, mas somente quando as agregações adicionais relacionadas a efeitos colaterais para o mesmo comando original.</span><span class="sxs-lookup"><span data-stu-id="bdb51-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="bdb51-235">Por exemplo, em [um padrão de eventos de domínio melhor](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard diz:</span><span class="sxs-lookup"><span data-stu-id="bdb51-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="bdb51-236">Normalmente, quero os efeitos colaterais de um evento de domínio para ocorrer dentro da mesma transação lógica, mas não necessariamente no mesmo escopo de disparar o evento de domínio \[...\] Antes de podemos confirmar nosso transação, podemos expedir nosso eventos para seus respectivos manipuladores.</span><span class="sxs-lookup"><span data-stu-id="bdb51-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="bdb51-237">Se você despachar o direito de eventos de domínio *antes de* confirmar a transação original, é porque você deseja que os efeitos colaterais dos eventos a serem incluídos na mesma transação.</span><span class="sxs-lookup"><span data-stu-id="bdb51-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="bdb51-238">Por exemplo, se o método SaveChanges do EF DbContext falhar, a transação será reverter todas as alterações, incluindo o resultado de qualquer operação de efeito colateral implementado pelos manipuladores de eventos relacionados do domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="bdb51-239">Isso é porque o escopo de vida DbContext é por padrão definido como "com escopo."</span><span class="sxs-lookup"><span data-stu-id="bdb51-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="bdb51-240">Portanto, o objeto DbContext é compartilhado entre vários objetos de repositório seja instanciados dentro do mesmo escopo ou um gráfico de objeto.</span><span class="sxs-lookup"><span data-stu-id="bdb51-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="bdb51-241">Isso coincide com o escopo de HttpRequest ao desenvolver aplicativos de API da Web ou MVC.</span><span class="sxs-lookup"><span data-stu-id="bdb51-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="bdb51-242">Na realidade, ambas as abordagens (única transação atômica e consistência eventual) podem ser à direita.</span><span class="sxs-lookup"><span data-stu-id="bdb51-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="bdb51-243">Isso realmente depende em seus requisitos de negócios ou de domínio e o que os especialistas de domínio lhe.</span><span class="sxs-lookup"><span data-stu-id="bdb51-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="bdb51-244">Também depende de como escalonável necessário para o serviço (transações mais granulares tem menos impacto em relação a bloqueios do banco de dados).</span><span class="sxs-lookup"><span data-stu-id="bdb51-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="bdb51-245">E depende de quanto investimento está disposto a fazer em seu código, pois consistência eventual requer código mais complexo para detectar possíveis inconsistências entre agregações e a necessidade de implementar compensatórios ações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="bdb51-246">Levar em conta se você confirmar as alterações para a agregação original e posteriormente, quando os eventos estão sendo despachados, há um problema e os manipuladores de eventos não é possível confirmar seus efeitos colaterais, você terá as inconsistências entre agregações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="bdb51-247">Uma forma de permitir ações compensatórios seria armazenar os eventos de domínio nas tabelas de banco de dados adicionais para que eles possam ser parte da transação original.</span><span class="sxs-lookup"><span data-stu-id="bdb51-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="bdb51-248">Posteriormente, você pode ter um processo em lote que detecta inconsistências e executa ações compensatórios comparando a lista de eventos com o estado atual das agregações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="bdb51-249">As ações compensatórios fazem parte de um tópico complexo que exige a análise detalhada do lado, o que inclui analisá-lo com o usuário empresarial e especialistas de domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="bdb51-250">Em qualquer caso, você pode escolher a abordagem que você precisa.</span><span class="sxs-lookup"><span data-stu-id="bdb51-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="bdb51-251">Mas inicial adiada abordagem — disparar os eventos antes de confirmar, para usar uma única transação – é a abordagem mais simples ao usar o EF principal e um banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="bdb51-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="bdb51-252">É mais fácil de implementar e válido em muitos casos de negócios.</span><span class="sxs-lookup"><span data-stu-id="bdb51-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="bdb51-253">Também é a abordagem usada o ordenação microsserviço em eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="bdb51-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="bdb51-254">Mas como você realmente expedição esses eventos para seus manipuladores de eventos do respectivos?</span><span class="sxs-lookup"><span data-stu-id="bdb51-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="bdb51-255">O que é o \_objeto mediador que você vê no exemplo anterior?</span><span class="sxs-lookup"><span data-stu-id="bdb51-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="bdb51-256">Que tem a ver com as técnicas e artefatos que você pode usar para mapear entre seus manipuladores de eventos e eventos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="bdb51-257">O dispatcher de evento de domínio: mapeamento de eventos para manipuladores de eventos</span><span class="sxs-lookup"><span data-stu-id="bdb51-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="bdb51-258">Depois que você é capaz de expedição ou publicar os eventos, você precisa de algum tipo de artefato que publicará o evento de forma que cada manipulador relacionado pode obtê-lo e efeitos colaterais de processo com base nesse evento.</span><span class="sxs-lookup"><span data-stu-id="bdb51-258">Once you are able to dispatch or publish the events, you need some kind of artifact that will publish the event so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="bdb51-259">Uma abordagem é um sistema de mensagens real ou até mesmo um barramento de evento, possivelmente com base em um barramento de serviço em vez de eventos na memória.</span><span class="sxs-lookup"><span data-stu-id="bdb51-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="bdb51-260">No entanto, para o primeiro caso, real de mensagens pode ser um exagero para processar eventos de domínio, desde que você só precisa processar os eventos dentro do mesmo processo (ou seja, na mesma camada de aplicativo e de domínio).</span><span class="sxs-lookup"><span data-stu-id="bdb51-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="bdb51-261">É outra maneira de mapear os eventos para vários manipuladores de eventos usando o registro de tipos em um contêiner IoC para que você pode inferir dinamicamente onde os eventos de expedição.</span><span class="sxs-lookup"><span data-stu-id="bdb51-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="bdb51-262">Em outras palavras, você precisa saber o que precisam de manipuladores de eventos para obter um evento específico.</span><span class="sxs-lookup"><span data-stu-id="bdb51-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="bdb51-263">Figura 9 a 16 mostra um método simplificado para fazer isso.</span><span class="sxs-lookup"><span data-stu-id="bdb51-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="bdb51-264">**Figura 9 a 16**.</span><span class="sxs-lookup"><span data-stu-id="bdb51-264">**Figure 9-16**.</span></span> <span data-ttu-id="bdb51-265">Dispatcher de evento de domínio usando IoC</span><span class="sxs-lookup"><span data-stu-id="bdb51-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="bdb51-266">Você pode criar todos os detalhes técnicos e artefatos para implementar essa abordagem, você mesmo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="bdb51-267">No entanto, você também pode usar as bibliotecas disponíveis como [MediatR](https://github.com/jbogard/MediatR), que nos bastidores usa o contêiner de IoT.</span><span class="sxs-lookup"><span data-stu-id="bdb51-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoT container.</span></span> <span data-ttu-id="bdb51-268">Você, portanto, pode usar diretamente as interfaces predefinidas e métodos de expedição/publicar do objeto mediador.</span><span class="sxs-lookup"><span data-stu-id="bdb51-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="bdb51-269">No código, primeiro você precisa registrar os tipos de manipulador de eventos em seu contêiner IoC, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="bdb51-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example:</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement
        // IAsyncNotificationHandler<>) in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(
            typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
            .GetTypeInfo().Assembly)
            .Where(t => t.IsClosedTypeOf(typeof(IAsyncNotificationHandler<>)))
            .AsImplementedInterfaces();
        // Other registrations ...
    }
}
```

<span data-ttu-id="bdb51-270">O código primeiro identifica o assembly que contém os manipuladores de eventos de domínio ao localizar o assembly que contém qualquer um dos manipuladores (usar typeof(ValidateOrAddBuyerAggregateWhenXxxx), mas você escolher qualquer outro manipulador de eventos para localizar o assembly).</span><span class="sxs-lookup"><span data-stu-id="bdb51-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="bdb51-271">Como todos os manipuladores de eventos implementam a interface IAsyncNotificationHandler, em seguida, o código pesquisas apenas para os tipos e registra todos os manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="bdb51-272">Como assinar eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-272">How to subscribe to domain events</span></span>

<span data-ttu-id="bdb51-273">Quando você usa MediatR, cada manipulador de eventos deve usar um tipo de evento que é fornecido no parâmetro genérico da interface IAsyncNotificationHandler, como você pode ver no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="bdb51-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the IAsyncNotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="bdb51-274">Com base na relação entre o evento e o manipulador de eventos, que pode ser considerado a assinatura, o artefato MediatR pode descobrir todos os manipuladores de eventos para cada evento e acionar cada um dos manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="bdb51-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="bdb51-275">Como manipular eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-275">How to handle domain events</span></span>

<span data-ttu-id="bdb51-276">Por fim, o manipulador de eventos geralmente implementa o código de camada de aplicativo que usa os repositórios de infraestrutura para obter as agregações adicionais necessárias e executar a lógica do domínio de efeito colateral.</span><span class="sxs-lookup"><span data-stu-id="bdb51-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="bdb51-277">O código a seguir mostra um exemplo.</span><span class="sxs-lookup"><span data-stu-id="bdb51-277">The following code shows an example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
    : IAsyncNotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;
    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // Parameter validations
        //...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ?
            orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;
        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }
        buyer.VerifyOrAddPaymentMethod(cardTypeId,
            $"Payment Method on {DateTime.UtcNow}",
            orderStartedEvent.CardNumber,
            orderStartedEvent.CardSecurityNumber,
            orderStartedEvent.CardHolderName,
            orderStartedEvent.CardExpiration,
            orderStartedEvent.Order.Id);
        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) :
        _buyerRepository.Add(buyer);
        await _buyerRepository.UnitOfWork.SaveEntitiesAsync();
        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="bdb51-278">Esse código de manipulador de eventos é considerado código da camada de aplicativo porque ele usa os repositórios de infraestrutura, como explicado na próxima seção sobre a camada de persistência de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="bdb51-278">This event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="bdb51-279">Manipuladores de eventos também podem usar outros componentes de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="bdb51-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="bdb51-280">Eventos de domínio podem gerar eventos de integração a ser publicado fora dos limites de microsserviço</span><span class="sxs-lookup"><span data-stu-id="bdb51-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="bdb51-281">Por fim, é importante mencionar que, às vezes, convém propagado eventos microservices vários.</span><span class="sxs-lookup"><span data-stu-id="bdb51-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="bdb51-282">Que é considerado um evento de integração e ele pode ser publicado por meio de um barramento de evento qualquer manipulador de eventos de domínio específico.</span><span class="sxs-lookup"><span data-stu-id="bdb51-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="bdb51-283">Conclusões sobre eventos de domínio</span><span class="sxs-lookup"><span data-stu-id="bdb51-283">Conclusions on domain events</span></span> 

<span data-ttu-id="bdb51-284">Conforme mencionado, use eventos de domínio para implementar explicitamente os efeitos colaterais de alterações em seu domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="bdb51-285">Para usar a terminologia DDD, use eventos de domínio para implementar explicitamente efeitos colaterais em uma ou várias agregações.</span><span class="sxs-lookup"><span data-stu-id="bdb51-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="bdb51-286">Além disso e para melhor desempenho e menos impacto nas bloqueios de banco de dados, use a consistência eventual entre agregações dentro do mesmo domínio.</span><span class="sxs-lookup"><span data-stu-id="bdb51-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="bdb51-287">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="bdb51-287">Additional resources</span></span>

-   <span data-ttu-id="bdb51-288">**Greg Young. O que é um evento de domínio? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="bdb51-289">**Jan Stenberg. Eventos de domínio e a consistência Eventual**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="bdb51-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="bdb51-290">**Jimmy Bogard. Um padrão de eventos de domínio melhor**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="bdb51-291">**Vaughn Vernon. Efetivo agregação Design parte II: Fazendo agregações trabalho juntos**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_artigos/Vernon\_de2011\_ 2. pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="bdb51-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="bdb51-292">**Jimmy Bogard. Reforçar a seu domínio: eventos de domínio**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="bdb51-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="bdb51-293">**Tony Truong. Exemplo de eventos de domínio padrão**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="bdb51-294">**Udi Dahan. Como criar totalmente encapsulado modelos de domínio**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="bdb51-295">**Udi Dahan. Eventos de domínio – demorar 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="bdb51-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="bdb51-296">**Udi Dahan. Eventos de domínio – salvação**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="bdb51-297">**Jan Kronquist. Não publicar eventos de domínio, retorne-as! ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="bdb51-298">**Cesar de la Torre. Domínio eventos vs. Eventos de integração em arquiteturas DDD e microservices**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="bdb51-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="bdb51-299">[Anterior] (cliente-lado-validation.md) [Avançar] (infraestrutura-persistência-camada-design.md)</span><span class="sxs-lookup"><span data-stu-id="bdb51-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
