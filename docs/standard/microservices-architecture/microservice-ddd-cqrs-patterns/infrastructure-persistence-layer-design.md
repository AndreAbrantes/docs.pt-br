---
title: Projetando a camada de persistência da infraestrutura
description: Arquitetura de microsserviços do .NET para aplicativos .NET em contêineres | Projetando a camada de persistência da infraestrutura
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.openlocfilehash: 9da1020ac5b43971a8f976c518f4537bec866c26
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37105840"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="58851-103">Projetando a camada de persistência da infraestrutura</span><span class="sxs-lookup"><span data-stu-id="58851-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="58851-104">Os componentes de persistência de dados fornecem acesso aos dados hospedados dentro dos limites de um microsserviço (ou seja, em um banco de dados de microsserviço).</span><span class="sxs-lookup"><span data-stu-id="58851-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="58851-105">Eles contêm a implementação real dos componentes, como repositórios e classes [Unidade de Trabalho](https://martinfowler.com/eaaCatalog/unitOfWork.html), como DBContexts de EF personalizados.</span><span class="sxs-lookup"><span data-stu-id="58851-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="58851-106">O padrão de repositório</span><span class="sxs-lookup"><span data-stu-id="58851-106">The Repository pattern</span></span>

<span data-ttu-id="58851-107">Repositórios são classes ou componentes que encapsulam a lógica necessária para acessar fontes de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="58851-108">Eles centralizam a funcionalidade comum de acesso a dados, melhorando a sustentabilidade e desacoplando a infraestrutura ou a tecnologia usada para acessar os bancos de dados da camada do modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="58851-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="58851-109">Se você usa um ORM (mapeamento objeto-relacional) como o Entity Framework, o código que precisa ser implementado é simplificado, graças à LINQ (consulta integrada à linguagem) e à tipagem forte.</span><span class="sxs-lookup"><span data-stu-id="58851-109">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="58851-110">Isso permite que você se concentre na lógica de persistência de dados e não nos detalhes técnicos do acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="58851-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="58851-111">O padrão de repositório é uma maneira bem documentada de trabalhar com uma fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="58851-112">No livro [Padrões de Arquitetura de Aplicações Corporativas](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler descreve um repositório da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="58851-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="58851-113">Um repositório executa as tarefas de um intermediário entre as camadas de modelo de domínio e o mapeamento de dados, funcionando de maneira semelhante a um conjunto de objetos de domínio na memória.</span><span class="sxs-lookup"><span data-stu-id="58851-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="58851-114">Os objetos de clientes criam consultas de forma declarativa e enviam-nas para os repositórios buscando respostas.</span><span class="sxs-lookup"><span data-stu-id="58851-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="58851-115">Conceitualmente, um repositório encapsula um conjunto de objetos armazenados no banco de dados e as operações que podem ser executadas neles, fornecendo uma maneira que é mais próxima da camada de persistência.</span><span class="sxs-lookup"><span data-stu-id="58851-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="58851-116">Os repositórios também oferecem a capacidade de separação, de forma clara e em uma única direção, a dependência entre o domínio de trabalho e a alocação de dados ou o mapeamento.</span><span class="sxs-lookup"><span data-stu-id="58851-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="58851-117">Definir um repositório por agregação</span><span class="sxs-lookup"><span data-stu-id="58851-117">Define one repository per aggregate</span></span>

<span data-ttu-id="58851-118">Para cada agregação ou raiz de agregação, você deve criar uma classe de repositório.</span><span class="sxs-lookup"><span data-stu-id="58851-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="58851-119">Em um microsserviço baseado nos padrões de design orientado por domínio, o único canal que você deve usar para atualizar o banco de dados são os repositórios.</span><span class="sxs-lookup"><span data-stu-id="58851-119">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="58851-120">O motivo é que eles têm uma relação um-para-um com a raiz de agregação, que controla as invariáveis e a consistência transacional da agregação.</span><span class="sxs-lookup"><span data-stu-id="58851-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="58851-121">É possível consultar o banco de dados por outros canais [como ao seguir uma abordagem de CQRS (segregação de responsabilidade de comando e consulta)], porque as consultas não alteram o estado do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-121">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="58851-122">No entanto, a área transacional, ou seja, as atualizações, sempre deve ser controlada pelos repositórios e pelas raízes de agregação.</span><span class="sxs-lookup"><span data-stu-id="58851-122">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="58851-123">Basicamente, um repositório permite popular na memória dados que são provenientes do banco de dados, em forma de entidades de domínio.</span><span class="sxs-lookup"><span data-stu-id="58851-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="58851-124">Depois que as entidades estão na memória, elas podem ser alteradas e persistidas novamente no banco de dados por meio de transações.</span><span class="sxs-lookup"><span data-stu-id="58851-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="58851-125">Conforme observado anteriormente, se você estiver usando o padrão de arquitetura CQS/CQRS, as consultas inicias serão executadas por consultas à parte, fora do modelo de domínio, executadas por instruções SQL simples usando o Dapper.</span><span class="sxs-lookup"><span data-stu-id="58851-125">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="58851-126">Essa abordagem é muito mais flexível do que os repositórios porque você pode consultar e unir as tabelas necessárias, e essas consultas não são restritas pelas regras das agregações.</span><span class="sxs-lookup"><span data-stu-id="58851-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="58851-127">Esses dados irão para o aplicativo cliente ou para a camada de apresentação.</span><span class="sxs-lookup"><span data-stu-id="58851-127">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="58851-128">Se o usuário fizer alterações, os dados a serem atualizados virão da camada de apresentação ou do aplicativo cliente para a camada de aplicativo (como um serviço de API Web).</span><span class="sxs-lookup"><span data-stu-id="58851-128">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="58851-129">Ao receber um comando (com os dados) em um manipulador de comandos, você usará repositórios para obter os dados que deseja atualizar do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-129">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="58851-130">Você os atualizará na memória com as informações transmitidas com os comandos e, em seguida, adicionará ou atualizará esses dados (entidades de domínio) no banco de dados por meio de uma transação.</span><span class="sxs-lookup"><span data-stu-id="58851-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="58851-131">Lembre-se de que apenas um repositório deve ser definido para cada raiz de agregação, conforme é mostrado na Figura 9-17.</span><span class="sxs-lookup"><span data-stu-id="58851-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="58851-132">Para atingir a meta da raiz de agregação de manter a consistência transacional entre todos os objetos na agregação, você nunca deve criar um repositório para cada tabela no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="58851-133">**Figura 9-17**.</span><span class="sxs-lookup"><span data-stu-id="58851-133">**Figure 9-17**.</span></span> <span data-ttu-id="58851-134">A relação entre repositórios, agregações e tabelas de banco de dados</span><span class="sxs-lookup"><span data-stu-id="58851-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="58851-135">Impondo uma raiz de agregação por repositório</span><span class="sxs-lookup"><span data-stu-id="58851-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="58851-136">É importante implementar o design do repositório de uma forma que ele imponha a regra de que apenas as raízes de agregação devem ter repositórios.</span><span class="sxs-lookup"><span data-stu-id="58851-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="58851-137">Você pode criar um tipo de repositório genérico ou de base que restrinja o tipo de entidades com as quais trabalha para garantir que elas tenham a interface de marcador IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="58851-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="58851-138">Assim, cada classe de repositório implementada na camada de infraestrutura implementa seu próprio contrato ou interface, conforme é mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="58851-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="58851-139">Cada interface de repositório específica implementa a interface IRepository genérica:</span><span class="sxs-lookup"><span data-stu-id="58851-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="58851-140">No entanto, uma maneira melhor de fazer com que o código imponha a convenção de que cada repositório deve estar relacionado a uma única agregação seria implementar um tipo de repositório genérico para ficar explícito que você está usando um repositório destinado a uma agregação específica.</span><span class="sxs-lookup"><span data-stu-id="58851-140">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="58851-141">Isso pode ser feito facilmente com a implementação desse genérico na interface base IRepository, como no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="58851-141">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="58851-142">O padrão de repositório facilita os testes da lógica do aplicativo</span><span class="sxs-lookup"><span data-stu-id="58851-142">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="58851-143">O padrão de repositório permite testar facilmente o aplicativo com testes de unidade.</span><span class="sxs-lookup"><span data-stu-id="58851-143">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="58851-144">Lembre-se de que os testes de unidade testam apenas o código, não a infraestrutura, assim, as abstrações de repositório facilitam alcançar essa meta.</span><span class="sxs-lookup"><span data-stu-id="58851-144">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="58851-145">Como observado em uma seção anterior, é recomendável que você defina e coloque as interfaces de repositório na camada de modelo de domínio para que a camada de aplicativo (por exemplo, o microsserviço API Web) não dependa diretamente da camada de infraestrutura em que as classes de repositório reais foram implementadas.</span><span class="sxs-lookup"><span data-stu-id="58851-145">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="58851-146">Fazendo isso e usando a injeção de dependência nos controladores da API Web, você pode implementar repositórios fictícios que retornam dados falsos em vez de dados do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-146">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="58851-147">Essa abordagem de desacoplamento permite que você crie e execute testes de unidade que podem testar apenas a lógica do aplicativo sem precisar de conectividade com o banco de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-147">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="58851-148">As conexões com bancos de dados podem falhar e, principalmente, executar centenas de testes em relação a um banco de dados é prejudicial por dois motivos.</span><span class="sxs-lookup"><span data-stu-id="58851-148">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="58851-149">Primeiro, pode demorar muito devido ao grande número de testes.</span><span class="sxs-lookup"><span data-stu-id="58851-149">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="58851-150">Segundo, os registros do banco de dados podem ser alterados e afetar os resultados dos testes, deixando-os inconsistentes.</span><span class="sxs-lookup"><span data-stu-id="58851-150">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="58851-151">Testar em relação ao banco de dados não é um teste de unidade, mas sim um teste de integração.</span><span class="sxs-lookup"><span data-stu-id="58851-151">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="58851-152">É interessante ter muitos testes de unidade em execução rápida, mas menos testes de integração em relação aos bancos de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-152">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="58851-153">Em termos de separação de interesses para os testes de unidade, a lógica opera em entidades de domínio na memória.</span><span class="sxs-lookup"><span data-stu-id="58851-153">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="58851-154">Ela considera que a classe de repositório as entregou.</span><span class="sxs-lookup"><span data-stu-id="58851-154">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="58851-155">Depois que a lógica modifica as entidades de domínio, ela considera que a classe de repositório as armazenará corretamente.</span><span class="sxs-lookup"><span data-stu-id="58851-155">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="58851-156">O ponto importante aqui é criar testes de unidade em relação ao seu modelo de domínio e à sua lógica de domínio.</span><span class="sxs-lookup"><span data-stu-id="58851-156">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="58851-157">As raízes de agregação são os limites de consistência principais em DDD.</span><span class="sxs-lookup"><span data-stu-id="58851-157">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="58851-158">A diferença entre o padrão de repositório e o padrão da classe DAL (classe de acesso a dados) herdada</span><span class="sxs-lookup"><span data-stu-id="58851-158">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="58851-159">Um objeto de acesso a dados executa operações de acesso e persistência de dados diretamente no armazenamento.</span><span class="sxs-lookup"><span data-stu-id="58851-159">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="58851-160">O repositório marca os dados com as operações que você deseja executar na memória de um objeto de unidade de trabalho (como no EF ao usar o DbContext), mas essas atualizações não são realizadas imediatamente.</span><span class="sxs-lookup"><span data-stu-id="58851-160">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="58851-161">Uma unidade de trabalho é conhecida como uma única transação que envolve várias operações de inserção, atualização ou exclusão.</span><span class="sxs-lookup"><span data-stu-id="58851-161">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="58851-162">Simplificando, isso significa que, para uma ação de usuário específica (por exemplo, o registro em um site), as transações de inserção, atualização e exclusão são tratadas em uma única transação.</span><span class="sxs-lookup"><span data-stu-id="58851-162">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="58851-163">Isso é mais eficiente do que tratar várias transações de banco de dados de uma maneira mais intensa.</span><span class="sxs-lookup"><span data-stu-id="58851-163">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="58851-164">Essas várias operações de persistência serão executadas mais tarde em uma única ação quando o código da camada de aplicativo executar um comando para isso.</span><span class="sxs-lookup"><span data-stu-id="58851-164">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="58851-165">A decisão de como aplicar as alterações realizadas na memória ao armazenamento de banco de dados real geralmente se baseia no [padrão de unidade de trabalho](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="58851-165">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="58851-166">No EF, o padrão de unidade de trabalho é implementado como o DBContext.</span><span class="sxs-lookup"><span data-stu-id="58851-166">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="58851-167">Em muitos casos, esse padrão ou uma maneira de aplicar operações em relação ao armazenamento pode aumentar o desempenho do aplicativo e reduzir a possibilidade de inconsistências.</span><span class="sxs-lookup"><span data-stu-id="58851-167">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="58851-168">Além disso, ele reduz o bloqueio de transações nas tabelas do banco de dados, porque todas as operações pretendidas são confirmadas em uma única transação.</span><span class="sxs-lookup"><span data-stu-id="58851-168">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="58851-169">Isso é mais eficiente em comparação com a execução de muitas operações isoladas no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="58851-169">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="58851-170">Portanto, o ORM selecionado é capaz de otimizar a execução no banco de dados agrupando várias ações de atualização na mesma transação, em vez de executar várias transações pequenas e separadas.</span><span class="sxs-lookup"><span data-stu-id="58851-170">Therefore, the selected ORM is able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="58851-171">Os repositórios não devem ser obrigatórios</span><span class="sxs-lookup"><span data-stu-id="58851-171">Repositories should not be mandatory</span></span>

<span data-ttu-id="58851-172">Os repositórios personalizados são úteis pelos motivos já citados e essa é a abordagem para o microsserviço de pedidos no eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="58851-172">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="58851-173">No entanto, esse não é um padrão essencial a ser implementado em um design DDD (design orientado por domínio) ou até mesmo no desenvolvimento no .NET, em geral.</span><span class="sxs-lookup"><span data-stu-id="58851-173">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="58851-174">Por exemplo, Jimmy Bogard, ao fornecer comentários diretos para este guia, diz o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58851-174">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="58851-175">Esse provavelmente será meu maior comentário.</span><span class="sxs-lookup"><span data-stu-id="58851-175">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="58851-176">Eu realmente não sou fã de repositórios, principalmente porque eles ocultam detalhes importantes do mecanismo de persistência subjacente.</span><span class="sxs-lookup"><span data-stu-id="58851-176">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="58851-177">É por isso que eu também opto pelo MediatR para comandos.</span><span class="sxs-lookup"><span data-stu-id="58851-177">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="58851-178">Posso usar toda a capacidade da camada de persistência e enviar por push todo esse comportamento de domínio para minhas raízes de agregação.</span><span class="sxs-lookup"><span data-stu-id="58851-178">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="58851-179">Geralmente, eu não gosto de usar repositórios fictícios, ou seja, eu ainda preciso aplicar esse teste de integração na situação real.</span><span class="sxs-lookup"><span data-stu-id="58851-179">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="58851-180">Optar por CQRS significa que realmente não precisamos mais de repositórios.</span><span class="sxs-lookup"><span data-stu-id="58851-180">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="58851-181">Achamos os repositórios úteis, mas sabemos que eles não são tão críticos para o DDD quanto o padrão de agregação e o modelo de domínio avançado.</span><span class="sxs-lookup"><span data-stu-id="58851-181">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="58851-182">Portanto, use o padrão de repositório ou não, conforme achar mais adequado.</span><span class="sxs-lookup"><span data-stu-id="58851-182">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="58851-183">O padrão de especificação</span><span class="sxs-lookup"><span data-stu-id="58851-183">The Specification pattern</span></span>

<span data-ttu-id="58851-184">O padrão de especificação (o nome completo é padrão de especificação de consulta) é um padrão de design orientado por domínio projetado para ser o local em que você pode colocar a definição de uma consulta com uma lógica opcional de classificação e paginação.</span><span class="sxs-lookup"><span data-stu-id="58851-184">The Specification pattern (its full name would be Query-specification pattern) is a Domain-Driven Design pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="58851-185">O padrão de especificação define uma consulta em um objeto.</span><span class="sxs-lookup"><span data-stu-id="58851-185">The Specification pattern defines a query in an object.</span></span> <span data-ttu-id="58851-186">Por exemplo, para encapsular uma consulta paginada que procura por alguns produtos, você poderia criar uma especificação PagedProduct que usasse os parâmetros de entrada necessários (pageNumber, pageSize, filtro, etc.).</span><span class="sxs-lookup"><span data-stu-id="58851-186">For example, in order to encapsulate a paged query that searches for some products, you can create a PagedProduct specification that takes the necessary input parameters (pageNumber, pageSize, filter, etc.).</span></span> <span data-ttu-id="58851-187">Então, qualquer método de repositório [geralmente uma sobrecarga List()] aceitaria uma ISpecification e executaria a consulta esperada com base nessa especificação.</span><span class="sxs-lookup"><span data-stu-id="58851-187">Then, within any Repository method (usually a List() overload) it would accept an ISpecification and run the expected query based on that specification.</span></span>

<span data-ttu-id="58851-188">Essa abordagem oferece vários benefícios:</span><span class="sxs-lookup"><span data-stu-id="58851-188">There are several benefits to this approach:</span></span>

* <span data-ttu-id="58851-189">A especificação tem um nome (em vez de apenas um conjunto de expressões LINQ) sobre o qual é possível discutir.</span><span class="sxs-lookup"><span data-stu-id="58851-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

* <span data-ttu-id="58851-190">A especificação pode receber um teste de unidade em isolamento para garantir que ela seja adequada.</span><span class="sxs-lookup"><span data-stu-id="58851-190">The specification can be unit tested in isolation to ensure it is right.</span></span> <span data-ttu-id="58851-191">Ela também poderá ser reutilizada facilmente se você precisar de um comportamento semelhante.</span><span class="sxs-lookup"><span data-stu-id="58851-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="58851-192">Por exemplo, em uma ação de exibição de MVC e em uma ação de API Web, bem como em vários serviços.</span><span class="sxs-lookup"><span data-stu-id="58851-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

* <span data-ttu-id="58851-193">Uma especificação também pode ser usada para descrever a forma dos dados a serem retornados, para que as consultas possam retornar apenas os dados necessários.</span><span class="sxs-lookup"><span data-stu-id="58851-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="58851-194">Isso elimina a necessidade de carregamento lento em aplicativos Web (que geralmente não é uma boa ideia) e ajuda a eliminar a complexidade de detalhamento das implementações do repositório.</span><span class="sxs-lookup"><span data-stu-id="58851-194">This eliminates the need for lazy loading in web applications (which is usually not a good idea) and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="58851-195">Um exemplo de uma interface de especificação genérica é o código a seguir de [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span><span class="sxs-lookup"><span data-stu-id="58851-195">An example of a generic Specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="58851-196">Nas próximas seções, é explicado como implementar o padrão de especificação com o Entity Framework Core 2.0 e como usá-lo de qualquer classe de repositório.</span><span class="sxs-lookup"><span data-stu-id="58851-196">In the upcoming sections, it is explained how to implement the Specification pattern with Entity Framework Core 2.0 and how to use it from any Repository class.</span></span>

<span data-ttu-id="58851-197">**Observação importante:** o padrão de especificação é um padrão antigo que pode ser implementado de várias maneiras diferentes, como nos seguintes recursos adicionais.</span><span class="sxs-lookup"><span data-stu-id="58851-197">**Important note:** The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="58851-198">Como uma padrão/ideia, é bom conhecer as abordagens mais antigas, mas lembre-se de que as implementações mais antigas não usufruem dos recursos de linguagem modernos, como LINQ e expressões.</span><span class="sxs-lookup"><span data-stu-id="58851-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="58851-199">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="58851-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="58851-200">O padrão de repositório</span><span class="sxs-lookup"><span data-stu-id="58851-200">The Repository pattern</span></span>

-   <span data-ttu-id="58851-201">**Edward Hieatt e Rob Mee. Padrão de Repositório**
    [*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="58851-201">**Edward Hieatt and Rob Mee. Repository pattern.**
[*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="58851-202">**O Padrão de Repositório**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="58851-202">**The Repository pattern**
[*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="58851-203">**Padrão de Repositório: uma abstração da persistência de dados**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="58851-203">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="58851-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software (Design orientado por domínio: lidando com a complexidade no núcleo do software).**</span><span class="sxs-lookup"><span data-stu-id="58851-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="58851-205">(Livro; inclui uma discussão sobre o padrão de Repositório) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="58851-205">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="58851-206">Padrão de unidade de trabalho</span><span class="sxs-lookup"><span data-stu-id="58851-206">Unit of Work pattern</span></span>

-   <span data-ttu-id="58851-207">**Martin Fowler. Padrão de Unidade de Trabalho.**
    [*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="58851-207">**Martin Fowler. Unit of Work pattern.**
[*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="58851-208">**Implementando os padrões de repositório e de unidade de trabalho em um aplicativo ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="58851-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="58851-209">O padrão de especificação</span><span class="sxs-lookup"><span data-stu-id="58851-209">The Specification pattern</span></span>

-   <span data-ttu-id="58851-210">**O Padrão de Especificação.**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="58851-210">**The Specification pattern.**
[*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span></span>

-   <span data-ttu-id="58851-211">**Evans, Eric (2004). Domain Driven Design (Design orientado por domínio). Addison-Wesley. pág. 224.**</span><span class="sxs-lookup"><span data-stu-id="58851-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

-   <span data-ttu-id="58851-212">**Especificações. Martin Fowler**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="58851-212">**Specifications. Martin Fowler**
[*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="58851-213">[Anterior](domain-events-design-implementation.md)
[Próximo](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="58851-213">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
