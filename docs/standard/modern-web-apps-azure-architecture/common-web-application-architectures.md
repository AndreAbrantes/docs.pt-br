---
title: Arquiteturas comuns de aplicativo Web
description: Projetar aplicativos Web modernos com o ASP.NET Core e o Microsoft Azure | arquiteturas comuns de aplicativo Web
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.openlocfilehash: 943163ca4c82ad75f177ebe73559d909e7292c52
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33592490"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="0a50e-103">Arquiteturas comuns de aplicativo Web</span><span class="sxs-lookup"><span data-stu-id="0a50e-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="0a50e-104">"Se você acha que uma boa arquitetura é cara, tente usar uma arquitetura ruim."</span><span class="sxs-lookup"><span data-stu-id="0a50e-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="0a50e-105">_- Brian Foote e Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="0a50e-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="0a50e-106">Resumo</span><span class="sxs-lookup"><span data-stu-id="0a50e-106">Summary</span></span>

<span data-ttu-id="0a50e-107">A maioria dos aplicativos .NET tradicionais é implantada como unidades individuais correspondentes a um executável ou a um único aplicativo Web em execução em um único AppDomain do IIS.</span><span class="sxs-lookup"><span data-stu-id="0a50e-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="0a50e-108">Esse é o modelo de implantação mais simples e atende muito bem a diversos aplicativos internos e públicos menores.</span><span class="sxs-lookup"><span data-stu-id="0a50e-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="0a50e-109">No entanto, mesmo considerando essa única unidade de implantação, a maioria dos aplicativos de negócios não triviais se beneficia de uma separação lógica em várias camadas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="0a50e-110">O que é um aplicativo monolítico?</span><span class="sxs-lookup"><span data-stu-id="0a50e-110">What is a monolithic application?</span></span>

<span data-ttu-id="0a50e-111">Um aplicativo monolítico é aquele que é totalmente autossuficiente, em termos de comportamento.</span><span class="sxs-lookup"><span data-stu-id="0a50e-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="0a50e-112">Ele pode interagir com outros serviços ou armazenamentos de dados durante a execução de suas operações, mas o núcleo de seu comportamento é executado em seu próprio processo e o aplicativo inteiro normalmente é implantado como uma única unidade.</span><span class="sxs-lookup"><span data-stu-id="0a50e-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="0a50e-113">Se um aplicativo desse tipo precisar ser dimensionado horizontalmente, em geral, o aplicativo inteiro será duplicado em vários servidores ou máquinas virtuais.</span><span class="sxs-lookup"><span data-stu-id="0a50e-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="0a50e-114">Aplicativos todos-em-um</span><span class="sxs-lookup"><span data-stu-id="0a50e-114">All-in-One applications</span></span>

<span data-ttu-id="0a50e-115">O menor número possível de projetos para uma arquitetura de aplicativo é um.</span><span class="sxs-lookup"><span data-stu-id="0a50e-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="0a50e-116">Nessa arquitetura, toda a lógica do aplicativo está contida em um único projeto, compilada em um único assembly e implantada como uma única unidade.</span><span class="sxs-lookup"><span data-stu-id="0a50e-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="0a50e-117">Um novo projeto ASP.NET Core, seja ele criado no Visual Studio ou por meio da linha de comando, começa como um simples monólito "todos-em-um".</span><span class="sxs-lookup"><span data-stu-id="0a50e-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="0a50e-118">Ele contém todo o comportamento do aplicativo, incluindo a lógica de apresentação, de negócios e de acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="0a50e-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="0a50e-119">A Figura 5-1 mostra a estrutura de arquivos de um aplicativo de projeto único.</span><span class="sxs-lookup"><span data-stu-id="0a50e-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="0a50e-120">**Figura 5-1.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-120">**Figure 5-1.**</span></span> <span data-ttu-id="0a50e-121">Um aplicativo ASP.NET Core de projeto único</span><span class="sxs-lookup"><span data-stu-id="0a50e-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="0a50e-122">Em um cenário de projeto único, a separação de interesses é obtida com o uso de pastas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="0a50e-123">O modelo padrão inclui pastas separadas para as responsabilidades do padrão MVC de Modelos, Exibições e Controladores, bem como pastas adicionais para Dados e Serviços.</span><span class="sxs-lookup"><span data-stu-id="0a50e-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="0a50e-124">Nessa disposição, os detalhes de apresentação devem ser limitados tanto quanto possível à pasta Views e os detalhes de implementação de acesso a dados devem ser limitados às classes mantidas na pasta Data.</span><span class="sxs-lookup"><span data-stu-id="0a50e-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="0a50e-125">A lógica de negócios deve residir nos serviços e nas classes dentro da pasta Models.</span><span class="sxs-lookup"><span data-stu-id="0a50e-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="0a50e-126">Embora simples, a solução monolítica de projeto único traz algumas desvantagens.</span><span class="sxs-lookup"><span data-stu-id="0a50e-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="0a50e-127">À medida que o tamanho e a complexidade do projeto aumentam, o número de arquivos e pastas continuará crescendo também.</span><span class="sxs-lookup"><span data-stu-id="0a50e-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="0a50e-128">Os interesses de interface do usuário (modelos, exibições, controladores) residem em várias pastas, que não são agrupadas em ordem alfabética.</span><span class="sxs-lookup"><span data-stu-id="0a50e-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="0a50e-129">Esse problema só fica pior quando constructos adicionais no nível da interface do usuário, como Filters ou ModelBinders, são adicionados em suas próprias pastas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="0a50e-130">A lógica de negócios é distribuída entre as pastas Models e Services e não há nenhuma indicação clara de quais classes em quais pastas devem depender de qual delas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="0a50e-131">Essa falta de organização no nível do projeto costuma levar ao [código espaguete](http://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="0a50e-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="0a50e-132">Para resolver esses problemas, os aplicativos geralmente evoluem para soluções de vários projetos, em que cada projeto é considerado um residente de determinada *camada* do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="0a50e-133">O que são camadas?</span><span class="sxs-lookup"><span data-stu-id="0a50e-133">What are layers?</span></span>

<span data-ttu-id="0a50e-134">Conforme os aplicativos aumentam em complexidade, uma maneira de gerenciar essa complexidade é dividir o aplicativo de acordo com suas responsabilidades ou interesses.</span><span class="sxs-lookup"><span data-stu-id="0a50e-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="0a50e-135">Isso segue a separação do princípio de interesses e pode ajudar a manter organizada uma base de código em expansão, de modo que os desenvolvedores possam encontrar com facilidade o local em que determinada funcionalidade foi implementada.</span><span class="sxs-lookup"><span data-stu-id="0a50e-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="0a50e-136">Apesar disso, a arquitetura em camadas oferece inúmeras vantagens, além de apenas a organização do código.</span><span class="sxs-lookup"><span data-stu-id="0a50e-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="0a50e-137">Com a organização do código em camadas, a funcionalidade comum de baixo nível pode ser reutilizada em todo o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="0a50e-138">Essa reutilização é útil porque isso significa que menos código precisa ser escrito e porque ela pode permitir que o aplicativo seja padronizado em uma única implementação, seguindo o princípio DRY.</span><span class="sxs-lookup"><span data-stu-id="0a50e-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="0a50e-139">Com uma arquitetura em camadas, os aplicativos podem impor restrições sobre quais camadas podem se comunicar com outras camadas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="0a50e-140">Isso ajuda na obtenção do encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="0a50e-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="0a50e-141">Quando uma camada é alterada ou substituída, somente as camadas que trabalham com ela devem ser afetadas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="0a50e-142">Ao limitar quais camadas dependem de outras camadas, o impacto das alterações pode ser reduzido, de modo que uma única alteração não afete todo o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="0a50e-143">As camadas (e o encapsulamento) facilitam grande parte da substituição da funcionalidade dentro do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="0a50e-144">Por exemplo, um aplicativo inicialmente pode usar seu próprio banco de dados do SQL Server para persistência, mas, posteriormente, pode optar por usar uma estratégia de persistência baseada em nuvem ou uma protegida por uma API Web.</span><span class="sxs-lookup"><span data-stu-id="0a50e-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="0a50e-145">Se o aplicativo encapsulou corretamente sua implementação de persistência em uma camada lógica, essa camada específica do SQL Server pode ser substituída por uma nova que implementa a mesma interface pública.</span><span class="sxs-lookup"><span data-stu-id="0a50e-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="0a50e-146">Além do potencial de alternância de implementações em resposta a alterações futuras nos requisitos, as camadas de aplicativo também podem facilitar a alternância de implementações para fins de teste.</span><span class="sxs-lookup"><span data-stu-id="0a50e-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="0a50e-147">Em vez da necessidade de gravar testes que operam na camada de dados reais ou na camada de interface do usuário do aplicativo, essas camadas podem ser substituídas em tempo de teste com implementações fictícias que fornecem respostas conhecidas a solicitações.</span><span class="sxs-lookup"><span data-stu-id="0a50e-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="0a50e-148">Isso geralmente facilita e agiliza muito a gravação e a execução de testes quando comparado à execução de testes novamente na infraestrutura real do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="0a50e-149">A disposição em camadas lógicas é uma técnica comum para melhorar a organização do código em aplicativos de software empresariais, e há várias maneiras pelas quais o código pode ser organizado em camadas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="0a50e-150">As *camadas* representam uma separação lógica dentro do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="0a50e-151">Caso a lógica do aplicativo seja fisicamente distribuída em servidores ou processos separados, esses destinos de implantação física separados são chamados de *camadas*.</span><span class="sxs-lookup"><span data-stu-id="0a50e-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="0a50e-152">É possível, e bastante comum, ter um aplicativo de N-Camadas que é implantado em uma única camada.</span><span class="sxs-lookup"><span data-stu-id="0a50e-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="0a50e-153">Aplicativos tradicionais da arquitetura de "N Camadas"</span><span class="sxs-lookup"><span data-stu-id="0a50e-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="0a50e-154">A organização mais comum da lógica do aplicativo em camadas é mostrada na Figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="0a50e-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="0a50e-155">**Figura 5-2.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-155">**Figure 5-2.**</span></span> <span data-ttu-id="0a50e-156">Camadas de aplicativo típicas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="0a50e-157">Essas camadas são frequentemente abreviadas como interface do usuário, BLL (Camada de Lógica de Negócios) e DAL (Camada de Acesso a Dados).</span><span class="sxs-lookup"><span data-stu-id="0a50e-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="0a50e-158">Usando essa arquitetura, os usuários fazem solicitações por meio da camada de interface do usuário, que interage com a BLL.</span><span class="sxs-lookup"><span data-stu-id="0a50e-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="0a50e-159">A BLL, por sua vez, pode chamar a DAL para solicitações de acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="0a50e-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="0a50e-160">A camada de interface do usuário não deve fazer solicitações à DAL diretamente nem deve interagir com persistência diretamente por outros meios.</span><span class="sxs-lookup"><span data-stu-id="0a50e-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="0a50e-161">Da mesma forma, a BLL só deve interagir com persistência por meio da DAL.</span><span class="sxs-lookup"><span data-stu-id="0a50e-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="0a50e-162">Assim, cada camada tem sua própria responsabilidade conhecida.</span><span class="sxs-lookup"><span data-stu-id="0a50e-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="0a50e-163">Uma desvantagem dessa abordagem tradicional de disposição em camadas é que as dependências em tempo de compilação são executadas de cima para baixo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="0a50e-164">Ou seja, a camada de interface do usuário depende da BLL, que depende da DAL.</span><span class="sxs-lookup"><span data-stu-id="0a50e-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="0a50e-165">Isso significa que a BLL, que normalmente contém a lógica mais importante no aplicativo, depende dos detalhes de implementação de acesso a dados (e geralmente da existência de um banco de dados).</span><span class="sxs-lookup"><span data-stu-id="0a50e-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="0a50e-166">O teste da lógica de negócios em uma arquitetura como essa costuma ser difícil, exigindo um banco de dados de teste.</span><span class="sxs-lookup"><span data-stu-id="0a50e-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="0a50e-167">O princípio da inversão de dependência pode ser usado para resolver esse problema, como você verá na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="0a50e-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="0a50e-168">A Figura 5-3 mostra uma solução de exemplo, que divide o aplicativo em três projetos por responsabilidade (ou camada).</span><span class="sxs-lookup"><span data-stu-id="0a50e-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="0a50e-169">**Figura 5-3.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-169">**Figure 5-3.**</span></span> <span data-ttu-id="0a50e-170">Um aplicativo monolítico simples com três projetos.</span><span class="sxs-lookup"><span data-stu-id="0a50e-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="0a50e-171">Embora esse aplicativo use vários projetos para fins de organização, ele ainda é implantado como uma única unidade e seus clientes interagirão com ele como um único aplicativo Web.</span><span class="sxs-lookup"><span data-stu-id="0a50e-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="0a50e-172">Isso possibilita um processo de implantação muito simples.</span><span class="sxs-lookup"><span data-stu-id="0a50e-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="0a50e-173">A Figura 5-4 mostra como um aplicativo desse tipo pode ser hospedado por meio do Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="0a50e-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="0a50e-174">**Figura 5-4.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-174">**Figure 5-4.**</span></span> <span data-ttu-id="0a50e-175">Implantação simples do Aplicativo Web do Azure</span><span class="sxs-lookup"><span data-stu-id="0a50e-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="0a50e-176">Conforme o aplicativo precisar ser aumentado, soluções de implantação mais robustas e complexas poderão ser necessárias.</span><span class="sxs-lookup"><span data-stu-id="0a50e-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="0a50e-177">A Figura 5-5 mostra um exemplo de um plano de implantação mais complexo compatível com funcionalidades adicionais.</span><span class="sxs-lookup"><span data-stu-id="0a50e-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="0a50e-178">**Figura 5-5.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-178">**Figure 5-5.**</span></span> <span data-ttu-id="0a50e-179">Implantando um aplicativo Web em um Serviço de Aplicativo do Azure</span><span class="sxs-lookup"><span data-stu-id="0a50e-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="0a50e-180">Internamente, a organização desse projeto em vários projetos com base na responsabilidade melhora a facilidade de manutenção do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="0a50e-181">Essa unidade pode ser escalada verticalmente ou expandida para aproveitar a escalabilidade sob demanda baseada em nuvem.</span><span class="sxs-lookup"><span data-stu-id="0a50e-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="0a50e-182">Escalar verticalmente significa adicionar mais CPU, memória, espaço em disco ou outros recursos aos servidores que hospedam o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="0a50e-183">Escalar horizontalmente significa adicionar mais instâncias desses servidores, sejam servidores físicos, sejam máquinas virtuais.</span><span class="sxs-lookup"><span data-stu-id="0a50e-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="0a50e-184">Quando o aplicativo é hospedado em várias instâncias, um balanceador de carga é usado para atribuir solicitações a instâncias individuais do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="0a50e-185">A abordagem mais simples para dimensionar um aplicativo Web no Azure é configurar o dimensionamento manualmente no Plano do Serviço de Aplicativo do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="0a50e-186">A Figura 5-6 mostra a tela apropriada do painel do Azure para configurar a quantidade de instâncias que atendem um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="0a50e-187">**Figura 5-6.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-187">**Figure 5-6.**</span></span> <span data-ttu-id="0a50e-188">Dimensionamento do Plano do Serviço de Aplicativo no Azure.</span><span class="sxs-lookup"><span data-stu-id="0a50e-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="0a50e-189">Arquitetura limpa</span><span class="sxs-lookup"><span data-stu-id="0a50e-189">Clean architecture</span></span>

<span data-ttu-id="0a50e-190">Os aplicativos que seguem o Princípio da Inversão de Dependência, bem como os princípios de DDD (Design Controlado por Domínio), tendem a chegar a uma arquitetura semelhante.</span><span class="sxs-lookup"><span data-stu-id="0a50e-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="0a50e-191">Essa arquitetura foi conhecida por muitos nomes ao longo dos anos.</span><span class="sxs-lookup"><span data-stu-id="0a50e-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="0a50e-192">Um dos primeiros nomes foi Arquitetura Hexagonal, seguido por Portas e Adaptadores.</span><span class="sxs-lookup"><span data-stu-id="0a50e-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="0a50e-193">Mais recentemente, ela é citada como a [Arquitetura Cebola](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) ou [Arquitetura Limpa](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="0a50e-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="0a50e-194">É esse último nome, Arquitetura Limpa, que é usado como base para descrever a arquitetura neste livro eletrônico.</span><span class="sxs-lookup"><span data-stu-id="0a50e-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="0a50e-195">O termo Arquitetura Limpa pode ser aplicado a aplicativos criados com os Princípios de DDD, bem como os que não são criados com o DDD.</span><span class="sxs-lookup"><span data-stu-id="0a50e-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="0a50e-196">No caso anterior, essa combinação pode ser chamada de "Arquitetura de DDD Limpa".</span><span class="sxs-lookup"><span data-stu-id="0a50e-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="0a50e-197">A arquitetura limpa coloca a lógica de negócios e o modelo de aplicativo no centro do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="0a50e-198">Em vez de fazer com que a lógica de negócios dependa do acesso a dados ou de outros interesses da infraestrutura, essa dependência é invertida: os detalhes de implementação e a infraestrutura dependem do Núcleo do Aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="0a50e-199">Isso é feito pela definição de abstrações, ou interfaces, no Núcleo do Aplicativo, que, em seguida, são implementadas por tipos definidos na camada de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="0a50e-200">Uma maneira comum de visualizar essa arquitetura é usar uma série de círculos concêntricos, semelhantes a uma cebola.</span><span class="sxs-lookup"><span data-stu-id="0a50e-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="0a50e-201">A Figura 5-X mostra um exemplo desse estilo de representação de arquitetura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="0a50e-202">**Figura 5-7.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-202">**Figure 5-7.**</span></span> <span data-ttu-id="0a50e-203">Arquitetura Limpa; exibição de cebola</span><span class="sxs-lookup"><span data-stu-id="0a50e-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="0a50e-204">Nesse diagrama, as dependências fluem para o círculo interno.</span><span class="sxs-lookup"><span data-stu-id="0a50e-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="0a50e-205">Assim, você pode ver que o Núcleo do Aplicativo (que ganha seu nome devido à posição no núcleo desse diagrama) não tem dependências de outras camadas de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="0a50e-206">Bem no centro estão as entidades e as interfaces do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="0a50e-207">Fora dele, mas ainda no Núcleo do Aplicativo, estão os serviços de domínio, que normalmente implementam interfaces definidas no círculo interno.</span><span class="sxs-lookup"><span data-stu-id="0a50e-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="0a50e-208">Fora do Núcleo do Aplicativo, as camadas de Interface do Usuário e de Infraestrutura dependem do Núcleo do Aplicativo, mas não (necessariamente) entre si.</span><span class="sxs-lookup"><span data-stu-id="0a50e-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="0a50e-209">A Figura 5-X mostra um diagrama de camada horizontal mais tradicional que reflete melhor a dependência entre a interface do usuário e outras camadas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="0a50e-210">**Figura 5-8.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-210">**Figure 5-8.**</span></span> <span data-ttu-id="0a50e-211">Arquitetura Limpa; exibição de camada horizontal</span><span class="sxs-lookup"><span data-stu-id="0a50e-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="0a50e-212">Observe que as setas sólidas representam as dependências em tempo de compilação, enquanto a seta tracejada representa uma dependência somente em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="0a50e-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="0a50e-213">Usando a arquitetura limpa, a camada de interface do usuário funciona com as interfaces definidas no Núcleo do Aplicativo em tempo de compilação. O ideal é que ela não tenha conhecimento dos tipos de implementação definidos na camada de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="0a50e-214">No entanto, em tempo de execução, esses tipos de implementação serão necessários para a execução do aplicativo e, portanto, precisarão estar presentes e conectados às interfaces do Núcleo do Aplicativo por meio da injeção de dependência.</span><span class="sxs-lookup"><span data-stu-id="0a50e-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="0a50e-215">A Figura 5-9 mostra uma exibição mais detalhada da arquitetura de um aplicativo ASP.NET Core quando criado seguindo essas recomendações.</span><span class="sxs-lookup"><span data-stu-id="0a50e-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Arquitetura do ASP.NET Core](./media/image5-9.png)

<span data-ttu-id="0a50e-217">**Figura 5-9.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-217">**Figure 5-9.**</span></span> <span data-ttu-id="0a50e-218">Diagrama da arquitetura do ASP.NET Core que segue a Arquitetura Limpa.</span><span class="sxs-lookup"><span data-stu-id="0a50e-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="0a50e-219">Como o Núcleo do Aplicativo não depende da Infraestrutura, é muito fácil gravar testes de unidade automatizados para essa camada.</span><span class="sxs-lookup"><span data-stu-id="0a50e-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="0a50e-220">A Figuras 5-10 e 5-11 mostram como os testes se enquadram nessa arquitetura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="0a50e-222">**Figura 5-10.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-222">**Figure 5-10.**</span></span> <span data-ttu-id="0a50e-223">Realizando o teste de unidade do Núcleo do Aplicativo em isolamento.</span><span class="sxs-lookup"><span data-stu-id="0a50e-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="0a50e-225">**Figura 5-11.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-225">**Figure 5-11.**</span></span> <span data-ttu-id="0a50e-226">Realizando o teste de integração de implementações de Infraestrutura com dependências externas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="0a50e-227">Como a camada de interface do usuário não tem nenhuma dependência direta dos tipos definidos no projeto de Infraestrutura, da mesma forma, é muito fácil alternar entre implementações, a fim de facilitar o teste ou em resposta a alterações nos requisitos do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="0a50e-228">O uso interno do ASP.NET Core e o suporte à injeção de dependência torna essa arquitetura a maneira mais apropriada de estruturar aplicativos monolíticos não triviais.</span><span class="sxs-lookup"><span data-stu-id="0a50e-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="0a50e-229">Em aplicativos monolíticos, os projetos de Núcleo do Aplicativo, Infraestrutura e Interface do Usuário são todos executados como um único aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="0a50e-230">A arquitetura do aplicativo em tempo de execução pode ser semelhante à Figura 5-12.</span><span class="sxs-lookup"><span data-stu-id="0a50e-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![Arquitetura do ASP.NET Core 2](./media/image5-12.png)

<span data-ttu-id="0a50e-232">**Figura 5-12.**</span><span class="sxs-lookup"><span data-stu-id="0a50e-232">**Figure 5-12.**</span></span> <span data-ttu-id="0a50e-233">Arquitetura em tempo de execução de um aplicativo ASP.NET Core de exemplo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="0a50e-234">Organizando o código na Arquitetura Limpa</span><span class="sxs-lookup"><span data-stu-id="0a50e-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="0a50e-235">Em uma solução de Arquitetura Limpa, cada projeto tem responsabilidades bem-definidas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="0a50e-236">Dessa forma, alguns tipos pertencerão a cada projeto e, com frequência, você encontrará pastas correspondentes a esses tipos no projeto apropriado.</span><span class="sxs-lookup"><span data-stu-id="0a50e-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="0a50e-237">O Núcleo do Aplicativo contém o modelo de negócios, que inclui entidades, serviços e interfaces.</span><span class="sxs-lookup"><span data-stu-id="0a50e-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="0a50e-238">Essas interfaces incluem abstrações para operações que serão executadas por meio da Infraestrutura, como acesso a dados, acesso ao sistema de arquivos, chamadas de rede, etc. Às vezes, as interfaces ou os serviços definidos nessa camada precisarão trabalhar com tipos que não são de entidade que não têm dependências na interface do usuário ou na Infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="0a50e-239">Eles podem ser definidos como DTOs (Objetos de Transferência de Dados) simples.</span><span class="sxs-lookup"><span data-stu-id="0a50e-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="0a50e-240">Tipos de Núcleo do Aplicativo</span><span class="sxs-lookup"><span data-stu-id="0a50e-240">Application Core Types</span></span>
> -   <span data-ttu-id="0a50e-241">Entidades (classes de modelo de negócios que são persistidas)</span><span class="sxs-lookup"><span data-stu-id="0a50e-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="0a50e-242">Interfaces</span><span class="sxs-lookup"><span data-stu-id="0a50e-242">Interfaces</span></span>
> -   <span data-ttu-id="0a50e-243">Serviços</span><span class="sxs-lookup"><span data-stu-id="0a50e-243">Services</span></span>
> -   <span data-ttu-id="0a50e-244">DTOs</span><span class="sxs-lookup"><span data-stu-id="0a50e-244">DTOs</span></span>

<span data-ttu-id="0a50e-245">O projeto de Infraestrutura normalmente incluirá implementações de acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="0a50e-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="0a50e-246">Em um aplicativo Web ASP.NET Core típico, isso incluirá o DbContext do Entity Framework, as Migrações do EF Core que foram definidas e as classes de implementação de acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="0a50e-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="0a50e-247">A maneira mais comum de abstrair o código de implementação de acesso a dados é pelo uso do [padrão de design de Repositório](http://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="0a50e-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="0a50e-248">Além das implementações de acesso a dados, o projeto de Infraestrutura deve conter implementações de serviços que devem interagir com os interesses de infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="0a50e-249">Esses serviços devem implementar as interfaces definidas no Núcleo do Aplicativo e, portanto, a Infraestrutura deve ter uma referência ao projeto de Núcleo do Aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="0a50e-250">Tipos de infraestrutura</span><span class="sxs-lookup"><span data-stu-id="0a50e-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="0a50e-251">Tipos do EF Core (DbContext, Migrações)</span><span class="sxs-lookup"><span data-stu-id="0a50e-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="0a50e-252">Tipos de implementação de acesso a dados (Repositórios)</span><span class="sxs-lookup"><span data-stu-id="0a50e-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="0a50e-253">Serviços específicos a uma infraestrutura (FileLogger, SmtpNotifier, etc.)</span><span class="sxs-lookup"><span data-stu-id="0a50e-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="0a50e-254">A camada de interface do usuário em um aplicativo ASP.NET Core MVC será o ponto de entrada para o aplicativo e será um projeto ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="0a50e-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="0a50e-255">Esse projeto deve referenciar o projeto de Núcleo do Aplicativo e seus tipos devem interagir com a infraestrutura estritamente por meio das interfaces definidas no Núcleo do Aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="0a50e-256">Nenhuma criação de instância direta de tipos de camada de infraestrutura (ou chamadas estáticas a esses tipos) deve ser permitida na camada de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="0a50e-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="0a50e-257">Tipos de camada de interface do usuário</span><span class="sxs-lookup"><span data-stu-id="0a50e-257">UI Layer Types</span></span>
> -   <span data-ttu-id="0a50e-258">Controladores</span><span class="sxs-lookup"><span data-stu-id="0a50e-258">Controllers</span></span>
> -   <span data-ttu-id="0a50e-259">Filtros</span><span class="sxs-lookup"><span data-stu-id="0a50e-259">Filters</span></span>
> -   <span data-ttu-id="0a50e-260">Exibições</span><span class="sxs-lookup"><span data-stu-id="0a50e-260">Views</span></span>
> -   <span data-ttu-id="0a50e-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="0a50e-261">ViewModels</span></span>
> -   <span data-ttu-id="0a50e-262">Inicialização</span><span class="sxs-lookup"><span data-stu-id="0a50e-262">Startup</span></span>

<span data-ttu-id="0a50e-263">A classe Startup é responsável por configurar o aplicativo e conectar os tipos de implementação às interfaces, permitindo que a injeção de dependência funcione corretamente em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="0a50e-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="0a50e-264">Para conectar a injeção de dependência em ConfigureServices no arquivo Startup.cs do projeto de interface do usuário, o projeto poderá precisar referenciar o projeto de Infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="0a50e-265">Essa dependência pode ser eliminada com mais facilidade por meio de um contêiner de DI personalizado.</span><span class="sxs-lookup"><span data-stu-id="0a50e-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="0a50e-266">Para as finalidades desta amostra, a abordagem mais simples é permitir que o projeto de interface do usuário referencie o projeto de Infraestrutura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="0a50e-267">Contêineres e aplicativos monolíticos</span><span class="sxs-lookup"><span data-stu-id="0a50e-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="0a50e-268">Você pode criar um Aplicativo ou Serviço Web baseado em uma implantação única e monolítica e implantá-lo como um contêiner.</span><span class="sxs-lookup"><span data-stu-id="0a50e-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="0a50e-269">Dentro do aplicativo, ele pode não ser monolítico, mas organizados em várias bibliotecas, componentes ou camadas.</span><span class="sxs-lookup"><span data-stu-id="0a50e-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="0a50e-270">Externamente, ele é um único contêiner, como um único processo, um único aplicativo Web ou um único serviço.</span><span class="sxs-lookup"><span data-stu-id="0a50e-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="0a50e-271">Para gerenciar esse modelo, implante um contêiner único para representar o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="0a50e-272">Para dimensionar, basta adicionar mais cópias com um balanceador de carga na frente.</span><span class="sxs-lookup"><span data-stu-id="0a50e-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="0a50e-273">A simplicidade está em gerenciar um a implantação única em um contêiner ou VM único.</span><span class="sxs-lookup"><span data-stu-id="0a50e-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="0a50e-274">É possível incluir vários componentes/bibliotecas ou camadas internas em cada contêiner, conforme ilustrado na Figura 5-X.</span><span class="sxs-lookup"><span data-stu-id="0a50e-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="0a50e-275">Mas, seguindo o princípio de contêiner de *"um contêiner executa uma ação e faz isso em um processo*", o padrão monolítico pode gerar um conflito.</span><span class="sxs-lookup"><span data-stu-id="0a50e-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="0a50e-276">O ponto negativo dessa abordagem ficará evidente se ou quando o aplicativo crescer e for necessário dimensioná-lo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="0a50e-277">Se o aplicativo inteiro for dimensionado, isso não será realmente um problema.</span><span class="sxs-lookup"><span data-stu-id="0a50e-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="0a50e-278">Entretanto, na maioria dos casos, apenas algumas partes do aplicativo são os pontos de redução que exigem dimensionamento, enquanto outros componentes são menos utilizados.</span><span class="sxs-lookup"><span data-stu-id="0a50e-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="0a50e-279">Usando o exemplo de comércio eletrônico típico: o que você provavelmente precisa dimensionar é o componente de informações do produto.</span><span class="sxs-lookup"><span data-stu-id="0a50e-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="0a50e-280">Uma quantidade muito maior de clientes procura produtos em vez de comprá-los.</span><span class="sxs-lookup"><span data-stu-id="0a50e-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="0a50e-281">Mais clientes usam o carrinho em vez do pipeline de pagamento.</span><span class="sxs-lookup"><span data-stu-id="0a50e-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="0a50e-282">Menos clientes fazem comentários ou exibem o histórico de compras.</span><span class="sxs-lookup"><span data-stu-id="0a50e-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="0a50e-283">E você provavelmente tem apenas um grupo de funcionários, em uma única região, que precisa gerenciar o conteúdo e as campanhas de marketing.</span><span class="sxs-lookup"><span data-stu-id="0a50e-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="0a50e-284">Ao dimensionar o design monolítico, todo o código é implantado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0a50e-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="0a50e-285">Além do problema do dimensionamento de tudo, a alteração de um único componente exige um novo teste completo de todo o aplicativo e uma reimplantação completa de todas as instâncias.</span><span class="sxs-lookup"><span data-stu-id="0a50e-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="0a50e-286">A abordagem monolítica é comum e muitas organizações estão desenvolvendo aplicativos com essa abordagem de arquitetura.</span><span class="sxs-lookup"><span data-stu-id="0a50e-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="0a50e-287">Muitas estão tendo resultados bons o suficiente, enquanto outras estão atingindo os limites.</span><span class="sxs-lookup"><span data-stu-id="0a50e-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="0a50e-288">Muitas criaram seus aplicativos nesse modelo, porque as ferramentas e a infraestrutura eram muito difíceis de criar arquiteturas SOA, e elas não viam a necessidade – até que o aplicativo cresceu.</span><span class="sxs-lookup"><span data-stu-id="0a50e-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="0a50e-289">Se você acreditar que está atingindo os limites da abordagem monolítica, a divisão do aplicativo para permitir que ele aproveite melhor os contêineres e os microsserviços poderá ser a próxima etapa lógica.</span><span class="sxs-lookup"><span data-stu-id="0a50e-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="0a50e-290">A implantação de aplicativos monolíticos no Microsoft Azure pode ser feita por meio de VMs dedicadas para cada instância.</span><span class="sxs-lookup"><span data-stu-id="0a50e-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="0a50e-291">Com os [Conjuntos de Dimensionamento de VMs do Azure](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), você pode dimensionar as VMs com facilidade.</span><span class="sxs-lookup"><span data-stu-id="0a50e-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="0a50e-292">Os [Serviços de Aplicativos do Azure](https://azure.microsoft.com/services/app-service/) podem executar aplicativos monolíticos e dimensionar instâncias com facilidade, sem a necessidade de gerenciar as VMs.</span><span class="sxs-lookup"><span data-stu-id="0a50e-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="0a50e-293">Os Serviços de Aplicativos do Azure também podem executar instâncias únicas de contêineres do Docker, simplificando a implantação.</span><span class="sxs-lookup"><span data-stu-id="0a50e-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="0a50e-294">Usando o Docker, você pode implantar uma única VM como um host do Docker e executar várias instâncias.</span><span class="sxs-lookup"><span data-stu-id="0a50e-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="0a50e-295">Usando o balanceador do Azure, conforme mostrado na Figura 5-14, você pode gerenciar o dimensionamento.</span><span class="sxs-lookup"><span data-stu-id="0a50e-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="0a50e-296">A implantação em vários hosts pode ser gerenciada com técnicas de implantação tradicionais.</span><span class="sxs-lookup"><span data-stu-id="0a50e-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="0a50e-297">Os hosts do Docker podem ser gerenciados manualmente com comandos como **docker run** executados manualmente ou por meio da automação, como os pipelines de CD (Entrega Contínua).</span><span class="sxs-lookup"><span data-stu-id="0a50e-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="0a50e-298">Aplicativo monolítico implantado como um contêiner</span><span class="sxs-lookup"><span data-stu-id="0a50e-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="0a50e-299">Há benefícios no uso de contêineres para gerenciar implantações de aplicativos monolíticos.</span><span class="sxs-lookup"><span data-stu-id="0a50e-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="0a50e-300">O dimensionamento das instâncias de contêineres é muito mais rápido e fácil do que a implantação de VMs adicionais.</span><span class="sxs-lookup"><span data-stu-id="0a50e-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="0a50e-301">Mesmo ao usar Conjuntos de Dimensionamento de VMs para dimensionar VMs, a criação de instância das VMs é demorada.</span><span class="sxs-lookup"><span data-stu-id="0a50e-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="0a50e-302">Quando implantada como instâncias de aplicativo, a configuração do aplicativo é gerenciada como parte da VM.</span><span class="sxs-lookup"><span data-stu-id="0a50e-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="0a50e-303">Implantar atualizações como imagens do Docker é muito mais rápido e eficiente em termos de rede.</span><span class="sxs-lookup"><span data-stu-id="0a50e-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="0a50e-304">As Imagens do Docker costumam ser iniciadas em segundos, o que agiliza as distribuições.</span><span class="sxs-lookup"><span data-stu-id="0a50e-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="0a50e-305">Desmontar uma instância do Docker é tão fácil quanto emitir um comando **docker stop** e geralmente leva menos de um segundo.</span><span class="sxs-lookup"><span data-stu-id="0a50e-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="0a50e-306">Como os contêineres são inerentemente imutáveis por design, você nunca precisa se preocupar com VMs corrompidas, enquanto os scripts de atualização podem esquecer de levar em conta alguma configuração específica ou um arquivo deixado no disco.</span><span class="sxs-lookup"><span data-stu-id="0a50e-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="0a50e-307">Embora os aplicativos monolíticos possam se beneficiar com o Docker, a divisão do aplicativo monolítico em subsistemas que podem ser dimensionados, desenvolvidos e implantados individualmente pode ser o ponto de entrada para o realm de microsserviços.</span><span class="sxs-lookup"><span data-stu-id="0a50e-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="0a50e-308">Referências – Arquiteturas comuns da Web</span><span class="sxs-lookup"><span data-stu-id="0a50e-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="0a50e-309">**A Arquitetura Limpa**</span><span class="sxs-lookup"><span data-stu-id="0a50e-309">**The Clean Architecture**</span></span>  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="0a50e-310">**A Arquitetura Cebola**</span><span class="sxs-lookup"><span data-stu-id="0a50e-310">**The Onion Architecture**</span></span>  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="0a50e-311">**O Padrão de Repositório**</span><span class="sxs-lookup"><span data-stu-id="0a50e-311">**The Repository Pattern**</span></span>  
> <http://deviq.com/repository-pattern/>
> - <span data-ttu-id="0a50e-312">**Amostra de solução de Arquitetura Limpa**</span><span class="sxs-lookup"><span data-stu-id="0a50e-312">**Clean Architecture Solution Sample**</span></span>  
> <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="0a50e-313">**Livro eletrônico Architecting Microservices** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="0a50e-313">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="0a50e-314">[Anterior] (architectural-principles.md) [Próximo] (common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="0a50e-314">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
