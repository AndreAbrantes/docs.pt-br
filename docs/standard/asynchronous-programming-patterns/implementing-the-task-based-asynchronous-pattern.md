---
title: Implementando o padrão assíncrono baseado em tarefa
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 6218aa1a7b813601e9b718abf862e20a7cbcd313
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73124295"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="10223-102">Implementando o padrão assíncrono baseado em tarefa</span><span class="sxs-lookup"><span data-stu-id="10223-102">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="10223-103">Você pode implementar o Padrão Assíncrono baseado em Tarefas (TAP) de três formas: usando os compiladores C# e Visual Basic no Visual Studio, manualmente ou por meio de uma combinação dos métodos de compilador e manual.</span><span class="sxs-lookup"><span data-stu-id="10223-103">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="10223-104">As seções a seguir discutem cada método em detalhes.</span><span class="sxs-lookup"><span data-stu-id="10223-104">The following sections discuss each method in detail.</span></span> <span data-ttu-id="10223-105">Você pode usar o padrão TAP para implementar operações assíncronas associadas ao cálculo e associadas à E/S.</span><span class="sxs-lookup"><span data-stu-id="10223-105">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="10223-106">A seção [Cargas de trabalho](#workloads) descreve cada tipo de operação.</span><span class="sxs-lookup"><span data-stu-id="10223-106">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="10223-107">Gerando métodos do TAP</span><span class="sxs-lookup"><span data-stu-id="10223-107">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="10223-108">Usando os compiladores</span><span class="sxs-lookup"><span data-stu-id="10223-108">Using the compilers</span></span>
<span data-ttu-id="10223-109">Do .NET Framework 4.5 em diante, qualquer método que seja atribuído com a palavra-chave `async` (`Async` no Visual Basic) é considerado um método assíncrono e os compiladores de C# e do Visual Basic realizam as transformações necessárias para implementar o método de forma assíncrona usando o TAP.</span><span class="sxs-lookup"><span data-stu-id="10223-109">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="10223-110">Um método assíncrono deve retornar um objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> ou um objeto <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-110">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="10223-111">Para o último, o corpo da função deve retornar um `TResult`, e o compilador garante que esse resultado seja disponibilizado por meio do objeto de tarefa resultante.</span><span class="sxs-lookup"><span data-stu-id="10223-111">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="10223-112">Da mesma forma, quaisquer exceções que passem para o corpo do método sem tratamento são empacotadas na tarefa de saída e fazem com que a tarefa resultante termine no estado <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-112">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="10223-113">A exceção é quando uma <xref:System.OperationCanceledException> (ou um tipo derivado) passa sem tratamento e, nesse caso, a tarefa resultante termina no estado <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-113">The exception is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="10223-114">Gerando métodos do TAP manualmente</span><span class="sxs-lookup"><span data-stu-id="10223-114">Generating TAP methods manually</span></span>
<span data-ttu-id="10223-115">Você pode implementar o padrão TAP manualmente para obter maior controle sobre a implementação.</span><span class="sxs-lookup"><span data-stu-id="10223-115">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="10223-116">O compilador depende da área de superfície pública exposta no namespace <xref:System.Threading.Tasks?displayProperty=nameWithType> e dos tipos de suporte no namespace <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-116">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="10223-117">Para implementar o TAP você mesmo, crie um objeto <xref:System.Threading.Tasks.TaskCompletionSource%601>, execute a operação assíncrona e quando ela estiver concluída, chame o método <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> ou <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, ou a versão `Try` de um desses métodos.</span><span class="sxs-lookup"><span data-stu-id="10223-117">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="10223-118">Quando você implementa um método do TAP manualmente, deverá concluir a tarefa resultante quando a operação assíncrona representada for concluída.</span><span class="sxs-lookup"><span data-stu-id="10223-118">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="10223-119">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="10223-119">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="10223-120">Abordagem híbrida</span><span class="sxs-lookup"><span data-stu-id="10223-120">Hybrid approach</span></span>
 <span data-ttu-id="10223-121">Você pode achá-la útil para implementar o padrão TAP manualmente, mas também para delegar a lógica principal para a implementação para o compilador.</span><span class="sxs-lookup"><span data-stu-id="10223-121">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="10223-122">Por exemplo, talvez você queira usar a abordagem híbrida quando quiser verificar argumentos fora de um método assíncrono gerado pelo compilador para que as exceções possam escapar para o chamador direto do método, em vez de serem expostas por meio do objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="10223-122">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="10223-123">Outro caso em que tal delegação é útil é quando você está implementando a otimização de caminho rápido e deseja retornar uma tarefa armazenada em cache.</span><span class="sxs-lookup"><span data-stu-id="10223-123">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="10223-124">Cargas de trabalho</span><span class="sxs-lookup"><span data-stu-id="10223-124">Workloads</span></span>
<span data-ttu-id="10223-125">Você pode implementar operações assíncronas associadas ao cálculo e associadas à E/S como métodos do TAP.</span><span class="sxs-lookup"><span data-stu-id="10223-125">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="10223-126">No entanto, quando os métodos do TAP forem expostos publicamente de uma biblioteca, eles deverão receber somente cargas de trabalho que envolvem operações associadas à E/S (eles também podem envolver cálculos, mas não devem ser puramente computacionais).</span><span class="sxs-lookup"><span data-stu-id="10223-126">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="10223-127">Se um método for puramente vinculado à computação, ele deverá ser exposto apenas como uma implementação síncrona.</span><span class="sxs-lookup"><span data-stu-id="10223-127">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="10223-128">O código que o consome pode então escolher se deseja encapsular uma invocação desse método síncrono em uma tarefa para descarregar o trabalho em outro thread ou para obter paralelismo.</span><span class="sxs-lookup"><span data-stu-id="10223-128">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="10223-129">Além disso, se um método for associado à E/S, ele deverá ser exposto apenas como uma implementação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="10223-129">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="10223-130">Tarefas associadas ao cálculo</span><span class="sxs-lookup"><span data-stu-id="10223-130">Compute-bound tasks</span></span>
<span data-ttu-id="10223-131">A classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> é totalmente adequada para representar operações que exigem vários recursos computacionais.</span><span class="sxs-lookup"><span data-stu-id="10223-131">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="10223-132">Por padrão, ela aproveita o suporte especial dentro da classe <xref:System.Threading.ThreadPool> para fornecer execução eficiente e fornece também controle significativo sobre quando, onde e como executar cálculos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="10223-132">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="10223-133">Você pode gerar tarefas associadas ao cálculo de uma das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="10223-133">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="10223-134">No .NET Framework 4, use o método <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>, que aceita um delegado (geralmente um <xref:System.Action%601> ou um <xref:System.Func%601>) a ser executado de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="10223-134">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="10223-135">Se você fornecer um delegado <xref:System.Action%601>, o método retornará um objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> que representa a execução assíncrona desse delegado.</span><span class="sxs-lookup"><span data-stu-id="10223-135">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="10223-136">Se você fornecer um delegado <xref:System.Func%601>, o método retornará um objeto <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-136">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="10223-137">Sobrecargas do método <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> aceitam um token de cancelamento (<xref:System.Threading.CancellationToken>), opções de criação de tarefas (<xref:System.Threading.Tasks.TaskCreationOptions>) e um agendador de tarefas (<xref:System.Threading.Tasks.TaskScheduler>), que fornecem controle refinado sobre o planejamento e a execução da tarefa.</span><span class="sxs-lookup"><span data-stu-id="10223-137">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="10223-138">Uma instância de fábrica que tem como destino o agendador de tarefas atual está disponível como uma propriedade estática (<xref:System.Threading.Tasks.Task.Factory%2A>) da classe <xref:System.Threading.Tasks.Task>; por exemplo: `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="10223-138">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="10223-139">No .NET Framework 4.5 e em versões posteriores (incluindo o .NET Core e o .NET Standard), use o método <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> estático como um atalho para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-139">In the .NET Framework 4.5 and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="10223-140">Você pode usar <xref:System.Threading.Tasks.Task.Run%2A> para iniciar com facilidade uma tarefa associada ao cálculo que tem como destino o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="10223-140">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="10223-141">No .NET Framework 4.5 e em versões posteriores, esse é o mecanismo preferido para iniciar uma tarefa associada a cálculo.</span><span class="sxs-lookup"><span data-stu-id="10223-141">In the .NET Framework 4.5 and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="10223-142">Use `StartNew` diretamente somente quando desejar um controle mais refinado sobre a tarefa.</span><span class="sxs-lookup"><span data-stu-id="10223-142">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="10223-143">Use os construtores do tipo `Task` ou o método `Start` se desejar gerar e agendar a tarefa separadamente.</span><span class="sxs-lookup"><span data-stu-id="10223-143">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="10223-144">Métodos públicos devem retornar somente as tarefas que já foram iniciadas.</span><span class="sxs-lookup"><span data-stu-id="10223-144">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="10223-145">Use as sobrecargas do método <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-145">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="10223-146">Esse método cria uma nova tarefa que é agendada quando outra tarefa for concluída.</span><span class="sxs-lookup"><span data-stu-id="10223-146">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="10223-147">Algumas das sobrecargas <xref:System.Threading.Tasks.Task.ContinueWith%2A> aceitam um token de cancelamento, opções de continuação e um agendador de tarefas para obter melhor controle sobre o agendamento e a execução da tarefa de continuação.</span><span class="sxs-lookup"><span data-stu-id="10223-147">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="10223-148">Use os métodos <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> e <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10223-148">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="10223-149">Esses métodos criam uma nova tarefa que é agendada quando todos ou nenhum dos conjuntos de tarefas for concluído.</span><span class="sxs-lookup"><span data-stu-id="10223-149">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="10223-150">Esses métodos também fornecem sobrecargas para controlar o agendamento e a execução dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="10223-150">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="10223-151">Nas tarefas associadas ao cálculo, o sistema pode impedir a execução de uma tarefa agendada se ele receber uma solicitação de cancelamento antes de iniciar a execução da tarefa.</span><span class="sxs-lookup"><span data-stu-id="10223-151">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="10223-152">Assim, se você fornecer um token de cancelamento (objeto <xref:System.Threading.CancellationToken>), poderá passar esse token para o código assíncrono que monitora o token.</span><span class="sxs-lookup"><span data-stu-id="10223-152">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="10223-153">Também é possível fornecer o token para um dos métodos mencionados anteriormente, tais como `StartNew` ou `Run` para que o tempo de execução da `Task` também possa monitorar o token.</span><span class="sxs-lookup"><span data-stu-id="10223-153">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="10223-154">Por exemplo, considere um método assíncrono que renderiza uma imagem.</span><span class="sxs-lookup"><span data-stu-id="10223-154">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="10223-155">O corpo da tarefa pode sondar o token de cancelamento para que o código possa sair antecipadamente se uma solicitação de cancelamento chegar durante a renderização.</span><span class="sxs-lookup"><span data-stu-id="10223-155">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="10223-156">Além disso, se a solicitação de cancelamento chegar antes do início da renderização, você desejará impedir a operação de renderização:</span><span class="sxs-lookup"><span data-stu-id="10223-156">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="10223-157">Tarefas associadas ao cálculo terminarão em um estado <xref:System.Threading.Tasks.TaskStatus.Canceled> se pelo menos uma das seguintes condições for verdadeira:</span><span class="sxs-lookup"><span data-stu-id="10223-157">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="10223-158">Uma solicitação de cancelamento chega por meio do objeto <xref:System.Threading.CancellationToken>, que é fornecido como um argumento para o método de criação (por exemplo, `StartNew` ou `Run`) antes das transições de tarefas para o estado <xref:System.Threading.Tasks.TaskStatus.Running>.</span><span class="sxs-lookup"><span data-stu-id="10223-158">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="10223-159">Uma exceção <xref:System.OperationCanceledException> ficará sem tratamento dentro do corpo dessa tarefa, se a exceção contiver o mesmo <xref:System.Threading.CancellationToken> que é passado para a tarefa e se o token mostrar que o cancelamento foi solicitado.</span><span class="sxs-lookup"><span data-stu-id="10223-159">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="10223-160">Se outra exceção ficar sem tratamento dentro do corpo da tarefa, a tarefa terminará no estado <xref:System.Threading.Tasks.TaskStatus.Faulted> e quaisquer tentativas de aguardar a tarefa ou acessar seu resultado fará com que uma exceção seja lançada.</span><span class="sxs-lookup"><span data-stu-id="10223-160">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="10223-161">Tarefas associadas à E/S</span><span class="sxs-lookup"><span data-stu-id="10223-161">I/O-bound tasks</span></span>
<span data-ttu-id="10223-162">Para criar uma tarefa cujo backup não deve ser feito diretamente por um thread para a totalidade de sua execução, use o tipo <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="10223-162">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="10223-163">Esse tipo expõe uma propriedade <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> que retorna uma instância <xref:System.Threading.Tasks.Task%601> associada.</span><span class="sxs-lookup"><span data-stu-id="10223-163">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="10223-164">O ciclo de vida dessa tarefa é controlado por métodos <xref:System.Threading.Tasks.TaskCompletionSource%601>, tais como <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> e suas variantes `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="10223-164">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="10223-165">Digamos que você deseja criar uma tarefa que será concluída após um período de tempo especificado.</span><span class="sxs-lookup"><span data-stu-id="10223-165">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="10223-166">Por exemplo, talvez você queira atrasar uma atividade na interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="10223-166">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="10223-167">A classe <xref:System.Threading.Timer?displayProperty=nameWithType> já oferece a capacidade de invocar de forma assíncrona um delegado após um período especificado e usando <xref:System.Threading.Tasks.TaskCompletionSource%601> você pode colocar uma frente <xref:System.Threading.Tasks.Task%601> no cronômetro, por exemplo:</span><span class="sxs-lookup"><span data-stu-id="10223-167">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="10223-168">Desde o .NET Framework 4.5, o método <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> é fornecido para essa finalidade e você pode usá-lo dentro de outro método assíncrono, por exemplo, para implementar um loop de sondagem assíncrono:</span><span class="sxs-lookup"><span data-stu-id="10223-168">Starting with the .NET Framework 4.5, the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="10223-169">A classe <xref:System.Threading.Tasks.TaskCompletionSource%601> não tem uma equivalente não genérica.</span><span class="sxs-lookup"><span data-stu-id="10223-169">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="10223-170">No entanto, <xref:System.Threading.Tasks.Task%601> deriva de <xref:System.Threading.Tasks.Task>, de modo que você pode usar o objeto <xref:System.Threading.Tasks.TaskCompletionSource%601> genérico para métodos de associação de E/S que simplesmente retornam uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="10223-170">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="10223-171">Para fazer isso, é possível usar uma fonte com um `TResult` fictício (<xref:System.Boolean> é uma boa opção padrão, mas se você estiver preocupado sobre o usuário que fará downcast da <xref:System.Threading.Tasks.Task> para uma <xref:System.Threading.Tasks.Task%601>, poderá, em vez disso, usar um tipo `TResult` particular).</span><span class="sxs-lookup"><span data-stu-id="10223-171">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="10223-172">Por exemplo, o método `Delay` no exemplo anterior retorna a hora atual com o deslocamento resultante (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="10223-172">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="10223-173">Se esse valor de resultado for desnecessário, o método poderia então ser codificado da seguinte maneira (observe a alteração de tipo de retorno e a alteração de argumento para <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="10223-173">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="10223-174">Tarefas mistas associadas ao cálculo e associadas à E/S</span><span class="sxs-lookup"><span data-stu-id="10223-174">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="10223-175">Os métodos assíncronos não estão limitados apenas a operações associadas ao cálculo ou associadas à E/S, mas podem representar uma mistura das duas.</span><span class="sxs-lookup"><span data-stu-id="10223-175">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="10223-176">Na verdade, várias operações assíncronas são geralmente combinadas em operações mistas maiores.</span><span class="sxs-lookup"><span data-stu-id="10223-176">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="10223-177">Por exemplo, o método `RenderAsync` em um exemplo anterior executou uma operação que exige muitos recursos computacionais para renderizar uma imagem com base em algumas entradas `imageData`.</span><span class="sxs-lookup"><span data-stu-id="10223-177">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="10223-178">Essa `imageData` poderia ser proveniente de um serviço da web que você acessa de forma assíncrona:</span><span class="sxs-lookup"><span data-stu-id="10223-178">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="10223-179">Esse exemplo também demonstra como um token de cancelamento único pode ser encadeado por meio de várias operações assíncronas.</span><span class="sxs-lookup"><span data-stu-id="10223-179">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="10223-180">Para saber mais, veja a seção de uso de cancelamento em [Consumindo o padrão assíncrono baseado em tarefa](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="10223-180">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="10223-181">Consulte também</span><span class="sxs-lookup"><span data-stu-id="10223-181">See also</span></span>

- [<span data-ttu-id="10223-182">TAP (Padrão Assíncrono Baseado em Tarefa)</span><span class="sxs-lookup"><span data-stu-id="10223-182">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="10223-183">Consumindo o padrão assíncrono baseado em tarefa</span><span class="sxs-lookup"><span data-stu-id="10223-183">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="10223-184">Interoperabilidade com outros tipos e padrões assíncronos</span><span class="sxs-lookup"><span data-stu-id="10223-184">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)
