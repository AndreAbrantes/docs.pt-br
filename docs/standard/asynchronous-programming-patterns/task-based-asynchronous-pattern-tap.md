---
title: Padrão assíncrono baseado em tarefa (TAP)
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: c9dd8e49ad3270fe62b65469470485fcb169a4e7
ms.sourcegitcommit: 5d9f4b805787f890ca6e0dc7ea30a43018bc9cbb
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/12/2019
ms.locfileid: "57788538"
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="8c638-102">Padrão assíncrono baseado em tarefa (TAP)</span><span class="sxs-lookup"><span data-stu-id="8c638-102">Task-based asynchronous pattern (TAP)</span></span>
<span data-ttu-id="8c638-103">O TAP (Padrão Assíncrono Baseado em Tarefa) baseia-se nos tipos <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> no namespace <xref:System.Threading.Tasks?displayProperty=nameWithType>, os quais são usados para representar operações assíncronas arbitrárias.</span><span class="sxs-lookup"><span data-stu-id="8c638-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="8c638-104">O TAP é o padrão de design assíncrono recomendado para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="8c638-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="8c638-105">Nomenclatura, parâmetros e tipos de retorno</span><span class="sxs-lookup"><span data-stu-id="8c638-105">Naming, parameters, and return types</span></span>

<span data-ttu-id="8c638-106">O TAP usa um único método para representar o início e a conclusão de uma operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="8c638-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="8c638-107">Isso contrasta com o Modelo de programação assíncrona (APM ou `IAsyncResult`) e o Padrão assíncrono baseado em eventos (EAP).</span><span class="sxs-lookup"><span data-stu-id="8c638-107">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="8c638-108">O APM requer os métodos `Begin` e `End`.</span><span class="sxs-lookup"><span data-stu-id="8c638-108">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="8c638-109">O EAP requer um método que tenha o sufixo `Async` e também requer um ou mais eventos, tipos delegados de manipulador de eventos e tipos derivados de `EventArg`.</span><span class="sxs-lookup"><span data-stu-id="8c638-109">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="8c638-110">Os métodos assíncronos no TAP incluem o sufixo `Async` após o nome da operação para os métodos que retornam tipos aguardáveis, como <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask> e <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="8c638-110">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="8c638-111">Por exemplo, uma operação `Get` assíncrona que retorna um `Task<String>` pode ser nomeada `GetAsync`.</span><span class="sxs-lookup"><span data-stu-id="8c638-111">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="8c638-112">Se você estiver adicionando um método TAP a uma classe que já contenha o nome do método EAP com o sufixo `Async`, use, em vez dele, o sufixo `TaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="8c638-112">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="8c638-113">Por exemplo, se a classe já possuir um método `GetAsync`, use o nome `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="8c638-113">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="8c638-114">Se um método inicia com uma operação assíncrona, mas não retorna um tipo aguardável, o nome dele deve começar com `Begin`, `Start` ou algum outro verbo que sugira que esse método não retorna nem gera o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="8c638-114">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="8c638-115">Um método TAP retorna <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, dependendo se o método síncrono correspondente retorna void ou um tipo `TResult`.</span><span class="sxs-lookup"><span data-stu-id="8c638-115">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="8c638-116">Os parâmetros de um método TAP devem corresponder aos parâmetros de suas contrapartes síncronas e devem ser fornecidos na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="8c638-116">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="8c638-117">No entanto, os parâmetros `out` e `ref` são isentos dessa regra e devem ser evitados inteiramente.</span><span class="sxs-lookup"><span data-stu-id="8c638-117">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="8c638-118">Quaisquer dados retornados por um parâmetro `out` ou `ref` deve, em vez disso, ser retornado como parte do `TResult` retornado por <xref:System.Threading.Tasks.Task%601> e deve usar uma tupla ou uma estrutura de dados personalizada para acomodar diversos valores.</span><span class="sxs-lookup"><span data-stu-id="8c638-118">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="8c638-119">Considere também adicionar um parâmetro <xref:System.Threading.CancellationToken> mesmo se a contraparte síncrona do método TAP não oferece nenhum.</span><span class="sxs-lookup"><span data-stu-id="8c638-119">You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>
 
 <span data-ttu-id="8c638-120">Os métodos que são dedicados exclusivamente à criação, ao tratamento ou à combinação de tarefas (onde a intenção assíncrona do método está clara no nome do método ou no nome do tipo ao qual o método pertence) não precisam seguir esse padrão de nomenclatura; esses métodos são geralmente denominados *combinadores*.</span><span class="sxs-lookup"><span data-stu-id="8c638-120">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="8c638-121">Os exemplos de combinadores incluem <xref:System.Threading.Tasks.Task.WhenAll%2A> e <xref:System.Threading.Tasks.Task.WhenAny%2A> e são discutidos na seção [Usando os combinadores baseados em tarefas internos](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) do artigo [Consumindo o padrão assíncrono baseado em tarefa](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="8c638-121">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="8c638-122">Para obter exemplos de como a sintaxe do TAP difere da sintaxe usada em padrões de programação assíncronos herdados, como APM (Asynchronous Programming Model) e EAP (Event-based Asynchronous Pattern), confira [Padrões de programação assíncrona ](../../../docs/standard/asynchronous-programming-patterns/index.md).</span><span class="sxs-lookup"><span data-stu-id="8c638-122">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="8c638-123">Como iniciar uma operação assíncrona</span><span class="sxs-lookup"><span data-stu-id="8c638-123">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="8c638-124">Um método assíncrono baseado no TAP pode fazer uma pequena quantidade de trabalho de forma síncrona, como validar argumentos e iniciar a operação assíncrona, antes de retornar a tarefa resultante.</span><span class="sxs-lookup"><span data-stu-id="8c638-124">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="8c638-125">O trabalho síncrono deve ser mantido no mínimo possível para que o método assíncrono possa retornar rapidamente.</span><span class="sxs-lookup"><span data-stu-id="8c638-125">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="8c638-126">Os motivos para um retorno rápido incluem:</span><span class="sxs-lookup"><span data-stu-id="8c638-126">Reasons for a quick return include the following:</span></span>  
  
-   <span data-ttu-id="8c638-127">Os métodos assíncronos podem ser chamados de segmentos de interface do usuário (UI), e qualquer trabalho síncrono longo pode prejudicar a resposta do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="8c638-127">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
-   <span data-ttu-id="8c638-128">É possível iniciar vários métodos assíncronos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="8c638-128">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="8c638-129">Portanto, qualquer trabalho longo na parte síncrona de um método assíncrono pode atrasar a inicialização de outras operações assíncronas, diminuindo assim os benefícios de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="8c638-129">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="8c638-130">Em alguns casos, a quantidade de trabalho necessária para concluir a operação é menor do que a quantidade de trabalho necessária para iniciar a operação de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="8c638-130">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="8c638-131">Ler de um fluxo em que a operação de leitura pode ser satisfeita pelos dados que já estão armazenados no buffer de memória é um exemplo de cenário desse tipo.</span><span class="sxs-lookup"><span data-stu-id="8c638-131">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="8c638-132">Em casos como esse, a operação pode ser concluída de forma síncrona e retornar uma tarefa que já havia sido concluída.</span><span class="sxs-lookup"><span data-stu-id="8c638-132">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="8c638-133">Exceções</span><span class="sxs-lookup"><span data-stu-id="8c638-133">Exceptions</span></span>  
 <span data-ttu-id="8c638-134">Um método assíncrono deve gerar uma exceção para ser lançada fora da chamada do método assíncrono somente em resposta a um erro de uso.</span><span class="sxs-lookup"><span data-stu-id="8c638-134">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="8c638-135">Erros de uso nunca devem ocorrer em código de produção.</span><span class="sxs-lookup"><span data-stu-id="8c638-135">Usage errors should never occur in production code.</span></span> <span data-ttu-id="8c638-136">Por exemplo, se passar uma referência nula (`Nothing` no Visual Basic) como um dos argumentos do método faz com que um estado de erro (geralmente representado por uma exceção de <xref:System.ArgumentNullException>) ocorra, você pode alterar o código chamador para garantir que uma referência nula nunca seja passada.</span><span class="sxs-lookup"><span data-stu-id="8c638-136">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="8c638-137">Para todos outros erros, as exceções que ocorrem quando um método assíncrono está em execução devem ser atribuídas a tarefa retornada, mesmo quando o método assíncrono é concluído de forma síncrona antes de a tarefa ser retornada.</span><span class="sxs-lookup"><span data-stu-id="8c638-137">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="8c638-138">Normalmente, uma tarefa contém no máximo uma exceção.</span><span class="sxs-lookup"><span data-stu-id="8c638-138">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="8c638-139">No entanto, se a tarefa representa várias operações (por exemplo, <xref:System.Threading.Tasks.Task.WhenAll%2A>), várias exceções podem ser associadas a uma única tarefa.</span><span class="sxs-lookup"><span data-stu-id="8c638-139">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="8c638-140">Ambiente de destino</span><span class="sxs-lookup"><span data-stu-id="8c638-140">Target environment</span></span>  
 <span data-ttu-id="8c638-141">Quando você implementa um método TAP, pode determinar o local em que a execução assíncrona ocorre.</span><span class="sxs-lookup"><span data-stu-id="8c638-141">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="8c638-142">Você pode optar por executar a carga de trabalho no pool de thread, implementá-la usando E/S assíncrona (sem ser associada a um segmento para a maior parte da execução da operação), executá-la em um thread específico (como o thread da interface do usuário) ou usar qualquer número de contextos em potencial.</span><span class="sxs-lookup"><span data-stu-id="8c638-142">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="8c638-143">Um método TAP pode até não ter nada a executar e pode retornar apenas um <xref:System.Threading.Tasks.Task>, que representa a ocorrência de uma condição em outro lugar no sistema (por exemplo, uma tarefa que representa os dados que chegam a uma estrutura de dados na fila).</span><span class="sxs-lookup"><span data-stu-id="8c638-143">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>
 
 <span data-ttu-id="8c638-144">O chamador do método TAP pode bloquear a espera para o método TAP ser concluído com a espera síncrona na tarefa resultante ou pode executar código adicional (continuação) quando a operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="8c638-144">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="8c638-145">O criador do código de continuação tem o controle sobre o local em que o código é executado.</span><span class="sxs-lookup"><span data-stu-id="8c638-145">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="8c638-146">Você pode criar o código de continuação explicitamente com os métodos da classe <xref:System.Threading.Tasks.Task> (por exemplo, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) ou implicitamente usando o suporte à linguagem compilado nas continuações (por exemplo, `await` em C#, `Await` em Visual Basic, `AwaitValue` em F#).</span><span class="sxs-lookup"><span data-stu-id="8c638-146">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="8c638-147">Status da tarefa</span><span class="sxs-lookup"><span data-stu-id="8c638-147">Task status</span></span>  
 <span data-ttu-id="8c638-148">A classe <xref:System.Threading.Tasks.Task> fornece um ciclo de vida para operações assíncronas, e esse ciclo é representado pela enumeração <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="8c638-148">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="8c638-149">Para oferecer suporte a casos extremos de tipos que derivam de <xref:System.Threading.Tasks.Task> e de <xref:System.Threading.Tasks.Task%601> e suporte à separação da construção do agendamento, a classe <xref:System.Threading.Tasks.Task> expõe um método <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="8c638-149">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="8c638-150">As tarefas que são criadas pelos construtores públicos <xref:System.Threading.Tasks.Task> são chamadas de *tarefas frias*, porque começam seu ciclo de vida no estado não agendado <xref:System.Threading.Tasks.TaskStatus.Created> e são agendadas somente quando <xref:System.Threading.Tasks.Task.Start%2A> é chamado nessas instâncias.</span><span class="sxs-lookup"><span data-stu-id="8c638-150">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span> 
 
 <span data-ttu-id="8c638-151">Todas tarefas restantes começam seu ciclo de vida em um estado quente, o que significa que as operações assíncronas que elas representam já foram iniciadas, e seus status de tarefa são um valor de enumeração diferente de <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8c638-151">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8c638-152">Todas as tarefas que são retornadas dos métodos TAP devem ser ativadas.</span><span class="sxs-lookup"><span data-stu-id="8c638-152">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="8c638-153">**Se um método TAP usa internamente o construtor de uma tarefa para criar uma instância da tarefa a ser retornada, o método TAP deve chamar <xref:System.Threading.Tasks.Task.Start%2A> no objeto <xref:System.Threading.Tasks.Task> antes de retorná-la.**</span><span class="sxs-lookup"><span data-stu-id="8c638-153">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="8c638-154">Os consumidores de um método TAP podem presumir com segurança que a tarefa retornada está ativa e não devem tentar chamar <xref:System.Threading.Tasks.Task.Start%2A> em qualquer <xref:System.Threading.Tasks.Task> que é retornado de um método TAP.</span><span class="sxs-lookup"><span data-stu-id="8c638-154">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="8c638-155">A chamada <xref:System.Threading.Tasks.Task.Start%2A> em uma tarefa ativa resulta em uma exceção de <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="8c638-155">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="8c638-156">Cancelamento (opcional)</span><span class="sxs-lookup"><span data-stu-id="8c638-156">Cancellation (optional)</span></span>  
 <span data-ttu-id="8c638-157">Em TAP, o cancelamento é opcional para implementadores e consumidores de métodos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="8c638-157">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="8c638-158">Se uma operação permite o cancelamento, ela expõe uma sobrecarga do método assíncrono que aceita um símbolo de cancelamento (<xref:System.Threading.CancellationToken>).</span><span class="sxs-lookup"><span data-stu-id="8c638-158">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="8c638-159">Por convenção, o parâmetro é chamado `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="8c638-159">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="8c638-160">A operação assíncrona monitora esse token para solicitações de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="8c638-160">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="8c638-161">Se ela recebe uma solicitação de cancelamento, pode escolher honrar a solicitação e cancelar a operação.</span><span class="sxs-lookup"><span data-stu-id="8c638-161">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="8c638-162">Se a solicitação de cancelamento resulta em algum trabalho ser encerrado prematuramente, o método TAP retorna uma tarefa que termina em estado de <xref:System.Threading.Tasks.TaskStatus.Canceled>; não há nenhum resultado disponível, e nenhuma exceção é gerada.</span><span class="sxs-lookup"><span data-stu-id="8c638-162">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="8c638-163">O estado <xref:System.Threading.Tasks.TaskStatus.Canceled> é considerado um estado final (concluído) para uma tarefa, juntamente com os estados <xref:System.Threading.Tasks.TaskStatus.Faulted> e <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="8c638-163">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="8c638-164">Portanto, se uma tarefa está no estado <xref:System.Threading.Tasks.TaskStatus.Canceled>, sua propriedade <xref:System.Threading.Tasks.Task.IsCompleted%2A> retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="8c638-164">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="8c638-165">Quando uma tarefa termina no estado <xref:System.Threading.Tasks.TaskStatus.Canceled>, todas as continuações registradas com a tarefa ou agendadas são executadas, a menos que uma opção de continuação como <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> tenha sido especificada para optar pela não continuação.</span><span class="sxs-lookup"><span data-stu-id="8c638-165">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="8c638-166">Qualquer código que esteja aguardando de forma assíncrona uma tarefa cancelada com o uso de recursos de linguagem continuará a ser executada, mas receberá <xref:System.OperationCanceledException> ou uma exceção derivada dela.</span><span class="sxs-lookup"><span data-stu-id="8c638-166">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="8c638-167">O código bloqueado que espera de forma síncrona a tarefa através de métodos como <xref:System.Threading.Tasks.Task.Wait%2A> e <xref:System.Threading.Tasks.Task.WaitAll%2A> também continuará a ser executado com uma exceção.</span><span class="sxs-lookup"><span data-stu-id="8c638-167">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="8c638-168">Se um token de cancelamento solicitou o cancelamento antes do método TAP que aceita esse token ter sido chamado, o método TAP deve retornar uma tarefa <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="8c638-168">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="8c638-169">No entanto, se o cancelamento é solicitado enquanto a operação assíncrona é executada, a operação assíncrona não precisa aceitar a solicitação de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="8c638-169">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="8c638-170">A tarefa retornada deverá terminar no estado <xref:System.Threading.Tasks.TaskStatus.Canceled> somente se a operação terminar como um resultado da solicitação de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="8c638-170">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="8c638-171">Se o cancelamento for solicitado, mas um resultado ou uma exceção ainda forem gerados, a tarefa deve terminar no estado <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> ou <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span><span class="sxs-lookup"><span data-stu-id="8c638-171">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span> 
 
 <span data-ttu-id="8c638-172">Para métodos assíncronos que desejam expor a capacidade de serem cancelados primeiro, você não precisa fornecer uma sobrecarga que não aceita um token de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="8c638-172">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="8c638-173">Para os métodos que não podem ser cancelados, não forneça sobrecargas que aceitem um token de cancelamento; isso ajuda a indicar ao chamador se o método de destino é realmente cancelável.</span><span class="sxs-lookup"><span data-stu-id="8c638-173">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="8c638-174">O código consumidor que não deseja cancelamento pode chamar um método que aceita um <xref:System.Threading.CancellationToken> e fornece <xref:System.Threading.CancellationToken.None%2A> como o valor do argumento.</span><span class="sxs-lookup"><span data-stu-id="8c638-174">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="8c638-175"><xref:System.Threading.CancellationToken.None%2A> é funcionalmente equivalente ao <xref:System.Threading.CancellationToken> padrão.</span><span class="sxs-lookup"><span data-stu-id="8c638-175"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="8c638-176">Relatório de progresso (opcional)</span><span class="sxs-lookup"><span data-stu-id="8c638-176">Progress reporting (optional)</span></span>  
 <span data-ttu-id="8c638-177">Algumas operações assíncronas beneficiam-se do fornecimento de notificações de progresso; esses são normalmente usados para atualizar uma interface do usuário com informações sobre o andamento da operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="8c638-177">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span> 
 
 <span data-ttu-id="8c638-178">No TAP, o progresso é tratado por uma interface <xref:System.IProgress%601> que é passada para o método assíncrono como um parâmetro que é chamado geralmente de `progress`.</span><span class="sxs-lookup"><span data-stu-id="8c638-178">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="8c638-179">Fornecer a interface de progresso quando o método assíncrono é chamado ajuda a eliminar as condições de corrida resultantes do uso incorreto (isto é, quando os manipuladores de eventos registrados incorretamente depois que a operação é iniciada podem carecer de atualizações).</span><span class="sxs-lookup"><span data-stu-id="8c638-179">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="8c638-180">Mais importante, a interface de progresso suporta implementações de variação de progresso, conforme determinado pelo código consumidor.</span><span class="sxs-lookup"><span data-stu-id="8c638-180">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="8c638-181">Por exemplo, o código consumidor só pode importar-se com a última atualização de progresso, pode desejar armazenar em buffer todas as atualizações, pode querer chamar uma ação para cada atualização ou pode desejar controlar se a chamada é vinculada a um thread específico.</span><span class="sxs-lookup"><span data-stu-id="8c638-181">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="8c638-182">Todas essas opções podem ser obtidas usando-se uma implementação diferente de interface, personalizada de acordo com as necessidades específicas do consumidor.</span><span class="sxs-lookup"><span data-stu-id="8c638-182">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="8c638-183">Assim como no cancelamento, as implementações de TAP devem fornecer um parâmetro de <xref:System.IProgress%601> somente se a API oferecer suporte a notificações de progresso.</span><span class="sxs-lookup"><span data-stu-id="8c638-183">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span> 
 
 <span data-ttu-id="8c638-184">Por exemplo, se o método `ReadAsync` discutido anteriormente nesse artigo for capaz de relatar o progresso intermediário na forma do número de bytes lidos até aqui, o retorno de chamada de progresso poderá ser uma interface <xref:System.IProgress%601>:</span><span class="sxs-lookup"><span data-stu-id="8c638-184">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="8c638-185">Se um método `FindFilesAsync` retornar uma lista de todos os arquivos que estão de acordo com um padrão específico de pesquisa, o retorno da chamada de progresso deverá fornecer uma estimativa da porcentagem do trabalho concluído, bem como o conjunto atual de resultados parciais.</span><span class="sxs-lookup"><span data-stu-id="8c638-185">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="8c638-186">Isso poderia ser feito com uma tupla:</span><span class="sxs-lookup"><span data-stu-id="8c638-186">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="8c638-187">ou com um tipo de dados que é específico da API:</span><span class="sxs-lookup"><span data-stu-id="8c638-187">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="8c638-188">No último caso, o tipo de dados especial geralmente é sufixado com `ProgressInfo`.</span><span class="sxs-lookup"><span data-stu-id="8c638-188">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="8c638-189">Se as implementações de TAP fornecem sobrecargas que aceitam um parâmetro de `progress`, elas deverão permitir que o argumento seja `null`, caso em que nenhum progresso será relatado.</span><span class="sxs-lookup"><span data-stu-id="8c638-189">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="8c638-190">As implementações de TAP devem relatar o progresso para o objeto <xref:System.Progress%601> de forma síncrona, o que permite que o método assíncrono forneça rapidamente o progresso e permita que o consumidor de progresso determine como e onde melhor manipular as informações.</span><span class="sxs-lookup"><span data-stu-id="8c638-190">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="8c638-191">Por exemplo, a instância de progresso poderia optar por controlar retornos de chamada e gerar eventos em um contexto de sincronização capturado.</span><span class="sxs-lookup"><span data-stu-id="8c638-191">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="8c638-192">IProgress\<T> implementações</span><span class="sxs-lookup"><span data-stu-id="8c638-192">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="8c638-193">O [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] fornece uma implementação única de <xref:System.IProgress%601>: <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="8c638-193">The [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="8c638-194">A classe <xref:System.Progress%601> é declarada da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="8c638-194">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="8c638-195">Uma instância de <xref:System.Progress%601> expõe um evento <xref:System.Progress%601.ProgressChanged>, o qual é gerado sempre que a operação assíncrona relata uma atualização de progresso.</span><span class="sxs-lookup"><span data-stu-id="8c638-195">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="8c638-196">O evento <xref:System.Progress%601.ProgressChanged> é gerado no objeto de <xref:System.Threading.SynchronizationContext> que foi capturado quando a instância de <xref:System.Progress%601> foi criada.</span><span class="sxs-lookup"><span data-stu-id="8c638-196">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="8c638-197">Se não havia contexto de sincronização disponível, um contexto padrão que tem como alvo o pool de segmentos é usado.</span><span class="sxs-lookup"><span data-stu-id="8c638-197">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="8c638-198">É possível registrar manipuladores com esse evento.</span><span class="sxs-lookup"><span data-stu-id="8c638-198">Handlers may be registered with this event.</span></span> <span data-ttu-id="8c638-199">Um único manipulador também pode ser fornecido para o construtor <xref:System.Progress%601> para maior conveniência. Seu comportamento é exatamente como um manipulador de eventos para o evento <xref:System.Progress%601.ProgressChanged>.</span><span class="sxs-lookup"><span data-stu-id="8c638-199">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="8c638-200">As atualizações de progresso são geradas de forma assíncrona para evitar atrasar a operação assíncrona enquanto os manipuladores de eventos são executados.</span><span class="sxs-lookup"><span data-stu-id="8c638-200">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="8c638-201">Outra implementação de <xref:System.IProgress%601> pode optar por aplicar uma semântica diferente.</span><span class="sxs-lookup"><span data-stu-id="8c638-201">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="8c638-202">Escolhendo as sobrecargas a serem fornecidas</span><span class="sxs-lookup"><span data-stu-id="8c638-202">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="8c638-203">Se uma implementação de TAP ambos os parâmetros <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> e <xref:System.IProgress%601> opcionais, ela poderá potencialmente exigir até quatro cargas de trabalho:</span><span class="sxs-lookup"><span data-stu-id="8c638-203">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);   
public Task MethodNameAsync(…,   
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task   
Public MethodNameAsync(…, cancellationToken As CancellationToken,   
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="8c638-204">No entanto, muitas implementações de TAP fornecem recursos de cancelamento ou progresso de modo a exigir um único método:</span><span class="sxs-lookup"><span data-stu-id="8c638-204">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="8c638-205">Se uma implementação de TAP oferecer suporte a cancelamento ou progresso, mas não a ambos, ela poderá fornecer duas sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="8c638-205">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="8c638-206">Se uma implementação de TAP oferecer suporte a cancelamento e progresso, ela poderá expor todas as quatro sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="8c638-206">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="8c638-207">No entanto, ela pode fornecer somente estas duas:</span><span class="sxs-lookup"><span data-stu-id="8c638-207">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,   
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,   
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="8c638-208">Para compensar as duas combinações intermediárias ausentes, os desenvolvedores podem passar <xref:System.Threading.CancellationToken.None%2A> ou um <xref:System.Threading.CancellationToken> padrão para o parâmetro `cancellationToken` e `null` para o parâmetro `progress`.</span><span class="sxs-lookup"><span data-stu-id="8c638-208">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="8c638-209">Se você espera que cada uso do método TAP ofereça suporte a cancelamento ou progresso, pode omitir sobrecargas que não aceitam o parâmetro relevante.</span><span class="sxs-lookup"><span data-stu-id="8c638-209">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="8c638-210">Se você decidir expor várias sobrecargas para tornar o cancelamento ou o progresso opcional, as sobrecargas que não suportam cancelamento ou progresso devem se comportar como se passassem <xref:System.Threading.CancellationToken.None%2A> para o cancelamento ou `null` para o progresso para a sobrecarga que oferece suporte a eles.</span><span class="sxs-lookup"><span data-stu-id="8c638-210">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="8c638-211">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="8c638-211">Related topics</span></span>  
  
|<span data-ttu-id="8c638-212">Título</span><span class="sxs-lookup"><span data-stu-id="8c638-212">Title</span></span>|<span data-ttu-id="8c638-213">Descrição</span><span class="sxs-lookup"><span data-stu-id="8c638-213">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="8c638-214">Padrões de programação assíncrona</span><span class="sxs-lookup"><span data-stu-id="8c638-214">Asynchronous Programming Patterns</span></span>](../../../docs/standard/asynchronous-programming-patterns/index.md)|<span data-ttu-id="8c638-215">Apresenta os três padrões para execução de operações assíncronas: TAP (Padrão Assíncrono Baseado em Tarefas), APM (Modelo de Programação Assíncrona) e EAP (Padrão Assíncrono Baseado em Eventos).</span><span class="sxs-lookup"><span data-stu-id="8c638-215">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="8c638-216">Implementando o padrão assíncrono baseado em tarefa</span><span class="sxs-lookup"><span data-stu-id="8c638-216">Implementing the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="8c638-217">Descreve como implementar o TAP de três formas: usando os compiladores C# e Visual Basic no Visual Studio, manualmente ou por meio de uma combinação de compilador com o método manual.</span><span class="sxs-lookup"><span data-stu-id="8c638-217">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="8c638-218">Consumindo o padrão assíncrono baseado em tarefa</span><span class="sxs-lookup"><span data-stu-id="8c638-218">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="8c638-219">Descreve como você pode usar tarefas e retornos de chamada para implementar a espera sem causar bloqueios.</span><span class="sxs-lookup"><span data-stu-id="8c638-219">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="8c638-220">Interoperabilidade com outros tipos e padrões assíncronos</span><span class="sxs-lookup"><span data-stu-id="8c638-220">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="8c638-221">Descreve como usar o TAP (Padrão Assíncrono Baseado em Tarefas) para implementar o APM (Modelo de Programação Assíncrona) e o EAP (Padrão Assíncrono Baseado em Eventos).</span><span class="sxs-lookup"><span data-stu-id="8c638-221">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
