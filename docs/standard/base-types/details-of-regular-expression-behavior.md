---
title: Comportamento de expressão regular
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 504e315dda4e76f56a88d97149b1515b6743668b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124345"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="7f135-102">Detalhes do comportamento de expressões regulares</span><span class="sxs-lookup"><span data-stu-id="7f135-102">Details of regular expression behavior</span></span>

<span data-ttu-id="7f135-103">O mecanismo de expressões regulares do .NET Framework é um correspondente de expressão regular de retrocesso que incorpora um mecanismo de NFA (Automação Finita Não Determinística) tradicional, como o usado pelo Perl, Python, Emacs e Tcl.</span><span class="sxs-lookup"><span data-stu-id="7f135-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="7f135-104">Isso o distingue de mecanismos de DFA (Autômato finito determinístico) de expressões regulares puras mais rápidos, porém mais limitados, como os encontrados em awk, egrep ou lex.</span><span class="sxs-lookup"><span data-stu-id="7f135-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="7f135-105">Também o distingue de NFAs POSIX padronizados, porém mais lentos.</span><span class="sxs-lookup"><span data-stu-id="7f135-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="7f135-106">A seção a seguir descreve os três tipos de mecanismos de expressões regulares e explica por que as expressões regulares no .NET Framework são implementadas usando um mecanismo de NFA tradicional.</span><span class="sxs-lookup"><span data-stu-id="7f135-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="7f135-107">Benefícios do motor NFA</span><span class="sxs-lookup"><span data-stu-id="7f135-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="7f135-108">Quando mecanismos de DFA executam a correspondência de padrões, a ordem de processamento é orientada pela cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="7f135-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="7f135-109">O mecanismo começa no início da cadeia de caracteres de entrada e continua sequencialmente para determinar se o próximo caractere corresponde ao padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7f135-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="7f135-110">Podem assegurar uma correspondência com a cadeia de caracteres mais longa possível.</span><span class="sxs-lookup"><span data-stu-id="7f135-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="7f135-111">Como nunca testam o mesmo caractere duas vezes, os mecanismos de DFA não dão suporte ao retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7f135-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="7f135-112">No entanto, como um mecanismo de DFA contém somente o estado finito, não pode corresponder a um padrão com referências inversas; além disso, uma vez que não constrói uma expansão explícita, não pode capturar subexpressões.</span><span class="sxs-lookup"><span data-stu-id="7f135-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="7f135-113">Ao contrário de mecanismos de DFA, quando mecanismos de NFA tradicionais executam a correspondência de padrões, a ordem de processamento é orientada pelo padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7f135-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="7f135-114">Como processa um elemento de linguagem específico, o mecanismo usa a correspondência Greedy; ou seja, corresponde à maior parte possível da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="7f135-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="7f135-115">Contudo, também consegue salvar seu estado correspondendo a uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="7f135-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="7f135-116">Se uma correspondência falhar, o mecanismo poderá retornar para um estado salvo a fim de tentar correspondências adicionais.</span><span class="sxs-lookup"><span data-stu-id="7f135-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="7f135-117">Esse processo de abandonar uma correspondência de subexpressão bem-sucedida para que elementos de linguagem posteriores na expressão regular também possam corresponder é conhecido como *retrocesso*.</span><span class="sxs-lookup"><span data-stu-id="7f135-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="7f135-118">Os mecanismos de NFA usam o retrocesso para testar todas as possíveis expansões de uma expressão regular em uma ordem específica e aceitam a primeira correspondência.</span><span class="sxs-lookup"><span data-stu-id="7f135-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="7f135-119">Como um mecanismo de NFA tradicional constrói uma expansão específica da expressão regular para uma correspondência de sucesso, pode capturar correspondências de subexpressões e referências inversas correspondentes.</span><span class="sxs-lookup"><span data-stu-id="7f135-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="7f135-120">Entretanto, como um NFA tradicional retrocede, pode visitar o mesmo estado diversas vezes se chegar no estado por diferentes caminhos.</span><span class="sxs-lookup"><span data-stu-id="7f135-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="7f135-121">Como resultado, pode executar de modo exponencial lentamente na pior das hipóteses.</span><span class="sxs-lookup"><span data-stu-id="7f135-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="7f135-122">Já que um mecanismo de NFA tradicional aceita a primeira correspondência que encontra, também pode deixar outras correspondências (possivelmente mais longas) não descobertas.</span><span class="sxs-lookup"><span data-stu-id="7f135-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="7f135-123">Os mecanismos de NFA POSIX são como mecanismos de NFA tradicionais, exceto pelo fato de continuarem retrocedendo até poderem assegurar que encontraram a correspondência mais longa possível.</span><span class="sxs-lookup"><span data-stu-id="7f135-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="7f135-124">Como resultado, um mecanismo de NFA POSIX é mais lento do que um mecanismo de NFA tradicional; quando você usa um mecanismo de NFA POSIX, não pode favorecer uma correspondência menor em detrimento de uma maior alterando a ordem da pesquisa de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7f135-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="7f135-125">Os mecanismos de NFA tradicionais são favorecidos por programadores porque oferecem maior controle sobre a correspondência da cadeia de caracteres do que mecanismos de DFA ou NFA POSIX.</span><span class="sxs-lookup"><span data-stu-id="7f135-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="7f135-126">Embora, na pior das hipóteses, possam ser executados mais lentamente, você pode orientá-los para encontrar correspondências em tempo linear ou polinomial usando padrões que reduzem ambiguidades e limitam o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7f135-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="7f135-127">Em outras palavras, embora os motores NFA negociem o desempenho por potência e flexibilidade, na maioria dos casos eles oferecem bom desempenho aceitável se uma expressão regular for bem escrita e evitar casos em que o backtracking degrada o desempenho exponencialmente.</span><span class="sxs-lookup"><span data-stu-id="7f135-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="7f135-128">Para obter informações sobre a penalidade de desempenho causada por retrocesso excessivo e maneiras de criar uma expressão regular para solucioná-lo, consulte [Retrocesso](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="7f135-129">Recursos do mecanismo .NET Framework</span><span class="sxs-lookup"><span data-stu-id="7f135-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="7f135-130">Para tirar proveito dos benefícios de um mecanismo de NFA tradicional, o mecanismo de expressões regulares do .NET Framework inclui um conjunto completo de constructos para permitir que os programadores conduzam o mecanismo de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7f135-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="7f135-131">Tais constructos podem ser usados para encontrar correspondências mais rapidamente ou favorecer expansões específicas em detrimento de outras.</span><span class="sxs-lookup"><span data-stu-id="7f135-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="7f135-132">Outros recursos do mecanismo de expressões regulares do .NET Framework incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="7f135-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="7f135-133">Quantificadores preguiçosos: `??`, `*?` `+?`, , `{` *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="7f135-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="7f135-134">Esses constructos instruem o mecanismo de retrocesso a pesquisar o número mínimo de repetições primeiro.</span><span class="sxs-lookup"><span data-stu-id="7f135-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="7f135-135">Por outro lado, quantificadores Greedy comuns tentam corresponder ao número máximo de repetições primeiro.</span><span class="sxs-lookup"><span data-stu-id="7f135-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="7f135-136">O exemplo a seguir mostra a diferença entre os dois.</span><span class="sxs-lookup"><span data-stu-id="7f135-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="7f135-137">Uma expressão regular corresponde a uma frase que termina em um número e um grupo de captura deve extrair esse número.</span><span class="sxs-lookup"><span data-stu-id="7f135-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="7f135-138">A expressão regular `.+(\d+)\.` inclui o quantificador Greedy `.+`, que faz com que o mecanismo de expressões regulares capture o último dígito do número.</span><span class="sxs-lookup"><span data-stu-id="7f135-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="7f135-139">Por outro lado, a expressão regular `.+?(\d+)\.` inclui o quantificador lento `.+?`, que faz com que o mecanismo de expressões regulares capture o número inteiro.</span><span class="sxs-lookup"><span data-stu-id="7f135-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="7f135-140">As versões Greedy e lenta dessa expressão regular são definidas como mostrado na tabela a seguir:</span><span class="sxs-lookup"><span data-stu-id="7f135-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="7f135-141">Padrão</span><span class="sxs-lookup"><span data-stu-id="7f135-141">Pattern</span></span>|<span data-ttu-id="7f135-142">Descrição</span><span class="sxs-lookup"><span data-stu-id="7f135-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="7f135-143">`.+` (quantificador Greedy)</span><span class="sxs-lookup"><span data-stu-id="7f135-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="7f135-144">Corresponder a pelo menos uma ocorrência de qualquer caractere.</span><span class="sxs-lookup"><span data-stu-id="7f135-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="7f135-145">Isso faz com que o mecanismo de expressões regulares corresponda à cadeia de caracteres inteira e, em seguida, retroceda da forma necessária para corresponder ao restante do padrão.</span><span class="sxs-lookup"><span data-stu-id="7f135-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="7f135-146">`.+?` (quantificador lento)</span><span class="sxs-lookup"><span data-stu-id="7f135-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="7f135-147">Corresponder a pelo menos uma ocorrência de qualquer caractere, mas ao menor número possível.</span><span class="sxs-lookup"><span data-stu-id="7f135-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="7f135-148">Corresponder a pelo menos um caractere numérico e atribuí-lo ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7f135-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="7f135-149">Corresponde a um ponto final.</span><span class="sxs-lookup"><span data-stu-id="7f135-149">Match a period.</span></span>|

     <span data-ttu-id="7f135-150">Para obter mais informações sobre quantificadores lentos, confira [Quantificadores](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7f135-151">Olhar positivo `(?=`à frente: *subexpressão*`)`.</span><span class="sxs-lookup"><span data-stu-id="7f135-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="7f135-152">Esse recurso permite que o mecanismo de retrocesso retorne ao mesmo ponto no texto após corresponder a uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="7f135-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="7f135-153">É útil para pesquisar em todo o texto verificando vários padrões que iniciam na mesma posição.</span><span class="sxs-lookup"><span data-stu-id="7f135-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="7f135-154">Também permite que o mecanismo verifique se existe uma subcadeia de caracteres no final da correspondência sem incluir a subcadeia de caracteres no texto correspondente.</span><span class="sxs-lookup"><span data-stu-id="7f135-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="7f135-155">O exemplo a seguir usa lookahead positivo para extrair as palavras de uma frase que não são seguidas por símbolos de pontuação.</span><span class="sxs-lookup"><span data-stu-id="7f135-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="7f135-156">A expressão regular `\b[A-Z]+\b(?=\P{P})` é definida conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7f135-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7f135-157">Padrão</span><span class="sxs-lookup"><span data-stu-id="7f135-157">Pattern</span></span>|<span data-ttu-id="7f135-158">Descrição</span><span class="sxs-lookup"><span data-stu-id="7f135-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="7f135-159">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7f135-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="7f135-160">Corresponder a qualquer caractere alfabético uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="7f135-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="7f135-161">Como o método <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, essa comparação não diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="7f135-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="7f135-162">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7f135-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="7f135-163">Antecipe para determinar se o próximo caractere é um símbolo de pontuação.</span><span class="sxs-lookup"><span data-stu-id="7f135-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="7f135-164">Se não for, a correspondência será bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="7f135-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="7f135-165">Para obter mais informações sobre as asserções de lookahead positivo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7f135-166">Olhar negativo `(?!`à frente: *subexpressão*`)`.</span><span class="sxs-lookup"><span data-stu-id="7f135-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="7f135-167">Esse recurso adiciona a capacidade de corresponder a uma expressão somente se uma subexpressão não corresponder.</span><span class="sxs-lookup"><span data-stu-id="7f135-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="7f135-168">Ele é indicado especialmente para refinar uma pesquisa, porque, muitas vezes, é mais simples fornecer uma expressão para um caso que deve ser eliminado do que uma expressão para casos que precisam ser incluídos.</span><span class="sxs-lookup"><span data-stu-id="7f135-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="7f135-169">Por exemplo, é difícil escrever uma expressão para palavras que não começam com “non”.</span><span class="sxs-lookup"><span data-stu-id="7f135-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="7f135-170">O exemplo a seguir usa lookahead negativo para excluir.</span><span class="sxs-lookup"><span data-stu-id="7f135-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="7f135-171">O padrão de expressão regular `\b(?!non)\w+\b` é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7f135-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7f135-172">Padrão</span><span class="sxs-lookup"><span data-stu-id="7f135-172">Pattern</span></span>|<span data-ttu-id="7f135-173">Descrição</span><span class="sxs-lookup"><span data-stu-id="7f135-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="7f135-174">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7f135-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="7f135-175">Antecipar para garantir que a cadeia de caracteres atual não comece com “non”.</span><span class="sxs-lookup"><span data-stu-id="7f135-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="7f135-176">Se isso acontecer, a correspondência falha.</span><span class="sxs-lookup"><span data-stu-id="7f135-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="7f135-177">Fazer a correspondência a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="7f135-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="7f135-178">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7f135-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="7f135-179">Para obter mais informações sobre as asserções de lookahead negativo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7f135-180">Avaliação condicional: `(?(` *expressão*`)`*sim*`|`*não* `)` e `(?(` *nome*`)`sim*não*`|`*no*`)`, onde *a expressão* é uma subexpressão para combinar, *nome* é o nome de um grupo de captura, *sim* é a string para combinar se *a expressão* é compatível ou *nome* é um grupo capturado válido, não vazio, e *não* é a subexpressão para combinar se \*expressão \*não é correspondido ou *o nome* não é um grupo capturado válido e não vazio.</span><span class="sxs-lookup"><span data-stu-id="7f135-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="7f135-181">Esse recurso permite que o mecanismo pesquise usando mais de um padrão alternativo, dependendo do resultado de uma correspondência de subexpressão anterior ou do resultado de uma asserção de largura zero.</span><span class="sxs-lookup"><span data-stu-id="7f135-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="7f135-182">Isso possibilita uma forma mais potente de referência inversa que permite, por exemplo, corresponder a uma subexpressão com base no fato de uma subexpressão anterior ser correspondente.</span><span class="sxs-lookup"><span data-stu-id="7f135-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="7f135-183">A expressão regular no exemplo a seguir corresponde a parágrafos que são destinados a uso público e interno.</span><span class="sxs-lookup"><span data-stu-id="7f135-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="7f135-184">Os parágrafos destinados apenas a uso interno começam com uma marca `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="7f135-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="7f135-185">O padrão de expressão regular `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` usa avaliação condicional para atribuir o conteúdo de parágrafos destinados a uso público e interno a grupos de captura separados.</span><span class="sxs-lookup"><span data-stu-id="7f135-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="7f135-186">Esses parágrafos podem ser tratados de maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="7f135-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="7f135-187">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7f135-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7f135-188">Padrão</span><span class="sxs-lookup"><span data-stu-id="7f135-188">Pattern</span></span>|<span data-ttu-id="7f135-189">Descrição</span><span class="sxs-lookup"><span data-stu-id="7f135-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="7f135-190">Começar a correspondência no início de uma linha.</span><span class="sxs-lookup"><span data-stu-id="7f135-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="7f135-191">Corresponder a zero ou uma ocorrência da cadeia de caracteres `<PRIVATE>` seguida para um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f135-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="7f135-192">Atribuir a correspondência a um grupo de captura chamado `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="7f135-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="7f135-193">Se o grupo de captura `Pvt` existir, corresponder a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por zero ou um separador de pontuação, seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f135-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="7f135-194">Atribuir a subcadeia de caracteres ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7f135-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="7f135-195">Se o grupo de captura `Pvt` não existir, corresponder a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por zero ou um separador de pontuação, seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7f135-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="7f135-196">Atribuir a subcadeia de caracteres ao terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7f135-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="7f135-197">Corresponder ao final de uma linha ou ao final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7f135-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="7f135-198">Para obter mais informações sobre a avaliação condicional, consulte [Constructos de alternância](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7f135-199">Equilibrando definições `(?<`de grupo: *name1*`-`*name2* `>` *subexpressão*`)`.</span><span class="sxs-lookup"><span data-stu-id="7f135-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="7f135-200">Esse recurso permite que o mecanismo de expressões regulares controle constructos aninhados, como parênteses ou colchetes de abertura e fechamento.</span><span class="sxs-lookup"><span data-stu-id="7f135-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="7f135-201">Para ver um exemplo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7f135-202">Grupos atômicos: `(?>` *subexpressão*`)`.</span><span class="sxs-lookup"><span data-stu-id="7f135-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="7f135-203">Esse recurso permite que o mecanismo de retrocesso assegure que uma subexpressão corresponda apenas à primeira correspondência encontrada para ela, como se a expressão estivesse sendo executada independentemente da expressão que a contém.</span><span class="sxs-lookup"><span data-stu-id="7f135-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="7f135-204">Se você não usar esse constructo, as pesquisas de retrocesso de expressões maiores poderão alterar o comportamento de uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="7f135-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="7f135-205">Por exemplo, a `(a+)\w` expressão regular corresponde a um ou mais caracteres "a", juntamente com um caractere de palavra que segue a seqüência de caracteres "a" e atribui a seqüência de caracteres "a" ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7f135-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="7f135-206">No entanto, se o caractere final da seqüência de `\w` entrada também é um "a", ele é compatível com o elemento de idioma e não está incluído no grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="7f135-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="7f135-207">A expressão regular `((?>a+))\w` impede esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="7f135-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="7f135-208">Como todos os caracteres “a” consecutivos são correspondidos sem retrocesso, o primeiro grupo de captura inclui todos os caracteres “a” consecutivos.</span><span class="sxs-lookup"><span data-stu-id="7f135-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="7f135-209">Se os caracteres “a” não forem seguidos por pelo menos um caractere diferente de “a”, a correspondência falhará.</span><span class="sxs-lookup"><span data-stu-id="7f135-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="7f135-210">Para obter mais informações sobre grupos atômicos, consulte [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7f135-211">Correspondência da direita para a esquerda, que é especificada fornecendo a opção <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> para um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou um método de correspondência de instância estática.</span><span class="sxs-lookup"><span data-stu-id="7f135-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="7f135-212">Esse recurso é útil durante a pesquisa da direita para a esquerda em vez da esquerda para direita ou nos casos em que é mais eficiente iniciar uma correspondência na parte direita do padrão em vez de à esquerda.</span><span class="sxs-lookup"><span data-stu-id="7f135-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="7f135-213">Como mostra o exemplo a seguir, o uso da correspondência da direita para esquerda pode alterar o comportamento de quantificadores Greedy.</span><span class="sxs-lookup"><span data-stu-id="7f135-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="7f135-214">O exemplo realiza duas pesquisas por uma frase que termina em número.</span><span class="sxs-lookup"><span data-stu-id="7f135-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="7f135-215">A pesquisa da esquerda para a direita que usa o quantificador Greedy `+` corresponde a um dos seis dígitos na frase, enquanto a pesquisa da direita para a esquerda corresponde a todos os seis dígitos.</span><span class="sxs-lookup"><span data-stu-id="7f135-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="7f135-216">Para obter uma descrição do padrão de expressão regular, consulte o exemplo que ilustra quantificadores preguiçosos anteriormente nesta seção.</span><span class="sxs-lookup"><span data-stu-id="7f135-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="7f135-217">Para obter mais informações sobre a correspondência da direita para a esquerda, consulte [Opções de expressão regulares](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="7f135-218">Olhar positivo e `(?<=`negativo: *subexpressão* `)` para `(?<!`olhar positivo e *subexpressão* `)` para olhar negativo atrás.</span><span class="sxs-lookup"><span data-stu-id="7f135-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="7f135-219">Esse recurso é semelhante ao lookahead, que é discutido neste tópico.</span><span class="sxs-lookup"><span data-stu-id="7f135-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="7f135-220">Como o mecanismo de expressões regulares possibilita uma correspondência completa da direita para a esquerda, expressões regulares permitem lookbehinds irrestritos.</span><span class="sxs-lookup"><span data-stu-id="7f135-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="7f135-221">O lookbehind positivo e negativo também pode ser usado para evitar o aninhamento de quantificadores quando a subexpressão aninhada é um superconjunto de uma expressão externa.</span><span class="sxs-lookup"><span data-stu-id="7f135-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="7f135-222">Expressões regulares com tais quantificadores aninhados geralmente oferecem um desempenho ruim.</span><span class="sxs-lookup"><span data-stu-id="7f135-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="7f135-223">Por exemplo, o exemplo a seguir verifica se uma cadeia de caracteres começa e termina com um caractere alfanumérico e se qualquer outro caractere na cadeia de caracteres faz parte de um subconjunto maior.</span><span class="sxs-lookup"><span data-stu-id="7f135-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="7f135-224">Faz parte da expressão regular usada para validar endereços de email. Para obter mais informações, consulte [Como verificar se cadeias de caracteres estão em um formato de email válido](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="7f135-225">A expressão regular ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` é definida conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7f135-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7f135-226">Padrão</span><span class="sxs-lookup"><span data-stu-id="7f135-226">Pattern</span></span>|<span data-ttu-id="7f135-227">Descrição</span><span class="sxs-lookup"><span data-stu-id="7f135-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="7f135-228">Começar a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7f135-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="7f135-229">Corresponder a qualquer caractere numérico ou alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="7f135-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="7f135-230">(A comparação não diferencia maiúsculas de minúsculas.)</span><span class="sxs-lookup"><span data-stu-id="7f135-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="7f135-231">Corresponda a zero ou mais ocorrências de qualquer caractere de palavra, ou qualquer um \*dos seguintes caracteres: -, !, #, $, %, &, ', +, /, =, ?, ^, &#96;, {, }, &#124;, ou ~.</span><span class="sxs-lookup"><span data-stu-id="7f135-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="7f135-232">Olhar para o caractere anterior, que precisa ser numérico ou alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="7f135-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="7f135-233">(A comparação não diferencia maiúsculas de minúsculas.)</span><span class="sxs-lookup"><span data-stu-id="7f135-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="7f135-234">Encerrar a correspondência ao final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7f135-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="7f135-235">Para obter mais informações sobre lookbehind positivo e negativo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7f135-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="7f135-236">Artigos relacionados</span><span class="sxs-lookup"><span data-stu-id="7f135-236">Related articles</span></span>

|<span data-ttu-id="7f135-237">Title</span><span class="sxs-lookup"><span data-stu-id="7f135-237">Title</span></span>|<span data-ttu-id="7f135-238">Descrição</span><span class="sxs-lookup"><span data-stu-id="7f135-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="7f135-239">Retrocesso</span><span class="sxs-lookup"><span data-stu-id="7f135-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="7f135-240">Fornece informações sobre como o retrocesso de expressões regulares se ramifica para encontrar correspondências alternativas.</span><span class="sxs-lookup"><span data-stu-id="7f135-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="7f135-241">Compilação e reutilização</span><span class="sxs-lookup"><span data-stu-id="7f135-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="7f135-242">Fornece informações sobre a compilação e a reutilização de expressões regulares para aumentar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="7f135-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="7f135-243">Segurança de thread</span><span class="sxs-lookup"><span data-stu-id="7f135-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="7f135-244">Fornece informações sobre a segurança de thread de expressões regulares e explica quando você deve sincronizar o acesso a objetos de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7f135-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="7f135-245">Expressões regulares do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="7f135-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="7f135-246">Fornece uma visão geral sobre o aspecto de linguagem de programação das expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="7f135-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="7f135-247">O modelo de objeto de expressão regular</span><span class="sxs-lookup"><span data-stu-id="7f135-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="7f135-248">Oferece informações e exemplos de código que mostram como usar as classes de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7f135-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="7f135-249">Exemplos de expressão regular</span><span class="sxs-lookup"><span data-stu-id="7f135-249">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="7f135-250">Contém exemplos de código que mostram o uso de expressões regulares em aplicativos comuns.</span><span class="sxs-lookup"><span data-stu-id="7f135-250">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|
|[<span data-ttu-id="7f135-251">Linguagem de Expressão Regular - Referência Rápida</span><span class="sxs-lookup"><span data-stu-id="7f135-251">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="7f135-252">Oferece informações a respeito do conjunto de caracteres, operadores e constructos que você pode usar para definir expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="7f135-252">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="7f135-253">Referência</span><span class="sxs-lookup"><span data-stu-id="7f135-253">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
