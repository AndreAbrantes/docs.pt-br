---
title: Retrocesso em expressões regulares do .NET
description: Saiba como controlar o retrocesso na correspondência de padrões de expressão regular.
ms.date: 11/12/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET], backtracking
- strings [.NET], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.openlocfilehash: a15ef27f71eac9ed12889054283f8ac41d85922f
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94825241"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="4c114-103">Retrocesso em expressões regulares</span><span class="sxs-lookup"><span data-stu-id="4c114-103">Backtracking in Regular Expressions</span></span>
<span data-ttu-id="4c114-104">O retrocesso ocorre quando um padrão de expressão regular contém [quantificadores](quantifiers-in-regular-expressions.md) opcionais ou [constructos de alternância](alternation-constructs-in-regular-expressions.md) e o mecanismo de expressões regulares retorna a um estado salvo anterior para retomar sua pesquisa por uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](quantifiers-in-regular-expressions.md) or [alternation constructs](alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="4c114-105">O retrocesso é indispensável para o poder das expressões regulares, ele permite que as expressões sejam poderosas e flexíveis e correspondam a padrões muito complexos.</span><span class="sxs-lookup"><span data-stu-id="4c114-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="4c114-106">No entanto, todo esse poder tem um custo.</span><span class="sxs-lookup"><span data-stu-id="4c114-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="4c114-107">O retrocesso muitas vezes é o fator individual que mais afeta o desempenho do mecanismo de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="4c114-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="4c114-108">Felizmente, o desenvolvedor tem controle sobre o comportamento do mecanismo de expressões regulares e como ele usa o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="4c114-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="4c114-109">Este tópico explica como o retrocesso funciona e como ele pode ser controlado.</span><span class="sxs-lookup"><span data-stu-id="4c114-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4c114-110">Em geral, um mecanismo de NFA (Automação Finita Não Determinística), como o mecanismo de expressões regulares .NET, coloca a responsabilidade pela criação de expressões regulares eficientes e rápidas nas mãos do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="4c114-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  

## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="4c114-111">Comparação linear sem retrocesso</span><span class="sxs-lookup"><span data-stu-id="4c114-111">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="4c114-112">Se um padrão de expressão regular não tem quantificadores ou constructos de alternância opcionais, o mecanismo de expressões regulares é executado em tempo linear.</span><span class="sxs-lookup"><span data-stu-id="4c114-112">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="4c114-113">Ou seja, depois que o mecanismo de expressões regulares corresponde o primeiro elemento de linguagem no padrão com o texto da cadeia de caracteres de entrada, ele tenta corresponder o elemento de linguagem seguinte no padrão com o próximo caractere ou grupo de caracteres na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-113">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="4c114-114">Esse processo continuará até que a correspondência obtenha êxito ou falhe.</span><span class="sxs-lookup"><span data-stu-id="4c114-114">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="4c114-115">Em ambos os casos, o mecanismo de expressões regulares avança um caractere de cada vez na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-115">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="4c114-116">O exemplo a seguir ilustra esse cenário.</span><span class="sxs-lookup"><span data-stu-id="4c114-116">The following example provides an illustration.</span></span> <span data-ttu-id="4c114-117">A expressão regular `e{2}\w\b` procura duas ocorrências da letra “e” seguidas por qualquer caractere de palavra seguido por um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="4c114-117">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="4c114-118">Embora essa expressão regular inclua o quantificador `{2}`, ela é avaliada de uma maneira linear.</span><span class="sxs-lookup"><span data-stu-id="4c114-118">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="4c114-119">O mecanismo de expressões regulares não retrocede porque `{2}` não é um quantificador opcional, ele especifica um número exato e não um número variável de vezes que a subexpressão anterior deve corresponder.</span><span class="sxs-lookup"><span data-stu-id="4c114-119">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="4c114-120">Como resultado, o mecanismo de expressões regulares tenta corresponder o padrão da expressão regular com a cadeia de caracteres de entrada conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="4c114-120">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="4c114-121">Operação</span><span class="sxs-lookup"><span data-stu-id="4c114-121">Operation</span></span>|<span data-ttu-id="4c114-122">Posição no padrão</span><span class="sxs-lookup"><span data-stu-id="4c114-122">Position in pattern</span></span>|<span data-ttu-id="4c114-123">Posição na cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="4c114-123">Position in string</span></span>|<span data-ttu-id="4c114-124">Resultado</span><span class="sxs-lookup"><span data-stu-id="4c114-124">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="4c114-125">1</span><span class="sxs-lookup"><span data-stu-id="4c114-125">1</span></span>|<span data-ttu-id="4c114-126">e</span><span class="sxs-lookup"><span data-stu-id="4c114-126">e</span></span>|<span data-ttu-id="4c114-127">"needing a reed" (índice 0)</span><span class="sxs-lookup"><span data-stu-id="4c114-127">"needing a reed" (index 0)</span></span>|<span data-ttu-id="4c114-128">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-128">No match.</span></span>|  
|<span data-ttu-id="4c114-129">2</span><span class="sxs-lookup"><span data-stu-id="4c114-129">2</span></span>|<span data-ttu-id="4c114-130">e</span><span class="sxs-lookup"><span data-stu-id="4c114-130">e</span></span>|<span data-ttu-id="4c114-131">"eeding a reed" (índice 1)</span><span class="sxs-lookup"><span data-stu-id="4c114-131">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="4c114-132">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-132">Possible match.</span></span>|  
|<span data-ttu-id="4c114-133">3</span><span class="sxs-lookup"><span data-stu-id="4c114-133">3</span></span>|<span data-ttu-id="4c114-134">e{2}</span><span class="sxs-lookup"><span data-stu-id="4c114-134">e{2}</span></span>|<span data-ttu-id="4c114-135">"eding a reed" (índice 2)</span><span class="sxs-lookup"><span data-stu-id="4c114-135">"eding a reed" (index 2)</span></span>|<span data-ttu-id="4c114-136">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-136">Possible match.</span></span>|  
|<span data-ttu-id="4c114-137">4</span><span class="sxs-lookup"><span data-stu-id="4c114-137">4</span></span>|<span data-ttu-id="4c114-138">\w</span><span class="sxs-lookup"><span data-stu-id="4c114-138">\w</span></span>|<span data-ttu-id="4c114-139">"ding a reed" (índice 3)</span><span class="sxs-lookup"><span data-stu-id="4c114-139">"ding a reed" (index 3)</span></span>|<span data-ttu-id="4c114-140">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-140">Possible match.</span></span>|  
|<span data-ttu-id="4c114-141">5</span><span class="sxs-lookup"><span data-stu-id="4c114-141">5</span></span>|<span data-ttu-id="4c114-142">\b</span><span class="sxs-lookup"><span data-stu-id="4c114-142">\b</span></span>|<span data-ttu-id="4c114-143">"ing a reed" (índice 4)</span><span class="sxs-lookup"><span data-stu-id="4c114-143">"ing a reed" (index 4)</span></span>|<span data-ttu-id="4c114-144">Possível falha de correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-144">Possible match fails.</span></span>|  
|<span data-ttu-id="4c114-145">6</span><span class="sxs-lookup"><span data-stu-id="4c114-145">6</span></span>|<span data-ttu-id="4c114-146">e</span><span class="sxs-lookup"><span data-stu-id="4c114-146">e</span></span>|<span data-ttu-id="4c114-147">"eding a reed" (índice 2)</span><span class="sxs-lookup"><span data-stu-id="4c114-147">"eding a reed" (index 2)</span></span>|<span data-ttu-id="4c114-148">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-148">Possible match.</span></span>|  
|<span data-ttu-id="4c114-149">7</span><span class="sxs-lookup"><span data-stu-id="4c114-149">7</span></span>|<span data-ttu-id="4c114-150">e{2}</span><span class="sxs-lookup"><span data-stu-id="4c114-150">e{2}</span></span>|<span data-ttu-id="4c114-151">"ding a reed" (índice 3)</span><span class="sxs-lookup"><span data-stu-id="4c114-151">"ding a reed" (index 3)</span></span>|<span data-ttu-id="4c114-152">Possível falha de correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-152">Possible match fails.</span></span>|  
|<span data-ttu-id="4c114-153">8</span><span class="sxs-lookup"><span data-stu-id="4c114-153">8</span></span>|<span data-ttu-id="4c114-154">e</span><span class="sxs-lookup"><span data-stu-id="4c114-154">e</span></span>|<span data-ttu-id="4c114-155">"ding a reed" (índice 3)</span><span class="sxs-lookup"><span data-stu-id="4c114-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="4c114-156">Falha de correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-156">Match fails.</span></span>|  
|<span data-ttu-id="4c114-157">9</span><span class="sxs-lookup"><span data-stu-id="4c114-157">9</span></span>|<span data-ttu-id="4c114-158">e</span><span class="sxs-lookup"><span data-stu-id="4c114-158">e</span></span>|<span data-ttu-id="4c114-159">"ing a reed" (índice 4)</span><span class="sxs-lookup"><span data-stu-id="4c114-159">"ing a reed" (index 4)</span></span>|<span data-ttu-id="4c114-160">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-160">No match.</span></span>|  
|<span data-ttu-id="4c114-161">10</span><span class="sxs-lookup"><span data-stu-id="4c114-161">10</span></span>|<span data-ttu-id="4c114-162">e</span><span class="sxs-lookup"><span data-stu-id="4c114-162">e</span></span>|<span data-ttu-id="4c114-163">"ng a reed" (índice 5)</span><span class="sxs-lookup"><span data-stu-id="4c114-163">"ng a reed" (index 5)</span></span>|<span data-ttu-id="4c114-164">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-164">No match.</span></span>|  
|<span data-ttu-id="4c114-165">11</span><span class="sxs-lookup"><span data-stu-id="4c114-165">11</span></span>|<span data-ttu-id="4c114-166">e</span><span class="sxs-lookup"><span data-stu-id="4c114-166">e</span></span>|<span data-ttu-id="4c114-167">"g a reed" (índice 6)</span><span class="sxs-lookup"><span data-stu-id="4c114-167">"g a reed" (index 6)</span></span>|<span data-ttu-id="4c114-168">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-168">No match.</span></span>|  
|<span data-ttu-id="4c114-169">12</span><span class="sxs-lookup"><span data-stu-id="4c114-169">12</span></span>|<span data-ttu-id="4c114-170">e</span><span class="sxs-lookup"><span data-stu-id="4c114-170">e</span></span>|<span data-ttu-id="4c114-171">" a reed" (índice 7)</span><span class="sxs-lookup"><span data-stu-id="4c114-171">" a reed" (index 7)</span></span>|<span data-ttu-id="4c114-172">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-172">No match.</span></span>|  
|<span data-ttu-id="4c114-173">13</span><span class="sxs-lookup"><span data-stu-id="4c114-173">13</span></span>|<span data-ttu-id="4c114-174">e</span><span class="sxs-lookup"><span data-stu-id="4c114-174">e</span></span>|<span data-ttu-id="4c114-175">"a reed" (índice 8)</span><span class="sxs-lookup"><span data-stu-id="4c114-175">"a reed" (index 8)</span></span>|<span data-ttu-id="4c114-176">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-176">No match.</span></span>|  
|<span data-ttu-id="4c114-177">14</span><span class="sxs-lookup"><span data-stu-id="4c114-177">14</span></span>|<span data-ttu-id="4c114-178">e</span><span class="sxs-lookup"><span data-stu-id="4c114-178">e</span></span>|<span data-ttu-id="4c114-179">" reed" (índice 9)</span><span class="sxs-lookup"><span data-stu-id="4c114-179">" reed" (index 9)</span></span>|<span data-ttu-id="4c114-180">Nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-180">No match.</span></span>|  
|<span data-ttu-id="4c114-181">15</span><span class="sxs-lookup"><span data-stu-id="4c114-181">15</span></span>|<span data-ttu-id="4c114-182">e</span><span class="sxs-lookup"><span data-stu-id="4c114-182">e</span></span>|<span data-ttu-id="4c114-183">"reed" (índice 10)</span><span class="sxs-lookup"><span data-stu-id="4c114-183">"reed" (index 10)</span></span>|<span data-ttu-id="4c114-184">Nenhuma correspondência</span><span class="sxs-lookup"><span data-stu-id="4c114-184">No match</span></span>|  
|<span data-ttu-id="4c114-185">16</span><span class="sxs-lookup"><span data-stu-id="4c114-185">16</span></span>|<span data-ttu-id="4c114-186">e</span><span class="sxs-lookup"><span data-stu-id="4c114-186">e</span></span>|<span data-ttu-id="4c114-187">"eed" (índice 11)</span><span class="sxs-lookup"><span data-stu-id="4c114-187">"eed" (index 11)</span></span>|<span data-ttu-id="4c114-188">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-188">Possible match.</span></span>|  
|<span data-ttu-id="4c114-189">17</span><span class="sxs-lookup"><span data-stu-id="4c114-189">17</span></span>|<span data-ttu-id="4c114-190">e{2}</span><span class="sxs-lookup"><span data-stu-id="4c114-190">e{2}</span></span>|<span data-ttu-id="4c114-191">"ed" (índice 12)</span><span class="sxs-lookup"><span data-stu-id="4c114-191">"ed" (index 12)</span></span>|<span data-ttu-id="4c114-192">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-192">Possible match.</span></span>|  
|<span data-ttu-id="4c114-193">18</span><span class="sxs-lookup"><span data-stu-id="4c114-193">18</span></span>|<span data-ttu-id="4c114-194">\w</span><span class="sxs-lookup"><span data-stu-id="4c114-194">\w</span></span>|<span data-ttu-id="4c114-195">"d" (índice 13)</span><span class="sxs-lookup"><span data-stu-id="4c114-195">"d" (index 13)</span></span>|<span data-ttu-id="4c114-196">Possível correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-196">Possible match.</span></span>|  
|<span data-ttu-id="4c114-197">19</span><span class="sxs-lookup"><span data-stu-id="4c114-197">19</span></span>|<span data-ttu-id="4c114-198">\b</span><span class="sxs-lookup"><span data-stu-id="4c114-198">\b</span></span>|<span data-ttu-id="4c114-199">"" (índice 14)</span><span class="sxs-lookup"><span data-stu-id="4c114-199">"" (index 14)</span></span>|<span data-ttu-id="4c114-200">Correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-200">Match.</span></span>|  
  
 <span data-ttu-id="4c114-201">Se um padrão de expressão regular não inclui nenhum quantificador ou construtor de alternância opcional, o número máximo de comparações necessárias para corresponder ao padrão da expressão regular com a cadeia de caracteres de entrada é aproximadamente equivalente ao número de caracteres na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-201">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="4c114-202">Nesse caso, o mecanismo de expressões regulares usa 19 comparações para identificar possíveis correspondências nesta cadeia de 13 caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-202">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="4c114-203">Em outras palavras, o mecanismo de expressões regulares é executado em tempo quase linear se não contém quantificadores ou construtores de alternância opcionais.</span><span class="sxs-lookup"><span data-stu-id="4c114-203">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>

## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="4c114-204">Retrocesso com quantificadores opcionais ou construtores de alternância</span><span class="sxs-lookup"><span data-stu-id="4c114-204">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="4c114-205">Quando uma expressão regular inclui quantificadores ou construtores de alternância opcionais, a avaliação da cadeia de caracteres de entrada deixa de ser linear.</span><span class="sxs-lookup"><span data-stu-id="4c114-205">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="4c114-206">A correspondência de padrões com um mecanismo NFA é orientada pelos elementos de linguagem da expressão regular e não pelos caracteres a serem correspondidos na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-206">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="4c114-207">Assim, o mecanismo de expressões regulares tenta fazer a correspondência total de subexpressões opcionais ou alternativas.</span><span class="sxs-lookup"><span data-stu-id="4c114-207">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="4c114-208">Quando ele avança para o elemento de linguagem seguinte na subexpressão e a correspondência falha, o mecanismo de expressões regulares pode abandonar uma parte de sua correspondência bem-sucedida e retornar a um estado salvo anteriormente com o objetivo de corresponder a expressão regular inteira com a cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-208">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="4c114-209">Esse processo de retornar a um estado salvo anterior para localizar uma correspondência é conhecido como o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="4c114-209">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="4c114-210">Por exemplo, considere o padrão de expressão regular `.*(es)`, o qual corresponde os caracteres “es” e todos os caracteres que os precedem.</span><span class="sxs-lookup"><span data-stu-id="4c114-210">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="4c114-211">Como mostra o exemplo a seguir, se a cadeia de caracteres de entrada é "Essential services are provided by regular expressions." (Serviços essenciais são fornecidos por expressões regulares.), o padrão corresponde a cadeia de caracteres até o “es” (inclusive) em "expressions”.</span><span class="sxs-lookup"><span data-stu-id="4c114-211">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="4c114-212">Para fazer isso, o mecanismo de expressões regulares usa o retrocesso da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="4c114-212">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="4c114-213">Ele corresponde o `.*` (que corresponde a zero, uma ou mais ocorrências de qualquer caractere) com a cadeia de caracteres de entrada inteira.</span><span class="sxs-lookup"><span data-stu-id="4c114-213">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="4c114-214">Ele tenta corresponder “e” no padrão da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="4c114-214">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="4c114-215">No entanto, a cadeia de caracteres de entrada não tem nenhum caractere restante disponível para corresponder.</span><span class="sxs-lookup"><span data-stu-id="4c114-215">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="4c114-216">Ele retrocede para sua última correspondência bem-sucedida, "Essential services are provided by regular expressions", e tenta corresponder “e” com o ponto no final da frase.</span><span class="sxs-lookup"><span data-stu-id="4c114-216">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="4c114-217">A correspondência falha.</span><span class="sxs-lookup"><span data-stu-id="4c114-217">The match fails.</span></span>  
  
- <span data-ttu-id="4c114-218">Ele continua a retroceder para uma correspondência bem-sucedida anterior um caractere de cada vez até que a subcadeia de caracteres provisória correspondente seja “Essential services are provided by regular expr".</span><span class="sxs-lookup"><span data-stu-id="4c114-218">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="4c114-219">Ele então compara o “e” no padrão com o segundo “e” em “expressions” e encontra uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-219">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="4c114-220">Ele compara o “s” no padrão com o “s” após o caractere “e” que já foi correspondido (o primeiro “s” em “expressions”).</span><span class="sxs-lookup"><span data-stu-id="4c114-220">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="4c114-221">A correspondência é bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="4c114-221">The match is successful.</span></span>  
  
 <span data-ttu-id="4c114-222">Quando o retrocesso é usado, corresponder o padrão de expressão regular com a cadeia de caracteres de entrada, que tem 55 caracteres de comprimento, requer 67 operações de comparação.</span><span class="sxs-lookup"><span data-stu-id="4c114-222">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="4c114-223">Geralmente, se um padrão de expressão regular tem um único constructo de alternância ou um único quantificador opcional, o número de operações de comparação necessárias para corresponder ao padrão é mais que duas vezes maior do que o número de caracteres na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-223">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>

## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="4c114-224">Retrocesso com quantificadores opcionais aninhados</span><span class="sxs-lookup"><span data-stu-id="4c114-224">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="4c114-225">O número de operações de comparação necessárias para corresponder a um padrão de expressão regular pode aumentar exponencialmente se o padrão inclui um grande número de construtores de alternância, se ele inclui construtores de alternância aninhados ou, mais comumente, se ele inclui quantificadores opcionais aninhados.</span><span class="sxs-lookup"><span data-stu-id="4c114-225">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="4c114-226">Por exemplo, o padrão de expressão regular `^(a+)+$` foi criado para corresponder a uma cadeia de caracteres completa que contém um ou mais caracteres “a”.</span><span class="sxs-lookup"><span data-stu-id="4c114-226">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="4c114-227">O exemplo fornece duas cadeias de caracteres de entrada de comprimento idêntico, mas somente a primeira cadeia de caracteres corresponde ao padrão.</span><span class="sxs-lookup"><span data-stu-id="4c114-227">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="4c114-228">A classe <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> é usada para determinar a duração da operação de correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-228">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="4c114-229">Como a saída do exemplo mostra, o mecanismo de expressões regulares demora aproximadamente duas vezes mais tempo para descobrir que uma cadeia de caracteres de entrada não correspondeu ao padrão do que o tempo que foi necessário para identificar uma cadeia de caracteres compatível.</span><span class="sxs-lookup"><span data-stu-id="4c114-229">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="4c114-230">Isso acontece porque uma correspondência malsucedida sempre representa um cenário de pior caso.</span><span class="sxs-lookup"><span data-stu-id="4c114-230">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="4c114-231">O mecanismo de expressões regulares deve usar a expressão regular para seguir todos os caminhos possíveis através dos dados antes de concluir que a correspondência falhou e os parênteses aninhados criam vários caminhos adicionais nos dados.</span><span class="sxs-lookup"><span data-stu-id="4c114-231">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="4c114-232">O mecanismo de expressões regulares conclui que a segunda cadeia de caracteres não correspondeu ao padrão ao fazer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="4c114-232">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="4c114-233">Ele verifica que estava no início da cadeia de caracteres e então corresponde os primeiros cinco caracteres da cadeia de caracteres com o padrão `a+`.</span><span class="sxs-lookup"><span data-stu-id="4c114-233">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="4c114-234">Ele então determina que não há grupos adicionais de caracteres “a” na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-234">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="4c114-235">Finalmente, ele testa o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-235">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="4c114-236">Como um caractere adicional permanece na cadeia de caracteres, a correspondência falha.</span><span class="sxs-lookup"><span data-stu-id="4c114-236">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="4c114-237">Essa correspondência com falha requer 9 comparações.</span><span class="sxs-lookup"><span data-stu-id="4c114-237">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="4c114-238">O mecanismo de expressões regulares também salva as informações de estado de suas correspondências de “a” (as quais chamaremos a correspondência 1), "aa” (correspondência 2), "aaa" (correspondência 3) e “aaaa" (correspondência 4).</span><span class="sxs-lookup"><span data-stu-id="4c114-238">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="4c114-239">Ele retorna à correspondência 4 salva anteriormente.</span><span class="sxs-lookup"><span data-stu-id="4c114-239">It returns to the previously saved match 4.</span></span> <span data-ttu-id="4c114-240">Ele determina que há um caractere adicional “a” a ser atribuído a um grupo capturado adicional.</span><span class="sxs-lookup"><span data-stu-id="4c114-240">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="4c114-241">Finalmente, ele testa o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="4c114-242">Como um caractere adicional permanece na cadeia de caracteres, a correspondência falha.</span><span class="sxs-lookup"><span data-stu-id="4c114-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="4c114-243">Essa correspondência com falha requer 4 comparações.</span><span class="sxs-lookup"><span data-stu-id="4c114-243">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="4c114-244">Até agora, foi executado um total de 13 comparações.</span><span class="sxs-lookup"><span data-stu-id="4c114-244">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="4c114-245">Ele retorna à correspondência 3 salva anteriormente.</span><span class="sxs-lookup"><span data-stu-id="4c114-245">It returns to the previously saved match 3.</span></span> <span data-ttu-id="4c114-246">Ele determina que há dois caracteres adicionais “a” a serem atribuídos a um grupo capturado adicional.</span><span class="sxs-lookup"><span data-stu-id="4c114-246">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="4c114-247">No entanto, o teste de fim da cadeia de caracteres falha.</span><span class="sxs-lookup"><span data-stu-id="4c114-247">However, the end-of-string test fails.</span></span> <span data-ttu-id="4c114-248">Ele então retorna para a correspondência 3 e tenta corresponder os dois caracteres adicionais “a” em dois grupos capturados adicionais.</span><span class="sxs-lookup"><span data-stu-id="4c114-248">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="4c114-249">No entanto, o teste de fim da cadeia de caracteres continua a falhar.</span><span class="sxs-lookup"><span data-stu-id="4c114-249">The end-of-string test still fails.</span></span> <span data-ttu-id="4c114-250">Essas correspondências com falha exigem 12 comparações.</span><span class="sxs-lookup"><span data-stu-id="4c114-250">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="4c114-251">Até agora, foi executado um total de 25 comparações.</span><span class="sxs-lookup"><span data-stu-id="4c114-251">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="4c114-252">A comparação de cadeia de caracteres de entrada com a expressão regular continuará dessa forma até que o mecanismo de expressão regular tente todas as combinações possíveis de correspondências e conclua que não há nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-252">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="4c114-253">Devido aos quantificadores aninhados, essa comparação é O(2 <sup>n</sup>) ou uma operação exponencial, em que *n* é o número de caracteres na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-253">Because of the nested quantifiers, this comparison is an O(2 <sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="4c114-254">Isso significa que, no pior caso, uma cadeia de caracteres de entrada com 30 caracteres requer aproximadamente 1.073.741.824 comparações e uma cadeia de caracteres de entrada com 40 caracteres requer aproximadamente 1.099.511.627.776 comparações.</span><span class="sxs-lookup"><span data-stu-id="4c114-254">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="4c114-255">Se você usar cadeias de caracteres com esses tamanhos ou até mesmo com tamanhos maiores, os métodos de expressões regulares poderão demorar um tempo extremamente longo para terminar ao processarem uma entrada que não correspondam ao padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="4c114-255">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>

## <a name="controlling-backtracking"></a><span data-ttu-id="4c114-256">Controlando o retrocesso</span><span class="sxs-lookup"><span data-stu-id="4c114-256">Controlling Backtracking</span></span>  
 <span data-ttu-id="4c114-257">O retrocesso permite a você criar expressões regulares avançadas e flexíveis.</span><span class="sxs-lookup"><span data-stu-id="4c114-257">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="4c114-258">No entanto, conforme mostrado na seção anterior, esses benefícios podem estar associados a um baixo desempenho inaceitável.</span><span class="sxs-lookup"><span data-stu-id="4c114-258">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="4c114-259">Para evitar o retrocesso excessivo, você deve definir um intervalo de tempo limite no qual você criará uma instância de um objeto <xref:System.Text.RegularExpressions.Regex> ou chamará um método de correspondência de expressão regular estático.</span><span class="sxs-lookup"><span data-stu-id="4c114-259">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="4c114-260">Isso é abordado na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="4c114-260">This is discussed in the next section.</span></span> <span data-ttu-id="4c114-261">Além disso, o .NET dá suporte a três elementos de linguagem de expressão regular que limitam ou suprimem o retrocesso e que dão suporte a expressões regulares complexas com pouca ou nenhuma penalidade de desempenho: [grupos atômicos](#atomic-groups), [asserções lookbehind](#lookbehind-assertions)e [declarações de lookahead](#lookahead-assertions).</span><span class="sxs-lookup"><span data-stu-id="4c114-261">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [atomic groups](#atomic-groups), [lookbehind assertions](#lookbehind-assertions), and [lookahead assertions](#lookahead-assertions).</span></span> <span data-ttu-id="4c114-262">Para saber mais sobre cada elemento de linguagem, consulte [Constructos de agrupamento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="4c114-262">For more information about each language element, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>  

### <a name="defining-a-time-out-interval"></a><span data-ttu-id="4c114-263">Definindo um intervalo de tempo limite</span><span class="sxs-lookup"><span data-stu-id="4c114-263">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="4c114-264">Do .NET Framework 4.5 em diante, você pode definir um valor de tempo limite que representa o intervalo mais longo durante o qual o mecanismo de expressão regular pesquisará uma única correspondência antes de abandonar a tentativa e gerar uma exceção <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="4c114-264">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="4c114-265">Você especifica o intervalo de tempo limite ao fornecer um valor de <xref:System.TimeSpan> para o construtor <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> para instanciar expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="4c114-265">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor for instance regular expressions.</span></span> <span data-ttu-id="4c114-266">Além disso, cada método de correspondência de padrão estático tem uma sobrecarga com um parâmetro <xref:System.TimeSpan> que permite a você especificar um valor de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="4c114-266">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="4c114-267">Por padrão, o intervalo de tempo limite é definido para <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, o que significa que o mecanismo de expressões regulares nunca excede o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="4c114-267">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="4c114-268">É recomendável sempre definir um intervalo de tempo limite se a sua expressão regular depende de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="4c114-268">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="4c114-269">Uma exceção <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> indica que o mecanismo de expressões regulares não pôde localizar uma correspondência dentro do intervalo de tempo limite especificado, mas não indica como a exceção foi gerada.</span><span class="sxs-lookup"><span data-stu-id="4c114-269">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="4c114-270">O motivo poderia ser o retrocesso excessivo, mas também é possível que o intervalo de tempo limite tenha sido definido como um valor muito baixo considerando a carga do sistema no momento em que a exceção foi gerada.</span><span class="sxs-lookup"><span data-stu-id="4c114-270">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="4c114-271">Ao tratar a exceção, você pode escolher entre abandonar as correspondências adicionais com a cadeia de caracteres de entrada ou aumentar o intervalo de tempo limite e repetir a operação de correspondência.</span><span class="sxs-lookup"><span data-stu-id="4c114-271">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="4c114-272">Por exemplo, o código a seguir chama o construtor <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> para criar uma instância de um objeto <xref:System.Text.RegularExpressions.Regex> com um valor de tempo limite de um segundo.</span><span class="sxs-lookup"><span data-stu-id="4c114-272">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="4c114-273">O padrão de expressão regular `(a+)+$`, que faz a correspondência de uma ou várias sequências de um ou mais caracteres de “a” no final de uma linha, está sujeito ao retrocesso excessivo.</span><span class="sxs-lookup"><span data-stu-id="4c114-273">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="4c114-274">Se <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> gerada, o exemplo aumenta o valor do tempo limite até um intervalo máximo de três segundos.</span><span class="sxs-lookup"><span data-stu-id="4c114-274">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="4c114-275">Depois disso, ele abandona a tentativa de corresponder o padrão.</span><span class="sxs-lookup"><span data-stu-id="4c114-275">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  

### <a name="atomic-groups"></a><span data-ttu-id="4c114-276">Grupos atômicos</span><span class="sxs-lookup"><span data-stu-id="4c114-276">Atomic groups</span></span>
 <span data-ttu-id="4c114-277">O `(?>` elemento de linguagem de *subexpressão* `)` suprime a retrocesso na subexpressão.</span><span class="sxs-lookup"><span data-stu-id="4c114-277">The `(?>` *subexpression*`)` language element suppresses backtracking into the subexpression.</span></span> <span data-ttu-id="4c114-278">Depois que ele for correspondido com êxito, ele não resultará em nenhuma parte de sua correspondência para o retrocesso posterior.</span><span class="sxs-lookup"><span data-stu-id="4c114-278">Once it has successfully matched, it will not give up any part of its match to subsequent backtracking.</span></span> <span data-ttu-id="4c114-279">Por exemplo, no padrão `(?>\w*\d*)1` , se o `1` não puder ser correspondido, o não resultará em `\d*` nenhuma de suas correspondências, mesmo que isso signifique que isso permitiria que a `1` correspondência fosse bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="4c114-279">For example, in the pattern `(?>\w*\d*)1`, if the `1` cannot be matched, the `\d*` will not give up any of its match even if that means it would allow the `1` to successfully match.</span></span> <span data-ttu-id="4c114-280">Os grupos atômicos podem ajudar a evitar os problemas de desempenho associados às correspondências com falha.</span><span class="sxs-lookup"><span data-stu-id="4c114-280">Atomic groups can help prevent the performance problems associated with failed matches.</span></span>
  
 <span data-ttu-id="4c114-281">O exemplo a seguir ilustra como suprimir o retrocesso melhora o desempenho quando quantificadores aninhados são usados.</span><span class="sxs-lookup"><span data-stu-id="4c114-281">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="4c114-282">Ele mede o tempo necessário para que o mecanismo de expressão regular determine que uma cadeia de caracteres de entrada não corresponde a duas expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="4c114-282">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="4c114-283">A primeira expressão regular usa o retrocesso para tentar corresponder uma cadeia de caracteres que contém uma ou mais ocorrências de um ou mais dígitos hexadecimais, seguidos por dois-pontos, seguido por um ou mais dígitos hexadecimais, seguidos por dois dois-pontos.</span><span class="sxs-lookup"><span data-stu-id="4c114-283">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="4c114-284">A segunda expressão regular é idêntica à primeira, exceto que ela desabilita o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="4c114-284">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="4c114-285">Como a saída do exemplo mostra, a melhora do desempenho resultante da desabilitação do retrocesso é significativa.</span><span class="sxs-lookup"><span data-stu-id="4c114-285">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  

### <a name="lookbehind-assertions"></a><span data-ttu-id="4c114-286">Asserções lookbehind</span><span class="sxs-lookup"><span data-stu-id="4c114-286">Lookbehind Assertions</span></span>  
 <span data-ttu-id="4c114-287">O .NET inclui dois elementos de linguagem, `(?<=` *subexpressão* `)` e `(?<!` *subexpressão* `)` , que correspondem ao caractere ou caracteres anteriores na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-287">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="4c114-288">Ambos os elementos de linguagem são asserções de largura zero, ou seja, eles determinam se o caractere ou os caracteres que precedem imediatamente o caractere atual podem ser correspondidos pela *subexpressão*, sem avanço ou retrocesso.</span><span class="sxs-lookup"><span data-stu-id="4c114-288">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="4c114-289">`(?<=`*subexpressão* `)` é uma asserção lookbehind positiva; ou seja, o caractere ou os caracteres antes da posição atual devem corresponder à *subexpressão*.</span><span class="sxs-lookup"><span data-stu-id="4c114-289">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="4c114-290">`(?<!`*subexpressão* `)` é uma asserção lookbehind negativa; ou seja, o caractere ou os caracteres antes da posição atual não devem corresponder à *subexpressão*.</span><span class="sxs-lookup"><span data-stu-id="4c114-290">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="4c114-291">As asserções lookbehind positivas e negativas são mais úteis quando a *subexpressão* é um subconjunto da subexpressão anterior.</span><span class="sxs-lookup"><span data-stu-id="4c114-291">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="4c114-292">O exemplo a seguir usa dois padrões equivalentes à expressão regular que validam o nome de usuário em um endereço de email.</span><span class="sxs-lookup"><span data-stu-id="4c114-292">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="4c114-293">O primeiro padrão está sujeito a baixo desempenho devido ao retrocesso excessivo.</span><span class="sxs-lookup"><span data-stu-id="4c114-293">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="4c114-294">O segundo padrão modifica a primeira expressão regular ao substituir um quantificador aninhado por uma asserção lookbehind positiva.</span><span class="sxs-lookup"><span data-stu-id="4c114-294">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="4c114-295">A saída do exemplo exibe, o tempo de execução do método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c114-295">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="4c114-296">O primeiro padrão de expressão regular, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, é definido como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="4c114-296">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="4c114-297">Padrão</span><span class="sxs-lookup"><span data-stu-id="4c114-297">Pattern</span></span>|<span data-ttu-id="4c114-298">Descrição</span><span class="sxs-lookup"><span data-stu-id="4c114-298">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="4c114-299">Começa a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-299">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="4c114-300">Corresponde a um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="4c114-300">Match an alphanumeric character.</span></span> <span data-ttu-id="4c114-301">Essa comparação não diferencia maiúsculas de minúsculas porque o método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c114-301">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="4c114-302">Corresponde a zero, uma ou mais ocorrências de um hífen, ponto ou caractere de palavra.</span><span class="sxs-lookup"><span data-stu-id="4c114-302">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="4c114-303">Corresponde a um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="4c114-303">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="4c114-304">Corresponde a zero ou mais ocorrências da combinação de zero ou mais hífens, pontos ou caracteres de palavra, seguidos por um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="4c114-304">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="4c114-305">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="4c114-305">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="4c114-306">Corresponde a um sinal ("\@").</span><span class="sxs-lookup"><span data-stu-id="4c114-306">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="4c114-307">O segundo padrão de expressão regular, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, usa uma asserção lookbehind positiva.</span><span class="sxs-lookup"><span data-stu-id="4c114-307">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="4c114-308">Ele é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="4c114-308">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="4c114-309">Padrão</span><span class="sxs-lookup"><span data-stu-id="4c114-309">Pattern</span></span>|<span data-ttu-id="4c114-310">Descrição</span><span class="sxs-lookup"><span data-stu-id="4c114-310">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="4c114-311">Começa a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-311">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="4c114-312">Corresponde a um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="4c114-312">Match an alphanumeric character.</span></span> <span data-ttu-id="4c114-313">Essa comparação não diferencia maiúsculas de minúsculas porque o método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c114-313">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="4c114-314">Corresponde a zero ou mais ocorrências de um hífen, ponto ou caractere de palavra.</span><span class="sxs-lookup"><span data-stu-id="4c114-314">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="4c114-315">Examina de volta o último caractere correspondente e continua a correspondência se ele é alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="4c114-315">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="4c114-316">Observe que os caracteres alfanuméricos são um subconjunto do conjunto que consiste em pontos, hífens e todos os caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="4c114-316">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="4c114-317">Corresponde a um sinal ("\@").</span><span class="sxs-lookup"><span data-stu-id="4c114-317">Match an at sign ("\@").</span></span>|  

### <a name="lookahead-assertions"></a><span data-ttu-id="4c114-318">Asserções lookahead</span><span class="sxs-lookup"><span data-stu-id="4c114-318">Lookahead Assertions</span></span>  
 <span data-ttu-id="4c114-319">O .NET inclui dois elementos de linguagem, `(?=` *subexpressão* `)` e `(?!` *subexpressão* `)` , que correspondem ao próximo caractere ou caracteres na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-319">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="4c114-320">Ambos os elementos de linguagem são asserções de largura zero, ou seja, eles determinam se o caractere ou os caracteres que seguem imediatamente o caractere atual podem ser correspondidos pela *subexpressão*, sem avanço ou retrocesso.</span><span class="sxs-lookup"><span data-stu-id="4c114-320">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="4c114-321">`(?=`*subexpressão* `)` é uma asserção de antecipação positiva; ou seja, o caractere ou os caracteres após a posição atual devem corresponder à *subexpressão*.</span><span class="sxs-lookup"><span data-stu-id="4c114-321">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="4c114-322">`(?!`*subexpressão* `)` é uma asserção de antecipação negativa; ou seja, o caractere ou os caracteres após a posição atual não devem corresponder à *subexpressão*.</span><span class="sxs-lookup"><span data-stu-id="4c114-322">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="4c114-323">As declarações de lookahead positiva e negativa são mais úteis quando a *subexpressão* é um subconjunto da próxima subexpressão.</span><span class="sxs-lookup"><span data-stu-id="4c114-323">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="4c114-324">O exemplo a seguir usa dois padrões de expressão regular equivalentes que validam um nome de tipo totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="4c114-324">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="4c114-325">O primeiro padrão está sujeito a baixo desempenho devido ao retrocesso excessivo.</span><span class="sxs-lookup"><span data-stu-id="4c114-325">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="4c114-326">O segundo modifica a primeira expressão regular ao substituir um quantificador aninhado por uma asserção lookahead positiva.</span><span class="sxs-lookup"><span data-stu-id="4c114-326">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="4c114-327">A saída do exemplo exibe, o tempo de execução do método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c114-327">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="4c114-328">O primeiro padrão de expressão regular, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, é definido como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="4c114-328">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="4c114-329">Padrão</span><span class="sxs-lookup"><span data-stu-id="4c114-329">Pattern</span></span>|<span data-ttu-id="4c114-330">Descrição</span><span class="sxs-lookup"><span data-stu-id="4c114-330">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="4c114-331">Começa a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-331">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="4c114-332">Corresponde a um caractere alfabético (A-Z) seguido por zero ou mais caracteres de palavra uma ou mais vezes, seguidos de um ponto.</span><span class="sxs-lookup"><span data-stu-id="4c114-332">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="4c114-333">Essa comparação não diferencia maiúsculas de minúsculas porque o método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c114-333">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="4c114-334">Corresponde ao padrão anterior zero vezes ou mais.</span><span class="sxs-lookup"><span data-stu-id="4c114-334">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="4c114-335">Corresponder a um caractere alfabético seguido por zero ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="4c114-335">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="4c114-336">Finalizar a correspondência no final da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-336">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="4c114-337">O segundo padrão de expressão regular, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, usa uma asserção lookahead positiva.</span><span class="sxs-lookup"><span data-stu-id="4c114-337">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="4c114-338">Ele é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="4c114-338">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="4c114-339">Padrão</span><span class="sxs-lookup"><span data-stu-id="4c114-339">Pattern</span></span>|<span data-ttu-id="4c114-340">Descrição</span><span class="sxs-lookup"><span data-stu-id="4c114-340">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="4c114-341">Começa a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4c114-341">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="4c114-342">Examine além do primeiro caractere e continue a correspondência se ele for alfabético (A-Z).</span><span class="sxs-lookup"><span data-stu-id="4c114-342">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="4c114-343">Essa comparação não diferencia maiúsculas de minúsculas porque o método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c114-343">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="4c114-344">Corresponde a um ou mais caracteres de palavra seguidos por um ponto.</span><span class="sxs-lookup"><span data-stu-id="4c114-344">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="4c114-345">Corresponde ao padrão de um ou mais caracteres de palavra seguidos por um ponto zero ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="4c114-345">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="4c114-346">O caractere de palavra inicial deve ser alfabético.</span><span class="sxs-lookup"><span data-stu-id="4c114-346">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="4c114-347">Corresponder a um caractere alfabético seguido por zero ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="4c114-347">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="4c114-348">Finalizar a correspondência no final da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c114-348">End the match at the end of the input string.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="4c114-349">Confira também</span><span class="sxs-lookup"><span data-stu-id="4c114-349">See also</span></span>

- [<span data-ttu-id="4c114-350">Expressões regulares do .NET</span><span class="sxs-lookup"><span data-stu-id="4c114-350">.NET Regular Expressions</span></span>](regular-expressions.md)
- [<span data-ttu-id="4c114-351">Linguagem de expressões regulares – referência rápida</span><span class="sxs-lookup"><span data-stu-id="4c114-351">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="4c114-352">Quantificadores</span><span class="sxs-lookup"><span data-stu-id="4c114-352">Quantifiers</span></span>](quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="4c114-353">Constructos de alternância</span><span class="sxs-lookup"><span data-stu-id="4c114-353">Alternation Constructs</span></span>](alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="4c114-354">Constructos de agrupamento</span><span class="sxs-lookup"><span data-stu-id="4c114-354">Grouping Constructs</span></span>](grouping-constructs-in-regular-expressions.md)
