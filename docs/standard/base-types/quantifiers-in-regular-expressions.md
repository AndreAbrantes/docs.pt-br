---
title: Quantificadores em expressões regulares
description: Saiba mais sobre quantificadores de expressão regular, que especificam quantas instâncias de um caractere, grupo ou classe de caractere devem estar presentes na entrada para correspondência.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: 75d37527507b596d6017171279e84b8348489831
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95733575"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="11f7f-103">Quantificadores em expressões regulares</span><span class="sxs-lookup"><span data-stu-id="11f7f-103">Quantifiers in Regular Expressions</span></span>

<span data-ttu-id="11f7f-104">Os quantificadores especificam quantas instâncias de um caractere, grupo ou classe de caracteres devem estar presentes na entrada para encontrar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="11f7f-104">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="11f7f-105">A tabela a seguir lista os quantificadores tem suporte no .NET.</span><span class="sxs-lookup"><span data-stu-id="11f7f-105">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="11f7f-106">Quantificador Greedy</span><span class="sxs-lookup"><span data-stu-id="11f7f-106">Greedy quantifier</span></span>|<span data-ttu-id="11f7f-107">Quantificador lento</span><span class="sxs-lookup"><span data-stu-id="11f7f-107">Lazy quantifier</span></span>|<span data-ttu-id="11f7f-108">DESCRIÇÃO</span><span class="sxs-lookup"><span data-stu-id="11f7f-108">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="11f7f-109">Corresponder a zero ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-109">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="11f7f-110">Corresponder a um ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-110">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="11f7f-111">Corresponder a zero ou uma vez.</span><span class="sxs-lookup"><span data-stu-id="11f7f-111">Match zero or one time.</span></span>|  
|<span data-ttu-id="11f7f-112">`{`*n*`}`</span><span class="sxs-lookup"><span data-stu-id="11f7f-112">`{` *n* `}`</span></span>|<span data-ttu-id="11f7f-113">`{`*n*`}?`</span><span class="sxs-lookup"><span data-stu-id="11f7f-113">`{` *n* `}?`</span></span>|<span data-ttu-id="11f7f-114">Corresponder exatamente *n* vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-114">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="11f7f-115">`{`*n*`,}`</span><span class="sxs-lookup"><span data-stu-id="11f7f-115">`{` *n* `,}`</span></span>|<span data-ttu-id="11f7f-116">`{`*n*`,}?`</span><span class="sxs-lookup"><span data-stu-id="11f7f-116">`{` *n* `,}?`</span></span>|<span data-ttu-id="11f7f-117">Corresponder pelo menos *n* vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-117">Match at least *n* times.</span></span>|  
|<span data-ttu-id="11f7f-118">`{`*n* `,` *m*`}`</span><span class="sxs-lookup"><span data-stu-id="11f7f-118">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="11f7f-119">`{`*n* `,` *m*`}?`</span><span class="sxs-lookup"><span data-stu-id="11f7f-119">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="11f7f-120">Corresponder de *n* a *m* vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-120">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="11f7f-121">As quantidades `n` e `m` são constantes inteiras.</span><span class="sxs-lookup"><span data-stu-id="11f7f-121">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="11f7f-122">Normalmente, os quantificadores são Greedy; eles fazem com que o mecanismo de expressões regulares corresponda a quantas ocorrências de padrões determinados forem possíveis.</span><span class="sxs-lookup"><span data-stu-id="11f7f-122">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="11f7f-123">Acrescentar o caractere `?` a um quantificador o torna lento; faz com que o mecanismo de expressões regulares corresponda ao mínimo de ocorrências possíveis.</span><span class="sxs-lookup"><span data-stu-id="11f7f-123">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="11f7f-124">Para obter uma descrição completa da diferença entre quantificadores Greedy e lentos, consulte a seção [Quantificadores Greedy e lentos](#Greedy) mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="11f7f-124">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="11f7f-125">O aninhamento de quantificadores (por exemplo, como o padrão de expressão regular `(a*)*` faz) pode aumentar o número de comparações que o mecanismo de expressões regulares deve executar, como uma função exponencial do número de caracteres na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="11f7f-125">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="11f7f-126">Para saber mais sobre esse comportamento e suas soluções, veja [Retrocesso](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11f7f-126">For more information about this behavior and its workarounds, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="11f7f-127">Quantificadores em expressões regulares</span><span class="sxs-lookup"><span data-stu-id="11f7f-127">Regular Expression Quantifiers</span></span>  

 <span data-ttu-id="11f7f-128">As seções a seguir listam os quantificadores com suporte nas expressões regulares no .NET.</span><span class="sxs-lookup"><span data-stu-id="11f7f-128">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="11f7f-129">Se os caracteres \*, +, ?, { e } forem encontrados em um padrão de expressão regular, o mecanismo de expressões regulares vai interpretá-los como quantificadores ou parte de constructos de quantificador, exceto se estiverem incluídos em uma [classe de caracteres](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11f7f-129">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="11f7f-130">Para interpretá-los como caracteres literais fora de uma classe de caracteres, você precisa fazer o escape, antecedendo-os com uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="11f7f-130">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="11f7f-131">Por exemplo, a cadeia de caracteres `\*` em um padrão de expressão regular é interpretada como um caractere asterisco ("\*") integral.</span><span class="sxs-lookup"><span data-stu-id="11f7f-131">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="11f7f-132">Corresponder a zero ou mais vezes: \*</span><span class="sxs-lookup"><span data-stu-id="11f7f-132">Match Zero or More Times: \*</span></span>  

 <span data-ttu-id="11f7f-133">O quantificador `*` corresponde ao elemento anterior zero ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-133">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="11f7f-134">É equivalente ao quantificador `{0,}`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-134">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="11f7f-135">`*` é um quantificador Greedy, cujo equivalente lento é `*?`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-135">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="11f7f-136">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-136">The following example illustrates this regular expression.</span></span> <span data-ttu-id="11f7f-137">Dos nove grupos de dígitos na cadeia de caracteres de entrada, cinco correspondem ao padrão e quatro ( `95` , `929` , `9219` e `9919` ) não.</span><span class="sxs-lookup"><span data-stu-id="11f7f-137">Of the nine digit groups in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="11f7f-138">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-138">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-139">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-139">Pattern</span></span>|<span data-ttu-id="11f7f-140">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-140">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-141">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-141">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="11f7f-142">Corresponder a “9” seguido por zero ou mais caracteres “1”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-142">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="11f7f-143">Corresponder a zero ou mais caracteres “9”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-143">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-144">Terminar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-144">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="11f7f-145">Corresponder a um ou mais vezes: +</span><span class="sxs-lookup"><span data-stu-id="11f7f-145">Match One or More Times: +</span></span>  

 <span data-ttu-id="11f7f-146">O quantificador `+` corresponde ao elemento anterior uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-146">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="11f7f-147">É equivalente a `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-147">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="11f7f-148">`+` é um quantificador Greedy, cujo equivalente lento é `+?`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-148">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="11f7f-149">Por exemplo, a expressão regular `\ban+\w*?\b` tenta corresponder a palavras inteiras que começam com a letra `a` seguidas por uma ou mais instâncias da letra `n`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-149">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="11f7f-150">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-150">The following example illustrates this regular expression.</span></span> <span data-ttu-id="11f7f-151">A expressão regular corresponde às palavras `an`, `annual`, `announcement` e `antique`, e não correspondem corretamente a `autumn` e `all`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-151">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="11f7f-152">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-152">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-153">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-153">Pattern</span></span>|<span data-ttu-id="11f7f-154">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-154">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-155">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-155">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="11f7f-156">Corresponder a um “a” seguido por um ou mais caracteres “n”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-156">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="11f7f-157">Corresponder a um caractere de palavra zero ou mais vezes, mas o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-157">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-158">Terminar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-158">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="11f7f-159">Corresponder a zero ou uma vez: ?</span><span class="sxs-lookup"><span data-stu-id="11f7f-159">Match Zero or One Time: ?</span></span>  

 <span data-ttu-id="11f7f-160">O quantificador `?` corresponde ao elemento anterior zero ou uma vez.</span><span class="sxs-lookup"><span data-stu-id="11f7f-160">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="11f7f-161">É equivalente a `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-161">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="11f7f-162">`?` é um quantificador Greedy, cujo equivalente lento é `??`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-162">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="11f7f-163">Por exemplo, a expressão regular `\ban?\b` tenta corresponder a palavras inteiras que começam com a letra `a` seguidas por zero ou uma instância da letra `n`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-163">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="11f7f-164">Em outras palavras, ele tenta corresponder às palavras `a` e `an`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-164">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="11f7f-165">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-165">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="11f7f-166">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-166">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-167">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-167">Pattern</span></span>|<span data-ttu-id="11f7f-168">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-168">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-169">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-169">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="11f7f-170">Corresponder a um “a” seguido por zero ou um caractere “n”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-170">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-171">Terminar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-171">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="11f7f-172">Corresponder exatamente a n vezes: {n}</span><span class="sxs-lookup"><span data-stu-id="11f7f-172">Match Exactly n Times: {n}</span></span>  

 <span data-ttu-id="11f7f-173">O `{` *n* `}` quantificador n corresponde ao elemento anterior exatamente *n* vezes, em que *n* é qualquer inteiro.</span><span class="sxs-lookup"><span data-stu-id="11f7f-173">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="11f7f-174">`{`*n* `}` é um quantificador de ávido cujo equivalente lento é `{` *n* `}?` .</span><span class="sxs-lookup"><span data-stu-id="11f7f-174">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="11f7f-175">Por exemplo, a expressão regular `\b\d+\,\d{3}\b` tenta corresponder a um limite de palavra seguido por um ou mais dígitos decimais seguidos por três dígitos decimais seguidos por um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-175">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="11f7f-176">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-176">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="11f7f-177">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-177">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-178">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-178">Pattern</span></span>|<span data-ttu-id="11f7f-179">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-179">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-180">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-180">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="11f7f-181">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="11f7f-181">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="11f7f-182">Corresponder a um caractere de vírgula.</span><span class="sxs-lookup"><span data-stu-id="11f7f-182">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="11f7f-183">Corresponder a três dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="11f7f-183">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-184">Terminar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-184">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="11f7f-185">Corresponder a pelo menos n vezes: {n,}</span><span class="sxs-lookup"><span data-stu-id="11f7f-185">Match at Least n Times: {n,}</span></span>  

 <span data-ttu-id="11f7f-186">O `{` *n* `,}` quantificador n corresponde ao elemento anterior pelo menos *n* vezes, em que *n* é qualquer inteiro.</span><span class="sxs-lookup"><span data-stu-id="11f7f-186">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="11f7f-187">`{`*n* `,}` é um quantificador de ávido cujo equivalente lento é `{` *n* `,}?` .</span><span class="sxs-lookup"><span data-stu-id="11f7f-187">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="11f7f-188">Por exemplo, a expressão regular `\b\d{2,}\b\D+` tenta corresponder a um limite de palavra seguido por pelo menos dois dígitos seguidos por um limite de palavra e um caractere não dígito.</span><span class="sxs-lookup"><span data-stu-id="11f7f-188">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="11f7f-189">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-189">The following example illustrates this regular expression.</span></span> <span data-ttu-id="11f7f-190">A expressão regular não corresponde à frase `"7 days"` porque contém apenas um dígito decimal, mas corresponde com êxito às frases `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-190">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="11f7f-191">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-191">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-192">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-192">Pattern</span></span>|<span data-ttu-id="11f7f-193">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-193">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-194">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-194">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="11f7f-195">Corresponder a pelo menos dois dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="11f7f-195">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-196">Corresponder a um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-196">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="11f7f-197">Corresponder a pelo menos uma casa não decimal.</span><span class="sxs-lookup"><span data-stu-id="11f7f-197">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="11f7f-198">Corresponder entre n e m vezes: {n,m}</span><span class="sxs-lookup"><span data-stu-id="11f7f-198">Match Between n and m Times: {n,m}</span></span>  

 <span data-ttu-id="11f7f-199">O `{` *n* `,` *m* `}` quantificador n m corresponde ao elemento anterior pelo menos *n* vezes, mas não mais que *m* vezes, em que *n* e *m* são inteiros.</span><span class="sxs-lookup"><span data-stu-id="11f7f-199">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="11f7f-200">`{`*n* `,` *m* `}` é um quantificador de ávido cujo equivalente lento é `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="11f7f-200">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="11f7f-201">No exemplo a seguir, a expressão regular `(00\s){2,4}` tenta corresponder a entre duas e quatro ocorrências de dois dígitos zero seguidos por um espaço.</span><span class="sxs-lookup"><span data-stu-id="11f7f-201">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="11f7f-202">Observe que a parte final da cadeia de caracteres de entrada inclui esse padrão de cinco vezes em vez de no máximo quatro.</span><span class="sxs-lookup"><span data-stu-id="11f7f-202">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="11f7f-203">No entanto, apenas a parte inicial dessa subcadeia de caracteres (até o espaço e o quinto par de zeros) corresponde ao padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-203">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="11f7f-204">Corresponder a zero ou mais vezes (correspondência lenta): \*?</span><span class="sxs-lookup"><span data-stu-id="11f7f-204">Match Zero or More Times (Lazy Match): \*?</span></span>  

 <span data-ttu-id="11f7f-205">O quantificador `*?` corresponde ao elemento anterior zero ou mais vezes, mas o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-205">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="11f7f-206">É a contraparte lenta do quantificador Greedy `*`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-206">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="11f7f-207">No exemplo a seguir, a expressão regular `\b\w*?oo\w*?\b` corresponde a todas as palavras que contêm a cadeia de caracteres `oo`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-207">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="11f7f-208">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-208">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-209">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-209">Pattern</span></span>|<span data-ttu-id="11f7f-210">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-210">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-211">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-211">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="11f7f-212">Corresponder a zero ou mais caracteres de palavra, mas o menor número de caracteres possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-212">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="11f7f-213">Corresponder à cadeia de caracteres “oo”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-213">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="11f7f-214">Corresponder a zero ou mais caracteres de palavra, mas o menor número de caracteres possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-214">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-215">Terminar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-215">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="11f7f-216">Corresponder a uma ou mais vezes (correspondência lenta): +?</span><span class="sxs-lookup"><span data-stu-id="11f7f-216">Match One or More Times (Lazy Match): +?</span></span>  

 <span data-ttu-id="11f7f-217">O quantificador `+?` corresponde ao elemento anterior uma ou mais vezes, mas o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-217">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="11f7f-218">É a contraparte lenta do quantificador Greedy `+`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-218">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="11f7f-219">Por exemplo, a expressão regular `\b\w+?\b` corresponde a um ou mais caracteres separados por limites de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-219">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="11f7f-220">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-220">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="11f7f-221">Corresponder a zero ou uma vez (correspondência lenta): ??</span><span class="sxs-lookup"><span data-stu-id="11f7f-221">Match Zero or One Time (Lazy Match): ??</span></span>  

 <span data-ttu-id="11f7f-222">O quantificador `??` corresponde ao elemento anterior zero ou uma vez, mas o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-222">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="11f7f-223">É a contraparte lenta do quantificador Greedy `?`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-223">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="11f7f-224">Por exemplo, a expressão regular `^\s*(System.)??Console.Write(Line)??\(??` tenta corresponder às cadeias de caracteres “Console.Write” ou “Console.WriteLine”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-224">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="11f7f-225">A cadeia de caracteres também pode incluir "System."</span><span class="sxs-lookup"><span data-stu-id="11f7f-225">The string can also include "System."</span></span> <span data-ttu-id="11f7f-226">antes de “Console” e pode ser seguida por um parêntese de abertura.</span><span class="sxs-lookup"><span data-stu-id="11f7f-226">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="11f7f-227">A cadeia de caracteres deve estar no início de uma linha, embora possa ser antecedida por espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="11f7f-227">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="11f7f-228">O exemplo a seguir ilustra essa expressão regular.</span><span class="sxs-lookup"><span data-stu-id="11f7f-228">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="11f7f-229">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-229">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-230">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-230">Pattern</span></span>|<span data-ttu-id="11f7f-231">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-231">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="11f7f-232">Corresponder ao início do fluxo de entrada.</span><span class="sxs-lookup"><span data-stu-id="11f7f-232">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="11f7f-233">Corresponder a zero ou mais caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="11f7f-233">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="11f7f-234">Corresponde a zero ou uma ocorrência da cadeia de caracteres “System.”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-234">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="11f7f-235">Corresponder à cadeia de caracteres “Console.Write”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-235">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="11f7f-236">Corresponde a zero ou uma ocorrência da cadeia de caracteres “Line”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-236">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="11f7f-237">Corresponder a zero ou uma ocorrência do parêntese de abertura.</span><span class="sxs-lookup"><span data-stu-id="11f7f-237">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="11f7f-238">Corresponder exatamente a n vezes (correspondência lenta): {n}?</span><span class="sxs-lookup"><span data-stu-id="11f7f-238">Match Exactly n Times (Lazy Match): {n}?</span></span>  

 <span data-ttu-id="11f7f-239">O `{` *n* `}?` quantificador n corresponde ao elemento anterior exatamente `n` vezes, em que *n* é qualquer inteiro.</span><span class="sxs-lookup"><span data-stu-id="11f7f-239">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="11f7f-240">É a contraparte lenta do quantificador de ávido `{` *n* `}` .</span><span class="sxs-lookup"><span data-stu-id="11f7f-240">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="11f7f-241">No exemplo a seguir, a expressão regular `\b(\w{3,}?\.){2}?\w{3,}?\b` é usada para identificar um endereço de site.</span><span class="sxs-lookup"><span data-stu-id="11f7f-241">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="11f7f-242">Observe que corresponde a “www.microsoft.com” e “msdn.microsoft.com”, mas não corresponde a “mywebsite” ou “mycompany.com”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-242">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="11f7f-243">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-243">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-244">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-244">Pattern</span></span>|<span data-ttu-id="11f7f-245">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-245">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-246">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-246">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="11f7f-247">Corresponder a pelo menos três caracteres de palavra, mas o menor número de caracteres possível, seguido por um caractere de ponto.</span><span class="sxs-lookup"><span data-stu-id="11f7f-247">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="11f7f-248">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="11f7f-248">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="11f7f-249">Corresponder ao padrão no primeiro grupo duas vezes, mas o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-249">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="11f7f-250">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-250">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="11f7f-251">Corresponder a pelo menos n vezes (correspondência lenta): {n,}?</span><span class="sxs-lookup"><span data-stu-id="11f7f-251">Match at Least n Times (Lazy Match): {n,}?</span></span>  

 <span data-ttu-id="11f7f-252">O `{` *n* `,}?` quantificador n corresponde ao elemento anterior pelo menos `n` vezes, em que *n* é qualquer inteiro, mas o mínimo de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-252">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="11f7f-253">É a contraparte lenta do quantificador de ávido `{` *n* `,}` .</span><span class="sxs-lookup"><span data-stu-id="11f7f-253">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="11f7f-254">Consulte o exemplo do `{` *n* `}?` quantificador n na seção anterior para obter uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="11f7f-254">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="11f7f-255">A expressão regular nesse exemplo usa o `{` *n* `,}` quantificador n para corresponder uma cadeia de caracteres que tenha pelo menos três caracteres seguidos por um ponto.</span><span class="sxs-lookup"><span data-stu-id="11f7f-255">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="11f7f-256">Corresponder entre n e m vezes (correspondência lenta): {n,m}?</span><span class="sxs-lookup"><span data-stu-id="11f7f-256">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  

 <span data-ttu-id="11f7f-257">O `{` *n* `,` *m* `}?` quantificador n m corresponde ao elemento anterior entre `n` e `m` horas, em que *n* e *m* são inteiros, mas tantas vezes quanto possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-257">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="11f7f-258">É a contraparte lenta do quantificador de ávido `{` *n* `,` *m* `}` .</span><span class="sxs-lookup"><span data-stu-id="11f7f-258">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="11f7f-259">No exemplo a seguir, a expressão regular `\b[A-Z](\w*?\s*?){1,10}[.!?]` corresponde a frases que contêm entre uma e dez palavras.</span><span class="sxs-lookup"><span data-stu-id="11f7f-259">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="11f7f-260">Corresponde a todas as frases na cadeia de caracteres de entrada, exceto por uma frase que contém 18 palavras.</span><span class="sxs-lookup"><span data-stu-id="11f7f-260">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="11f7f-261">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-261">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-262">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-262">Pattern</span></span>|<span data-ttu-id="11f7f-263">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-263">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="11f7f-264">Iniciar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="11f7f-264">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="11f7f-265">Corresponder a um caractere maiúscula de A a Z.</span><span class="sxs-lookup"><span data-stu-id="11f7f-265">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="11f7f-266">Corresponder a zero ou mais caracteres de palavra, seguidos por um ou mais caracteres de espaço em branco, mas o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-266">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="11f7f-267">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="11f7f-267">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="11f7f-268">Corresponder ao padrão anterior entre 1 e 10 vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-268">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="11f7f-269">Corresponder a qualquer um dos caracteres de pontuação “.”, “!” ou “?”.</span><span class="sxs-lookup"><span data-stu-id="11f7f-269">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>

## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="11f7f-270">Quantificadores Greedy e lentos</span><span class="sxs-lookup"><span data-stu-id="11f7f-270">Greedy and Lazy Quantifiers</span></span>  

 <span data-ttu-id="11f7f-271">Alguns quantificadores têm duas versões:</span><span class="sxs-lookup"><span data-stu-id="11f7f-271">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="11f7f-272">Uma versão Greedy.</span><span class="sxs-lookup"><span data-stu-id="11f7f-272">A greedy version.</span></span>  
  
     <span data-ttu-id="11f7f-273">Um quantificador Greedy tenta corresponder a um elemento tantas vezes quanto possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-273">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="11f7f-274">Uma versão não Greedy (ou lenta).</span><span class="sxs-lookup"><span data-stu-id="11f7f-274">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="11f7f-275">Um quantificador não Greedy tenta corresponder a um elemento o menor número de vezes possível.</span><span class="sxs-lookup"><span data-stu-id="11f7f-275">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="11f7f-276">Você pode transformar um quantificador Greedy em um quantificador lento simplesmente adicionando um `?`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-276">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="11f7f-277">Considere uma expressão regular simples que se destina a extrair os últimos quatro dígitos de uma cadeia de caracteres de números, como um número de cartão de crédito.</span><span class="sxs-lookup"><span data-stu-id="11f7f-277">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="11f7f-278">A versão da expressão regular que usa o quantificador Greedy `*` é `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-278">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="11f7f-279">No entanto, se uma cadeia de caracteres contiver dois números, essa expressão regular corresponde aos últimos quatro dígitos do segundo número, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-279">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="11f7f-280">A expressão regular não corresponde ao primeiro número porque o quantificador `*` tenta corresponder ao elemento anterior tantas vezes quanto possível em toda a cadeia de caracteres e encontra sua correspondência no final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="11f7f-280">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="11f7f-281">Esse não é o comportamento desejado.</span><span class="sxs-lookup"><span data-stu-id="11f7f-281">This is not the desired behavior.</span></span> <span data-ttu-id="11f7f-282">Em vez disso, é possível usar o quantificador lento `*?` para extrair dígitos de ambos os números, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-282">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="11f7f-283">Na maioria dos casos, expressões regulares com quantificadores Greedy e lentos retornam as mesmas correspondências.</span><span class="sxs-lookup"><span data-stu-id="11f7f-283">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="11f7f-284">Geralmente retornam resultados diferentes quando são usadas com o metacaractere curinga (`.`), que corresponde a qualquer caractere.</span><span class="sxs-lookup"><span data-stu-id="11f7f-284">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="11f7f-285">Quantificadores e correspondências vazias</span><span class="sxs-lookup"><span data-stu-id="11f7f-285">Quantifiers and Empty Matches</span></span>  

 <span data-ttu-id="11f7f-286">Os quantificadores `*` , `+` e `{` *n* `,` *m* `}` e suas contrapartes lentas nunca se repetirão após uma correspondência vazia quando o número mínimo de capturas for encontrado.</span><span class="sxs-lookup"><span data-stu-id="11f7f-286">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="11f7f-287">Essa regra impede que quantificadores entrem em loops infinitos em correspondências vazias de subexpressão quando o número máximo de capturas de grupo possíveis é infinito ou quase infinito.</span><span class="sxs-lookup"><span data-stu-id="11f7f-287">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="11f7f-288">Por exemplo, o código a seguir mostra o resultado de uma chamada para o método <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> com o padrão de expressão regular `(a?)*` que corresponde a zero ou a um caractere "a" zero ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-288">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="11f7f-289">Observe que o grupo de captura único captura cada “a” bem como <xref:System.String.Empty?displayProperty=nameWithType>, mas que não há uma segunda correspondência vazia, porque a primeira correspondência vazia faz com que o quantificador pare de se repetir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-289">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="11f7f-290">Para ver a diferença prática entre um grupo de captura que define um número mínimo e máximo de captura e um que define um número fixo de capturas, considere os padrões de expressão regular `(a\1|(?(1)\1)){0,2}` e `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="11f7f-290">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="11f7f-291">Ambas as expressões regulares consistem em um único grupo de captura, que é definido como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="11f7f-291">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="11f7f-292">Padrão</span><span class="sxs-lookup"><span data-stu-id="11f7f-292">Pattern</span></span>|<span data-ttu-id="11f7f-293">Descrição</span><span class="sxs-lookup"><span data-stu-id="11f7f-293">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="11f7f-294">Faça qualquer correspondência a “a” juntamente com o valor do primeiro grupo capturado…</span><span class="sxs-lookup"><span data-stu-id="11f7f-294">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="11f7f-295">…</span><span class="sxs-lookup"><span data-stu-id="11f7f-295">…</span></span> <span data-ttu-id="11f7f-296">ou teste se o primeiro grupo capturado foi definido.</span><span class="sxs-lookup"><span data-stu-id="11f7f-296">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="11f7f-297">(Observe que o constructo `(?(1)` não define um grupo de captura).</span><span class="sxs-lookup"><span data-stu-id="11f7f-297">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="11f7f-298">Se o primeiro grupo capturado existir, faça uma correspondência ao valor.</span><span class="sxs-lookup"><span data-stu-id="11f7f-298">If the first captured group exists, match its value.</span></span> <span data-ttu-id="11f7f-299">Se o grupo não existir, será correspondente a <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="11f7f-299">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="11f7f-300">A primeira expressão regular tenta corresponder a esse padrão entre zero e duas vezes; a segunda, exatamente duas vezes.</span><span class="sxs-lookup"><span data-stu-id="11f7f-300">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="11f7f-301">Como o primeiro padrão atinge o número mínimo de capturas com a primeira captura de <xref:System.String.Empty?displayProperty=nameWithType>, ele nunca se repete para tentar corresponder a `a\1`; o quantificador `{0,2}` permite apenas correspondências vazias na última iteração.</span><span class="sxs-lookup"><span data-stu-id="11f7f-301">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="11f7f-302">Por outro lado, a segunda expressão regular corresponde a “a” porque avalia `a\1` uma segunda vez; o número mínimo de iterações, 2, força o mecanismo a se repetir após uma correspondência vazia.</span><span class="sxs-lookup"><span data-stu-id="11f7f-302">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="11f7f-303">Confira também</span><span class="sxs-lookup"><span data-stu-id="11f7f-303">See also</span></span>

- [<span data-ttu-id="11f7f-304">Linguagem de expressões regulares – referência rápida</span><span class="sxs-lookup"><span data-stu-id="11f7f-304">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="11f7f-305">Retrocesso</span><span class="sxs-lookup"><span data-stu-id="11f7f-305">Backtracking</span></span>](backtracking-in-regular-expressions.md)
