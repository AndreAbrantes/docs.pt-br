---
title: "Opções de expressões regulares"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET Framework regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: cc32a98930c4c1243f53fc9c5d2a10f339b4de11
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/15/2018
---
# <a name="regular-expression-options"></a><span data-ttu-id="c747f-102">Opções de expressões regulares</span><span class="sxs-lookup"><span data-stu-id="c747f-102">Regular Expression Options</span></span>
<a name="Top"></a> <span data-ttu-id="c747f-103">Por padrão, a comparação de uma cadeia de caracteres de entrada com quaisquer caracteres literais em um padrão de expressão regular diferencia maiúsculas e minúsculas; o espaço em branco em um padrão de expressão regular é interpretado como caracteres de espaço em branco literais e os grupos de captura em uma expressão regular são nomeados implícita e explicitamente.</span><span class="sxs-lookup"><span data-stu-id="c747f-103">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="c747f-104">É possível modificar esses e vários outros aspectos do comportamento de expressão regular especificando opções de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="c747f-104">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="c747f-105">Essas opções, que estão listadas na tabela a seguir, podem ser incluídas embutidas como parte do padrão de expressão regular, ou podem ser fornecidas a um construtor de classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> ou método de correspondência padrão estático como um valor de enumeração <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-105">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>  
  
|<span data-ttu-id="c747f-106">Membro de RegexOptions</span><span class="sxs-lookup"><span data-stu-id="c747f-106">RegexOptions member</span></span>|<span data-ttu-id="c747f-107">Caractere embutido</span><span class="sxs-lookup"><span data-stu-id="c747f-107">Inline character</span></span>|<span data-ttu-id="c747f-108">Efeito</span><span class="sxs-lookup"><span data-stu-id="c747f-108">Effect</span></span>|  
|-------------------------|----------------------|------------|  
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="c747f-109">Não disponível</span><span class="sxs-lookup"><span data-stu-id="c747f-109">Not available</span></span>|<span data-ttu-id="c747f-110">Use o comportamento padrão.</span><span class="sxs-lookup"><span data-stu-id="c747f-110">Use default behavior.</span></span> <span data-ttu-id="c747f-111">Para obter mais informações, consulte [Opções padrão](#Default).</span><span class="sxs-lookup"><span data-stu-id="c747f-111">For more information, see [Default Options](#Default).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="c747f-112">Use correspondência sem diferenciação de maiúsculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c747f-112">Use case-insensitive matching.</span></span> <span data-ttu-id="c747f-113">Para obter mais informações, consulte [Correspondência sem diferenciação de maiúsculas e minúsculas](#Case).</span><span class="sxs-lookup"><span data-stu-id="c747f-113">For more information, see [Case-Insensitive Matching](#Case).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="c747f-114">Use o modo multilinha, em que `^` e `$` correspondem com o início e o fim de cada linha (em vez do início e o fim da cadeia de caracteres de entrada).</span><span class="sxs-lookup"><span data-stu-id="c747f-114">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="c747f-115">Para obter mais informações, consulte [Modo multilinha](#Multiline).</span><span class="sxs-lookup"><span data-stu-id="c747f-115">For more information, see [Multiline Mode](#Multiline).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="c747f-116">Use o modo de linha única, em que o ponto (.) corresponde com todos os caracteres (em vez de todos os caracteres, exceto `\n`).</span><span class="sxs-lookup"><span data-stu-id="c747f-116">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="c747f-117">Para obter mais informações, consulte [Modo de linha única](#Singleline).</span><span class="sxs-lookup"><span data-stu-id="c747f-117">For more information, see [Singleline Mode](#Singleline).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="c747f-118">Não capture grupos sem nome.</span><span class="sxs-lookup"><span data-stu-id="c747f-118">Do not capture unnamed groups.</span></span> <span data-ttu-id="c747f-119">As únicas capturas válidas são grupos explicitamente nomeados ou numerados na forma `(?<`*name*`>` *subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="c747f-119">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="c747f-120">Para obter mais informações, consulte [Apenas capturas explícitas](#Explicit).</span><span class="sxs-lookup"><span data-stu-id="c747f-120">For more information, see [Explicit Captures Only](#Explicit).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="c747f-121">Não disponível</span><span class="sxs-lookup"><span data-stu-id="c747f-121">Not available</span></span>|<span data-ttu-id="c747f-122">Compile a expressão regular para um assembly.</span><span class="sxs-lookup"><span data-stu-id="c747f-122">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="c747f-123">Para obter mais informações, consulte [Expressões regulares compiladas](#Compiled).</span><span class="sxs-lookup"><span data-stu-id="c747f-123">For more information, see [Compiled Regular Expressions](#Compiled).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="c747f-124">Exclua um espaço em branco sem escape do padrão e habilite comentários após uma tecla de cerquilha (`#`).</span><span class="sxs-lookup"><span data-stu-id="c747f-124">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="c747f-125">Para obter mais informações, confira [Ignorar espaço em branco](#Whitespace).</span><span class="sxs-lookup"><span data-stu-id="c747f-125">For more information, see [Ignore White Space](#Whitespace).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="c747f-126">Não disponível</span><span class="sxs-lookup"><span data-stu-id="c747f-126">Not available</span></span>|<span data-ttu-id="c747f-127">Altera a direção da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="c747f-127">Change the search direction.</span></span> <span data-ttu-id="c747f-128">A pesquisa se move da direita para a esquerda, em vez de da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="c747f-128">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="c747f-129">Para obter mais informações, consulte [Modo da direita para a esquerda](#RightToLeft).</span><span class="sxs-lookup"><span data-stu-id="c747f-129">For more information, see [Right-to-Left Mode](#RightToLeft).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="c747f-130">Não disponível</span><span class="sxs-lookup"><span data-stu-id="c747f-130">Not available</span></span>|<span data-ttu-id="c747f-131">Habilite o comportamento compatível com ECMAScript para a expressão.</span><span class="sxs-lookup"><span data-stu-id="c747f-131">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="c747f-132">Para obter mais informações, consulte [Comportamento de correspondência de ECMAScript](#ECMAScript).</span><span class="sxs-lookup"><span data-stu-id="c747f-132">For more information, see [ECMAScript Matching Behavior](#ECMAScript).</span></span>|  
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="c747f-133">Não disponível</span><span class="sxs-lookup"><span data-stu-id="c747f-133">Not available</span></span>|<span data-ttu-id="c747f-134">Ignorar diferenças culturais no idioma.</span><span class="sxs-lookup"><span data-stu-id="c747f-134">Ignore cultural differences in language.</span></span> <span data-ttu-id="c747f-135">Para obter mais informações, consulte [Comparação usando cultura invariável](#Invariant).</span><span class="sxs-lookup"><span data-stu-id="c747f-135">For more information, see [Comparison Using the Invariant Culture](#Invariant).</span></span>|  
  
## <a name="specifying-the-options"></a><span data-ttu-id="c747f-136">Especificando as opções</span><span class="sxs-lookup"><span data-stu-id="c747f-136">Specifying the Options</span></span>  
 <span data-ttu-id="c747f-137">É possível especificar opções para expressões regulares de uma destas três maneiras:</span><span class="sxs-lookup"><span data-stu-id="c747f-137">You can specify options for regular expressions in one of three ways:</span></span>  
  
-   <span data-ttu-id="c747f-138">No parâmetro `options` de um construtor de classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> ou método de correspondência padrão (`Shared` no Visual Basic) estático, como <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-138">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c747f-139">O parâmetro `options` é uma combinação OR bit a bit de valores enumerados <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-139">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>  
  
     <span data-ttu-id="c747f-140">Quando as opções são fornecidas a uma instância <xref:System.Text.RegularExpressions.Regex> mediante uso do parâmetro `options` de um construtor de classe, as opções são atribuídas à propriedade <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-140">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c747f-141">No entanto, a propriedade <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> não reflete opções embutidas no próprio padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-141">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>  
  
     <span data-ttu-id="c747f-142">O exemplo a seguir fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="c747f-142">The following example provides an illustration.</span></span> <span data-ttu-id="c747f-143">Ele usa o parâmetro `options` do método <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> para habilitar correspondência sem diferenciação entre maiúsculas e minúsculas e ignorar espaço em branco do parâmetro ao identificar palavras que começam com a letra "d".</span><span class="sxs-lookup"><span data-stu-id="c747f-143">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
     [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]  
  
-   <span data-ttu-id="c747f-144">Aplicando opções embutidas em um padrão de expressão regular com a sintaxe `(?imnsx-imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="c747f-144">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="c747f-145">A opção se aplica ao padrão do ponto em que a opção é definida até o fim do padrão ou o ponto em que a opção tem é indefinida por outra opção embutida.</span><span class="sxs-lookup"><span data-stu-id="c747f-145">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="c747f-146">Observe que a propriedade <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> de uma instância <xref:System.Text.RegularExpressions.Regex> não reflete essas opções embutidas.</span><span class="sxs-lookup"><span data-stu-id="c747f-146">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="c747f-147">Para saber mais, confira o tópico [Constructos diversos](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c747f-147">For more information, see the [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>  
  
     <span data-ttu-id="c747f-148">O exemplo a seguir fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="c747f-148">The following example provides an illustration.</span></span> <span data-ttu-id="c747f-149">Ele usa opções embutidas para habilitar a correspondência sem diferenciação entre maiúsculas e minúsculas e ignorar o espaço em branco do padrão ao identificar palavras que começam com a letra “d”.</span><span class="sxs-lookup"><span data-stu-id="c747f-149">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
     [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]  
  
-   <span data-ttu-id="c747f-150">Aplicando opções embutidas em um constructo de agrupamento em particular em um padrão de expressão regular com a sintaxe `(?imnsx-imnsx:`*subexpressão*`)`.</span><span class="sxs-lookup"><span data-stu-id="c747f-150">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="c747f-151">Nenhum sinal antes de um conjunto de opções ativa o conjunto; um sinal de subtração antes de um conjunto de opções desativa o conjunto.</span><span class="sxs-lookup"><span data-stu-id="c747f-151">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="c747f-152">(`?` é uma parte fixa da sintaxe do constructo do idioma exigida com as opções habilitadas ou desabilitadas). A opção se aplica apenas àquele grupo.</span><span class="sxs-lookup"><span data-stu-id="c747f-152">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="c747f-153">Para saber mais, confira [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c747f-153">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
     <span data-ttu-id="c747f-154">O exemplo a seguir fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="c747f-154">The following example provides an illustration.</span></span> <span data-ttu-id="c747f-155">Ele usa opções embutidas em um constructo de agrupamento para habilitar a correspondência sem diferenciação entre maiúsculas e minúsculas e ignorar espaço em branco do padrão ao identificar palavras que começam com a letra “d”.</span><span class="sxs-lookup"><span data-stu-id="c747f-155">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
     [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
 <span data-ttu-id="c747f-156">Se as opções forem embutidas especificadas, um sinal de menos (`-`) antes de uma opção ou conjunto de opções desativa essas opções.</span><span class="sxs-lookup"><span data-stu-id="c747f-156">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="c747f-157">Por exemplo, a construção embutida `(?ix-ms)` ativa as opções <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> e desativa as opções <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-157">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="c747f-158">Todas as opções de expressão regular são desativadas por padrão.</span><span class="sxs-lookup"><span data-stu-id="c747f-158">All regular expression options are turned off by default.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-159">Se as opções de expressão regular especificadas no parâmetro `options` de uma chamada de construtor ou método entrar em conflito com as opções especificadas embutidas em um padrão de expressão regular, serão usadas as opções embutidas.</span><span class="sxs-lookup"><span data-stu-id="c747f-159">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>  
  
 <span data-ttu-id="c747f-160">As cinco opções de expressão regular a seguir podem ser definidas com parâmetro de opções e embutidas:</span><span class="sxs-lookup"><span data-stu-id="c747f-160">The following five regular expression options can be set both with the options parameter and inline:</span></span>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>  
  
 <span data-ttu-id="c747f-161">As cinco opções de expressão regular a seguir podem ser definidas usando o parâmetro `options`, mas não podem ser definidas embutidas:</span><span class="sxs-lookup"><span data-stu-id="c747f-161">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>  
  
## <a name="determining-the-options"></a><span data-ttu-id="c747f-162">Determinando as opções</span><span class="sxs-lookup"><span data-stu-id="c747f-162">Determining the Options</span></span>  
 <span data-ttu-id="c747f-163">É possível determinar que opções foram fornecidas a um objeto <xref:System.Text.RegularExpressions.Regex> quando ele tiver sido instanciado recuperando o valor da propriedade <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> somente leitura.</span><span class="sxs-lookup"><span data-stu-id="c747f-163">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c747f-164">Essa propriedade é particularmente útil para determinar as opções definidas para uma expressão regular compilada criada pelo método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-164">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c747f-165">Para testar a presença de qualquer opção, exceto <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, realize uma operação AND com o valor da propriedade <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> e o valor <xref:System.Text.RegularExpressions.RegexOptions> no qual você está interessado.</span><span class="sxs-lookup"><span data-stu-id="c747f-165">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="c747f-166">Em seguida, teste se o resultado é igual ao valor de <xref:System.Text.RegularExpressions.RegexOptions>.</span><span class="sxs-lookup"><span data-stu-id="c747f-166">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="c747f-167">O exemplo a seguir testa se a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> foi definida.</span><span class="sxs-lookup"><span data-stu-id="c747f-167">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
 [!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]  
  
 <span data-ttu-id="c747f-168">Para testar <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine se o valor da propriedade <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> é igual a <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, como ilustra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="c747f-168">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
 [!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]  
  
 <span data-ttu-id="c747f-169">As seções a seguir listam as opções com suporte na expressão regular no .NET.</span><span class="sxs-lookup"><span data-stu-id="c747f-169">The following sections list the options supported by regular expression in .NET.</span></span>  
  
<a name="Default"></a>   
## <a name="default-options"></a><span data-ttu-id="c747f-170">Opções padrão</span><span class="sxs-lookup"><span data-stu-id="c747f-170">Default Options</span></span>  
 <span data-ttu-id="c747f-171">A opção <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> indica que nenhuma opção foi especificada, e o mecanismo de expressão regular usa seu comportamento padrão.</span><span class="sxs-lookup"><span data-stu-id="c747f-171">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="c747f-172">Isso inclui o seguinte:</span><span class="sxs-lookup"><span data-stu-id="c747f-172">This includes the following:</span></span>  
  
-   <span data-ttu-id="c747f-173">O padrão é interpretado como canônico e não como uma expressão regular ECMAScript.</span><span class="sxs-lookup"><span data-stu-id="c747f-173">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>  
  
-   <span data-ttu-id="c747f-174">O padrão da expressão regular é combinado na cadeia de caracteres de entrada da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="c747f-174">The regular expression pattern is matched in the input string from left to right.</span></span>  
  
-   <span data-ttu-id="c747f-175">As comparações diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c747f-175">Comparisons are case-sensitive.</span></span>  
  
-   <span data-ttu-id="c747f-176">Os elementos de linguagem `^` e `$` correspondem com o início e o fim da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-176">The `^` and `$` language elements match the beginning and end of the input string.</span></span>  
  
-   <span data-ttu-id="c747f-177">O elemento de linguagem `.` corresponde com todos os caracteres, exceto `\n`.</span><span class="sxs-lookup"><span data-stu-id="c747f-177">The `.` language element matches every character except `\n`.</span></span>  
  
-   <span data-ttu-id="c747f-178">Qualquer espaço em branco em um padrão de expressão regular é interpretado como caractere de espaço literal.</span><span class="sxs-lookup"><span data-stu-id="c747f-178">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>  
  
-   <span data-ttu-id="c747f-179">As convenções da cultura atual são usadas ao comparar o padrão com a cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-179">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>  
  
-   <span data-ttu-id="c747f-180">Os grupos de capturas no padrão de expressão regular são implícitos e explícitos.</span><span class="sxs-lookup"><span data-stu-id="c747f-180">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-181">A opção <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> não tem equivalente embutido.</span><span class="sxs-lookup"><span data-stu-id="c747f-181">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="c747f-182">Quando as opções de expressões regulares são embutidas aplicadas, o comportamento padrão é restaurado de modo opção a opção, desativando uma opção em particular.</span><span class="sxs-lookup"><span data-stu-id="c747f-182">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="c747f-183">Por exemplo, `(?i)` ativa a comparação sem diferenciar maiúsculas de minúsculas e `(?-i)` restaura a comparação que diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c747f-183">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>  
  
 <span data-ttu-id="c747f-184">Como a opção <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> representa o comportamento padrão do mecanismo de expressão regular, raramente, ela é explicitamente especificada em uma chamada de método.</span><span class="sxs-lookup"><span data-stu-id="c747f-184">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="c747f-185">Em vez disso, é chamado um método de construtor ou de correspondência padrão estático sem um parâmetro `options`.</span><span class="sxs-lookup"><span data-stu-id="c747f-185">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>  
  
 [<span data-ttu-id="c747f-186">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-186">Back to Top</span></span>](#Top)  
  
<a name="Case"></a>   
## <a name="case-insensitive-matching"></a><span data-ttu-id="c747f-187">Correspondência sem diferenciação entre maiúsculas e minúsculas</span><span class="sxs-lookup"><span data-stu-id="c747f-187">Case-Insensitive Matching</span></span>  
 <span data-ttu-id="c747f-188">A opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> ou a opção embutida `i` fornece correspondência sem diferenciação entre maiúsculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c747f-188">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="c747f-189">Por padrão, são usadas as convenções de diferenciação entre maiúsculas e minúsculas da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="c747f-189">By default, the casing conventions of the current culture are used.</span></span>  
  
 <span data-ttu-id="c747f-190">O exemplo a seguir define um padrão de expressão regular, `\bthe\w*\b`, que corresponde com todas as palavras que começam com "the".</span><span class="sxs-lookup"><span data-stu-id="c747f-190">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="c747f-191">Como a primeira chamada para o método <xref:System.Text.RegularExpressions.Regex.Match%2A> usa a comparação que diferencia maiúsculas de minúsculas padrão, a saída indica que a cadeia de caracteres "The", que inicia a frase, não é combinada.</span><span class="sxs-lookup"><span data-stu-id="c747f-191">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="c747f-192">Ela é combinada quando o método <xref:System.Text.RegularExpressions.Regex.Match%2A> é chamado com opções definidas para <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span><span class="sxs-lookup"><span data-stu-id="c747f-192">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
 [!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]  
  
 <span data-ttu-id="c747f-193">O exemplo a seguir modifica o padrão da expressão regular do exemplo anterior para usar opções embutidas, em vez do parâmetro `options` para fornecer comparação de diferenciação entre maiúsculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c747f-193">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="c747f-194">O primeiro padrão define a opção que não diferencia maiúsculas de minúsculas em um constructo de agrupamento que se aplica apenas à letra “t” na cadeia de caracteres “the”.</span><span class="sxs-lookup"><span data-stu-id="c747f-194">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="c747f-195">Como o constructo da opção ocorre no início do padrão, o segundo padrão aplica a opção que não diferencia maiúsculas de minúsculas a toda a expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-195">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
 [!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]  
  
 [<span data-ttu-id="c747f-196">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-196">Back to Top</span></span>](#Top)  
  
<a name="Multiline"></a>   
## <a name="multiline-mode"></a><span data-ttu-id="c747f-197">Modo multilinha</span><span class="sxs-lookup"><span data-stu-id="c747f-197">Multiline Mode</span></span>  
 <span data-ttu-id="c747f-198">A opção <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> ou a opção embutida `m` habilita o mecanismo de expressão regular para processar uma cadeia de caracteres de entrada que consiste em várias linhas.</span><span class="sxs-lookup"><span data-stu-id="c747f-198">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="c747f-199">Ele altera a interpretação dos elementos de linguagem `^` e `$` para que correspondem com o início e o fim de uma linha, em vez de o início e o fim da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-199">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>  
  
 <span data-ttu-id="c747f-200">Por padrão, `$` corresponde apenas com o final da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-200">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="c747f-201">Se você especificar a opção <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>, ela corresponde com o caractere newline (`\n`) ou com o fim da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-201">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="c747f-202">Porém, não corresponde com a combinação de caractere de retorno de carro/avanço de linha.</span><span class="sxs-lookup"><span data-stu-id="c747f-202">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="c747f-203">Para uma correspondência bem-sucedida, use a subexpressão `\r?$` em vez de apenas `$`.</span><span class="sxs-lookup"><span data-stu-id="c747f-203">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>  
  
 <span data-ttu-id="c747f-204">O exemplo a seguir extrai nomes e pontuações de jogadores de boliche e os adiciona a uma coleção <xref:System.Collections.Generic.SortedList%602>, que os classifica em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="c747f-204">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="c747f-205">O método <xref:System.Text.RegularExpressions.Regex.Matches%2A> é chamado duas vezes.</span><span class="sxs-lookup"><span data-stu-id="c747f-205">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="c747f-206">Na primeira chamada do método, a expressão regular é `^(\w+)\s(\d+)$` e nenhuma opção é definida.</span><span class="sxs-lookup"><span data-stu-id="c747f-206">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="c747f-207">Como a saída mostra, uma vez que o mecanismo de expressões regulares não pode corresponder ao padrão de entrada junto com o início e o fim da cadeia de caracteres de entrada, nenhuma correspondência é encontrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-207">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="c747f-208">Na segunda chamada do método, a expressão regular é alterada para `^(\w+)\s(\d+)\r?$` e as opções são definidas para <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-208">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c747f-209">Como a saída mostra, os nomes e pontuações são combinados com sucesso e as pontuações são exibidas em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="c747f-209">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
 [!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]  
  
 <span data-ttu-id="c747f-210">O padrão de expressão regular `^(\w+)\s(\d+)\r*$` é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c747f-210">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c747f-211">Padrão</span><span class="sxs-lookup"><span data-stu-id="c747f-211">Pattern</span></span>|<span data-ttu-id="c747f-212">Descrição</span><span class="sxs-lookup"><span data-stu-id="c747f-212">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="c747f-213">Começar no início da linha.</span><span class="sxs-lookup"><span data-stu-id="c747f-213">Begin at the start of the line.</span></span>|  
|`(\w+)`|<span data-ttu-id="c747f-214">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c747f-214">Match one or more word characters.</span></span> <span data-ttu-id="c747f-215">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-215">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="c747f-216">Corresponde a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c747f-216">Match a white-space character.</span></span>|  
|`(\d+)`|<span data-ttu-id="c747f-217">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="c747f-217">Match one or more decimal digits.</span></span> <span data-ttu-id="c747f-218">Este é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-218">This is the second capturing group.</span></span>|  
|`\r?`|<span data-ttu-id="c747f-219">Corresponder a zero ou um caractere de retorno de carro.</span><span class="sxs-lookup"><span data-stu-id="c747f-219">Match zero or one carriage return character.</span></span>|  
|`$`|<span data-ttu-id="c747f-220">Termina no fim da linha.</span><span class="sxs-lookup"><span data-stu-id="c747f-220">End at the end of the line.</span></span>|  
  
 <span data-ttu-id="c747f-221">O exemplo a seguir é equivalente ao anterior, exceto que ele usa a opção embutida `(?m)` para definir a opção de multilinhas.</span><span class="sxs-lookup"><span data-stu-id="c747f-221">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
 [!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]  
  
 [<span data-ttu-id="c747f-222">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-222">Back to Top</span></span>](#Top)  
  
<a name="Singleline"></a>   
## <a name="single-line-mode"></a><span data-ttu-id="c747f-223">Modo de linha única</span><span class="sxs-lookup"><span data-stu-id="c747f-223">Single-line Mode</span></span>  
 <span data-ttu-id="c747f-224">A opção <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>, ou a opção embutida `s`, faz o mecanismo de expressão regular tratar a cadeia de caracteres de entrada como se consistisse em uma única linha.</span><span class="sxs-lookup"><span data-stu-id="c747f-224">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="c747f-225">Ele faz isso mudando o comportamento do elemento de linguagem de ponto (`.`) para que corresponda a todos os caracteres, em vez de corresponder a todo caractere exceto pelo newline `\n` ou \u000A.</span><span class="sxs-lookup"><span data-stu-id="c747f-225">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>  
  
 <span data-ttu-id="c747f-226">O exemplo a seguir ilustra como o comportamento do elemento de linguagem `.` muda quando se usa a opção <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-226">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c747f-227">A expressão regular `^.+` começa no início da cadeia de caracteres e corresponde a todos os caracteres.</span><span class="sxs-lookup"><span data-stu-id="c747f-227">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="c747f-228">Por padrão, a correspondência termina no final da primeira linha; o padrão de expressão regular corresponde ao caractere de retorno de carro, `\r` ou \ u000D, mas não corresponde a `\n`.</span><span class="sxs-lookup"><span data-stu-id="c747f-228">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="c747f-229">Como a opção <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> interpreta toda a cadeia de caracteres de entrada como uma única linha, ela corresponde a cada caractere na cadeia de caracteres de entrada, incluindo `\n`.</span><span class="sxs-lookup"><span data-stu-id="c747f-229">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
 [!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]  
  
 <span data-ttu-id="c747f-230">O exemplo a seguir é equivalente ao anterior, exceto que ele usa a opção embutida `(?s)` para habilitar o modo de linha única.</span><span class="sxs-lookup"><span data-stu-id="c747f-230">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
 [!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]  
  
 [<span data-ttu-id="c747f-231">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-231">Back to Top</span></span>](#Top)  
  
<a name="Explicit"></a>   
## <a name="explicit-captures-only"></a><span data-ttu-id="c747f-232">Apenas capturas explícitas</span><span class="sxs-lookup"><span data-stu-id="c747f-232">Explicit Captures Only</span></span>  
 <span data-ttu-id="c747f-233">Por padrão, grupos de capturas são definidos pelo uso de parênteses no padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-233">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="c747f-234">Grupos nomeados recebem um nome ou número pela opção de linguagem `(?<`*nome*`>`*subexpressão*`)`, enquanto grupos não nomeados são acessíveis pelo índice.</span><span class="sxs-lookup"><span data-stu-id="c747f-234">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="c747f-235">No objeto <xref:System.Text.RegularExpressions.GroupCollection>, grupos não nomeados precedem grupos nomeados.</span><span class="sxs-lookup"><span data-stu-id="c747f-235">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>  
  
 <span data-ttu-id="c747f-236">Construções de agrupamento costumam ser usadas apenas para aplicar quantificadores a vários elementos de linguagem, e as subcadeias de caracteres não são de interesse.</span><span class="sxs-lookup"><span data-stu-id="c747f-236">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="c747f-237">Por exemplo, se a seguinte expressão regular:</span><span class="sxs-lookup"><span data-stu-id="c747f-237">For example, if the following regular expression:</span></span>  
  
```  
\b\(?((\w+),?\s?)+[\.!?]\)?  
```  
  
 <span data-ttu-id="c747f-238">for feita somente para extrair frases que terminem com um ponto, ponto de exclamação ou ponto de interrogação de um documento, apenas a frase resultante (representada pelo objeto <xref:System.Text.RegularExpressions.Match>) é de interesse.</span><span class="sxs-lookup"><span data-stu-id="c747f-238">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="c747f-239">As palavras individuais na coleção não são.</span><span class="sxs-lookup"><span data-stu-id="c747f-239">The individual words in the collection are not.</span></span>  
  
 <span data-ttu-id="c747f-240">Capturar grupos que não serão usados posteriormente pode ser caro, pois o mecanismo de expressão regular precisa preencher os objetos de coleção <xref:System.Text.RegularExpressions.GroupCollection> e <xref:System.Text.RegularExpressions.CaptureCollection>.</span><span class="sxs-lookup"><span data-stu-id="c747f-240">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="c747f-241">Como alternativa, você pode usar a opção <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> ou a opção embutida `n` para especificar que apenas as capturas válidas são explicitamente nomeadas ou grupos numerados que são projetados pelo constructo `(?<`*nome*`>` *subexpressão*`)`.</span><span class="sxs-lookup"><span data-stu-id="c747f-241">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>  
  
 <span data-ttu-id="c747f-242">O exemplo a seguir exibe informações sobre as correspondências retornadas pelo padrão de expressão regular `\b\(?((\w+),?\s?)+[\.!?]\)?` quando o método <xref:System.Text.RegularExpressions.Regex.Match%2A> é chamado com e sem a opção <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-242">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c747f-243">Como mostra a saída da chamada do primeiro método, o mecanismo de expressão regular preenche totalmente os objetos da coleção <xref:System.Text.RegularExpressions.GroupCollection> e <xref:System.Text.RegularExpressions.CaptureCollection> com informações sobre subcadeias de caracteres capturadas.</span><span class="sxs-lookup"><span data-stu-id="c747f-243">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="c747f-244">Como o segundo método é chamado com `options` definido para <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, ele não captura informações sobre grupos.</span><span class="sxs-lookup"><span data-stu-id="c747f-244">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
 [!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]  
  
 <span data-ttu-id="c747f-245">O padrão de expressão regular`\b\(?((?>\w+),?\s?)+[\.!?]\)?` é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c747f-245">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c747f-246">Padrão</span><span class="sxs-lookup"><span data-stu-id="c747f-246">Pattern</span></span>|<span data-ttu-id="c747f-247">Descrição</span><span class="sxs-lookup"><span data-stu-id="c747f-247">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c747f-248">Começar em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="c747f-248">Begin at a word boundary.</span></span>|  
|`\(?`|<span data-ttu-id="c747f-249">Corresponder zero ou uma ocorrência do parêntese de abertura (“(“).</span><span class="sxs-lookup"><span data-stu-id="c747f-249">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|  
|`(?>\w+),?`|<span data-ttu-id="c747f-250">Corresponder um ou mais caracteres de palavra seguidos por zero ou uma vírgula.</span><span class="sxs-lookup"><span data-stu-id="c747f-250">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="c747f-251">Não retroceda ao corresponder caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c747f-251">Do not backtrack when matching word characters.</span></span>|  
|`\s?`|<span data-ttu-id="c747f-252">Corresponder a zero ou a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c747f-252">Match zero or one white-space characters.</span></span>|  
|`((\w+),?\s?)+`|<span data-ttu-id="c747f-253">Corresponder a combinação de um ou mais caracteres de palavra, zero ou mais vírgulas e zero ou um caractere de espaço em branco uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="c747f-253">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|  
|`[\.!?]\)?`|<span data-ttu-id="c747f-254">Combina qualquer um dos três símbolos de pontuação seguidos por zero ou um parêntese de fechamento (")").</span><span class="sxs-lookup"><span data-stu-id="c747f-254">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|  
  
 <span data-ttu-id="c747f-255">Você também pode usar o elemento embutido `(?n)` para suprimir capturas automáticas.</span><span class="sxs-lookup"><span data-stu-id="c747f-255">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="c747f-256">O exemplo a seguir modifica o padrão de expressão regular anterior para usar o elemento embutido `(?n)` em vez da opção <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-256">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
 [!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]  
  
 <span data-ttu-id="c747f-257">Por fim, é possível usar o elemento do grupo embutido `(?n:)` para suprimir capturas automáticas grupo a grupo.</span><span class="sxs-lookup"><span data-stu-id="c747f-257">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="c747f-258">O exemplo a seguir modifica o padrão anterior para suprimir capturas sem nome no grupo externo, `((?>\w+),?\s?)`.</span><span class="sxs-lookup"><span data-stu-id="c747f-258">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="c747f-259">Observe que isso também suprime capturas sem nome no grupo interno.</span><span class="sxs-lookup"><span data-stu-id="c747f-259">Note that this suppresses unnamed captures in the inner group as well.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
 [!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]  
  
 [<span data-ttu-id="c747f-260">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-260">Back to Top</span></span>](#Top)  
  
<a name="Compiled"></a>   
## <a name="compiled-regular-expressions"></a><span data-ttu-id="c747f-261">Expressões regulares compiladas</span><span class="sxs-lookup"><span data-stu-id="c747f-261">Compiled Regular Expressions</span></span>  
 <span data-ttu-id="c747f-262">Por padrão, as expressões regulares no .NET são interpretadas.</span><span class="sxs-lookup"><span data-stu-id="c747f-262">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="c747f-263">Quando um objeto <xref:System.Text.RegularExpressions.Regex> é instanciado ou um método <xref:System.Text.RegularExpressions.Regex> estático é chamado, o padrão de expressão regular é analisado em um conjunto de opcodes personalizados, e um interpretador usa esses opcodes para executar a expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-263">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="c747f-264">Isso envolve uma troca: o custo de inicializar o mecanismo de expressões regulares é minimizado com prejuízo do desempenho do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="c747f-264">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>  
  
 <span data-ttu-id="c747f-265">Você pode usar expressões regulares compiladas, em vez de interpretadas, usando a opção <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-265">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c747f-266">Neste caso, quando um padrão é enviado ao mecanismo de expressões regulares, ele é analisado em um subconjunto de opcodes e convertido para a MSIL (linguagem intermediária da Microsoft), que pode ser enviada diretamente ao Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="c747f-266">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="c747f-267">Expressões regulares compiladas maximizam o desempenho do tempo de execução à custa do tempo de inicialização.</span><span class="sxs-lookup"><span data-stu-id="c747f-267">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-268">Uma expressão regular só pode ser compilada fornecendo o valor <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> ao parâmetro `options` de um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou um método de correspondência padrão estático.</span><span class="sxs-lookup"><span data-stu-id="c747f-268">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="c747f-269">Não está disponível como uma opção embutida.</span><span class="sxs-lookup"><span data-stu-id="c747f-269">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="c747f-270">É possível usar expressões regulares compiladas em chamadas para expressões regulares estáticas e de instância.</span><span class="sxs-lookup"><span data-stu-id="c747f-270">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="c747f-271">Em expressões regulares estáticas, a opção <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> é enviada ao parâmetro `options` do método de correspondência padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-271">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="c747f-272">Em expressões regulares de instância, é enviado ao parâmetro `options` do construtor de classe <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="c747f-272">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="c747f-273">Em ambos os casos, resulta em melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="c747f-273">In both cases, it results in enhanced performance.</span></span>  
  
 <span data-ttu-id="c747f-274">Porém, essa melhoria de desempenho ocorre apenas sob as seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="c747f-274">However, this improvement in performance occurs only under the following conditions:</span></span>  
  
-   <span data-ttu-id="c747f-275">É usado um objeto <xref:System.Text.RegularExpressions.Regex> que representa uma expressão regular em particular, em várias chamadas para métodos de correspondência padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-275">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>  
  
-   <span data-ttu-id="c747f-276">O objeto <xref:System.Text.RegularExpressions.Regex> não pode sair do escopo, então pode ser reutilizado.</span><span class="sxs-lookup"><span data-stu-id="c747f-276">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>  
  
-   <span data-ttu-id="c747f-277">Uma expressão regular estática é usada em várias chamadas para métodos de correspondência padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-277">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="c747f-278">(A melhoria de desempenho é possível porque as expressões regulares usadas em chamadas de método estático são armazenadas em cache pelo mecanismo de expressão regular.)</span><span class="sxs-lookup"><span data-stu-id="c747f-278">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-279">A opção <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> não está relacionada ao método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, que cria um assembly de uso especial contendo expressões regulares compiladas predefinidas.</span><span class="sxs-lookup"><span data-stu-id="c747f-279">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>  
  
 [<span data-ttu-id="c747f-280">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-280">Back to Top</span></span>](#Top)  
  
<a name="Whitespace"></a>   
## <a name="ignore-white-space"></a><span data-ttu-id="c747f-281">Ignorar espaço em branco</span><span class="sxs-lookup"><span data-stu-id="c747f-281">Ignore White Space</span></span>  
 <span data-ttu-id="c747f-282">Por padrão, o espaço em branco em um padrão de expressão regular é significativo; ele força o mecanismo de expressões regulares para combinar um caractere de espaço em branco na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-282">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="c747f-283">Devido a isso, a expressão regular "`\b\w+\s`" e "`\b\w+`" são, de um modo geral, equivalentes.</span><span class="sxs-lookup"><span data-stu-id="c747f-283">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="c747f-284">Além disso, quando a tecla de cerquilha (#) é encontrada em um padrão de expressão regular, ela é interpretada como um caractere literal a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="c747f-284">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>  
  
 <span data-ttu-id="c747f-285">A opção <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> ou a opção embutida `x` muda seu comportamento padrão da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="c747f-285">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>  
  
-   <span data-ttu-id="c747f-286">É ignorado o espaço em branco sem escape no padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-286">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="c747f-287">Para fazer parte de um padrão de expressão regular, os caracteres de espaço em branco devem ser escapados (por exemplo, `\s` ou "`\`").</span><span class="sxs-lookup"><span data-stu-id="c747f-287">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>  
  
-   <span data-ttu-id="c747f-288">A tecla de cerquilha (#) é interpretada como o início de um comentário, em vez de um caractere literal.</span><span class="sxs-lookup"><span data-stu-id="c747f-288">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="c747f-289">Todo o texto no padrão de expressão regular do caractere # até o fim da cadeia de caracteres é interpretado como comentário.</span><span class="sxs-lookup"><span data-stu-id="c747f-289">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>  
  
 <span data-ttu-id="c747f-290">No entanto, nos casos a seguir, os caracteres de espaço em branco em uma expressão regular não serão ignorados, mesmo se você usar a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="c747f-290">However, in the following cases, white-space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>  
  
-   <span data-ttu-id="c747f-291">O espaço em branco dentro de uma classe de caractere sempre é interpretado literalmente.</span><span class="sxs-lookup"><span data-stu-id="c747f-291">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="c747f-292">Por exemplo, o padrão da expressão regular `[ .,;:]` corresponde a qualquer caractere de espaço em branco, ponto, vírgula, dois pontos ou ponto e vírgula único.</span><span class="sxs-lookup"><span data-stu-id="c747f-292">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>  
  
-   <span data-ttu-id="c747f-293">O espaço em branco não é permitido dentro de um quantificador entre colchetes, como `{`*n*`}`, `{`*n*`,}` e `{`*n*`,`*m*`}`.</span><span class="sxs-lookup"><span data-stu-id="c747f-293">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="c747f-294">Por exemplo, o padrão de expressão regular `\d{1. 3}` falha ao corresponder quaisquer sequências de dígitos de um a três dígitos porque contém um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c747f-294">For example, the regular expression pattern `\d{1. 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>  
  
-   <span data-ttu-id="c747f-295">Não é permitido espaço em branco dentro da sequência de caracteres que introduz um elemento de linguagem.</span><span class="sxs-lookup"><span data-stu-id="c747f-295">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="c747f-296">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="c747f-296">For example:</span></span>  
  
    -   <span data-ttu-id="c747f-297">O elemento de linguagem `(?:`*subexpressão*`)` representa um grupo sem captura; a parte `(?:` do elemento não pode ter espaços inseridos.</span><span class="sxs-lookup"><span data-stu-id="c747f-297">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="c747f-298">O padrão `(? :`*subexpressão*`)` lança uma <xref:System.ArgumentException> no tempo de execução porque o mecanismo de expressão regular não consegue analisar o padrão, e o padrão `( ?:`*subexpressão*`)` falha em corresponder a *subexpressão*.</span><span class="sxs-lookup"><span data-stu-id="c747f-298">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression*.</span></span>  
  
    -   <span data-ttu-id="c747f-299">O elemento de linguagem `\p{`*name*`}`, que representa uma categoria Unicode ou um bloco nomeado, não pode incluir espaços inseridos na parte `\p{` do elemento.</span><span class="sxs-lookup"><span data-stu-id="c747f-299">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="c747f-300">Se você incluir um espaço em branco, o elemento lança uma <xref:System.ArgumentException> no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="c747f-300">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>  
  
 <span data-ttu-id="c747f-301">Habilitar essa opção ajuda a simplificar expressões regulares que costumam ser difíceis de analisar e entender.</span><span class="sxs-lookup"><span data-stu-id="c747f-301">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="c747f-302">Melhora a legibilidade e torna possível documentar uma expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-302">It improves readability, and makes it possible to document a regular expression.</span></span>  
  
 <span data-ttu-id="c747f-303">O exemplo a seguir define o padrão de expressão regular a seguir:</span><span class="sxs-lookup"><span data-stu-id="c747f-303">The following example defines the following regular expression pattern:</span></span>  
  
 `\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`  
  
 <span data-ttu-id="c747f-304">Esse padrão é similar ao padrão definido na seção [Apenas capturas explícitas](#Explicit), exceto por usar a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> para ignorar espaço em branco de padrão.</span><span class="sxs-lookup"><span data-stu-id="c747f-304">This pattern is similar to the pattern defined in the [Explicit Captures Only](#Explicit) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
 [!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]  
  
 <span data-ttu-id="c747f-305">O exemplo a seguir usa a opção embutida `(?x)` para ignorar o espaço em branco padrão.</span><span class="sxs-lookup"><span data-stu-id="c747f-305">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
 [!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]  
  
 [<span data-ttu-id="c747f-306">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-306">Back to Top</span></span>](#Top)  
  
<a name="RightToLeft"></a>   
## <a name="right-to-left-mode"></a><span data-ttu-id="c747f-307">Modo da direita para a esquerda</span><span class="sxs-lookup"><span data-stu-id="c747f-307">Right-to-Left Mode</span></span>  
 <span data-ttu-id="c747f-308">Por padrão, o mecanismo de expressão regular pesquisa da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="c747f-308">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="c747f-309">É possível reverter a direção de pesquisa usando a opção <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-309">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c747f-310">A pesquisa inicia automaticamente na última posição de caractere da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="c747f-310">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="c747f-311">Para métodos de correspondência padrão que incluem um parâmetro de posição inicial, como <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, a posição inicial é o índice da posição do caractere mais à direita em que a pesquisa deve iniciar.</span><span class="sxs-lookup"><span data-stu-id="c747f-311">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-312">O modo de padrão da direita para a esquerda está disponível apenas fornecendo o valor <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> para o parâmetro `options` de um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou o método de correspondência padrão estático.</span><span class="sxs-lookup"><span data-stu-id="c747f-312">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="c747f-313">Não está disponível como uma opção embutida.</span><span class="sxs-lookup"><span data-stu-id="c747f-313">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="c747f-314">A opção <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> só muda a direção de pesquisa, ela não interpreta o padrão de expressão regular da direita para a esquerda.</span><span class="sxs-lookup"><span data-stu-id="c747f-314">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="c747f-315">Por exemplo, a expressão regular `\bb\w+\s` corresponde palavras que começam com a letra "b" e são seguidas por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c747f-315">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="c747f-316">No exemplo a seguir, a cadeia de caracteres de entrada consiste em três palavras que incluem um ou mais caracteres “b”.</span><span class="sxs-lookup"><span data-stu-id="c747f-316">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="c747f-317">A primeira palavra começa com “b”, a segunda termina com “b” e a terceira inclui dois caracteres “b” no meio da palavra.</span><span class="sxs-lookup"><span data-stu-id="c747f-317">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="c747f-318">Como a saída do exemplo mostra, apenas a primeira palavra corresponde ao padrão da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c747f-318">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
 [!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]  
  
 <span data-ttu-id="c747f-319">Observe também que a asserção lookahead (o elemento de linguagem `(?=`*subexpression*`)`) e a asserção lookbehind (o elemento de linguagem `(?<=`*subexpression*`)`) não mudam de direção.</span><span class="sxs-lookup"><span data-stu-id="c747f-319">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="c747f-320">As asserções lookahead buscam à direita; as asserções lookbehind buscam à esquerda.</span><span class="sxs-lookup"><span data-stu-id="c747f-320">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="c747f-321">Por exemplo, a expressão regular `(?<=\d{1,2}\s)\w+,?\s\d{4}` usa a asserção lookbehind para testar uma data que antecede um nome de mês.</span><span class="sxs-lookup"><span data-stu-id="c747f-321">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="c747f-322">A expressão regular corresponde ao mês e o ano.</span><span class="sxs-lookup"><span data-stu-id="c747f-322">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="c747f-323">Para saber mais sobre as asserções lookahead e lookbehind, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c747f-323">For information on lookahead and lookbehind assertsions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
 [!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]  
  
 <span data-ttu-id="c747f-324">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c747f-324">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c747f-325">Padrão</span><span class="sxs-lookup"><span data-stu-id="c747f-325">Pattern</span></span>|<span data-ttu-id="c747f-326">Descrição</span><span class="sxs-lookup"><span data-stu-id="c747f-326">Description</span></span>|  
|-------------|-----------------|  
|`(?<=\d{1,2}\s)`|<span data-ttu-id="c747f-327">O início da correspondência deve ser antecedido por um ou dois dígitos decimais seguidos por um espaço.</span><span class="sxs-lookup"><span data-stu-id="c747f-327">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|  
|`\w+`|<span data-ttu-id="c747f-328">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c747f-328">Match one or more word characters.</span></span>|  
|`,?`|<span data-ttu-id="c747f-329">Corresponder a zero ou um caractere de vírgula.</span><span class="sxs-lookup"><span data-stu-id="c747f-329">Match zero or one comma characters.</span></span>|  
|`\s`|<span data-ttu-id="c747f-330">Corresponde a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c747f-330">Match a white-space character.</span></span>|  
|`\d{4}`|<span data-ttu-id="c747f-331">Corresponder a quatro dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="c747f-331">Match four decimal digits.</span></span>|  
  
 [<span data-ttu-id="c747f-332">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-332">Back to Top</span></span>](#Top)  
  
<a name="ECMAScript"></a>   
## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="c747f-333">Comportamento de correspondência de ECMAScript</span><span class="sxs-lookup"><span data-stu-id="c747f-333">ECMAScript Matching Behavior</span></span>  
 <span data-ttu-id="c747f-334">Por padrão, o mecanismo de expressões regulares usa comportamento canônico ao corresponder um padrão de expressão regular a um texto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c747f-334">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="c747f-335">Porém, é possível instruir o mecanismo de expressão regular a usar o comportamento de correspondência ECMAScript especificando a opção <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-335">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-336">O comportamento compatível com ECMAScript está disponível apenas fornecendo o valor <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> para o parâmetro `options` de um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou método de correspondência padrão estático.</span><span class="sxs-lookup"><span data-stu-id="c747f-336">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="c747f-337">Não está disponível como uma opção embutida.</span><span class="sxs-lookup"><span data-stu-id="c747f-337">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="c747f-338">A opção <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> só pode ser combinada com as opções <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-338">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="c747f-339">O uso de qualquer outra opção em uma expressão regular resulta em <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="c747f-339">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="c747f-340">O comportamento das expressões regulares ECMAScript e canônicas difere em três áreas: sintaxe da classe de caractere, grupos de captura autorreferidos e interpretação octal versus de referência inversa.</span><span class="sxs-lookup"><span data-stu-id="c747f-340">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>  
  
-   <span data-ttu-id="c747f-341">Sintaxe da classe de caractere.</span><span class="sxs-lookup"><span data-stu-id="c747f-341">Character class syntax.</span></span> <span data-ttu-id="c747f-342">Como as expressões regulares canônicas dão suporte a Unicode e o ECMAScrip não, as classes de caractere no ECMAScrip têm uma sintaxe mais limitada e alguns elementos de linguagem da classe de caractere têm um significado diferente.</span><span class="sxs-lookup"><span data-stu-id="c747f-342">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="c747f-343">Por exemplo, o ECMAScript não oferece suporte a elementos de linguagem como a categoria Unicode ou elementos de bloco `\p` e `\P`.</span><span class="sxs-lookup"><span data-stu-id="c747f-343">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="c747f-344">De modo similar, o elemento `\w`, que corresponde um caractere de palavra, é equivalente à classe de caractere `[a-zA-Z_0-9]` ao usar ECMAScript e `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` ao usar comportamento canônico.</span><span class="sxs-lookup"><span data-stu-id="c747f-344">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="c747f-345">Para saber mais, confira [Classes de caracteres](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c747f-345">For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span>  
  
     <span data-ttu-id="c747f-346">O exemplo a seguir ilustra a diferença entre correspondência padrão ECMAScript e canônica.</span><span class="sxs-lookup"><span data-stu-id="c747f-346">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="c747f-347">Define uma expressão regular, `\b(\w+\s*)+`, que combina palavras seguidas por caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c747f-347">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="c747f-348">A entrada consiste em duas cadeias de caracteres, uma que usa o conjunto de caracteres latinos e outra que usa o conjunto de caracteres cirílicos.</span><span class="sxs-lookup"><span data-stu-id="c747f-348">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="c747f-349">Como a saída mostra, a chamada para o método <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> que usa correspondência ECMAScript falha ao combinar as palavras cirílicas, enquanto a chamada de método que usa correspondência canônica não corresponde essas palavras.</span><span class="sxs-lookup"><span data-stu-id="c747f-349">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
     [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]  
  
-   <span data-ttu-id="c747f-350">Grupos de capturas com autorreferência.</span><span class="sxs-lookup"><span data-stu-id="c747f-350">Self-referencing capturing groups.</span></span> <span data-ttu-id="c747f-351">Uma classe de captura de expressão regular com uma referência inversa para si mesma deve ser atualizada com cada iteração de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-351">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="c747f-352">Como o exemplo a seguir mostra, esse recurso habilita a expressão regular `((a+)(\1) ?)+` para corresponder a cadeia de caracteres de entrada " aa aaaa aaaaaa " ao usar ECMAScript, mas não ao usar correspondência canônica.</span><span class="sxs-lookup"><span data-stu-id="c747f-352">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>  
  
     [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
     [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]  
  
     <span data-ttu-id="c747f-353">A expressão regular é definida como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c747f-353">The regular expression is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="c747f-354">Padrão</span><span class="sxs-lookup"><span data-stu-id="c747f-354">Pattern</span></span>|<span data-ttu-id="c747f-355">Descrição</span><span class="sxs-lookup"><span data-stu-id="c747f-355">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="c747f-356">(a+)</span><span class="sxs-lookup"><span data-stu-id="c747f-356">(a+)</span></span>|<span data-ttu-id="c747f-357">Corresponda a letra "a" uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="c747f-357">Match the letter "a" one or more times.</span></span> <span data-ttu-id="c747f-358">Esse é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-358">This is the second capturing group.</span></span>|  
    |<span data-ttu-id="c747f-359">(\1)</span><span class="sxs-lookup"><span data-stu-id="c747f-359">(\1)</span></span>|<span data-ttu-id="c747f-360">Corresponda a subcadeia de caracteres capturada pelo primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-360">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="c747f-361">Este é o terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-361">This is the third capturing group.</span></span>|  
    |<span data-ttu-id="c747f-362">?</span><span class="sxs-lookup"><span data-stu-id="c747f-362">?</span></span>|<span data-ttu-id="c747f-363">Corresponda zero ou um caractere de espaço.</span><span class="sxs-lookup"><span data-stu-id="c747f-363">Match zero or one space characters.</span></span>|  
    |<span data-ttu-id="c747f-364">((a+)(\1) ?)+</span><span class="sxs-lookup"><span data-stu-id="c747f-364">((a+)(\1) ?)+</span></span>|<span data-ttu-id="c747f-365">Corresponda o padrão de um ou mais caracteres "a" seguidos por uma cadeia de caracteres que corresponda o primeiro grupo de capturas seguido por zero ou um caractere de espaço uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="c747f-365">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="c747f-366">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-366">This is the first capturing group.</span></span>|  
  
-   <span data-ttu-id="c747f-367">Resolução de ambiguidades entre escapes octais e referências inversas.</span><span class="sxs-lookup"><span data-stu-id="c747f-367">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="c747f-368">A tabela a seguir resume as diferenças na interpretação octal versus de referência inversa por expressões regulares canônicas e ECMAScript.</span><span class="sxs-lookup"><span data-stu-id="c747f-368">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>  
  
    |<span data-ttu-id="c747f-369">Expressão regular</span><span class="sxs-lookup"><span data-stu-id="c747f-369">Regular expression</span></span>|<span data-ttu-id="c747f-370">Comportamento canônico</span><span class="sxs-lookup"><span data-stu-id="c747f-370">Canonical behavior</span></span>|<span data-ttu-id="c747f-371">Comportamento de ECMAScript</span><span class="sxs-lookup"><span data-stu-id="c747f-371">ECMAScript behavior</span></span>|  
    |------------------------|------------------------|-------------------------|  
    |<span data-ttu-id="c747f-372">`\0` seguido por 0 - 2 dígitos octais</span><span class="sxs-lookup"><span data-stu-id="c747f-372">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="c747f-373">Interprete como um octal.</span><span class="sxs-lookup"><span data-stu-id="c747f-373">Interpret as an octal.</span></span> <span data-ttu-id="c747f-374">Por exemplo, `\044` é sempre interpretado como um valor octal e significa "$".</span><span class="sxs-lookup"><span data-stu-id="c747f-374">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="c747f-375">Mesmo comportamento.</span><span class="sxs-lookup"><span data-stu-id="c747f-375">Same behavior.</span></span>|  
    |<span data-ttu-id="c747f-376">`\` seguido por um dígito de 1 a 9, seguido por nenhum dígito decimal adicional,</span><span class="sxs-lookup"><span data-stu-id="c747f-376">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,</span></span>|<span data-ttu-id="c747f-377">Interprete como referência inversa.</span><span class="sxs-lookup"><span data-stu-id="c747f-377">Interpret as a backreference.</span></span> <span data-ttu-id="c747f-378">Por exemplo, `\9` sempre significa referência inversa 9, mesmo que um nono grupo de capturas não exista.</span><span class="sxs-lookup"><span data-stu-id="c747f-378">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="c747f-379">Se o grupo de captura não existir, o analisador de expressão regular lança uma <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="c747f-379">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="c747f-380">Se existir um grupo de capturas de um único dígito decimal, faça referência inversa a esse dígito.</span><span class="sxs-lookup"><span data-stu-id="c747f-380">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="c747f-381">Caso contrário, interprete o valor como literal.</span><span class="sxs-lookup"><span data-stu-id="c747f-381">Otherwise, interpret the value as a literal.</span></span>|  
    |<span data-ttu-id="c747f-382">`\` seguido por um dígito de 1 a 9, seguido por dígitos decimais adicionais</span><span class="sxs-lookup"><span data-stu-id="c747f-382">`\` followed by a digit from 1 to 9, followed by additional decimal digits</span></span>|<span data-ttu-id="c747f-383">Interprete os dígitos como um valor decimal.</span><span class="sxs-lookup"><span data-stu-id="c747f-383">Interpret the digits as a decimal value.</span></span> <span data-ttu-id="c747f-384">Se o grupo de capturas existir, interprete a expressão como referência inversa.</span><span class="sxs-lookup"><span data-stu-id="c747f-384">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="c747f-385">Caso contrário, interprete os dígitos octais iniciais até o octal 377; ou seja, considere apenas 8 bits inferiores do valor.</span><span class="sxs-lookup"><span data-stu-id="c747f-385">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="c747f-386">Interprete os dígitos restantes como literais.</span><span class="sxs-lookup"><span data-stu-id="c747f-386">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="c747f-387">Por exemplo, na expressão `\3000`, se o grupo de capturas 300 existir, interprete como referência inversa 300; se o grupo de capturas 300 não existir, interprete como um octal 300 seguido por 0.</span><span class="sxs-lookup"><span data-stu-id="c747f-387">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="c747f-388">Interprete como uma referência inversa convertendo todos os dígitos possíveis para um valor decimal que pode fazer referência a uma captura.</span><span class="sxs-lookup"><span data-stu-id="c747f-388">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="c747f-389">Se nenhum dígito puder ser convertido, interprete como um octal usando os dígitos octais iniciais até o octal 377; interprete os dígitos restantes como literais.</span><span class="sxs-lookup"><span data-stu-id="c747f-389">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|  
  
 [<span data-ttu-id="c747f-390">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="c747f-390">Back to Top</span></span>](#Top)  
  
<a name="Invariant"></a>   
## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="c747f-391">Comparação usando a cultura invariável</span><span class="sxs-lookup"><span data-stu-id="c747f-391">Comparison Using the Invariant Culture</span></span>  
 <span data-ttu-id="c747f-392">Por padrão, quando o mecanismo de expressão regular realiza comparações sem diferenciar maiúsculas de minúsculas, ele usa as convenções de maiúsculas de minúsculas da cultura atual para determinar caracteres equivalentes em maiúsculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c747f-392">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>  
  
 <span data-ttu-id="c747f-393">Porém, esse comportamento é indesejável para alguns tipos de comparações, especialmente ao comparar a entrada do usuário com os nomes de recursos do sistema, como senhas, arquivos ou URLs.</span><span class="sxs-lookup"><span data-stu-id="c747f-393">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="c747f-394">O exemplo a seguir ilustra esse cenário.</span><span class="sxs-lookup"><span data-stu-id="c747f-394">The following example illustrates such as scenario.</span></span> <span data-ttu-id="c747f-395">O código tem como objetivo bloquear o acesso a qualquer recurso cuja URL seja prefixada com **FILE://**.</span><span class="sxs-lookup"><span data-stu-id="c747f-395">The code is intended to block access to any resource whose URL is prefaced with **FILE://**.</span></span> <span data-ttu-id="c747f-396">A expressão regular tenta uma correspondência sem diferenciar maiúsculas e minúsculas com a cadeia de caracteres usando a expressão regular `$FILE://`.</span><span class="sxs-lookup"><span data-stu-id="c747f-396">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="c747f-397">Porém, quando a cultura do sistema atual é tr-TR (Turco-Turquia), "I" não é o equivalente maiúsculo de "i".</span><span class="sxs-lookup"><span data-stu-id="c747f-397">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="c747f-398">Como resultado, a chamada para o método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> retorna `false` e o acesso ao arquivo é permitido.</span><span class="sxs-lookup"><span data-stu-id="c747f-398">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
 [!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]  
  
> [!NOTE]
>  <span data-ttu-id="c747f-399">Para obter mais informações sobre comparações de cadeias de caracteres que diferenciam maiúsculas de minúsculas e usam cultura invariável, consulte [Práticas recomendadas para o uso de cadeias de caracteres](../../../docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="c747f-399">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](../../../docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="c747f-400">Em vez de usar comparações que não diferenciam maiúsculas de minúsculas da cultura atual, é possível especificar a opção <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> para ignorar diferenças culturais no idioma e usar as convenções da cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="c747f-400">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c747f-401">A comparação usando cultura invariável está disponível apenas fornecendo o valor <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> para o parâmetro `options` de um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou método de correspondência padrão estático.</span><span class="sxs-lookup"><span data-stu-id="c747f-401">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="c747f-402">Não está disponível como uma opção embutida.</span><span class="sxs-lookup"><span data-stu-id="c747f-402">It is not available as an inline option.</span></span>  
  
 <span data-ttu-id="c747f-403">O exemplo a seguir é idêntico ao anterior, exceto que o método estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> é chamado com opções que incluem <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c747f-403">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c747f-404">Mesmo quando a cultura atual é definida como turco (Turquia), o mecanismo de expressões regulares consegue corresponder com sucesso “FILE” e “file” e bloquear o acesso ao recurso do arquivo.</span><span class="sxs-lookup"><span data-stu-id="c747f-404">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>  
  
 [!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
 [!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]  
  
## <a name="see-also"></a><span data-ttu-id="c747f-405">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c747f-405">See Also</span></span>  
 [<span data-ttu-id="c747f-406">Linguagem de expressão regular – referência rápida</span><span class="sxs-lookup"><span data-stu-id="c747f-406">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
