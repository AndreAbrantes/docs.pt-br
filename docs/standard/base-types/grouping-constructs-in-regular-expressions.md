---
title: "Agrupando construtores em expressões regulares"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 766f20f92cd4ac2d987137f86616a69df9f53600
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/15/2018
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="e6935-102">Agrupando construtores em expressões regulares</span><span class="sxs-lookup"><span data-stu-id="e6935-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="e6935-103">As construções de agrupamento delineiam as subexpressões de uma expressão regular e capturam a subcadeia de caracteres de uma cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="e6935-104">Você pode usar construções de agrupamento para fazer isto:</span><span class="sxs-lookup"><span data-stu-id="e6935-104">You can use grouping constructs to do the following:</span></span>  
  
-   <span data-ttu-id="e6935-105">Fazer a correspondência de uma subexpressão que é repetida na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-105">Match a subexpression that is repeated in the input string.</span></span>  
  
-   <span data-ttu-id="e6935-106">Aplicar um quantificador a uma subexpressão com diversos elementos de linguagem de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="e6935-107">Para saber mais sobre quantificadores, confira [Quantificadores](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e6935-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e6935-108">Inclua uma subexpressão na cadeia de caracteres retornada pelos métodos <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="e6935-109">Recupere subexpressões individuais da propriedade <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> e processe-as separadamente do texto correspondente como um todo.</span><span class="sxs-lookup"><span data-stu-id="e6935-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="e6935-110">A tabela a seguir lista os constructos de agrupamento com suporte do mecanismo de expressões regulares .NET e indica captura ou não captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="e6935-111">Constructo de agrupamento</span><span class="sxs-lookup"><span data-stu-id="e6935-111">Grouping construct</span></span>|<span data-ttu-id="e6935-112">Captura ou não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="e6935-113">Subexpressões correspondentes</span><span class="sxs-lookup"><span data-stu-id="e6935-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="e6935-114">Capturando</span><span class="sxs-lookup"><span data-stu-id="e6935-114">Capturing</span></span>|  
|[<span data-ttu-id="e6935-115">Subexpressões correspondentes nomeadas</span><span class="sxs-lookup"><span data-stu-id="e6935-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="e6935-116">Capturando</span><span class="sxs-lookup"><span data-stu-id="e6935-116">Capturing</span></span>|  
|[<span data-ttu-id="e6935-117">Definições de grupo de balanceamento</span><span class="sxs-lookup"><span data-stu-id="e6935-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="e6935-118">Capturando</span><span class="sxs-lookup"><span data-stu-id="e6935-118">Capturing</span></span>|  
|[<span data-ttu-id="e6935-119">Grupos de não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="e6935-120">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-120">Noncapturing</span></span>|  
|[<span data-ttu-id="e6935-121">Opções de grupo</span><span class="sxs-lookup"><span data-stu-id="e6935-121">Group options</span></span>](#group_options)|<span data-ttu-id="e6935-122">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-122">Noncapturing</span></span>|  
|[<span data-ttu-id="e6935-123">Asserções lookahead positivas de largura zero</span><span class="sxs-lookup"><span data-stu-id="e6935-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="e6935-124">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-124">Noncapturing</span></span>|  
|[<span data-ttu-id="e6935-125">Asserções lookahead negativas de largura zero</span><span class="sxs-lookup"><span data-stu-id="e6935-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="e6935-126">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-126">Noncapturing</span></span>|  
|[<span data-ttu-id="e6935-127">Asserções lookbehind positivas de largura zero</span><span class="sxs-lookup"><span data-stu-id="e6935-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="e6935-128">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-128">Noncapturing</span></span>|  
|[<span data-ttu-id="e6935-129">Asserções lookbehind negativas de largura zero</span><span class="sxs-lookup"><span data-stu-id="e6935-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="e6935-130">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-130">Noncapturing</span></span>|  
|[<span data-ttu-id="e6935-131">Subexpressões sem retrocesso</span><span class="sxs-lookup"><span data-stu-id="e6935-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="e6935-132">Não captura</span><span class="sxs-lookup"><span data-stu-id="e6935-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="e6935-133">Para saber mais sobre grupos e modelos de objetos de expressão regular, veja [Constructos de agrupamento e objetos de expressão regular](#Objects).</span><span class="sxs-lookup"><span data-stu-id="e6935-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="e6935-134">Subexpressões correspondentes</span><span class="sxs-lookup"><span data-stu-id="e6935-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="e6935-135">O constructo de agrupamento a seguir captura uma subexpressão correspondente:</span><span class="sxs-lookup"><span data-stu-id="e6935-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="e6935-136">`(` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-137">em que *subexpression* é qualquer padrão de expressão regular válido.</span><span class="sxs-lookup"><span data-stu-id="e6935-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="e6935-138">As capturas que usam parênteses são numeradas automaticamente, da esquerda para a direita, com base na ordem do parêntese de abertura na expressão regular, começando em um.</span><span class="sxs-lookup"><span data-stu-id="e6935-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="e6935-139">A captura que recebe o número zero é o texto que coincide com todo o padrão da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6935-140">Por padrão, o elemento da linguagem `(`*subexpression*`)` captura a subexpressão correspondente.</span><span class="sxs-lookup"><span data-stu-id="e6935-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="e6935-141">Porém, se o parâmetro <xref:System.Text.RegularExpressions.RegexOptions> de um padrão de expressão regular que corresponde ao método inclui o sinalizador <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> ou se a opção `n` é aplicada a essa subexpressão (consulte [Opções de grupo](#group_options) mais adiante neste tópico), a subexpressão coincidente não é capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="e6935-142">Você pode acessar os grupos capturados de quatro formas:</span><span class="sxs-lookup"><span data-stu-id="e6935-142">You can access captured groups in four ways:</span></span>  
  
-   <span data-ttu-id="e6935-143">Usando o constructo de referência inversa na expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="e6935-144">A subexpressão correspondente é referenciada na mesma expressão regular usando a sintaxe `\`*number*, em que *number* é o número ordinal da subexpressão capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="e6935-145">Usando o constructo de referência inversa nomeado na expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="e6935-146">A subexpressão coincidente é referenciada na mesma expressão regular usando a sintaxe `\k<`*name*`>`, em que *name* é o nome de um grupo de captura, ou `\k<`*number*`>`, em que *number* é o número ordinal de um grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="e6935-147">O grupo de captura tem um nome padrão que é idêntico a seu número ordinal.</span><span class="sxs-lookup"><span data-stu-id="e6935-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="e6935-148">Para saber mais, confira [Subexpressões coincidentes nomeadas](#named_matched_subexpression) mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e6935-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
-   <span data-ttu-id="e6935-149">Ao usar a sequência de substituição `$`*number* em uma chamada de método <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, em que *number* é o número ordinal da subexpressão capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="e6935-150">Usando de forma programática o objeto <xref:System.Text.RegularExpressions.GroupCollection> retornado pela propriedade <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e6935-151">O membro na posição zero da coleção representa toda a correspondência da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="e6935-152">Cada membro subsequente representa uma subexpressão correspondente.</span><span class="sxs-lookup"><span data-stu-id="e6935-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="e6935-153">Para obter mais informações, veja a seção [Construções de agrupamento e objetos de expressão regular](#Objects).</span><span class="sxs-lookup"><span data-stu-id="e6935-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="e6935-154">O exemplo a seguir mostra uma expressão regular que identifica palavras duplicadas no texto.</span><span class="sxs-lookup"><span data-stu-id="e6935-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="e6935-155">Os dois grupos de captura padrão da expressão regular representam as duas instâncias da palavra duplicada.</span><span class="sxs-lookup"><span data-stu-id="e6935-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="e6935-156">A segunda instância é capturada para relatar a posição inicial na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="e6935-157">Este é o padrão da expressão regular:</span><span class="sxs-lookup"><span data-stu-id="e6935-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="e6935-158">A tabela a seguir mostra como o padrão da expressão regular é interpretado.</span><span class="sxs-lookup"><span data-stu-id="e6935-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="e6935-159">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-159">Pattern</span></span>|<span data-ttu-id="e6935-160">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="e6935-161">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-161">Match one or more word characters.</span></span> <span data-ttu-id="e6935-162">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="e6935-163">Corresponde a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="e6935-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="e6935-164">Corresponde à cadeia de caracteres no primeiro grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-164">Match the string in the first captured group.</span></span> <span data-ttu-id="e6935-165">Este é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-165">This is the second capturing group.</span></span> <span data-ttu-id="e6935-166">O exemplo o atribui a um grupo capturado para que seja possível recuperar a posição inicial da palavra duplicada da propriedade `Match.Index`.</span><span class="sxs-lookup"><span data-stu-id="e6935-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="e6935-167">Estabeleça a correspondência com caracteres que não compõem palavras, como espaços em branco e pontuação.</span><span class="sxs-lookup"><span data-stu-id="e6935-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="e6935-168">Isso impede a correspondência de um padrão de expressão regular com uma expressão que começa com a palavra do primeiro grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="e6935-169">Subexpressões Correspondentes Nomeadas</span><span class="sxs-lookup"><span data-stu-id="e6935-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="e6935-170">O constructo de agrupamento a seguir captura uma subexpressão correspondente e permite acessá-la usando seu nome ou número:</span><span class="sxs-lookup"><span data-stu-id="e6935-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="e6935-171">ou:</span><span class="sxs-lookup"><span data-stu-id="e6935-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="e6935-172">em que *name* é um nome de grupo válido e *subexpression* é qualquer padrão de expressão regular válido.</span><span class="sxs-lookup"><span data-stu-id="e6935-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="e6935-173">*name* não deve conter caracteres de pontuação nem começar com um número.</span><span class="sxs-lookup"><span data-stu-id="e6935-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6935-174">Se o parâmetro <xref:System.Text.RegularExpressions.RegexOptions> de um padrão de expressão regular que corresponde ao método inclui o sinalizador <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> ou se a opção `n` é aplicada a essa subexpressão (consulte [Opções de grupo](#group_options) mais adiante neste tópico), a única forma de capturar uma subexpressão é atribuir nomes explícitos a grupos de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="e6935-175">Você pode acessar grupos capturados nomeados destas formas:</span><span class="sxs-lookup"><span data-stu-id="e6935-175">You can access named captured groups in the following ways:</span></span>  
  
-   <span data-ttu-id="e6935-176">Usando o constructo de referência inversa nomeado na expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="e6935-177">A subexpressão coincidente é referenciada na mesma expressão regular usando a sintaxe `\k<`*name*`>`, em que *name* é o nome da subexpressão capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="e6935-178">Usando o constructo de referência inversa na expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="e6935-179">A subexpressão correspondente é referenciada na mesma expressão regular usando a sintaxe `\`*number*, em que *number* é o número ordinal da subexpressão capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="e6935-180">As subexpressões correspondentes nomeadas são numeradas em ordem de sequência, da esquerda da direita, após as subexpressões correspondentes.</span><span class="sxs-lookup"><span data-stu-id="e6935-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
-   <span data-ttu-id="e6935-181">Ao usar a sequência de substituição `${`*name*`}` em uma chamada de método <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, em que *name* é o nome da subexpressão capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="e6935-182">Ao usar a sequência de substituição `$`*number* em uma chamada de método <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, em que *number* é o número ordinal da subexpressão capturada.</span><span class="sxs-lookup"><span data-stu-id="e6935-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="e6935-183">Usando de forma programática o objeto <xref:System.Text.RegularExpressions.GroupCollection> retornado pela propriedade <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e6935-184">O membro na posição zero da coleção representa toda a correspondência da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="e6935-185">Cada membro subsequente representa uma subexpressão correspondente.</span><span class="sxs-lookup"><span data-stu-id="e6935-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="e6935-186">Os grupos capturados nomeados são armazenados na coleção depois dos grupos capturados numerados.</span><span class="sxs-lookup"><span data-stu-id="e6935-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
-   <span data-ttu-id="e6935-187">De forma programática, ao fornecer o nome da subexpressão ao indexador do objeto <xref:System.Text.RegularExpressions.GroupCollection> (no C#) ou a sua propriedade <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e6935-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="e6935-188">Um padrão de expressão regular simples mostra como os grupos numerados (sem nome) e nomeados podem ser usados como referência de forma programática ou usando sintaxe de linguagem de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="e6935-189">A expressão regular `((?<One>abc)\d+)?(?<Two>xyz)(.*)` gera os seguintes grupos de captura por número e nome.</span><span class="sxs-lookup"><span data-stu-id="e6935-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="e6935-190">O primeiro grupo de captura (o número 0) sempre faz referência a todo o padrão.</span><span class="sxs-lookup"><span data-stu-id="e6935-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="e6935-191">Número</span><span class="sxs-lookup"><span data-stu-id="e6935-191">Number</span></span>|<span data-ttu-id="e6935-192">Nome</span><span class="sxs-lookup"><span data-stu-id="e6935-192">Name</span></span>|<span data-ttu-id="e6935-193">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="e6935-194">0</span><span class="sxs-lookup"><span data-stu-id="e6935-194">0</span></span>|<span data-ttu-id="e6935-195">0 (nome padrão)</span><span class="sxs-lookup"><span data-stu-id="e6935-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="e6935-196">1</span><span class="sxs-lookup"><span data-stu-id="e6935-196">1</span></span>|<span data-ttu-id="e6935-197">1 (nome padrão)</span><span class="sxs-lookup"><span data-stu-id="e6935-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="e6935-198">2</span><span class="sxs-lookup"><span data-stu-id="e6935-198">2</span></span>|<span data-ttu-id="e6935-199">2 (nome padrão)</span><span class="sxs-lookup"><span data-stu-id="e6935-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="e6935-200">3</span><span class="sxs-lookup"><span data-stu-id="e6935-200">3</span></span>|<span data-ttu-id="e6935-201">Um</span><span class="sxs-lookup"><span data-stu-id="e6935-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="e6935-202">4</span><span class="sxs-lookup"><span data-stu-id="e6935-202">4</span></span>|<span data-ttu-id="e6935-203">Dois</span><span class="sxs-lookup"><span data-stu-id="e6935-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="e6935-204">O exemplo a seguir mostra uma expressão regular que identifica palavras duplicadas e a palavra que aparece logo na sequência.</span><span class="sxs-lookup"><span data-stu-id="e6935-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="e6935-205">O padrão da expressão regular define duas subexpressões nomeadas: `duplicateWord`, que representa a palavra duplicada e `nextWord`, que representa a palavra que aparece logo na sequência.</span><span class="sxs-lookup"><span data-stu-id="e6935-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="e6935-206">Este é o padrão da expressão regular:</span><span class="sxs-lookup"><span data-stu-id="e6935-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="e6935-207">A tabela a seguir mostra como a expressão regular é interpretada.</span><span class="sxs-lookup"><span data-stu-id="e6935-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="e6935-208">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-208">Pattern</span></span>|<span data-ttu-id="e6935-209">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="e6935-210">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-210">Match one or more word characters.</span></span> <span data-ttu-id="e6935-211">Atribua um nome ao grupo de captura `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="e6935-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="e6935-212">Corresponde a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="e6935-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="e6935-213">Estabeleça a correspondência com o grupo de captura chamado `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="e6935-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="e6935-214">Estabeleça a correspondência com caracteres que não compõem palavras, como espaços em branco e pontuação.</span><span class="sxs-lookup"><span data-stu-id="e6935-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="e6935-215">Isso impede a correspondência de um padrão de expressão regular com uma expressão que começa com a palavra do primeiro grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="e6935-216">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-216">Match one or more word characters.</span></span> <span data-ttu-id="e6935-217">Atribua um nome ao grupo de captura `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="e6935-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="e6935-218">Observe que o nome de um grupo pode ser repetido em uma expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="e6935-219">Por exemplo, é possível que mais de um grupo seja nomeado como `digit`, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="e6935-220">No caso de nomes duplicados, o valor do objeto <xref:System.Text.RegularExpressions.Group> é determinado pela última captura bem-sucedida na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="e6935-221">Além disso, a <xref:System.Text.RegularExpressions.CaptureCollection> é preenchida com informações sobre cada captura exatamente como seria se o nome do grupo não fosse duplicado.</span><span class="sxs-lookup"><span data-stu-id="e6935-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="e6935-222">No exemplo a seguir, a expressão regular `\D+(?<digit>\d+)\D+(?<digit>\d+)?` inclui duas ocorrências de um grupo chamado `digit`.</span><span class="sxs-lookup"><span data-stu-id="e6935-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="e6935-223">O primeiro grupo chamado `digit` captura um ou mais caracteres de dígito.</span><span class="sxs-lookup"><span data-stu-id="e6935-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="e6935-224">O primeiro grupo chamado `digit` captura zero ou uma ocorrência de um ou mais caracteres de dígito.</span><span class="sxs-lookup"><span data-stu-id="e6935-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="e6935-225">Como a saída do exemplo apresentado mostra, se o segundo grupo de captura corresponder ao texto com êxito, o valor desse texto definirá o valor do objeto <xref:System.Text.RegularExpressions.Group>.</span><span class="sxs-lookup"><span data-stu-id="e6935-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="e6935-226">Se o segundo grupo de captura não corresponder à cadeia de caracteres de entrada, o valor da última correspondência bem-sucedida definirá o valor do objeto <xref:System.Text.RegularExpressions.Group>.</span><span class="sxs-lookup"><span data-stu-id="e6935-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="e6935-227">A tabela a seguir mostra como a expressão regular é interpretada.</span><span class="sxs-lookup"><span data-stu-id="e6935-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="e6935-228">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-228">Pattern</span></span>|<span data-ttu-id="e6935-229">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="e6935-230">Corresponder a um ou mais caracteres de dígito não decimal.</span><span class="sxs-lookup"><span data-stu-id="e6935-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="e6935-231">Corresponder a um ou mais caracteres de dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="e6935-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="e6935-232">Atribuir a correspondência ao grupo chamado `digit`.</span><span class="sxs-lookup"><span data-stu-id="e6935-232">Assign the match to the `digit` named group.</span></span>|  
|<span data-ttu-id="e6935-233">\D+</span><span class="sxs-lookup"><span data-stu-id="e6935-233">\D+</span></span>|<span data-ttu-id="e6935-234">Corresponder a um ou mais caracteres de dígito não decimal.</span><span class="sxs-lookup"><span data-stu-id="e6935-234">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="e6935-235">Faz a correspondência de zero ou uma ocorrência de um período seguido por um ou mais caracteres de dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="e6935-235">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="e6935-236">Atribuir a correspondência ao grupo chamado `digit`.</span><span class="sxs-lookup"><span data-stu-id="e6935-236">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="e6935-237">Definições de grupo de balanceamento</span><span class="sxs-lookup"><span data-stu-id="e6935-237">Balancing Group Definitions</span></span>  
 <span data-ttu-id="e6935-238">Uma definição de grupo de balanceamento exclui a definição de um grupo definido anteriormente e armazena, no grupo atual, o intervalo entre o grupo definido anteriormente e o atual.</span><span class="sxs-lookup"><span data-stu-id="e6935-238">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="e6935-239">Esse constructo de agrupamento tem o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="e6935-239">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="e6935-240">ou:</span><span class="sxs-lookup"><span data-stu-id="e6935-240">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="e6935-241">em que *name1* é o grupo atual (opcional), *name2* é um grupo definido anteriormente e *subexpression* é qualquer padrão de expressão regular válido.</span><span class="sxs-lookup"><span data-stu-id="e6935-241">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="e6935-242">A definição de grupo de balanceamento exclui a definição de *name2* e armazena o intervalo entre *name2* e *name1* em *name1*.</span><span class="sxs-lookup"><span data-stu-id="e6935-242">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="e6935-243">Se nenhum grupo *name2* for definido, a correspondência retrocede.</span><span class="sxs-lookup"><span data-stu-id="e6935-243">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="e6935-244">Como a exclusão da última definição de *name2* revela a definição anterior de *name2*, essa construção permite que você use a pilha de capturas para o grupo *name2* como um contador, a fim de registrar construções aninhadas, como parênteses e colchetes.</span><span class="sxs-lookup"><span data-stu-id="e6935-244">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="e6935-245">A definição de grupo de balanceamento usa *name2* como pilha.</span><span class="sxs-lookup"><span data-stu-id="e6935-245">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="e6935-246">O caractere inicial de cada construção aninhada é colocado no grupo e em sua coleção <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-246">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="e6935-247">Quando o caractere de fechamento passa pela correspondência, seu caractere de abertura é removido do grupo e a coleção <xref:System.Text.RegularExpressions.Group.Captures%2A> diminui em um.</span><span class="sxs-lookup"><span data-stu-id="e6935-247">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="e6935-248">Depois da correspondência dos caracteres de abertura e fechamento de todas as construções, *name1* fica vazio.</span><span class="sxs-lookup"><span data-stu-id="e6935-248">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6935-249">Depois de modificar a expressão regular do exemplo a seguir para usar o caractere de abertura e fechamento adequado de um constructo aninhado, você pode usá-lo para gerenciar a maioria dos constructo aninhados, como expressões matemáticas ou linhas do código do programa que incluem diversas chamadas de método aninhado.</span><span class="sxs-lookup"><span data-stu-id="e6935-249">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="e6935-250">O exemplo a seguir usa uma definição de grupo de balanceamento para estabelecer a correspondência entre os sinais de menor e maior (<>) em uma cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-250">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="e6935-251">O exemplo define dois grupos nomeados, `Open` e `Close`, que são usados como pilha para acompanhar a correspondência entre esses sinais.</span><span class="sxs-lookup"><span data-stu-id="e6935-251">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="e6935-252">Cada sinal de menor capturado é enviado para a coleção da captura do grupo `Open` e cada sinal de maior capturado é enviado para a coleção de captura do grupo `Close`.</span><span class="sxs-lookup"><span data-stu-id="e6935-252">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="e6935-253">A definição do grupo de balanceamento assegura que há um sinal de maior para cada sinal de menor.</span><span class="sxs-lookup"><span data-stu-id="e6935-253">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="e6935-254">Caso não haja, o subpadrão final `(?(Open)(?!))`, só será avaliado se o grupo `Open` não estiver vazio, ou seja, se todas as construções aninhadas não tiverem sido fechadas.</span><span class="sxs-lookup"><span data-stu-id="e6935-254">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="e6935-255">Se o subpadrão final for avaliado, a correspondência falha, porque o subpadrão `(?!)` é uma asserção lookahead negativa de largura zero que sempre falha.</span><span class="sxs-lookup"><span data-stu-id="e6935-255">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="e6935-256">O padrão da expressão regular é:</span><span class="sxs-lookup"><span data-stu-id="e6935-256">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="e6935-257">A expressão regular é interpretada da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="e6935-257">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="e6935-258">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-258">Pattern</span></span>|<span data-ttu-id="e6935-259">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-259">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="e6935-260">Começa no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="e6935-260">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="e6935-261">Corresponde a zero ou mais caracteres que não são sinais de menor nem maior.</span><span class="sxs-lookup"><span data-stu-id="e6935-261">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="e6935-262">Corresponde a um sinal de menor e o atribui a um grupo nomeado `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-262">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="e6935-263">Corresponde a zero ou mais caracteres que não são sinais de menor nem maior.</span><span class="sxs-lookup"><span data-stu-id="e6935-263">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="e6935-264">Corresponde uma ou mais ocorrências de um sinal de menor, seguida por zero ou mais caracteres que não são sinais de menor ou maior.</span><span class="sxs-lookup"><span data-stu-id="e6935-264">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="e6935-265">Este é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-265">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="e6935-266">Corresponde a um sinal de maior, atribui a subcadeia de caracteres entre o grupo `Open` e o grupo atual ao grupo `Close` e exclui a definição do grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-266">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="e6935-267">Corresponde a zero ou mais ocorrências de caracteres que não são sinais de menor ou maior.</span><span class="sxs-lookup"><span data-stu-id="e6935-267">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="e6935-268">Corresponde a uma ou mais ocorrências de sinal de menor seguidas por zero ou mais ocorrências de qualquer caractere que não seja um sinal de menor ou maior.</span><span class="sxs-lookup"><span data-stu-id="e6935-268">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="e6935-269">Ao estabelecer a correspondência de um sinal de maior, atribua a subcadeia de caracteres entre o grupo `Open` e o grupo atual ao grupo `Close` e exclua a definição do grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-269">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="e6935-270">Este é o terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-270">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="e6935-271">Corresponde a zero ou mais ocorrências do seguinte padrão: uma ou mais ocorrências de sinal de menor seguidas por zero ou mais ocorrências de qualquer caractere que não seja um sinal de menor ou maior, seguida por uma ou mais ocorrências de sinal de maior, seguida por zero ou mais ocorrências de caracteres que não sejam sinais de menor ou maior.</span><span class="sxs-lookup"><span data-stu-id="e6935-271">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="e6935-272">Ao estabelecer a correspondência de um sinal de maior, exclua a definição do grupo `Open` e atribua a subcadeia entre o grupo `Open` e o grupo atual ao grupo `Close`.</span><span class="sxs-lookup"><span data-stu-id="e6935-272">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="e6935-273">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-273">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="e6935-274">Se o grupo `Open` existir, abandone a correspondência se for possível estabelecer a correspondência de uma cadeia de caracteres vazia, mas não avance a posição do mecanismo de expressão regular na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="e6935-274">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="e6935-275">Trata-se de uma asserção lookahead negativa de largura zero.</span><span class="sxs-lookup"><span data-stu-id="e6935-275">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="e6935-276">Como sempre há cadeias de caracteres vazias presentes em cadeias de caracteres de entrada, essa correspondência sempre falha.</span><span class="sxs-lookup"><span data-stu-id="e6935-276">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="e6935-277">A falha nessa correspondência indica que os sinais de menor e maior não estão balanceados.</span><span class="sxs-lookup"><span data-stu-id="e6935-277">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="e6935-278">Corresponder ao final da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-278">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="e6935-279">A subexpressão final, `(?(Open)(?!))`, indica se a construção de aninhamento da cadeia de caracteres de entrada está balanceada corretamente (por exemplo, se cada sinal de maior corresponde a um sinal de menor).</span><span class="sxs-lookup"><span data-stu-id="e6935-279">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="e6935-280">Ela usa a correspondência condicional com base em um grupo capturado válido; para obter mais informações, veja [Construções de alternância](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e6935-280">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="e6935-281">Se o grupo `Open` for definido, o mecanismo de expressão regular tenta estabelecer a correspondência da subexpressão `(?!)` na cadeia de caracteres de saída.</span><span class="sxs-lookup"><span data-stu-id="e6935-281">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="e6935-282">O grupo `Open` só deve ser definido se as construções de aninhamento não estiverem balanceadas.</span><span class="sxs-lookup"><span data-stu-id="e6935-282">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="e6935-283">Portanto, o padrão para correspondência na cadeia de caracteres de entrada sempre deve fazer com que a correspondência falhe.</span><span class="sxs-lookup"><span data-stu-id="e6935-283">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="e6935-284">Nesse caso, `(?!)` é uma asserção lookahead negativa de largura zero que sempre falha, porque sempre há cadeias de caracteres vazias presentes na próxima posição da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-284">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="e6935-285">No exemplo, o mecanismo da expressão regular avalia a cadeia de caracteres de entrada "\<abc><mno\<xyz>>" como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-285">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-286">Etapa</span><span class="sxs-lookup"><span data-stu-id="e6935-286">Step</span></span>|<span data-ttu-id="e6935-287">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-287">Pattern</span></span>|<span data-ttu-id="e6935-288">Resultado</span><span class="sxs-lookup"><span data-stu-id="e6935-288">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="e6935-289">1</span><span class="sxs-lookup"><span data-stu-id="e6935-289">1</span></span>|`^`|<span data-ttu-id="e6935-290">Começa a correspondência no início da cadeia de caracteres de entrada</span><span class="sxs-lookup"><span data-stu-id="e6935-290">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="e6935-291">2</span><span class="sxs-lookup"><span data-stu-id="e6935-291">2</span></span>|`[^<>]*`|<span data-ttu-id="e6935-292">Procura caracteres que não sejam sinais de menor e maior antes do sinal de menor e não encontra correspondências.</span><span class="sxs-lookup"><span data-stu-id="e6935-292">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="e6935-293">3</span><span class="sxs-lookup"><span data-stu-id="e6935-293">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="e6935-294">Corresponde ao sinal de menor em "\<abc>" e o atribui ao grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-294">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="e6935-295">4</span><span class="sxs-lookup"><span data-stu-id="e6935-295">4</span></span>|`[^<>]*`|<span data-ttu-id="e6935-296">Corresponde a "abc".</span><span class="sxs-lookup"><span data-stu-id="e6935-296">Matches "abc".</span></span>|  
|<span data-ttu-id="e6935-297">5</span><span class="sxs-lookup"><span data-stu-id="e6935-297">5</span></span>|`)+`|<span data-ttu-id="e6935-298">"<abc" é o valor do segundo grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-298">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="e6935-299">O próximo caractere na cadeia de caracteres de entrada não é um sinal de menor. Por isso, o mecanismo de expressão regular não volta para o subpadrão `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-299">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-300">6</span><span class="sxs-lookup"><span data-stu-id="e6935-300">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="e6935-301">Corresponde ao sinal de maior de "\<abc>", atribui "abc", que é a subcadeia de caracteres entre o grupo `Open` e o sinal de menor, para o grupo `Close` e exclui o valor atual ("<") do grupo `Open`, deixando-o vazio.</span><span class="sxs-lookup"><span data-stu-id="e6935-301">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="e6935-302">7</span><span class="sxs-lookup"><span data-stu-id="e6935-302">7</span></span>|`[^<>]*`|<span data-ttu-id="e6935-303">Procura caracteres que não sejam sinais de menor e maior depois do sinal de maior e não encontra correspondências.</span><span class="sxs-lookup"><span data-stu-id="e6935-303">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="e6935-304">8</span><span class="sxs-lookup"><span data-stu-id="e6935-304">8</span></span>|`)+`|<span data-ttu-id="e6935-305">O valor do terceiro grupo capturado é ">".</span><span class="sxs-lookup"><span data-stu-id="e6935-305">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="e6935-306">O próximo caractere na cadeia de caracteres de entrada não é um sinal de maior. Por isso, o mecanismo de expressão regular não volta para o subpadrão `((?'Close-Open'>)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-306">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-307">9</span><span class="sxs-lookup"><span data-stu-id="e6935-307">9</span></span>|`)*`|<span data-ttu-id="e6935-308">O valor do primeiro grupo capturado é "\<abc>".</span><span class="sxs-lookup"><span data-stu-id="e6935-308">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="e6935-309">O próximo caractere na cadeia de caracteres de entrada é um sinal de menor. Por isso, o mecanismo de expressão regular volta para o subpadrão `(((?'Open'<)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-309">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-310">10</span><span class="sxs-lookup"><span data-stu-id="e6935-310">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="e6935-311">Corresponde ao sinal de menor em "\<mno>" e o atribui ao grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-311">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="e6935-312">Agora, sua coleção <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> tem um único valor, "<".</span><span class="sxs-lookup"><span data-stu-id="e6935-312">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="e6935-313">11</span><span class="sxs-lookup"><span data-stu-id="e6935-313">11</span></span>|`[^<>]*`|<span data-ttu-id="e6935-314">Corresponde a "mno".</span><span class="sxs-lookup"><span data-stu-id="e6935-314">Matches "mno".</span></span>|  
|<span data-ttu-id="e6935-315">12</span><span class="sxs-lookup"><span data-stu-id="e6935-315">12</span></span>|`)+`|<span data-ttu-id="e6935-316">"<mno" é o valor do segundo grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="e6935-317">O próximo caractere na cadeia de caracteres de entrada é um sinal de menor. Por isso, o mecanismo de expressão regular volta para o subpadrão `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-318">13</span><span class="sxs-lookup"><span data-stu-id="e6935-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="e6935-319">Corresponde ao sinal de menor em "\<xyz>" e o atribui ao grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="e6935-320">Agora, a coleção <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> do grupo `Open` inclui duas capturas: o sinal de menor de "\<mno>" e o sinal de menor de "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="e6935-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="e6935-321">14</span><span class="sxs-lookup"><span data-stu-id="e6935-321">14</span></span>|`[^<>]*`|<span data-ttu-id="e6935-322">Corresponde a "xyz".</span><span class="sxs-lookup"><span data-stu-id="e6935-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="e6935-323">15</span><span class="sxs-lookup"><span data-stu-id="e6935-323">15</span></span>|`)+`|<span data-ttu-id="e6935-324">"<xyz" é o valor do segundo grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="e6935-325">O próximo caractere na cadeia de caracteres de entrada não é um sinal de menor. Por isso, o mecanismo de expressão regular não volta para o subpadrão `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-326">16</span><span class="sxs-lookup"><span data-stu-id="e6935-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="e6935-327">Corresponde ao sinal de maior em "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="e6935-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="e6935-328">"xyz" atribui a subcadeia de caracteres entre o grupo `Open` e o sinal de maior ao grupo `Close` e exclui o valor atual do grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="e6935-329">O valor da captura anterior (ao sinal de menor em "\<mno>") torna-se o valor atual do grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-329">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="e6935-330">Agora, a coleção <xref:System.Text.RegularExpressions.Group.Captures%2A> do grupo `Open` inclui uma única captura: o sinal de menor de "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="e6935-330">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="e6935-331">17</span><span class="sxs-lookup"><span data-stu-id="e6935-331">17</span></span>|`[^<>]*`|<span data-ttu-id="e6935-332">Procura caracteres que não sejam sinais de menor e maior e não encontra correspondências.</span><span class="sxs-lookup"><span data-stu-id="e6935-332">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="e6935-333">18</span><span class="sxs-lookup"><span data-stu-id="e6935-333">18</span></span>|`)+`|<span data-ttu-id="e6935-334">O valor do terceiro grupo capturado é ">".</span><span class="sxs-lookup"><span data-stu-id="e6935-334">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="e6935-335">O próximo caractere na cadeia de caracteres de entrada é um sinal de maior. Por isso, o mecanismo de expressão regular volta para o subpadrão `((?'Close-Open'>)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-335">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-336">19</span><span class="sxs-lookup"><span data-stu-id="e6935-336">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="e6935-337">Corresponde ao sinal de maior final de "xyz>>", atribui "mno\<xyz>" (a subcadeia de caracteres entre o grupo `Open` e o sinal de maior) ao grupo `Close` e exclui o valor atual do grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="e6935-337">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="e6935-338">Agora, o grupo `Open` está vazio.</span><span class="sxs-lookup"><span data-stu-id="e6935-338">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="e6935-339">20</span><span class="sxs-lookup"><span data-stu-id="e6935-339">20</span></span>|`[^<>]*`|<span data-ttu-id="e6935-340">Procura caracteres que não sejam sinais de menor e maior e não encontra correspondências.</span><span class="sxs-lookup"><span data-stu-id="e6935-340">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="e6935-341">21</span><span class="sxs-lookup"><span data-stu-id="e6935-341">21</span></span>|`)+`|<span data-ttu-id="e6935-342">O valor do terceiro grupo capturado é ">".</span><span class="sxs-lookup"><span data-stu-id="e6935-342">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="e6935-343">O próximo caractere na cadeia de caracteres de entrada não é um sinal de maior. Por isso, o mecanismo de expressão regular não volta para o subpadrão `((?'Close-Open'>)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-343">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-344">22</span><span class="sxs-lookup"><span data-stu-id="e6935-344">22</span></span>|`)*`|<span data-ttu-id="e6935-345">O valor do primeiro grupo capturado é "<mno\<xyz>>".</span><span class="sxs-lookup"><span data-stu-id="e6935-345">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="e6935-346">O próximo caractere na cadeia de caracteres de entrada não é um sinal de menor. Por isso, o mecanismo de expressão regular não volta para o subpadrão `(((?'Open'<)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-346">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="e6935-347">23</span><span class="sxs-lookup"><span data-stu-id="e6935-347">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="e6935-348">O grupo `Open` não é definido. Por isso, não há tentativa de correspondência.</span><span class="sxs-lookup"><span data-stu-id="e6935-348">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="e6935-349">24</span><span class="sxs-lookup"><span data-stu-id="e6935-349">24</span></span>|`$`|<span data-ttu-id="e6935-350">Corresponde ao final da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-350">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="e6935-351">Grupos de Não Captura</span><span class="sxs-lookup"><span data-stu-id="e6935-351">Noncapturing Groups</span></span>  
 <span data-ttu-id="e6935-352">O constructo de grupo a seguir não captura a subcadeia de caracteres correspondente a uma subexpressão:</span><span class="sxs-lookup"><span data-stu-id="e6935-352">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="e6935-353">em que *subexpression* é qualquer padrão de expressão regular válido.</span><span class="sxs-lookup"><span data-stu-id="e6935-353">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="e6935-354">O constructo de grupo de não captura geralmente é usada quando um quantificador é aplicado a um grupo, mas as subcadeias de caracteres capturadas pelo grupo não são úteis.</span><span class="sxs-lookup"><span data-stu-id="e6935-354">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6935-355">Se uma expressão regular inclui constructos aninhados de agrupamento, um constructo de grupo de não captura externo não se aplica às construções aninhadas internas de grupo.</span><span class="sxs-lookup"><span data-stu-id="e6935-355">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="e6935-356">O exemplo a seguir mostra uma expressão regular que inclui grupos de não captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-356">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="e6935-357">O resultado não inclui grupos capturados.</span><span class="sxs-lookup"><span data-stu-id="e6935-357">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="e6935-358">A expressão regular `(?:\b(?:\w+)\W*)+\.` corresponde a uma sentença terminada por um ponto final.</span><span class="sxs-lookup"><span data-stu-id="e6935-358">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="e6935-359">Como a expressão regular concentra-se em sentenças, e não em palavras, as construções de agrupamento são usadas apenas como quantificadores.</span><span class="sxs-lookup"><span data-stu-id="e6935-359">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="e6935-360">O padrão da expressão regular é interpretado conforme a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-360">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-361">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-361">Pattern</span></span>|<span data-ttu-id="e6935-362">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-362">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-363">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-363">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="e6935-364">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-364">Match one or more word characters.</span></span> <span data-ttu-id="e6935-365">Não atribui o texto coincidente a um grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-365">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="e6935-366">Corresponde a zero ou mais caracteres que não compõem palavras.</span><span class="sxs-lookup"><span data-stu-id="e6935-366">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="e6935-367">Corresponde ao padrão de um ou mais caracteres de palavra que começam com um limite de palavra, seguido por zero ou um espaço em branco uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="e6935-367">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="e6935-368">Não atribui o texto coincidente a um grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-368">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="e6935-369">Corresponde a um ponto final.</span><span class="sxs-lookup"><span data-stu-id="e6935-369">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="e6935-370">Opções de Grupo</span><span class="sxs-lookup"><span data-stu-id="e6935-370">Group Options</span></span>  
 <span data-ttu-id="e6935-371">O constructo de agrupamento a seguir aplica ou desabilita as opções especificadas em uma subexpressão:</span><span class="sxs-lookup"><span data-stu-id="e6935-371">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="e6935-372">`(?imnsx-imnsx:` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-372">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-373">em que *subexpression* é qualquer padrão de expressão regular válido.</span><span class="sxs-lookup"><span data-stu-id="e6935-373">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="e6935-374">Por exemplo, `(?i-s:)` ativa a diferenciação de maiúsculas e minúsculas e desabilita o modo de linha única.</span><span class="sxs-lookup"><span data-stu-id="e6935-374">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="e6935-375">Para saber mais sobre as opções embutidas que você pode especificar, veja [Opções de expressões regulares](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="e6935-375">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6935-376">Você pode especificar opções que se aplicam a toda uma expressão regular, em vez de a uma subexpressão, usando um construtor de classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> ou método estático.</span><span class="sxs-lookup"><span data-stu-id="e6935-376">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="e6935-377">Você também pode especificar opções embutidas que são aplicadas após um ponto específico de uma expressão regular, usando a construção de linguagem `(?imnsx-imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="e6935-377">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="e6935-378">O constructo de opções de grupo não é um grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-378">The group options construct is not a capturing group.</span></span> <span data-ttu-id="e6935-379">Ou seja, embora todas as porções de uma cadeia de caracteres que são capturadas pela *subexpressão* sejam incluídas na correspondência, elas não são incluídas em grupos capturados, nem usadas para preencher o objeto <xref:System.Text.RegularExpressions.GroupCollection>.</span><span class="sxs-lookup"><span data-stu-id="e6935-379">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="e6935-380">Por exemplo, a expressão regular `\b(?ix: d \w+)\s` no exemplo a seguir usa opções embutidas em um constructo de agrupamento para habilitar a correspondência sem diferenciação de maiúsculas e minúsculas e ignorar os espaços em branco do padrão, ao identificar todas as palavras que começam com a letra "d".</span><span class="sxs-lookup"><span data-stu-id="e6935-380">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="e6935-381">A expressão regular é definida como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-381">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-382">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-382">Pattern</span></span>|<span data-ttu-id="e6935-383">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-383">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-384">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-384">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="e6935-385">Usa a correspondência sem diferenciar letras maiúsculas e minúsculas e ignora espaços em branco nesse padrão e corresponde um "d" seguido por um ou mais caracteres que compõem palavras.</span><span class="sxs-lookup"><span data-stu-id="e6935-385">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="e6935-386">Corresponde a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="e6935-386">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="e6935-387">Asserções Lookahead Positivas de Largura Zero</span><span class="sxs-lookup"><span data-stu-id="e6935-387">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="e6935-388">O constructo de agrupamento a seguir define uma asserção lookahead positiva de largura zero:</span><span class="sxs-lookup"><span data-stu-id="e6935-388">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="e6935-389">`(?=` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-389">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-390">em que *subexpression* é qualquer padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-390">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="e6935-391">Para que a correspondência seja executada com êxito, a cadeia de caracteres de entrada deve corresponder ao padrão de expressão regular na *subexpression*, embora a subcadeia de caracteres com a qual a correspondência foi estabelecida não conste no resultado.</span><span class="sxs-lookup"><span data-stu-id="e6935-391">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="e6935-392">A asserção lookahead positiva de largura zero não retrocede.</span><span class="sxs-lookup"><span data-stu-id="e6935-392">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="e6935-393">Geralmente, as asserções desse tipo podem ser encontradas no final de um padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-393">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="e6935-394">Isso define uma subcadeia de caracteres que deve estar presente no final da cadeia de caracteres para que seja possível estabelecer a correspondência, mas que não seja incluída na correspondência.</span><span class="sxs-lookup"><span data-stu-id="e6935-394">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="e6935-395">Isso também é útil para evitar retrocessos em excesso.</span><span class="sxs-lookup"><span data-stu-id="e6935-395">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="e6935-396">Você pode usar asserções lookahead positivas de largura zero que garantam que um grupo capturado específico seja iniciado por um texto que corresponda a um subconjunto do padrão definido para o grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="e6935-396">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="e6935-397">Por exemplo, se um grupo de captura corresponder a caracteres de palavras em sequência, você pode usar uma asserção desse tipo para que o primeiro caractere seja uma caractere alfabético maiúsculo.</span><span class="sxs-lookup"><span data-stu-id="e6935-397">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="e6935-398">O exemplo a seguir usa asserção lookahead positiva de largura zero para estabelecer a correspondência da palavra que precede o verbo "is" na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-398">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="e6935-399">A expressão regular `\b\w+(?=\sis\b)` é interpretada conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-399">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-400">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-400">Pattern</span></span>|<span data-ttu-id="e6935-401">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-401">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-402">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-402">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="e6935-403">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-403">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="e6935-404">Determina se os caracteres que compõem palavras são seguidos por um caractere de espaço em branco e pela cadeia de caracteres "is", que termina com um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-404">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="e6935-405">Nesse caso, a correspondência ocorreu com êxito.</span><span class="sxs-lookup"><span data-stu-id="e6935-405">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="e6935-406">Asserções Lookahead Negativas de Largura Zero</span><span class="sxs-lookup"><span data-stu-id="e6935-406">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="e6935-407">O constructo de agrupamento a seguir define uma asserção lookahead negativa de largura zero:</span><span class="sxs-lookup"><span data-stu-id="e6935-407">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="e6935-408">`(?!` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-408">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-409">em que *subexpression* é qualquer padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-409">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="e6935-410">Para que a correspondência seja executada com êxito, a cadeia de caracteres de entrada não deve corresponder ao padrão de expressão regular na *subexpression*, embora a cadeia de caracteres com a qual a correspondência foi estabelecida não conste no resultado.</span><span class="sxs-lookup"><span data-stu-id="e6935-410">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="e6935-411">Geralmente, as asserções desse tipo podem ser encontradas no início ou no final de uma expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-411">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="e6935-412">No início da expressão regular, elas podem definir um padrão específico que não deve ser correspondido quando o início da expressão regular definir um padrão parecido, mas mais geral, para a correspondência.</span><span class="sxs-lookup"><span data-stu-id="e6935-412">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="e6935-413">Nesse caso, ela geralmente é usada para limitar o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="e6935-413">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="e6935-414">No final de uma expressão regular, pode definir uma subexpressão que pode não ocorrer no final de uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="e6935-414">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="e6935-415">O exemplo a seguir define uma expressão regular que usa uma asserção lookahead de largura zero no início da expressão regular para fazer a correspondência de palavras que não começam com "un".</span><span class="sxs-lookup"><span data-stu-id="e6935-415">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="e6935-416">A expressão regular `\b(?!un)\w+\b` é interpretada conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-416">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-417">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-417">Pattern</span></span>|<span data-ttu-id="e6935-418">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-418">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-419">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-419">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="e6935-420">Determina se os dois caracteres seguintes são "un".</span><span class="sxs-lookup"><span data-stu-id="e6935-420">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="e6935-421">Caso não sejam, é possível estabelecer a correspondência.</span><span class="sxs-lookup"><span data-stu-id="e6935-421">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="e6935-422">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-422">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="e6935-423">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-423">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="e6935-424">O exemplo a seguir define uma expressão regular que usa uma asserção lookahead de largura zero no final da expressão regular para fazer a correspondência de palavras que não terminam com um caractere de pontuação.</span><span class="sxs-lookup"><span data-stu-id="e6935-424">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="e6935-425">A expressão regular `\b\w+\b(?!\p{P})` é interpretada conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-425">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-426">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-426">Pattern</span></span>|<span data-ttu-id="e6935-427">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-427">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-428">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-428">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="e6935-429">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-429">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="e6935-430">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-430">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="e6935-431">Se o caractere seguinte não for um símbolo de pontuação (por exemplo, um ponto final ou uma vírgula), a correspondência é estabelecida.</span><span class="sxs-lookup"><span data-stu-id="e6935-431">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="e6935-432">Asserções Lookbehind Positivas de Largura Zero</span><span class="sxs-lookup"><span data-stu-id="e6935-432">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="e6935-433">O constructo de agrupamento a seguir define uma asserção lookbehind positiva de largura zero:</span><span class="sxs-lookup"><span data-stu-id="e6935-433">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="e6935-434">`(?<=` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-434">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-435">em que *subexpression* é qualquer padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-435">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="e6935-436">Para que a correspondência seja executada com êxito, a *subexpressão* deve ocorrer na cadeia de caracteres de entrada à esquerda da posição atual, embora `subexpression` não conste no resultado.</span><span class="sxs-lookup"><span data-stu-id="e6935-436">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="e6935-437">A asserção lookbehind positiva de largura zero não retrocede.</span><span class="sxs-lookup"><span data-stu-id="e6935-437">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="e6935-438">As asserções lookbehind positivas de largura zero geralmente são usadas no início de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="e6935-438">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="e6935-439">O padrão que elas definem é uma pré-condição para a correspondência, embora não constem no resultado.</span><span class="sxs-lookup"><span data-stu-id="e6935-439">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="e6935-440">Por exemplo, o exemplo a seguir estabelece a correspondência para os dois últimos dígitos de ano no século XXI (ou seja, ele requer que os dígitos "20" apareçam antes da cadeia de caracteres coincidente).</span><span class="sxs-lookup"><span data-stu-id="e6935-440">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="e6935-441">O padrão da expressão regular `(?<=\b20)\d{2}\b` é interpretado conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-441">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-442">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-442">Pattern</span></span>|<span data-ttu-id="e6935-443">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-443">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="e6935-444">Corresponde a dois dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="e6935-444">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="e6935-445">Continua a estabelecer a correspondência se os dois dígitos decimais forem precedidos por dígitos decimais "20" em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-445">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="e6935-446">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-446">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="e6935-447">As asserções lookbehind positivas de largura zero também são usadas para limitar o retrocesso quando o último caractere de um grupo capturado precisar ser um subconjunto de caracteres que corresponde ao padrão de expressão regular desse grupo.</span><span class="sxs-lookup"><span data-stu-id="e6935-447">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="e6935-448">Por exemplo, se um grupo captura todos os caracteres de palavras em sequência, você pode usar uma asserção lookbehind positivas de largura zero tipo para que o primeiro caractere seja uma letra.</span><span class="sxs-lookup"><span data-stu-id="e6935-448">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="e6935-449">Asserções Lookbehind Negativas de Largura Zero</span><span class="sxs-lookup"><span data-stu-id="e6935-449">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="e6935-450">O constructo de agrupamento a seguir define uma asserção lookbehind negativa de largura zero:</span><span class="sxs-lookup"><span data-stu-id="e6935-450">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="e6935-451">`(?<!` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-451">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-452">em que *subexpression* é qualquer padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-452">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="e6935-453">Para que a correspondência seja executada com êxito, a *subexpressão* não deve ocorrer na cadeia de caracteres de entrada à esquerda da posição atual.</span><span class="sxs-lookup"><span data-stu-id="e6935-453">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="e6935-454">No entanto, todas as subcadeias de caracteres que não corresponderem a `subexpression`, não serão incluídas no resultado.</span><span class="sxs-lookup"><span data-stu-id="e6935-454">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="e6935-455">As asserções lookbehind negativas de largura zero geralmente são usadas no início de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="e6935-455">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="e6935-456">O padrão definido por elas elimina uma correspondência na cadeia de caracteres seguinte.</span><span class="sxs-lookup"><span data-stu-id="e6935-456">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="e6935-457">Elas também são usadas para limitar o retrocesso quando o último caractere de um grupo capturado não precisar ser um ou mais caracteres que corresponde ao padrão de expressão regular desse grupo.</span><span class="sxs-lookup"><span data-stu-id="e6935-457">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="e6935-458">Por exemplo, se um grupo captura todos os caracteres de palavras em sequência, você pode usar uma asserção lookbehind positiva de largura zero para que o primeiro caractere não seja um sublinhado (_).</span><span class="sxs-lookup"><span data-stu-id="e6935-458">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="e6935-459">O exemplo a seguir estabelece a correspondência de data para qualquer dia da semana que não seja sábado nem domingo.</span><span class="sxs-lookup"><span data-stu-id="e6935-459">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="e6935-460">O padrão da expressão regular `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` é interpretado conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-460">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-461">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-461">Pattern</span></span>|<span data-ttu-id="e6935-462">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-462">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-463">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-463">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="e6935-464">Corresponde a um ou mais caracteres de palavra seguido por um espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="e6935-464">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="e6935-465">Corresponde a um ou dois dígitos decimais seguidos por uma caractere de espaço em branco e uma vírgula.</span><span class="sxs-lookup"><span data-stu-id="e6935-465">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="e6935-466">Corresponde a quatro dígitos decimais e encerra a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-466">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="e6935-467">Se a correspondência for precedida por algo que não seja as cadeias de caracteres "Sábado" ou "Domingo" seguidas por um espaço, a correspondência é realizada com êxito.</span><span class="sxs-lookup"><span data-stu-id="e6935-467">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="e6935-468">Subexpressões sem retrocesso</span><span class="sxs-lookup"><span data-stu-id="e6935-468">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="e6935-469">O constructo de agrupamento a seguir representa uma subexpressão sem retrocesso, também conhecida como subexpressão "greedy":</span><span class="sxs-lookup"><span data-stu-id="e6935-469">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="e6935-470">`(?>` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="e6935-470">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="e6935-471">em que *subexpression* é qualquer padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="e6935-471">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="e6935-472">Geralmente, se uma expressão regular incluir um padrão de correspondência opcional ou alternativo e a correspondência não for realizada com êxito, o mecanismo da expressão regular pode ramificar em diversas orientações para estabelecer a correspondência entre uma cadeia de caracteres de entrada e um padrão.</span><span class="sxs-lookup"><span data-stu-id="e6935-472">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="e6935-473">Se a correspondência não for encontrada na primeira ramificação, o mecanismo da expressão regular pode voltar ou retroceder ao ponto da primeira correspondência e tentar estabelecer a correspondência usando a segunda ramificação.</span><span class="sxs-lookup"><span data-stu-id="e6935-473">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="e6935-474">Esse processo pode continuar até que as tentativas se esgotem.</span><span class="sxs-lookup"><span data-stu-id="e6935-474">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="e6935-475">O constructo de linguagem da `(?>`*subexpression*`)` desabilita o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="e6935-475">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="e6935-476">O mecanismo de expressão regular estabelece a correspondência entre o máximo de caracteres da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="e6935-476">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="e6935-477">Quando não for possível estabelecer outras correspondências, ele não retrocede para tentar alternativas.</span><span class="sxs-lookup"><span data-stu-id="e6935-477">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="e6935-478">Ou seja, a subexpressão corresponde somente às cadeias de caracteres que poderiam corresponder somente à subexpressão. Ela não tenta fazer a correspondência de uma cadeia de caracteres com base na subexpressão em questão e nas subexpressões seguintes.</span><span class="sxs-lookup"><span data-stu-id="e6935-478">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="e6935-479">Essa opção é recomendada quando você sabe que o retrocesso não terá êxito.</span><span class="sxs-lookup"><span data-stu-id="e6935-479">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="e6935-480">Evitar que o mecanismo de expressão regular faça pesquisas desnecessárias, melhora o desempenho.</span><span class="sxs-lookup"><span data-stu-id="e6935-480">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="e6935-481">O exemplo a seguir mostra como uma subexpressão sem retrocesso modifica os resultados de uma correspondência padrão.</span><span class="sxs-lookup"><span data-stu-id="e6935-481">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="e6935-482">A expressão regular de retrocesso estabelece a correspondência de diversos caracteres repetidos, seguidos por outra ocorrência do mesmo caractere de um limite de palavra, mas a expressão regular sem retrocesso não faz isso.</span><span class="sxs-lookup"><span data-stu-id="e6935-482">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="e6935-483">A expressão regular sem retrocesso `(?>(\w)\1+).\b` é definida como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-483">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-484">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-484">Pattern</span></span>|<span data-ttu-id="e6935-485">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-485">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="e6935-486">Corresponde a um único caractere que compõe palavras e o atribui ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-486">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="e6935-487">Corresponde ao valor da primeira subcadeia de caracteres de captura uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="e6935-487">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="e6935-488">Corresponde a qualquer caractere.</span><span class="sxs-lookup"><span data-stu-id="e6935-488">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="e6935-489">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-489">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="e6935-490">Corresponde a uma ou mais ocorrências de um caractere de palavra duplicado, mas não executa o retrocesso para estabelecer a correspondência com o último caractere em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-490">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="e6935-491">Agrupando Constructos e Objetos de Expressão Regulares</span><span class="sxs-lookup"><span data-stu-id="e6935-491">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="e6935-492">As subcadeias de caracteres que correspondem a um grupo de captura de expressão regular são representadas por objetos <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType>, que podem ser recuperados do objeto <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> que é retornado pela propriedade <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-492">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e6935-493">O objeto <xref:System.Text.RegularExpressions.GroupCollection> é preenchido desta forma:</span><span class="sxs-lookup"><span data-stu-id="e6935-493">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
-   <span data-ttu-id="e6935-494">O primeiro objeto <xref:System.Text.RegularExpressions.Group> da coleção (o objeto de índice zero) representa a correspondência total.</span><span class="sxs-lookup"><span data-stu-id="e6935-494">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
-   <span data-ttu-id="e6935-495">O conjunto seguinte de objetos <xref:System.Text.RegularExpressions.Group> representa os grupos de captura não nomeados (numerados).</span><span class="sxs-lookup"><span data-stu-id="e6935-495">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="e6935-496">Eles aparecem na ordem em que são definidos na expressão regular, da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="e6935-496">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="e6935-497">Os valores dos índices desses grupos variam de 1 até o número de grupos de captura não nomeados presentes na coleção.</span><span class="sxs-lookup"><span data-stu-id="e6935-497">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="e6935-498">O índice de um determinado grupo equivale a sua referência inversa numerada.</span><span class="sxs-lookup"><span data-stu-id="e6935-498">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="e6935-499">Para saber mais sobre referências inversas, veja [Constructos de referência inversa](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md)).</span><span class="sxs-lookup"><span data-stu-id="e6935-499">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
-   <span data-ttu-id="e6935-500">O conjunto final de objetos <xref:System.Text.RegularExpressions.Group> representa os grupos de captura nomeados.</span><span class="sxs-lookup"><span data-stu-id="e6935-500">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="e6935-501">Eles aparecem na ordem em que são definidos na expressão regular, da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="e6935-501">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="e6935-502">O valor do índice do primeiro grupo de captura nomeado é um número maior que o índice do último grupo de captura não nomeado.</span><span class="sxs-lookup"><span data-stu-id="e6935-502">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="e6935-503">Se não houver grupos de captura não nomeados na expressão regular, o valor do índice do primeiro grupo de captura nomeado será um.</span><span class="sxs-lookup"><span data-stu-id="e6935-503">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="e6935-504">Se você aplicar um quantificador a um grupo de captura, as propriedades <xref:System.Text.RegularExpressions.Group><xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> do objeto refletirão a última subcadeia de caracteres capturada por um grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-504">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="e6935-505">Você pode recuperar todo o conjunto de subcadeias de caracteres capturadas por grupos que têm quantificadores do objeto <xref:System.Text.RegularExpressions.CaptureCollection> e que são retornados pela propriedade <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-505">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="e6935-506">O exemplo a seguir esclarece a relação entre os objetos <xref:System.Text.RegularExpressions.Group> e <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="e6935-506">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="e6935-507">O padrão da expressão regular `\b(\w+)\W+)+` extrai palavras, uma a uma, da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="e6935-507">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="e6935-508">Ele é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e6935-508">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e6935-509">Padrão</span><span class="sxs-lookup"><span data-stu-id="e6935-509">Pattern</span></span>|<span data-ttu-id="e6935-510">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6935-510">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e6935-511">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-511">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="e6935-512">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-512">Match one or more word characters.</span></span> <span data-ttu-id="e6935-513">Juntos, esses caracteres compõem uma palavra.</span><span class="sxs-lookup"><span data-stu-id="e6935-513">Together, these characters form a word.</span></span> <span data-ttu-id="e6935-514">Este é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-514">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="e6935-515">Estabeleça a correspondência com um ou mais caracteres que não compõem palavras.</span><span class="sxs-lookup"><span data-stu-id="e6935-515">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="e6935-516">Corresponde ao padrão de um ou mais caracteres de palavra, seguido por um ou mais caracteres que não compõem palavras, uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="e6935-516">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="e6935-517">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-517">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="e6935-518">O primeiro grupo de captura corresponde a cada palavra da sentença.</span><span class="sxs-lookup"><span data-stu-id="e6935-518">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="e6935-519">O segundo grupo de captura corresponde a cada palavras com a pontuação ou o espaço em branco que segue a palavra em questão.</span><span class="sxs-lookup"><span data-stu-id="e6935-519">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="e6935-520">O objeto <xref:System.Text.RegularExpressions.Group>, cujo índice é 2, fornece informações sobre o texto correspondente ao segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="e6935-520">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="e6935-521">O conjunto completo de palavras capturadas pelo grupo de captura está disponível no objeto <xref:System.Text.RegularExpressions.CaptureCollection>, retornado pela propriedade <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e6935-521">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e6935-522">Consulte também</span><span class="sxs-lookup"><span data-stu-id="e6935-522">See Also</span></span>  
 [<span data-ttu-id="e6935-523">Linguagem de expressão regular – referência rápida</span><span class="sxs-lookup"><span data-stu-id="e6935-523">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="e6935-524">Retrocesso</span><span class="sxs-lookup"><span data-stu-id="e6935-524">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
