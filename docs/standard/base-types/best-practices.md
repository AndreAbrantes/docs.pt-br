---
title: Práticas recomendadas para expressões regulares no .NET
description: Saiba como criar expressões regulares eficientes e eficazes no .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 9b09f5a2505888c6154a58a3512c94c51f89295b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124416"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="c4671-103">Melhores práticas para expressões regulares em .NET</span><span class="sxs-lookup"><span data-stu-id="c4671-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="c4671-104">O mecanismo de expressões regulares no .NET é uma ferramenta poderosa e repleta de recursos que processa o texto com base em correspondências de padrões em vez de em comparar e corresponder o texto literal.</span><span class="sxs-lookup"><span data-stu-id="c4671-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="c4671-105">Na maioria dos casos, ele realiza a correspondência de padrões de forma rápida e eficiente.</span><span class="sxs-lookup"><span data-stu-id="c4671-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="c4671-106">No entanto, em alguns casos, o mecanismo de expressões regulares pode parecer ser muito lento.</span><span class="sxs-lookup"><span data-stu-id="c4671-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="c4671-107">Em casos extremos, pode até mesmo parecer parar de responder enquanto processa uma entrada relativamente pequena em um período de horas ou até mesmo dias.</span><span class="sxs-lookup"><span data-stu-id="c4671-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="c4671-108">Este tópico descreve algumas das práticas recomendadas que os desenvolvedores podem adotar para garantir que as expressões regulares obtenham o máximo de desempenho.</span><span class="sxs-lookup"><span data-stu-id="c4671-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

## <a name="consider-the-input-source"></a><span data-ttu-id="c4671-109">Considere a fonte de entrada</span><span class="sxs-lookup"><span data-stu-id="c4671-109">Consider the input source</span></span>

<span data-ttu-id="c4671-110">Em geral, as expressões regulares podem aceitar dois tipos de entrada: restrita e não restrita.</span><span class="sxs-lookup"><span data-stu-id="c4671-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="c4671-111">Uma entrada restrita é o texto proveniente de uma fonte conhecida ou confiável e segue um formato predefinido.</span><span class="sxs-lookup"><span data-stu-id="c4671-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="c4671-112">Uma entrada irrestrita é um texto que se origina de uma origem não confiável como um usuário não confiável e não pode seguir um formato predefinido ou esperado.</span><span class="sxs-lookup"><span data-stu-id="c4671-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="c4671-113">Os padrões de expressões regulares geralmente são escritos para corresponder a entradas válidas.</span><span class="sxs-lookup"><span data-stu-id="c4671-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="c4671-114">Ou seja, os desenvolvedores examinam o texto que desejam corresponder e escrevem um padrão de expressão regular que corresponde a ele.</span><span class="sxs-lookup"><span data-stu-id="c4671-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="c4671-115">Os desenvolvedores então determinam se esse padrão requer correção ou uma elaboração adicional testando-o com vários itens de entrada válidos.</span><span class="sxs-lookup"><span data-stu-id="c4671-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="c4671-116">Quando o padrão corresponde a todas as entradas válidas presumidas, é declarado como pronto para produção e pode ser incluído em um aplicativo final.</span><span class="sxs-lookup"><span data-stu-id="c4671-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="c4671-117">Isso torna um padrão de expressão regular apropriado para corresponder uma entrada restrita.</span><span class="sxs-lookup"><span data-stu-id="c4671-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="c4671-118">No entanto, ele não o torna adequado para corresponder à entrada sem restrição.</span><span class="sxs-lookup"><span data-stu-id="c4671-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="c4671-119">Para corresponder a uma entrada sem restrição, uma expressão regular deve ser capaz de manipular três tipos de texto:</span><span class="sxs-lookup"><span data-stu-id="c4671-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="c4671-120">Texto que corresponda ao padrão da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="c4671-121">Texto que não corresponda ao padrão da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="c4671-122">Texto que quase corresponda ao padrão da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="c4671-123">O último tipo de texto é particularmente problemático para uma expressão regular que foi escrita para lidar com entradas restritas.</span><span class="sxs-lookup"><span data-stu-id="c4671-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="c4671-124">Se essa expressão regular também depender de [retrocesso](../../../docs/standard/base-types/backtracking-in-regular-expressions.md) abrangente, o mecanismo de expressões regulares poderá gastar um período fora do normal (em alguns casos, muitas horas ou dias) processando texto aparentemente inócuo.</span><span class="sxs-lookup"><span data-stu-id="c4671-124">If that regular expression also relies on extensive [backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="c4671-125">O exemplo a seguir usa uma expressão regular que é propensa a retrocesso excessivo e que pode rejeitar endereços de email válidos.</span><span class="sxs-lookup"><span data-stu-id="c4671-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="c4671-126">Você não deve usá-lo em uma rotina de validação de email.</span><span class="sxs-lookup"><span data-stu-id="c4671-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="c4671-127">Se você desejar uma expressão regular que valida endereços de email, confira [Como verificar se cadeias de caracteres estão em um formato de email válido](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="c4671-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="c4671-128">Por exemplo, considere uma expressão regular muito usada, mas extremamente problemática, para validar o alias de um endereço de email.</span><span class="sxs-lookup"><span data-stu-id="c4671-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="c4671-129">A expressão regular `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` é escrita para processar o que é considerado um endereço de email válido, o que consiste em um caractere alfanumérico seguido por zero ou mais caracteres que podem ser alfanuméricos, pontos ou hifens.</span><span class="sxs-lookup"><span data-stu-id="c4671-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="c4671-130">A expressão regular deve terminar com um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="c4671-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="c4671-131">No entanto, como mostra o exemplo a seguir, embora esta expressão regular manipule entradas válidas facilmente, seu desempenho é muito ineficiente ao processar uma entrada quase válida.</span><span class="sxs-lookup"><span data-stu-id="c4671-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="c4671-132">Conforme mostrado pela saída do exemplo, o mecanismo de expressões regulares processa o alias de email válido quase no mesmo tempo, independentemente do seu comprimento.</span><span class="sxs-lookup"><span data-stu-id="c4671-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="c4671-133">Por outro lado, quando o endereço de email quase válido tem mais de cinco caracteres, o tempo de processamento chega a dobrar para cada caractere adicional na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="c4671-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="c4671-134">Isso significa que uma cadeia de 28 caracteres quase válidos levaria mais de uma hora para ser processada e uma cadeia de 33 caracteres quase válidos demoraria quase um dia.</span><span class="sxs-lookup"><span data-stu-id="c4671-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="c4671-135">Como essa expressão regular foi desenvolvida considerando apenas a correspondência com o formato da entrada, ela não leva em consideração entradas que não correspondem ao padrão.</span><span class="sxs-lookup"><span data-stu-id="c4671-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="c4671-136">Isso, por sua vez, pode permitir que entradas não restritas quase correspondentes ao padrão da expressão regular prejudiquem significativamente o desempenho.</span><span class="sxs-lookup"><span data-stu-id="c4671-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="c4671-137">Para resolver este problema, você pode fazer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="c4671-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="c4671-138">Ao desenvolver um padrão, você deve considerar como o retrocesso pode afetar o desempenho do mecanismo de expressões regulares, especialmente se a expressão regular for criada para processar entradas sem restrição.</span><span class="sxs-lookup"><span data-stu-id="c4671-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="c4671-139">Para obter mais informações, consulte a [seção Take Charge of Backtracking.](#take-charge-of-backtracking)</span><span class="sxs-lookup"><span data-stu-id="c4671-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="c4671-140">Teste rigorosamente sua expressão regular usando entradas inválidas e quase válidas, bem como entradas válidas.</span><span class="sxs-lookup"><span data-stu-id="c4671-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="c4671-141">Para gerar entradas para uma expressão regular específica aleatoriamente, você pode usar [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), que é uma ferramenta de exploração de expressões regulares da Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="c4671-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="c4671-142">Trate a instanciação de objetos adequadamente</span><span class="sxs-lookup"><span data-stu-id="c4671-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="c4671-143">No coração do modelo de objeto de expressões regulares do .NET está a classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>, a qual representa o mecanismo de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="c4671-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="c4671-144">Muitas vezes, o maior fator individual que afeta o desempenho das expressões regulares é a forma como o mecanismo <xref:System.Text.RegularExpressions.Regex> é usado.</span><span class="sxs-lookup"><span data-stu-id="c4671-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="c4671-145">Definir uma expressão regular envolve o acoplamento vigoroso do mecanismo de expressões regulares com um padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="c4671-146">Esse processo de acoplamento, seja envolvendo a instanciação de um objeto <xref:System.Text.RegularExpressions.Regex> ao passar para seu construtor um padrão de expressão regular ou chamando um método estático ao passar o padrão de expressão regular com a cadeia de caracteres a ser analisada, é necessariamente caro.</span><span class="sxs-lookup"><span data-stu-id="c4671-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="c4671-147">Para uma discussão mais detalhada das implicações de desempenho do uso de expressões regulares interpretadas e compiladas, confira [Otimizando o desempenho de expressões regulares, parte II: Tomando conta do retrocesso](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) no blog da equipe de BCL.</span><span class="sxs-lookup"><span data-stu-id="c4671-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="c4671-148">É possível acoplar o mecanismo de expressões regulares com um padrão específico de expressão regular e usar o mecanismo para fazer a correspondência com texto de várias maneiras:</span><span class="sxs-lookup"><span data-stu-id="c4671-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="c4671-149">Você pode chamar um método estático de correspondência de padrões, <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4671-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c4671-150">Isso não requer a instanciação de um objeto de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="c4671-151">É possível criar uma instância de um objeto <xref:System.Text.RegularExpressions.Regex> e chamar um método instanciado de correspondência de padrões de uma expressão regular interpretada.</span><span class="sxs-lookup"><span data-stu-id="c4671-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="c4671-152">Esse é o método padrão para associar o mecanismo de expressões regulares a uma expressão regular padrão.</span><span class="sxs-lookup"><span data-stu-id="c4671-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="c4671-153">Ele ocorre quando um objeto <xref:System.Text.RegularExpressions.Regex> é instanciado sem um argumento `options` que inclua o sinalizador <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="c4671-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="c4671-154">Você pode criar uma instância de um objeto <xref:System.Text.RegularExpressions.Regex> e chamar um método instanciado de correspondência de padrões de uma expressão regular compilada.</span><span class="sxs-lookup"><span data-stu-id="c4671-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="c4671-155">Os objetos de expressão regular representam padrões compilados quando um objeto <xref:System.Text.RegularExpressions.Regex> é instanciado com um argumento `options` que inclui o sinalizador <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="c4671-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="c4671-156">Você pode criar um objeto <xref:System.Text.RegularExpressions.Regex> com propósito especial que é fortemente acoplado a um padrão de expressão regular específico, compilá-lo e salvá-lo em um assembly autônomo.</span><span class="sxs-lookup"><span data-stu-id="c4671-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="c4671-157">Você pode fazer ao chamar o método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4671-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="c4671-158">A maneira específica como você chama métodos de correspondência de expressões regulares pode ter impacto significativo em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c4671-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="c4671-159">As seções a seguir abordam quando usar chamadas de métodos estáticos, expressões regulares interpretadas e expressões regulares compiladas para melhorar o desempenho do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c4671-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c4671-160">A forma da chamada de método (estático, interpretada, compilada) afeta o desempenho se a mesma expressão regular é usada repetidamente em chamadas de método ou se um aplicativo faz uso extensivo de objetos de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="c4671-161">Expressões regulares estáticas</span><span class="sxs-lookup"><span data-stu-id="c4671-161">Static regular expressions</span></span>

<span data-ttu-id="c4671-162">Os métodos de expressões regulares estáticas são recomendados como uma alternativa a criar repetidamente instâncias de um objeto de expressão regular com a mesma expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="c4671-163">Ao contrário dos padrões de expressão regulares usados por objetos de expressão regulares, os códigos de operação ou a linguagem intermediária da Microsoft compilada (MSIL) a partir de padrões usados em chamadas de método séptico são armazenados em cache interno pelo mecanismo de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="c4671-164">Por exemplo, um manipulador de eventos chama frequentemente outro método para validar a entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="c4671-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="c4671-165">Isso é refletido no código a seguir, no qual o evento <xref:System.Windows.Forms.Button> de um controle <xref:System.Windows.Forms.Control.Click> é usado para chamar um método `IsValidCurrency`, o qu al verifica se o usuário inseriu um símbolo de moeda seguido por pelo menos um dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="c4671-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="c4671-166">Uma implementação bem ineficiente do método `IsValidCurrency` é mostrada no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4671-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="c4671-167">Observe que cada chamada de método reinstancia um objeto <xref:System.Text.RegularExpressions.Regex> com o mesmo padrão.</span><span class="sxs-lookup"><span data-stu-id="c4671-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="c4671-168">Isso, por sua vez, significa que o padrão de expressão regular deve ser recompilado toda vez que o método é chamado.</span><span class="sxs-lookup"><span data-stu-id="c4671-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="c4671-169">Você deve substituir esse código ineficiente por uma chamada ao método estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4671-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c4671-170">Isso elimina a necessidade de criar uma instância de um objeto <xref:System.Text.RegularExpressions.Regex> toda vez que você deseja chamar um método de correspondência de padrões e permite que o mecanismo de expressões regulares recupere uma versão compilada da expressão regular do cache.</span><span class="sxs-lookup"><span data-stu-id="c4671-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="c4671-171">Por padrão, os 15 padrões de expressões regulares estáticas usados mais recentemente são armazenados no cache.</span><span class="sxs-lookup"><span data-stu-id="c4671-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="c4671-172">Para aplicativos que requerem um número maior de expressões regulares estáticas armazenadas no cache, o tamanho do cache pode ser ajustado com a definição da propriedade <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4671-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="c4671-173">A expressão regular `\p{Sc}+\s*\d+` que é usada neste exemplo verifica que a cadeia de caracteres de entrada consiste em um símbolo de moeda e pelo menos um dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="c4671-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="c4671-174">O padrão é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4671-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="c4671-175">Padrão</span><span class="sxs-lookup"><span data-stu-id="c4671-175">Pattern</span></span>|<span data-ttu-id="c4671-176">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="c4671-177">Corresponde a um ou mais caracteres no símbolo Unicode, categoria de moeda.</span><span class="sxs-lookup"><span data-stu-id="c4671-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="c4671-178">Corresponder a zero ou mais caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c4671-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="c4671-179">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="c4671-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="c4671-180">Expressões regulares compiladas vs. interpretadas</span><span class="sxs-lookup"><span data-stu-id="c4671-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="c4671-181">Os padrões de expressões regulares não são associados ao mecanismo de expressões regulares com a especificação da opção <xref:System.Text.RegularExpressions.RegexOptions.Compiled> são interpretados.</span><span class="sxs-lookup"><span data-stu-id="c4671-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="c4671-182">Quando um objeto de expressão regular é instanciado, o mecanismo de expressões regulares converte a expressão regular em um conjunto de códigos de operação.</span><span class="sxs-lookup"><span data-stu-id="c4671-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="c4671-183">Quando um método de instância é chamado, os códigos de operação são convertidos para MSIL e executados pelo compilador JIT.</span><span class="sxs-lookup"><span data-stu-id="c4671-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="c4671-184">Da mesma forma, quando um método estático de expressão regular é chamado e a expressão regular não pode ser encontrada no cache, o mecanismo de expressão regular converte a expressão regular em um conjunto de códigos operacionais e os armazena no cache.</span><span class="sxs-lookup"><span data-stu-id="c4671-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="c4671-185">Em seguida, converte esses códigos de operação para MSIL de modo que o compilador JIT possa executá-los.</span><span class="sxs-lookup"><span data-stu-id="c4671-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="c4671-186">As expressões regulares interpretadas reduzem o tempo de inicialização ao custo de um tempo de execução mais lento.</span><span class="sxs-lookup"><span data-stu-id="c4671-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="c4671-187">Devido a isso, eles são melhores utilizados quando a expressão regular é usada em um pequeno número de chamadas de método ou se o número exato de chamadas para métodos de expressão regular é desconhecido, mas com a expectativa de ser pequeno.</span><span class="sxs-lookup"><span data-stu-id="c4671-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="c4671-188">À medida que número de chamadas de método aumenta, o ganho de desempenho do tempo de inicialização reduzido é superado pela velocidade de execução mais lenta.</span><span class="sxs-lookup"><span data-stu-id="c4671-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="c4671-189">Os padrões de expressões regulares associados ao mecanismo de expressões regulares com a especificação da opção <xref:System.Text.RegularExpressions.RegexOptions.Compiled> são compilados.</span><span class="sxs-lookup"><span data-stu-id="c4671-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="c4671-190">Isso significa que, quando um objeto de expressão regular é instanciado ou quando um método de expressão regular estática é chamado e a expressão regular não pode ser encontrada no cache, o mecanismo de expressões regulares converte a expressão regular para um conjunto intermediário de códigos de operação, que em seguida é convertido para MSIL.</span><span class="sxs-lookup"><span data-stu-id="c4671-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="c4671-191">Quando um método é chamado, o compilador JIT executa o MSIL.</span><span class="sxs-lookup"><span data-stu-id="c4671-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="c4671-192">Em contraste com as expressões regulares interpretadas, as expressões regulares compiladas aumentam o tempo de inicialização, mas executam os métodos individuais de correspondência padrão de forma mais rápida.</span><span class="sxs-lookup"><span data-stu-id="c4671-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="c4671-193">Como resultado, o benefício de desempenho que resulta da compilação da expressão regular aumenta em proporção ao número de métodos de expressões regulares chamados.</span><span class="sxs-lookup"><span data-stu-id="c4671-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="c4671-194">Para resumir, recomendamos que você use expressões regulares interpretadas ao chamar métodos de expressões regulares com uma expressão regular específica com relativa pouca frequência.</span><span class="sxs-lookup"><span data-stu-id="c4671-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="c4671-195">Você deve usar expressões regulares compiladas ao chamar os métodos de expressões regulares com uma expressão regular específica com uma relativa frequência.</span><span class="sxs-lookup"><span data-stu-id="c4671-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="c4671-196">É difícil determinar o limite exato em que as velocidades de execução mais lentas das expressões regulares interpretadas suplantam os ganhos proporcionados pelo tempo de inicialização reduzido ou o limite em que os tempos de inicialização mais lentos das expressões regulares compiladas suplantam os ganhos gerados por suas velocidades de execução mais rápida.</span><span class="sxs-lookup"><span data-stu-id="c4671-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="c4671-197">O limite depende de vários fatores, incluindo a complexidade da expressão regular e dos dados específicos que são processados.</span><span class="sxs-lookup"><span data-stu-id="c4671-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="c4671-198">Para determinar se expressões regulares interpretadas ou compiladas oferecem o melhor desempenho para seu cenário de aplicativo específico, você pode usar a classe <xref:System.Diagnostics.Stopwatch> para comparar seu tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="c4671-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="c4671-199">O exemplo a seguir compara o desempenho de expressões regulares compiladas e interpretadas ao ler as dez primeiras frases e ao ler todas as frases no texto *The Financier* de Theodore Dreiser.</span><span class="sxs-lookup"><span data-stu-id="c4671-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="c4671-200">Conforme mostrado pela saída do exemplo, quando apenas dez chamadas são feitas para os métodos correspondentes de expressão regular, uma expressão regular interpretada oferece um desempenho melhor do que uma expressão regular compilada.</span><span class="sxs-lookup"><span data-stu-id="c4671-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="c4671-201">No entanto, uma expressão regular compilada oferece melhor desempenho quando um grande número de chamadas (neste caso, mais 13.000) é feito.</span><span class="sxs-lookup"><span data-stu-id="c4671-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="c4671-202">O padrão de expressão regular usado neste exemplo, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, é definido como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4671-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="c4671-203">Padrão</span><span class="sxs-lookup"><span data-stu-id="c4671-203">Pattern</span></span>|<span data-ttu-id="c4671-204">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="c4671-205">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="c4671-206">Fazer a correspondência a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="c4671-207">Corresponde a um zero ou um retorno de carro seguido por um caractere de nova linha, ou zero ou uma vírgula seguida por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c4671-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="c4671-208">Corresponde a zero ou mais ocorrências de um ou mais caracteres de palavra que são seguidos por zero ou por retornos de carro e por um caractere de nova linha ou por zero ou uma vírgula seguida por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c4671-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="c4671-209">Fazer a correspondência a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="c4671-210">Corresponde a um ponto, um ponto de interrogação, dois-pontos, ponto-e-vírgula ou ponto de exclamação.</span><span class="sxs-lookup"><span data-stu-id="c4671-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="c4671-211">Expressões regulares: Compilados para uma montagem</span><span class="sxs-lookup"><span data-stu-id="c4671-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="c4671-212">O .NET também permite criar um assembly que contém expressões regulares compiladas.</span><span class="sxs-lookup"><span data-stu-id="c4671-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="c4671-213">Isso move a ocorrência de desempenho da compilação de expressões regulares do tempo de execução para o tempo de design.</span><span class="sxs-lookup"><span data-stu-id="c4671-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="c4671-214">No entanto, também envolve trabalho extra: você deve definir as expressões regulares com antecedência e compilá-las em um assembly.</span><span class="sxs-lookup"><span data-stu-id="c4671-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="c4671-215">O compilador pode então fazer referência a esse assembly ao compilar código-fonte que usa expressões regulares do assembly.</span><span class="sxs-lookup"><span data-stu-id="c4671-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="c4671-216">Cada expressão regular compilada no assembly é representada por uma classe que deriva de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="c4671-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="c4671-217">Para compilar expressões regulares em um assembly, é necessário chamar o método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> e passar a ele uma matriz de objetos <xref:System.Text.RegularExpressions.RegexCompilationInfo> que representam as expressões regulares que serão compiladas e um objeto de <xref:System.Reflection.AssemblyName> que contém informações sobre o assembly a ser criado.</span><span class="sxs-lookup"><span data-stu-id="c4671-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="c4671-218">Recomendamos que você compile as expressões regulares em um assembly nestas situações:</span><span class="sxs-lookup"><span data-stu-id="c4671-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="c4671-219">Se você é um desenvolvedor de componentes que deseja criar uma biblioteca de expressões regulares reutilizáveis.</span><span class="sxs-lookup"><span data-stu-id="c4671-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="c4671-220">Se você pretende que seus métodos de correspondência de padrões das expressões regulares sejam chamados um número indefinido de vezes -- de uma ou duas vezes a milhares ou dezenas de milhares de vezes.</span><span class="sxs-lookup"><span data-stu-id="c4671-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="c4671-221">Ao contrário de expressões regulares compiladas ou interpretadas, as expressões regulares compiladas em assemblies separados oferecem desempenho consistente, independentemente do número de chamadas a métodos.</span><span class="sxs-lookup"><span data-stu-id="c4671-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="c4671-222">Se estiver usando expressões regulares compiladas para otimizar o desempenho, não use reflexão para criar o assembly, carregar o mecanismo de expressões regulares e executar os métodos de correspondência de padrões.</span><span class="sxs-lookup"><span data-stu-id="c4671-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="c4671-223">Isso requer que você evite criar padrões de expressões regulares dinamicamente, e que você especifique as opções de correspondência de padrões (como correspondência de padrões sem diferenciação de maiúsculas e minúsculas) no momento em que o assembly é criado.</span><span class="sxs-lookup"><span data-stu-id="c4671-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="c4671-224">Exige também que você separe o código que cria o assembly do código que usa a expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="c4671-225">O exemplo a seguir mostra como criar um assembly que contém uma expressão regular compilada.</span><span class="sxs-lookup"><span data-stu-id="c4671-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="c4671-226">Ele cria uma `RegexLib.dll` montagem nomeada com `SentencePattern`uma única classe de expressão regular, que contém o padrão de expressão regular correspondente a frases usado na seção [''Expressões regulares'.](#interpreted-vs-compiled-regular-expressions)</span><span class="sxs-lookup"><span data-stu-id="c4671-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="c4671-227">Quando o exemplo é compilado em um executável e executado, ele cria um assembly denominado `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="c4671-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="c4671-228">A expressão regular é representada por uma classe denominada `Utilities.RegularExpressions.SentencePattern` que é derivada de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="c4671-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="c4671-229">O exemplo a seguir usa a expressão regular compilada para extrair as sentenças do texto *The Financier*, de Theodore Dreiser.</span><span class="sxs-lookup"><span data-stu-id="c4671-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="c4671-230">Tome conta do retrocesso</span><span class="sxs-lookup"><span data-stu-id="c4671-230">Take charge of backtracking</span></span>

<span data-ttu-id="c4671-231">Normalmente, o mecanismo de expressões regulares usa progressão linear para percorrer uma cadeia de caracteres de entrada e compará-la a uma expressão regular padrão.</span><span class="sxs-lookup"><span data-stu-id="c4671-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="c4671-232">No entanto, quando quantificadores indefinidos, como `*`, `+` e `?` são usados em uma expressão regular padrão, o mecanismo de expressões regulares pode desistir de uma parte das correspondências parciais com êxito e retornar a um estado salvo anteriormente para procurar uma correspondência com êxito para o padrão inteiro.</span><span class="sxs-lookup"><span data-stu-id="c4671-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="c4671-233">Esse processo é conhecido como retrocesso.</span><span class="sxs-lookup"><span data-stu-id="c4671-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="c4671-234">Para saber mais sobre o retrocesso, confira [Detalhes do comportamento de expressões regulares](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) e [Retrocesso](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c4671-234">For more information on backtracking, see [Details of Regular Expression Behavior](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) and [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="c4671-235">Para uma discussão mais detalhada do retrocesso, confira [Como otimizar o desempenho de expressões regulares, Parte II: Como tolar conta do retrocesso](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) no blog da equipe do BCL.</span><span class="sxs-lookup"><span data-stu-id="c4671-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="c4671-236">O suporte ao retrocesso proporciona poder e flexibilidade às expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="c4671-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="c4671-237">Ele também coloca a responsabilidade por controlar o funcionamento do mecanismo de expressões regulares nas mãos dos desenvolvedores de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="c4671-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="c4671-238">Como os desenvolvedores geralmente não estão cientes dessa responsabilidade, o uso indevido do retrocesso ou a confiança no retrocesso excessivo geralmente exerce o papel mais significativo na degradação do desempenho da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="c4671-239">Em um cenário de pior caso, o tempo de execução pode dobrar para cada caractere adicional na cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="c4671-240">Na verdade, quando o retrocesso é usado excessivamente, é fácil criar o equivalente programático de um loop infinito se a entrada quase corresponder ao padrão da expressão regular; o mecanismo de expressões regulares pode levar horas ou mesmo dias para processar uma cadeia de caracteres de entrada relativamente curta.</span><span class="sxs-lookup"><span data-stu-id="c4671-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="c4671-241">Frequentemente, os aplicativos pagam uma penalidade de desempenho por usar o retrocesso, mesmo ele não sendo essencial para uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="c4671-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="c4671-242">Por exemplo, a expressão regular `\b\p{Lu}\w*\b` corresponde a todas as palavras que começam com um caractere maiúsculo, como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4671-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="c4671-243">Padrão</span><span class="sxs-lookup"><span data-stu-id="c4671-243">Pattern</span></span>|<span data-ttu-id="c4671-244">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="c4671-245">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="c4671-246">Corresponder a um caractere maiúsculo.</span><span class="sxs-lookup"><span data-stu-id="c4671-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="c4671-247">Corresponder a zero ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="c4671-248">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="c4671-249">Como um limite de palavra não é o mesmo que ou um subconjunto de, um caractere de palavra, não há nenhuma possibilidade de o mecanismo de expressões regulares cruzar um limite de palavra ao corresponder caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="c4671-250">Isso significa que, para esta expressão regular, o retrocesso nunca pode contribuir para o êxito total de qualquer correspondência – ele só pode prejudicar o desempenho, pois o mecanismo de expressões regulares é forçado a salvar o estado para cada correspondência preliminar bem-sucedida de um caractere de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="c4671-251">Se você determinar que o retrocesso não é necessário, `(?>subexpression)` você pode desativá-lo usando o elemento de linguagem, conhecido como um grupo atômico.</span><span class="sxs-lookup"><span data-stu-id="c4671-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="c4671-252">O exemplo a seguir analisa uma cadeia de caracteres de entrada usando duas expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="c4671-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="c4671-253">A primeira, `\b\p{Lu}\w*\b`, depende do retrocesso.</span><span class="sxs-lookup"><span data-stu-id="c4671-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="c4671-254">A segunda, `\b\p{Lu}(?>\w*)\b`, desabilita o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="c4671-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="c4671-255">Conforme mostrado pela saída do exemplo, ambas produzem o mesmo resultado.</span><span class="sxs-lookup"><span data-stu-id="c4671-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="c4671-256">Em muitos casos, o retrocesso é essencial para corresponder um padrão de expressão regular ao texto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="c4671-257">No entanto, o retrocesso excessivo pode prejudicar severamente o desempenho e criar a impressão de que um aplicativo parou de responder.</span><span class="sxs-lookup"><span data-stu-id="c4671-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="c4671-258">Em particular, isso acontece quando quantificadores são aninhados e o texto que corresponde à subexpressão externa é um subconjunto do texto que corresponde à subexpressão interna.</span><span class="sxs-lookup"><span data-stu-id="c4671-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="c4671-259">Além de evitar retrocessos excessivos, você deve usar o recurso de tempo limite para garantir que retrocessos excessivos não degradem severamente o desempenho da expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="c4671-260">Para obter mais informações, confira a seção [Usar valores de tempo limite](#use-time-out-values).</span><span class="sxs-lookup"><span data-stu-id="c4671-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="c4671-261">Por exemplo, o padrão de expressão regular `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` destina-se a corresponder a um número de peça que consiste em pelo menos um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="c4671-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="c4671-262">Todos os demais caracteres podem consistir em um caractere alfanumérico, um hífen, um sublinhado ou um ponto, embora o último caractere deva ser alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="c4671-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="c4671-263">Um cifrão termina o número da peça.</span><span class="sxs-lookup"><span data-stu-id="c4671-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="c4671-264">Em alguns casos, esse padrão de expressão regular pode exibir um desempenho muito ruim porque os quantificadores estão aninhados e porque a subexpressão `[0-9A-Z]` é um subconjunto da subexpressão `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="c4671-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="c4671-265">Nesses casos, você pode otimizar o desempenho da expressão regular ao remover os quantificadores aninhados e substituir a subexpressão externa por uma declaração de lookahead ou lookbehind de largura zero.</span><span class="sxs-lookup"><span data-stu-id="c4671-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="c4671-266">As asserções lookahead e lookbehind são âncoras; elas não movem o ponteiro na cadeia de caracteres de entrada, mas fazem uma verificação para verificar se uma condição especificada foi atendida.</span><span class="sxs-lookup"><span data-stu-id="c4671-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="c4671-267">Por exemplo, a expressão regular do número de peça pode ser reescrita como `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="c4671-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="c4671-268">Esse padrão de expressão regular é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4671-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="c4671-269">Padrão</span><span class="sxs-lookup"><span data-stu-id="c4671-269">Pattern</span></span>|<span data-ttu-id="c4671-270">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="c4671-271">Começar a correspondência no início da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="c4671-272">Corresponde a um caractere alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="c4671-272">Match an alphanumeric character.</span></span> <span data-ttu-id="c4671-273">O número de peça deve consistir em pelo menos este caractere.</span><span class="sxs-lookup"><span data-stu-id="c4671-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="c4671-274">Corresponde a zero ou mais ocorrências de qualquer caractere de palavra, hífen ou ponto.</span><span class="sxs-lookup"><span data-stu-id="c4671-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="c4671-275">Corresponde a um cifrão.</span><span class="sxs-lookup"><span data-stu-id="c4671-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="c4671-276">Examine além do cifrão final para garantir que o caractere anterior seja alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="c4671-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="c4671-277">Finalizar a correspondência no final da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="c4671-278">O exemplo a seguir ilustra o uso dessa expressão regular para corresponder a uma que contém possíveis números de peças.</span><span class="sxs-lookup"><span data-stu-id="c4671-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="c4671-279">A linguagem de expressões regulares no .NET inclui os seguintes elementos de linguagem que você pode usar para eliminar quantificadores aninhados.</span><span class="sxs-lookup"><span data-stu-id="c4671-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="c4671-280">Para saber mais, confira [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c4671-280">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="c4671-281">Elemento de linguagem</span><span class="sxs-lookup"><span data-stu-id="c4671-281">Language element</span></span>|<span data-ttu-id="c4671-282">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="c4671-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="c4671-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="c4671-284">Lookahead positivo de largura zero.</span><span class="sxs-lookup"><span data-stu-id="c4671-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="c4671-285">Examine além da posição atual para determinar se `subexpression` coincide com a cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="c4671-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="c4671-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="c4671-287">Lookahead negativo de largura zero.</span><span class="sxs-lookup"><span data-stu-id="c4671-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="c4671-288">Examine além da posição atual para determinar se `subexpression` não coincide com a cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="c4671-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="c4671-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="c4671-290">Lookbehind positivo de largura zero.</span><span class="sxs-lookup"><span data-stu-id="c4671-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="c4671-291">Examine o conteúdo que antecede a posição atual para determinar se `subexpression` coincide com a cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="c4671-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="c4671-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="c4671-293">Lookbehind negativo de largura zero.</span><span class="sxs-lookup"><span data-stu-id="c4671-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="c4671-294">Examine o conteúdo que antecede a posição atual para determinar se `subexpression` não coincide com a cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4671-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="c4671-295">Use valores de tempo limite</span><span class="sxs-lookup"><span data-stu-id="c4671-295">Use time-out values</span></span>

<span data-ttu-id="c4671-296">Se suas expressões regulares processarem entradas quase correspondentes ao padrão da expressão regular, elas poderão frequentemente confiar no retrocesso excessivo, o que afeta significativamente o desempenho.</span><span class="sxs-lookup"><span data-stu-id="c4671-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="c4671-297">Além de considerar cuidadosamente o uso do retrocesso e testar a expressão regular contra entradas quase correspondentes, você deve sempre definir um valor de tempo limite para garantir que o impacto do retrocesso excessivo, caso ocorra, seja minimizado.</span><span class="sxs-lookup"><span data-stu-id="c4671-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="c4671-298">O intervalo de tempo de tempo de expressão regular define o período de tempo que o mecanismo de expressão regular procurará por uma única correspondência antes de se esporem. O intervalo de tempo <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>padrão é, o que significa que a expressão regular não terá tempo. Você pode substituir esse valor e definir um intervalo de tempo de saída da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="c4671-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="c4671-299">Ao fornecer um valor de tempo limite ao criar uma instância de um objeto <xref:System.Text.RegularExpressions.Regex> ao chamar o construtor <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4671-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span>

- <span data-ttu-id="c4671-300">Ao chamar um método estático de correspondência de padrão, como <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, que inclui um parâmetro `matchTimeout`.</span><span class="sxs-lookup"><span data-stu-id="c4671-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="c4671-301">Para expressões regulares compiladas que são criadas chamando-se o método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, ao chamar o construtor que tem um parâmetro do tipo <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="c4671-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="c4671-302">Se você tiver definido um intervalo de tempo limite e uma correspondência não for localizada no final do intervalo, o método de expressão regular gerará uma exceção <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="c4671-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="c4671-303">No manipulador de exceção, você pode optar por tentar fazer novamente a correspondência com um intervalo de tempo limite mais longo, abandonar a tentativa de correspondência e assumir que não há nenhuma correspondência ou abandonar a tentativa de correspondência e registrar as informações de exceção para análise futura.</span><span class="sxs-lookup"><span data-stu-id="c4671-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="c4671-304">O exemplo a seguir define um método `GetWordData` que instancia uma expressão regular com um intervalo de tempo limite de 350 milissegundos para calcular o número de palavras e o número médio de caracteres em uma palavra em um documento de texto.</span><span class="sxs-lookup"><span data-stu-id="c4671-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="c4671-305">Se a operação de correspondência exceder o tempo limite, o intervalo de tempo limite será aumentado em 350 milissegundos e o objeto de <xref:System.Text.RegularExpressions.Regex> será reinstanciado.</span><span class="sxs-lookup"><span data-stu-id="c4671-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="c4671-306">Se o novo intervalo de tempo limite exceder 1 segundo, o método gerará novamente a exceção no chamador.</span><span class="sxs-lookup"><span data-stu-id="c4671-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="c4671-307">Capture somente quando necessário</span><span class="sxs-lookup"><span data-stu-id="c4671-307">Capture only when necessary</span></span>

<span data-ttu-id="c4671-308">As expressões regulares no .NET dão suporte a vários constructos de agrupamento, que permitem a você agrupar um padrão de expressão regular em uma ou mais subexpressões.</span><span class="sxs-lookup"><span data-stu-id="c4671-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="c4671-309">Os construtos de agrupamento mais usados `(`na linguagem de expressão regular .NET são `(?<` *a subexpressão*`)`, que define um grupo de captura numerado e a*subexpressão*`)` *de nome,*`>`que define um grupo de captura chamado.</span><span class="sxs-lookup"><span data-stu-id="c4671-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="c4671-310">Os construtores de agrupamento são essenciais para criar referências reversas e definir uma subexpressão à qual um quantificador é aplicado.</span><span class="sxs-lookup"><span data-stu-id="c4671-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="c4671-311">No entanto, o uso desses elementos de linguagem tem um custo.</span><span class="sxs-lookup"><span data-stu-id="c4671-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="c4671-312">Eles fazem com que o objeto <xref:System.Text.RegularExpressions.GroupCollection> retornado pela propriedade <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> seja preenchido com as capturas sem nome ou nomeadas mais recentes. Além disso, se uma única construção de agrupamento capturou várias subcadeias de caracteres na cadeia de caracteres de entrada, também preenchem o objeto <xref:System.Text.RegularExpressions.CaptureCollection> retornado pela propriedade <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> de um grupo de captura específico com vários objetos <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="c4671-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="c4671-313">Muitas vezes, os construtores de agrupamento são usados somente em uma expressão regular de modo que quantificadores possam ser aplicados a eles e os grupos capturados por essas subexpressão não são usados posteriormente.</span><span class="sxs-lookup"><span data-stu-id="c4671-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="c4671-314">Por exemplo, a expressão regular `\b(\w+[;,]?\s?)+[.?!]` é criada para capturar uma frase inteira.</span><span class="sxs-lookup"><span data-stu-id="c4671-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="c4671-315">A tabela a seguir descreve os elementos de linguagem nesse padrão de expressão regular e seu efeito nas coleções <xref:System.Text.RegularExpressions.Match> e <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> do objeto <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4671-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="c4671-316">Padrão</span><span class="sxs-lookup"><span data-stu-id="c4671-316">Pattern</span></span>|<span data-ttu-id="c4671-317">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="c4671-318">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="c4671-319">Fazer a correspondência a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="c4671-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="c4671-320">Corresponde a zero ou uma vírgula ou ponto e vírgula.</span><span class="sxs-lookup"><span data-stu-id="c4671-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="c4671-321">Corresponder a zero ou a um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="c4671-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="c4671-322">Corresponde a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por uma vírgula opcional ou por ponto-e-vírgula seguido por um caractere de espaço em branco opcional.</span><span class="sxs-lookup"><span data-stu-id="c4671-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="c4671-323">Isso define o primeiro grupo de captura, que é necessário para que a combinação de vários caracteres de palavra (ou seja, uma palavra) seguido por um símbolo de pontuação opcional seja repetida até que o mecanismo de expressões regulares atinja o final de uma sentença.</span><span class="sxs-lookup"><span data-stu-id="c4671-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="c4671-324">Corresponde a um ponto, um ponto de interrogação ou um ponto de exclamação.</span><span class="sxs-lookup"><span data-stu-id="c4671-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="c4671-325">Como o exemplo a seguir mostra, quando uma correspondência é encontrada, os objetos <xref:System.Text.RegularExpressions.GroupCollection> e de <xref:System.Text.RegularExpressions.CaptureCollection> são preenchidos com as capturas da correspondência.</span><span class="sxs-lookup"><span data-stu-id="c4671-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="c4671-326">Nesse caso, o grupo de captura `(\w+[;,]?\s?)` existe para que o quantificador `+` possa ser aplicado a ele, o que permite que o padrão de expressão regular corresponda a cada palavra em uma sentença.</span><span class="sxs-lookup"><span data-stu-id="c4671-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="c4671-327">Caso contrário, ele corresponderia à última palavra em uma sentença.</span><span class="sxs-lookup"><span data-stu-id="c4671-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="c4671-328">Quando você usa subexpressões apenas para aplicar quantificadores a elas e não está interessado em texto capturado, desabilite as capturas de grupo.</span><span class="sxs-lookup"><span data-stu-id="c4671-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="c4671-329">Por exemplo, o elemento de linguagem `(?:subexpression)` evita que o grupo ao qual ele se aplica capture subcadeias de caracteres correspondidas.</span><span class="sxs-lookup"><span data-stu-id="c4671-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="c4671-330">No exemplo a seguir, o padrão de expressão regular do exemplo anterior é alterado para `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="c4671-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="c4671-331">Conforme mostrado pela saída, ele impede que o mecanismo de expressões regulares preencha as coleções <xref:System.Text.RegularExpressions.GroupCollection> e de <xref:System.Text.RegularExpressions.CaptureCollection>.</span><span class="sxs-lookup"><span data-stu-id="c4671-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="c4671-332">É possível desabilitar as capturas de uma das seguintes formas:</span><span class="sxs-lookup"><span data-stu-id="c4671-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="c4671-333">Use o elemento de linguagem `(?:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="c4671-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="c4671-334">Esse elemento impede a captura de subcadeias de caracteres correspondidas no grupo ao qual se ele aplica.</span><span class="sxs-lookup"><span data-stu-id="c4671-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="c4671-335">Ele não desabilita capturas de subcadeias de caracteres em grupos aninhados.</span><span class="sxs-lookup"><span data-stu-id="c4671-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="c4671-336">Use a opção <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>.</span><span class="sxs-lookup"><span data-stu-id="c4671-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="c4671-337">Ela desabilita todas as capturas sem nome ou implícitas no padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="c4671-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="c4671-338">Quando você usa essa opção, somente as subcadeias de caracteres que correspondem aos grupos nomeados definidos com o elemento de linguagem `(?<name>subexpression)` podem ser capturadas.</span><span class="sxs-lookup"><span data-stu-id="c4671-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="c4671-339">O sinalizador <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> pode ser passado para o parâmetro `options` de um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou para o parâmetro `options` de um método de correspondência estática <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="c4671-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="c4671-340">Use a opção `n` no elemento de linguagem `(?imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="c4671-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="c4671-341">Esta opção desabilita todas as capturas sem nome ou implícitas a partir do ponto no padrão de expressão regular em que o elemento aparece.</span><span class="sxs-lookup"><span data-stu-id="c4671-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="c4671-342">As capturas são desabilitadas até o final do padrão ou até a opção `(-n)` permitir capturas sem nome ou implícitas.</span><span class="sxs-lookup"><span data-stu-id="c4671-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="c4671-343">Para saber mais, confira [Constructos diversos](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c4671-343">For more information, see [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="c4671-344">Use a opção `n` no elemento de linguagem `(?imnsx:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="c4671-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="c4671-345">Esta opção desativa todas as capturas sem nome ou implícitas em `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="c4671-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="c4671-346">As capturas por grupos de capturas aninhadas sem nome ou implícitas também são desabilitadas.</span><span class="sxs-lookup"><span data-stu-id="c4671-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="c4671-347">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="c4671-347">Related topics</span></span>

|<span data-ttu-id="c4671-348">Title</span><span class="sxs-lookup"><span data-stu-id="c4671-348">Title</span></span>|<span data-ttu-id="c4671-349">Descrição</span><span class="sxs-lookup"><span data-stu-id="c4671-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="c4671-350">Detalhes do comportamento de expressões regulares</span><span class="sxs-lookup"><span data-stu-id="c4671-350">Details of Regular Expression Behavior</span></span>](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|<span data-ttu-id="c4671-351">Examina a implementação do mecanismo de expressões regulares no .NET.</span><span class="sxs-lookup"><span data-stu-id="c4671-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="c4671-352">O tópico concentra-se na flexibilidade de expressões regulares e explica a responsabilidade do desenvolvedor para garantir o funcionamento eficiente e robusto do mecanismo de expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="c4671-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="c4671-353">Retrocesso</span><span class="sxs-lookup"><span data-stu-id="c4671-353">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="c4671-354">Explica o que é o retrocesso é como ele afeta o desempenho da expressão regular e examina os elementos de linguagem que fornecem alternativas ao retrocesso.</span><span class="sxs-lookup"><span data-stu-id="c4671-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="c4671-355">Linguagem de Expressão Regular - Referência Rápida</span><span class="sxs-lookup"><span data-stu-id="c4671-355">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="c4671-356">Descreve os elementos de linguagem de expressões regulares do .NET e fornece links para a documentação detalhada de cada elemento da linguagem.</span><span class="sxs-lookup"><span data-stu-id="c4671-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
