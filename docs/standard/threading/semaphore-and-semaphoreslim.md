---
title: Semaphore e SemaphoreSlim
description: Saiba mais sobre o Semaphore & SemaphoreSlim. O semáforo de classe é um wrapper fino em volta do objeto de semáforo do Win32. A classe SemaphoreSlim é um semáforo rápido.
ms.date: 03/30/2017
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: 34ffe11f7211d2d8b282bfd27f8c48328a5cb6d1
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95681893"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="0b3eb-105">Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="0b3eb-105">Semaphore and SemaphoreSlim</span></span>

<span data-ttu-id="0b3eb-106">A classe <xref:System.Threading.Semaphore?displayProperty=nameWithType> representa um sinal com nome (em todo o sistema) ou local.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-106">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="0b3eb-107">É um wrapper fino em torno do objeto de sinal Win32.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-107">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="0b3eb-108">Sinais do Win32 são contagem de sinais que podem ser usadas para controlar o acesso a um pool de recursos.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-108">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="0b3eb-109">A classe <xref:System.Threading.SemaphoreSlim> representa um sinal leve e rápido que pode ser usado para aguardar por um único processo quando forem esperados tempos de espera muito curtos.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-109">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="0b3eb-110"><xref:System.Threading.SemaphoreSlim> conta com o máximo possível em primitivos de sincronização fornecidos pelo Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="0b3eb-110"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="0b3eb-111">No entanto, fornece também identificadores de espera baseados no kernel inicializados lentamente, conforme necessário para dar suporte à espera de vários sinais.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-111">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="0b3eb-112"><xref:System.Threading.SemaphoreSlim> oferece suporte também ao uso de tokens de cancelamento, mas não oferece suporte a sinais com nome ou ao uso de um identificador de espera para sincronização.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-112"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="0b3eb-113">Gerenciando um recurso limitado</span><span class="sxs-lookup"><span data-stu-id="0b3eb-113">Managing a Limited Resource</span></span>  

 <span data-ttu-id="0b3eb-114">Os threads inserem o sinal chamando o método <xref:System.Threading.WaitHandle.WaitOne%2A>, que é herdado da classe <xref:System.Threading.WaitHandle>, no caso de um objeto <xref:System.Threading.Semaphore?displayProperty=nameWithType> ou o método <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType>, no caso de um objeto <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-114">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="0b3eb-115">Quando a chamada é retornada, a contagem no sinal é reduzida.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-115">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="0b3eb-116">Quando um thread solicita entrada e a contagem é zero, o thread é bloqueado.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-116">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="0b3eb-117">À medida que os threads liberam o sinal chamando o método <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>, os threads bloqueados têm permissão para entrar.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-117">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="0b3eb-118">Não há uma ordem garantida, como primeiro a entrar, primeiro a sair (PEPS) ou último a entrar, primeiro a sair (UEPS) para threads bloqueados para inserir o sinal.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-118">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="0b3eb-119">Um thread pode inserir o sinal várias vezes chamando o método <xref:System.Threading.Semaphore?displayProperty=nameWithType> do objeto <xref:System.Threading.WaitHandle.WaitOne%2A> ou o método <xref:System.Threading.SemaphoreSlim> do objeto <xref:System.Threading.SemaphoreSlim.Wait%2A> repetidas vezes.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-119">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="0b3eb-120">Para liberar o sinal, o thread pode chamar a sobrecarga do método <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> o mesmo número de vezes ou chamar a sobrecarga do método <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> ou <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> e especificar o número de entradas a ser liberado.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-120">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="0b3eb-121">Sinais e identidade do thread</span><span class="sxs-lookup"><span data-stu-id="0b3eb-121">Semaphores and Thread Identity</span></span>  

 <span data-ttu-id="0b3eb-122">Os dois tipos de sinais não impõem a identidade do thread em chamadas para os métodos <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A> e <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-122">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="0b3eb-123">Por exemplo, um cenário de uso comum para sinais envolve um thread de produtor e um thread de consumidor, com um thread sempre incrementando a contagem de sinais e o outro sempre diminuindo-a.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-123">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="0b3eb-124">É responsabilidade do programador garantir que um thread não libere o sinal muitas vezes.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-124">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="0b3eb-125">Por exemplo, suponha que um sinal tenha uma contagem máxima de dois, e que o thread A e o thread B insiram o sinal.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-125">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="0b3eb-126">Se um erro de programação no thread B fizer com que ele chame `Release` duas vezes, ambas as chamadas serão bem-sucedidas.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-126">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="0b3eb-127">A contagem no sinal está completa e quando o thread A eventualmente chama `Release`, uma <xref:System.Threading.SemaphoreFullException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-127">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="0b3eb-128">Sinais com nome</span><span class="sxs-lookup"><span data-stu-id="0b3eb-128">Named Semaphores</span></span>  

 <span data-ttu-id="0b3eb-129">O sistema operacional Windows permite que os sinais tenham nomes.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-129">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="0b3eb-130">Um sinal com nome é para todo o sistema.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-130">A named semaphore is system wide.</span></span> <span data-ttu-id="0b3eb-131">Ou seja, depois que o sinal com nome for criado, ele ficará visível para todos os threads em todos os processos.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-131">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="0b3eb-132">Assim, o sinal com nome pode ser usado para sincronizar as atividades de processos, bem como os threads.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-132">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="0b3eb-133">Você pode criar um objeto <xref:System.Threading.Semaphore> que representa um sinal de sistema com nome usando um dos construtores que especifica um nome.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-133">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0b3eb-134">Como os sinais com nome são para todo o sistema, é possível ter vários objetos <xref:System.Threading.Semaphore> que representam o mesmo sinal com nome.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-134">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="0b3eb-135">Cada vez que você chamar um construtor ou o método <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>, um novo objeto <xref:System.Threading.Semaphore> é criado.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-135">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="0b3eb-136">Especificar o mesmo nome repetidas vezes cria vários objetos que representam o mesmo sinal com nome.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-136">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="0b3eb-137">Tenha cuidado ao usar sinais com nome.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-137">Be careful when you use named semaphores.</span></span> <span data-ttu-id="0b3eb-138">Como eles são para todo o sistema, outro processo que usa o mesmo nome pode inserir seu sinal inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-138">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="0b3eb-139">Código mal-intencionado em execução no mesmo computador pode usar isso como base de um ataque de negação de serviço.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-139">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="0b3eb-140">Use a segurança de controle de acesso para proteger um objeto <xref:System.Threading.Semaphore> que representa um sinal com nome, preferencialmente usando um construtor que especifica um objeto <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-140">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="0b3eb-141">Também é possível aplicar a segurança de controle de acesso usando o método <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>, mas isso deixa uma janela de vulnerabilidade entre o momento em que o sinal é criado e o momento em que ele é protegido.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-141">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="0b3eb-142">Proteger sinais com a segurança de controle de acesso ajuda a impedir ataques mal-intencionados, mas não resolve o problema de colisão de nome não intencional.</span><span class="sxs-lookup"><span data-stu-id="0b3eb-142">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0b3eb-143">Confira também</span><span class="sxs-lookup"><span data-stu-id="0b3eb-143">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="0b3eb-144">Threading de objetos e recursos</span><span class="sxs-lookup"><span data-stu-id="0b3eb-144">Threading Objects and Features</span></span>](threading-objects-and-features.md)
