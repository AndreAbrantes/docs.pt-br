---
title: Visão geral dos primitivos de sincronização
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 37abcb6b3a8fdf4ef91d5e946a97db7ca1428ce8
ms.sourcegitcommit: fb78d8abbdb87144a3872cf154930157090dd933
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/27/2018
ms.locfileid: "47204593"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="699d6-102">Visão geral dos primitivos de sincronização</span><span class="sxs-lookup"><span data-stu-id="699d6-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a><span data-ttu-id="699d6-103">O .NET Framework fornece uma variedade de primitivos de sincronização para controlar as interações de threads e evitar condições de corrida.</span><span class="sxs-lookup"><span data-stu-id="699d6-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="699d6-104">Eles podem ser divididos em três categorias: operações interliconectadas, sinalização e bloqueio.</span><span class="sxs-lookup"><span data-stu-id="699d6-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="699d6-105">As categorias não estão claramente definidas nem organizadas. Alguns mecanismos de sincronização têm características de várias categorias; eventos que liberam um único thread em um momento são funcionalmente como bloqueios; a versão de qualquer bloqueio pode ser considerada como um sinal; e operações interconectadas podem ser usadas para construir bloqueios.</span><span class="sxs-lookup"><span data-stu-id="699d6-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="699d6-106">No entanto, as categorias ainda são úteis.</span><span class="sxs-lookup"><span data-stu-id="699d6-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="699d6-107">É importante lembrar que a sincronização de threads é cooperativa.</span><span class="sxs-lookup"><span data-stu-id="699d6-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="699d6-108">Se um thread ignora um mecanismo de sincronização e acessa diretamente o recurso protegido, esse mecanismo de sincronização não pode ser eficaz.</span><span class="sxs-lookup"><span data-stu-id="699d6-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="699d6-109">Esta visão geral contém as seguintes seções:</span><span class="sxs-lookup"><span data-stu-id="699d6-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="699d6-110">Bloqueio</span><span class="sxs-lookup"><span data-stu-id="699d6-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="699d6-111">Sinalização</span><span class="sxs-lookup"><span data-stu-id="699d6-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="699d6-112">Tipos de sincronização leve</span><span class="sxs-lookup"><span data-stu-id="699d6-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="699d6-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="699d6-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="699d6-114">Operações interconectadas</span><span class="sxs-lookup"><span data-stu-id="699d6-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="699d6-115">Bloqueio</span><span class="sxs-lookup"><span data-stu-id="699d6-115">Locking</span></span>  
 <span data-ttu-id="699d6-116">Bloqueios oferecem controle de um recurso para um thread por vez, ou para um número especificado de threads.</span><span class="sxs-lookup"><span data-stu-id="699d6-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="699d6-117">Um thread que solicita um bloqueio exclusivo quando o bloqueio está sendo usado permanece bloqueado até o bloqueio ficar disponível.</span><span class="sxs-lookup"><span data-stu-id="699d6-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="699d6-118">Bloqueios exclusivos</span><span class="sxs-lookup"><span data-stu-id="699d6-118">Exclusive Locks</span></span>  
 <span data-ttu-id="699d6-119">A forma mais simples de bloqueio é a instrução `lock` em C# e a instrução `SyncLock` no Visual Basic, que controla o acesso a um bloco de código.</span><span class="sxs-lookup"><span data-stu-id="699d6-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="699d6-120">Tal bloco é normalmente chamado de seção crítica.</span><span class="sxs-lookup"><span data-stu-id="699d6-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="699d6-121">A instrução `lock` é implementada usando os métodos <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> e <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>, e usa um bloco `try…finally` para garantir que o bloqueio será liberado.</span><span class="sxs-lookup"><span data-stu-id="699d6-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="699d6-122">Em geral, usar a instrução `lock` ou `SyncLock` para proteger pequenos blocos de código, sem nunca abranger mais de um único método, é a melhor maneira de usar a classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="699d6-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="699d6-123">Embora poderosa, a classe <xref:System.Threading.Monitor> é propensa a deadlocks e a bloqueios órfãos.</span><span class="sxs-lookup"><span data-stu-id="699d6-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="699d6-124">Classe Monitor</span><span class="sxs-lookup"><span data-stu-id="699d6-124">Monitor Class</span></span>  
 <span data-ttu-id="699d6-125">A classe <xref:System.Threading.Monitor> fornece funcionalidade adicional, que pode ser usada em conjunto com a instrução `lock`:</span><span class="sxs-lookup"><span data-stu-id="699d6-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="699d6-126">O método <xref:System.Threading.Monitor.TryEnter%2A> permite que um thread que está bloqueado aguardando o recurso desista após um intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="699d6-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="699d6-127">Ele retorna um valor booliano que indica êxito ou falha, que pode ser usado para detectar e evitar deadlocks potenciais.</span><span class="sxs-lookup"><span data-stu-id="699d6-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="699d6-128">O método <xref:System.Threading.Monitor.Wait%2A> é chamado por um thread em uma seção crítica.</span><span class="sxs-lookup"><span data-stu-id="699d6-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="699d6-129">Ele fornece controle de recursos e blocos até que o recurso esteja disponível novamente.</span><span class="sxs-lookup"><span data-stu-id="699d6-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="699d6-130">Os métodos <xref:System.Threading.Monitor.Pulse%2A> e <xref:System.Threading.Monitor.PulseAll%2A> permitem que um thread que está prestes a liberar o bloqueio ou a chamar <xref:System.Threading.Monitor.Wait%2A> coloque um ou mais threads na fila de pronto para que eles possam adquirir o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="699d6-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="699d6-131">Os tempos limite de sobrecargas do método <xref:System.Threading.Monitor.Wait%2A> permitem que os threads em espera pulem para a fila de pronto.</span><span class="sxs-lookup"><span data-stu-id="699d6-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="699d6-132">A classe <xref:System.Threading.Monitor> pode fornecer o bloqueio em vários domínios de aplicativo se o objeto usado para o bloqueio for derivado de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="699d6-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="699d6-133"><xref:System.Threading.Monitor> tem afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="699d6-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="699d6-134">Ou seja, um thread que inseriu o monitor deve sair chamando <xref:System.Threading.Monitor.Exit%2A> ou <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="699d6-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="699d6-135">A classe <xref:System.Threading.Monitor> não está instanciada.</span><span class="sxs-lookup"><span data-stu-id="699d6-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="699d6-136">Seus métodos são estáticos (`Shared` no Visual Basic) e afetam um objeto de bloqueio que pode ser instanciado.</span><span class="sxs-lookup"><span data-stu-id="699d6-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="699d6-137">Para obter uma visão conceitual, consulte [Monitores](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="699d6-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="699d6-138">Classe Mutex</span><span class="sxs-lookup"><span data-stu-id="699d6-138">Mutex Class</span></span>  
 <span data-ttu-id="699d6-139">Os threads solicitam um <xref:System.Threading.Mutex> chamando uma sobrecarga de seu método <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="699d6-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="699d6-140">Sobrecargas com tempos limite são fornecidas para permitir que os threads desistam da espera.</span><span class="sxs-lookup"><span data-stu-id="699d6-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="699d6-141">Ao contrário da classe <xref:System.Threading.Monitor>, um mutex pode ser local ou global.</span><span class="sxs-lookup"><span data-stu-id="699d6-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="699d6-142">Global mutexes, também chamados de mutexes nomeados, são visíveis em todo o sistema operacional e podem ser usados para sincronizar threads em vários domínios de aplicativos ou processos.</span><span class="sxs-lookup"><span data-stu-id="699d6-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="699d6-143">Os mutexes locais derivam de <xref:System.MarshalByRefObject> e podem ser usados nos limites do domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="699d6-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="699d6-144">Além disso, <xref:System.Threading.Mutex> deriva de <xref:System.Threading.WaitHandle> e isso significa que ele pode ser usado com os mecanismos de sinalização fornecidos pelo <xref:System.Threading.WaitHandle>, como os métodos <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="699d6-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="699d6-145">Como <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> tem afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="699d6-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="699d6-146">Ao contrário de <xref:System.Threading.Monitor>, um <xref:System.Threading.Mutex> é um objeto que pode ser instanciado.</span><span class="sxs-lookup"><span data-stu-id="699d6-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="699d6-147">Para obter uma visão conceitual, consulte [Mutexes](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="699d6-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="699d6-148">Classe de SpinLock</span><span class="sxs-lookup"><span data-stu-id="699d6-148">SpinLock Class</span></span>  
 <span data-ttu-id="699d6-149">Começando com o [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], você pode usar a classe <xref:System.Threading.SpinLock> quando a sobrecarga exigida por <xref:System.Threading.Monitor> prejudicar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="699d6-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="699d6-150">Quando <xref:System.Threading.SpinLock> encontra uma seção crítica bloqueada, ele simplesmente gira em um loop até o bloqueio ficar disponível.</span><span class="sxs-lookup"><span data-stu-id="699d6-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="699d6-151">Se o bloqueio for mantido por um período muito curto, a rotação pode fornecer melhor desempenho do que o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="699d6-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="699d6-152">No entanto, se o bloqueio for mantido por mais de algumas dezenas de ciclos, o <xref:System.Threading.SpinLock> terá um desempenho tão bom quanto o <xref:System.Threading.Monitor>, mas usará mais ciclos de CPU e, portanto, poderá prejudicar o desempenho de outros processos ou threads.</span><span class="sxs-lookup"><span data-stu-id="699d6-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="699d6-153">Outros bloqueios</span><span class="sxs-lookup"><span data-stu-id="699d6-153">Other Locks</span></span>  
 <span data-ttu-id="699d6-154">Os bloqueios não precisam ser exclusivos.</span><span class="sxs-lookup"><span data-stu-id="699d6-154">Locks need not be exclusive.</span></span> <span data-ttu-id="699d6-155">Normalmente é útil permitir que um número limitado de threads acesse simultaneamente um recurso.</span><span class="sxs-lookup"><span data-stu-id="699d6-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="699d6-156">Semaphores e bloqueios de leitor-gravador são criados para controlar esse tipo de acesso a recursos em pool.</span><span class="sxs-lookup"><span data-stu-id="699d6-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="699d6-157">Classe ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="699d6-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="699d6-158">A classe <xref:System.Threading.ReaderWriterLockSlim> aborda o caso em que um thread que altera os dados, o gravador, deve ter acesso exclusivo a um recurso.</span><span class="sxs-lookup"><span data-stu-id="699d6-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="699d6-159">Quando o gravador não está ativo, qualquer número de leitores pode acessar o recurso (por exemplo, ao chamar o método <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>).</span><span class="sxs-lookup"><span data-stu-id="699d6-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="699d6-160">Quando um thread solicita acesso exclusivo (por exemplo, ao chamar o método <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>), o leitor subsequente solicita o bloqueio até que todos os leitores existentes tenham saído do bloqueio e o gravador tenha entrado e saído do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="699d6-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="699d6-161"><xref:System.Threading.ReaderWriterLockSlim> tem afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="699d6-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="699d6-162">Para obter uma visão conceitual, consulte [Bloqueios de leitor-gravador](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="699d6-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="699d6-163">Classe Semaphore</span><span class="sxs-lookup"><span data-stu-id="699d6-163">Semaphore Class</span></span>  
 <span data-ttu-id="699d6-164">A classe <xref:System.Threading.Semaphore> permite que um número especificado de threads acesse um recurso.</span><span class="sxs-lookup"><span data-stu-id="699d6-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="699d6-165">Threads adicionais solicitam o bloqueio de um recurso até que um thread libere o semaphore.</span><span class="sxs-lookup"><span data-stu-id="699d6-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="699d6-166">Como a classe <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> deriva de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="699d6-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="699d6-167">Além disso, como <xref:System.Threading.Mutex>, um <xref:System.Threading.Semaphore> pode ser local ou global.</span><span class="sxs-lookup"><span data-stu-id="699d6-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="699d6-168">Ele pode ser usado nos limites do domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="699d6-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="699d6-169">Ao contrário de <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> e <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> não tem afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="699d6-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="699d6-170">Isso significa que ele pode ser usado em cenários onde um thread adquire o semaphore e o outro o libera.</span><span class="sxs-lookup"><span data-stu-id="699d6-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="699d6-171">Para obter uma visão conceitual, consulte [Semaphore e SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="699d6-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="699d6-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> é um sinal leve para sincronização no limite de um único processo.</span><span class="sxs-lookup"><span data-stu-id="699d6-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="699d6-173">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="699d6-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="699d6-174">Sinalização</span><span class="sxs-lookup"><span data-stu-id="699d6-174">Signaling</span></span>  
 <span data-ttu-id="699d6-175">A maneira mais simples de esperar por um sinal de outro thread é chamando o método <xref:System.Threading.Thread.Join%2A> que é bloqueado até o outro thread ser concluído.</span><span class="sxs-lookup"><span data-stu-id="699d6-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="699d6-176"><xref:System.Threading.Thread.Join%2A> tem duas sobrecargas que permitem que o thread bloqueado interrompa a espera após um intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="699d6-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="699d6-177">Identificadores de espera fornecem um conjunto mais avançado de recursos de espera e sinalização.</span><span class="sxs-lookup"><span data-stu-id="699d6-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="699d6-178">Identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="699d6-178">Wait Handles</span></span>  
 <span data-ttu-id="699d6-179">Os identificadores de espera derivam da classe <xref:System.Threading.WaitHandle> que, por sua vez, deriva de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="699d6-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="699d6-180">Assim, os identificadores de espera podem ser usados para sincronizar as atividades de threads entre limites de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="699d6-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="699d6-181">Os threads bloqueiam os identificadores de espera chamando o método de instância <xref:System.Threading.WaitHandle.WaitOne%2A> ou um dos métodos estáticos <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> ou <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="699d6-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="699d6-182">Como eles são liberados depende de qual método foi chamado e do tipo de identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="699d6-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="699d6-183">Para obter uma visão conceitual, consulte [Identificadores de espera](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="699d6-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="699d6-184">Identificadores de espera de eventos</span><span class="sxs-lookup"><span data-stu-id="699d6-184">Event Wait Handles</span></span>  
 <span data-ttu-id="699d6-185">Os identificadores de espera de eventos incluem a classe <xref:System.Threading.EventWaitHandle> e suas classes derivadas, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="699d6-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="699d6-186">Os threads são liberados de um identificador de espera de eventos quando ele é sinalizado, chamando seu método <xref:System.Threading.EventWaitHandle.Set%2A> ou usando o método <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="699d6-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="699d6-187">Os identificadores de espera de eventos são automaticamente redefinidos, como uma borboleta que permite que apenas um thread seja sinalizado de cada vez, ou deverão ser redefinidos manualmente, como uma entrada que é fechada até ser sinalizada e, em seguida, aberta até que alguém a feche.</span><span class="sxs-lookup"><span data-stu-id="699d6-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="699d6-188">Como seus nomes sugerem, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> representam o primeiro e último, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="699d6-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="699d6-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> é um evento leve para sincronização no limite de um único processo.</span><span class="sxs-lookup"><span data-stu-id="699d6-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="699d6-190">Um <xref:System.Threading.EventWaitHandle> pode representar qualquer tipo de evento e pode ser local ou global.</span><span class="sxs-lookup"><span data-stu-id="699d6-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="699d6-191">As classes derivadas <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> são sempre locais.</span><span class="sxs-lookup"><span data-stu-id="699d6-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="699d6-192">Identificadores de espera de eventos não têm afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="699d6-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="699d6-193">Qualquer thread pode sinalizar um identificador de espera de eventos.</span><span class="sxs-lookup"><span data-stu-id="699d6-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="699d6-194">Para uma visão conceitual, consulte [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="699d6-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="699d6-195">Classes Mutex e Semaphore</span><span class="sxs-lookup"><span data-stu-id="699d6-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="699d6-196">Como as classes <xref:System.Threading.Mutex> e <xref:System.Threading.Semaphore> derivam de <xref:System.Threading.WaitHandle>, elas podem ser usadas com os métodos estáticos de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="699d6-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="699d6-197">Por exemplo, um thread pode usar o método <xref:System.Threading.WaitHandle.WaitAll%2A> para aguardar até que todas as três condições a seguir forem verdadeiras: um <xref:System.Threading.EventWaitHandle> é sinalizado, um <xref:System.Threading.Mutex> é liberado e um <xref:System.Threading.Semaphore> é liberado.</span><span class="sxs-lookup"><span data-stu-id="699d6-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="699d6-198">Da mesma forma, um thread pode usar o método <xref:System.Threading.WaitHandle.WaitAny%2A> para aguardar até que qualquer uma dessas condições seja verdadeira.</span><span class="sxs-lookup"><span data-stu-id="699d6-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="699d6-199">No caso de um <xref:System.Threading.Mutex> ou de um <xref:System.Threading.Semaphore>, ser sinalizado significa ser liberado.</span><span class="sxs-lookup"><span data-stu-id="699d6-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="699d6-200">Se o tipo for usado como o primeiro argumento do método <xref:System.Threading.WaitHandle.SignalAndWait%2A>, ele será liberado.</span><span class="sxs-lookup"><span data-stu-id="699d6-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="699d6-201">No caso de um <xref:System.Threading.Mutex>, que tem afinidade de thread, uma exceção será gerada se o thread de chamada não possuir o mutex.</span><span class="sxs-lookup"><span data-stu-id="699d6-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="699d6-202">Conforme observado anteriormente, os semaphores não têm afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="699d6-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="699d6-203">Barreira</span><span class="sxs-lookup"><span data-stu-id="699d6-203">Barrier</span></span>  
 <span data-ttu-id="699d6-204">A classe <xref:System.Threading.Barrier> fornece uma maneira de sincronizar, de forma cíclica, vários threads para que todos sejam bloqueados no mesmo ponto e aguardem a conclusão dos outros threads.</span><span class="sxs-lookup"><span data-stu-id="699d6-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="699d6-205">Uma barreira é útil quando um ou mais threads requerem os resultados de outro thread para poderem prosseguir para a próxima fase de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="699d6-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="699d6-206">Para saber mais, consulte [Barreira](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="699d6-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="699d6-207">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="699d6-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="699d6-208">Tipos de sincronização leve</span><span class="sxs-lookup"><span data-stu-id="699d6-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="699d6-209">Começando com o [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], você pode usar primitivos de sincronização que fornecem desempenho rápido, evitando a dispendiosa dependência de objetos do kernel do Win32, como identificadores de espera, sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="699d6-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="699d6-210">Em geral, você deve usar esses tipos quando os tempos de espera são curtos e somente quando os tipos de sincronização originais foram usados e considerados insatisfatórios.</span><span class="sxs-lookup"><span data-stu-id="699d6-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="699d6-211">Os tipos leves não podem ser usados em cenários que exigem a comunicação entre processos.</span><span class="sxs-lookup"><span data-stu-id="699d6-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="699d6-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> é uma versão leve de <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="699d6-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="699d6-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> é uma versão leve de <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="699d6-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="699d6-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> representa um evento que é sinalizado quando a contagem é zero.</span><span class="sxs-lookup"><span data-stu-id="699d6-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="699d6-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> permite que vários threads sincronizem entre si sem exigir o controle de um thread mestre.</span><span class="sxs-lookup"><span data-stu-id="699d6-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="699d6-216">Uma barreira impede cada thread de continuar até que todos os threads atinjam um ponto especificado.</span><span class="sxs-lookup"><span data-stu-id="699d6-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="699d6-217">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="699d6-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="699d6-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="699d6-218">SpinWait</span></span>  
 <span data-ttu-id="699d6-219">Começando com o [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], você pode usar a estrutura de <xref:System.Threading.SpinWait?displayProperty=nameWithType> quando um thread tiver de esperar pela sinalização de um evento ou por uma condição específica. No entanto, quando o tempo de espera real for menor do que o tempo necessário, use um identificador de espera ou bloqueie o thread atual.</span><span class="sxs-lookup"><span data-stu-id="699d6-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="699d6-220">Usando o <xref:System.Threading.SpinWait>, você pode especificar um curto período de tempo para girar enquanto espera e, em seguida, gerar (por exemplo, aguardando ou em espera) somente se a condição não for atendida no tempo especificado.</span><span class="sxs-lookup"><span data-stu-id="699d6-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="699d6-221">Voltar ao início</span><span class="sxs-lookup"><span data-stu-id="699d6-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="699d6-222">Operações interconectadas</span><span class="sxs-lookup"><span data-stu-id="699d6-222">Interlocked Operations</span></span>  
 <span data-ttu-id="699d6-223">As operações interconectadas são operações atômicas simples realizadas em um local de memória por métodos estáticos da classe <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="699d6-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="699d6-224">Essas operações atômicas incluem adição, incremento e decremento, troca, troca condicional (dependendo de uma comparação) e operações de leitura de valores de 64 bits em plataformas de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="699d6-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="699d6-225">A garantia de atomicidade é limitada às operações individuais; quando várias operações devem ser executadas como uma unidade, um mecanismo de sincronização da mais alta granularidade deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="699d6-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="699d6-226">Embora nenhuma dessas operações sejam bloqueios ou sinais, eles podem ser usadas para construir sinais e bloqueios.</span><span class="sxs-lookup"><span data-stu-id="699d6-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="699d6-227">Como são nativas do sistema operacional Windows, as operações interconectadas são extremamente rápidas.</span><span class="sxs-lookup"><span data-stu-id="699d6-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="699d6-228">Operações interconectadas podem ser usadas com garantias de memória volátil para gravar aplicativos que apresentam simultaneidade eficiente sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="699d6-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="699d6-229">No entanto, elas exigem programação sofisticada, de baixo nível, para a maioria das finalidades, portanto, bloqueios simples são uma opção melhor.</span><span class="sxs-lookup"><span data-stu-id="699d6-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="699d6-230">Para obter uma visão conceitual, consulte [Operações interconectadas](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="699d6-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="699d6-231">Consulte também</span><span class="sxs-lookup"><span data-stu-id="699d6-231">See also</span></span>

- [<span data-ttu-id="699d6-232">Sincronizando dados para multithreading</span><span class="sxs-lookup"><span data-stu-id="699d6-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="699d6-233">Monitores</span><span class="sxs-lookup"><span data-stu-id="699d6-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
- [<span data-ttu-id="699d6-234">Mutexes</span><span class="sxs-lookup"><span data-stu-id="699d6-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
- [<span data-ttu-id="699d6-235">Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="699d6-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
- [<span data-ttu-id="699d6-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="699d6-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
- [<span data-ttu-id="699d6-237">Identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="699d6-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
- [<span data-ttu-id="699d6-238">Operações interconectadas</span><span class="sxs-lookup"><span data-stu-id="699d6-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
- [<span data-ttu-id="699d6-239">Bloqueios de leitor-gravador</span><span class="sxs-lookup"><span data-stu-id="699d6-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
- [<span data-ttu-id="699d6-240">Barreira</span><span class="sxs-lookup"><span data-stu-id="699d6-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
- [<span data-ttu-id="699d6-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="699d6-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
- [<span data-ttu-id="699d6-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="699d6-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
