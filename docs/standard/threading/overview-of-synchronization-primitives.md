---
title: Visão geral dos primitivos de sincronização
description: Saiba mais sobre os primitivos de sincronização de thread do .NET usados para sincronizar o acesso a uma interação de thread de controle ou recurso compartilhado
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 43f78c914b7cb01f9b0de4c258d5882548e52790
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73106586"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="39b50-103">Visão geral dos primitivos de sincronização</span><span class="sxs-lookup"><span data-stu-id="39b50-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="39b50-104">O .NET fornece uma variedade de tipos que você pode usar para sincronizar o acesso a um recurso compartilhado ou coordenar a interação de thread.</span><span class="sxs-lookup"><span data-stu-id="39b50-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="39b50-105">Use a mesma instância de primitivos de sincronização para proteger o acesso de um recurso compartilhado.</span><span class="sxs-lookup"><span data-stu-id="39b50-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="39b50-106">Se usar instâncias primitivas de sincronização diferentes para proteger o mesmo recurso, você evitará a proteção fornecida por um primitivo de sincronização.</span><span class="sxs-lookup"><span data-stu-id="39b50-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="39b50-107">Tipos de sincronização leve e a classe WaitHandle</span><span class="sxs-lookup"><span data-stu-id="39b50-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="39b50-108">Vários primitivos de sincronização .NET derivam da classe <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, que encapsula um identificador de sincronização do sistema operacional nativo e usa um mecanismo de sinalização de interação de thread.</span><span class="sxs-lookup"><span data-stu-id="39b50-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="39b50-109">Essas classes incluem:</span><span class="sxs-lookup"><span data-stu-id="39b50-109">Those classes include:</span></span>

- <span data-ttu-id="39b50-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, que concede acesso exclusivo a um recurso compartilhado.</span><span class="sxs-lookup"><span data-stu-id="39b50-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="39b50-111">O estado de um mutex será sinalizado se nenhum thread for seu proprietário.</span><span class="sxs-lookup"><span data-stu-id="39b50-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="39b50-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, que limita o número de threads que podem acessar um recurso compartilhado ou um pool de recursos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="39b50-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="39b50-113">O estado de um semáforo é definido como sinalizado quando a contagem é maior que zero e não sinalizado quando a contagem é zero.</span><span class="sxs-lookup"><span data-stu-id="39b50-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="39b50-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, que representa um evento de sincronização de thread e pode estar em um estado sinalizado ou não sinalizado.</span><span class="sxs-lookup"><span data-stu-id="39b50-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="39b50-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, que é derivado de <xref:System.Threading.EventWaitHandle> e, quando sinalizado, é redefinido automaticamente para um estado não sinalizado após o lançamento de um único thread em espera.</span><span class="sxs-lookup"><span data-stu-id="39b50-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="39b50-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, que é derivado de <xref:System.Threading.EventWaitHandle> e, quando sinalizado, permanece no estado sinalizado até que o método <xref:System.Threading.EventWaitHandle.Reset%2A> seja chamado.</span><span class="sxs-lookup"><span data-stu-id="39b50-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="39b50-117">No .NET Framework, porque <xref:System.Threading.WaitHandle> deriva de <xref:System.MarshalByRefObject?displayProperty=nameWithType>, esses tipos podem ser usados para sincronizar as atividades de threads entre limites de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="39b50-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="39b50-118">No .NET Framework e no .NET Core, alguns desses tipos podem representar os identificadores de sincronização de sistema nomeado, que são visíveis em todo o sistema operacional e podem ser usados para a sincronização entre processos:</span><span class="sxs-lookup"><span data-stu-id="39b50-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="39b50-119"><xref:System.Threading.Mutex> (.NET Framework e .NET Core),</span><span class="sxs-lookup"><span data-stu-id="39b50-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="39b50-120"><xref:System.Threading.Semaphore> (.NET Framework e .NET Core no Windows),</span><span class="sxs-lookup"><span data-stu-id="39b50-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="39b50-121"><xref:System.Threading.EventWaitHandle> (.NET Framework e .NET Core no Windows).</span><span class="sxs-lookup"><span data-stu-id="39b50-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="39b50-122">Para obter mais informações, veja a referência de API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="39b50-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="39b50-123">Tipos de sincronização leve não dependem de identificadores do sistema operacional subjacente e normalmente fornecem um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="39b50-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="39b50-124">No entanto, não podem ser usados para a sincronização entre processos.</span><span class="sxs-lookup"><span data-stu-id="39b50-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="39b50-125">Use esses tipos para sincronização de thread dentro de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="39b50-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="39b50-126">Alguns desses tipos são alternativas aos tipos derivados de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="39b50-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="39b50-127">Por exemplo, <xref:System.Threading.SemaphoreSlim> é uma alternativa leve para <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="39b50-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="39b50-128">Sincronização de acesso a um recurso compartilhado</span><span class="sxs-lookup"><span data-stu-id="39b50-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="39b50-129">O .NET fornece uma variedade de primitivos de sincronização para controlar o acesso a um recurso compartilhado por vários threads.</span><span class="sxs-lookup"><span data-stu-id="39b50-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="39b50-130">Classe Monitor</span><span class="sxs-lookup"><span data-stu-id="39b50-130">Monitor class</span></span>

<span data-ttu-id="39b50-131">A classe <xref:System.Threading.Monitor?displayProperty=nameWithType> concede acesso mutuamente exclusivo em um recurso compartilhado, adquirindo ou liberando um bloqueio no objeto que identifica o recurso.</span><span class="sxs-lookup"><span data-stu-id="39b50-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="39b50-132">Embora um bloqueio seja mantido, o thread que mantém o bloqueio pode adquiri-lo novamente e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="39b50-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="39b50-133">Qualquer outro thread é impedido de adquirir o bloqueio e o método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> aguardará até que o bloqueio seja liberado.</span><span class="sxs-lookup"><span data-stu-id="39b50-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="39b50-134">O método <xref:System.Threading.Monitor.Enter%2A> adquire um bloqueio liberado.</span><span class="sxs-lookup"><span data-stu-id="39b50-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="39b50-135">Você também pode usar o método <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> para especificar o tempo durante o qual um thread tenta adquirir um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="39b50-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="39b50-136">Porque a classe <xref:System.Threading.Monitor> tem afinidade de thread, o thread que adquiriu um bloqueio deve liberar o bloqueio chamando o método <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="39b50-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="39b50-137">Você pode coordenar a interação de threads que adquirirem um bloqueio no mesmo objeto usando os métodos <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> e <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="39b50-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="39b50-138">Para obter mais informações, veja a referência de API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="39b50-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="39b50-139">Use a instrução [lock](../../csharp/language-reference/keywords/lock-statement.md) no C# e a instrução [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) no Visual Basic para sincronizar o acesso a um recurso compartilhado, em vez de usar a classe <xref:System.Threading.Monitor> diretamente.</span><span class="sxs-lookup"><span data-stu-id="39b50-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="39b50-140">Essas instruções são implementadas usando os métodos <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> e um bloco `try…finally` para garantir que o bloqueio adquirido sempre seja liberado.</span><span class="sxs-lookup"><span data-stu-id="39b50-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="39b50-141">Classe Mutex</span><span class="sxs-lookup"><span data-stu-id="39b50-141">Mutex class</span></span>

<span data-ttu-id="39b50-142">A classe <xref:System.Threading.Mutex?displayProperty=nameWithType>, como <xref:System.Threading.Monitor>, concede acesso exclusivo a um recurso compartilhado.</span><span class="sxs-lookup"><span data-stu-id="39b50-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="39b50-143">Use uma das sobrecargas do método [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) para solicitar a propriedade de um mutex.</span><span class="sxs-lookup"><span data-stu-id="39b50-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="39b50-144">Como <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> tem afinidade de thread e o thread que adquiriu um mutex deverá liberá-lo chamando o método <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="39b50-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="39b50-145">Diferente de <xref:System.Threading.Monitor>, a classe <xref:System.Threading.Mutex> pode ser usada para sincronização entre processos.</span><span class="sxs-lookup"><span data-stu-id="39b50-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="39b50-146">Para fazer isso, use um mutex nomeado, que fica visível em todo o sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="39b50-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="39b50-147">Para criar uma instância de mutex nomeada, use um [construtor Mutex](<xref:System.Threading.Mutex.%23ctor%2A>) que especifique um nome.</span><span class="sxs-lookup"><span data-stu-id="39b50-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="39b50-148">Você também pode chamar o método <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> para abrir um mutex do sistema nomeado existente.</span><span class="sxs-lookup"><span data-stu-id="39b50-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="39b50-149">Para obter mais informações, veja o artigo [Mutexes](mutexes.md) e a referência da API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="39b50-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="39b50-150">Estrutura de SpinLock</span><span class="sxs-lookup"><span data-stu-id="39b50-150">SpinLock structure</span></span>

<span data-ttu-id="39b50-151">A estrutura <xref:System.Threading.SpinLock?displayProperty=nameWithType>, como <xref:System.Threading.Monitor>, concede acesso exclusivo a um recurso compartilhado com base na disponibilidade de um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="39b50-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="39b50-152">Quando <xref:System.Threading.SpinLock> tenta adquirir um bloqueio que não está disponível, ele aguarda em um loop, verificando repetidamente até o bloqueio ficar disponível.</span><span class="sxs-lookup"><span data-stu-id="39b50-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="39b50-153">Para obter mais informações sobre as vantagens e as desvantagens do uso do bloqueio de rotação, veja o artigo [SpinLock](spinlock.md) e a referência da API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="39b50-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="39b50-154">Classe ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="39b50-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="39b50-155">A classe <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> concede acesso exclusivo a um recurso compartilhado para gravação e permite que vários threads acessem o recurso simultaneamente para leitura.</span><span class="sxs-lookup"><span data-stu-id="39b50-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="39b50-156">Você talvez queira usar <xref:System.Threading.ReaderWriterLockSlim> para sincronizar o acesso a uma estrutura de dados compartilhada que dá suporte a operações de leitura thread-safe, mas requer acesso exclusivo para realizar a operação de gravação.</span><span class="sxs-lookup"><span data-stu-id="39b50-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="39b50-157">Quando um thread solicita acesso exclusivo (por exemplo, ao chamar o método <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>), o leitor subsequente solicita o bloqueio até que todos os leitores e gravadores existentes tenham saído do bloqueio e o gravador tenha entrado e saído do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="39b50-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="39b50-158">Para obter mais informações, veja a referência de API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="39b50-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="39b50-159">Classes Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="39b50-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="39b50-160">As classes <xref:System.Threading.Semaphore?displayProperty=nameWithType> e <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> limitam o número de threads que podem acessar um recurso compartilhado ou um pool de recursos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="39b50-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="39b50-161">Threads adicionais que solicitam o recurso aguardam até que qualquer thread liberar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="39b50-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="39b50-162">Como o semáforo não tem afinidade de thread, um thread pode adquirir o semáforo e outro pode liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="39b50-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="39b50-163"><xref:System.Threading.SemaphoreSlim> é uma alternativa leve a <xref:System.Threading.Semaphore> e pode ser usado somente para sincronização dentro do limite de um único processo.</span><span class="sxs-lookup"><span data-stu-id="39b50-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="39b50-164">No Windows, você pode usar <xref:System.Threading.Semaphore> para a sincronização entre processos.</span><span class="sxs-lookup"><span data-stu-id="39b50-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="39b50-165">Para fazer isso, crie uma instância <xref:System.Threading.Semaphore> que representa um semáforo de sistema nomeado usando um dos [Construtores de semáforo](<xref:System.Threading.Semaphore.%23ctor%2A>) que especifica um nome ou o método <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="39b50-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="39b50-166"><xref:System.Threading.SemaphoreSlim> não dá suporte a sinais de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="39b50-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="39b50-167">Para obter mais informações, veja o artigo [Semaphore e SemaphoreSlim](semaphore-and-semaphoreslim.md) e a referência à API <xref:System.Threading.Semaphore> ou <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="39b50-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="39b50-168">Interação ou sinalização de thread</span><span class="sxs-lookup"><span data-stu-id="39b50-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="39b50-169">Interação de thread (ou sinalização do thread) significa que um thread deve aguardar notificação ou um sinal de um ou mais threads para continuar.</span><span class="sxs-lookup"><span data-stu-id="39b50-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="39b50-170">Por exemplo, se o thread A chamar o método <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> do thread B, o thread A será bloqueado até que o thread B seja concluído.</span><span class="sxs-lookup"><span data-stu-id="39b50-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="39b50-171">Os primitivos de sincronização descritos na seção anterior fornecem um mecanismo diferente para sinalização: ao liberar um bloqueio, um thread notifica outro thread de que ele pode continuar adquirindo o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="39b50-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="39b50-172">Esta seção descreve outras construções de sinalização fornecidas pelo .NET.</span><span class="sxs-lookup"><span data-stu-id="39b50-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="39b50-173">Classes EventWaitHandle, AutoResetEvent, ManualResetEvent e ManualResetEventSlim</span><span class="sxs-lookup"><span data-stu-id="39b50-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="39b50-174">A classe <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> representa um evento de sincronização de thread.</span><span class="sxs-lookup"><span data-stu-id="39b50-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="39b50-175">Um evento de sincronização pode estar em um estado não sinalizado ou sinalizado.</span><span class="sxs-lookup"><span data-stu-id="39b50-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="39b50-176">Quando o estado de um evento não é sinalizado, um thread que chama a sobrecarga <xref:System.Threading.WaitHandle.WaitOne%2A?> do evento é bloqueado até que um evento seja sinalizado.</span><span class="sxs-lookup"><span data-stu-id="39b50-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="39b50-177">O método <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> define o estado de um evento como sinalizado.</span><span class="sxs-lookup"><span data-stu-id="39b50-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="39b50-178">O comportamento de um <xref:System.Threading.EventWaitHandle> que foi assinalado depende de seu modo de redefinição:</span><span class="sxs-lookup"><span data-stu-id="39b50-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="39b50-179">Um <xref:System.Threading.EventWaitHandle> criado com o sinalizador <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> é redefinido automaticamente após liberar um único thread em espera.</span><span class="sxs-lookup"><span data-stu-id="39b50-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="39b50-180">É como uma roleta que permite que apenas um thread de cada vez seja sinalizado.</span><span class="sxs-lookup"><span data-stu-id="39b50-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="39b50-181">A classe <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, que deriva de <xref:System.Threading.EventWaitHandle>, representa esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="39b50-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="39b50-182">Um <xref:System.Threading.EventWaitHandle> criado com o sinalizador <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> permanece sinalizado até que seu método <xref:System.Threading.EventWaitHandle.Reset%2A> seja chamado.</span><span class="sxs-lookup"><span data-stu-id="39b50-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="39b50-183">É como um portão que é fechado até ser sinalizado e então permanece aberto até que alguém o feche.</span><span class="sxs-lookup"><span data-stu-id="39b50-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="39b50-184">A classe <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, que deriva de <xref:System.Threading.EventWaitHandle>, representa esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="39b50-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="39b50-185">A classe <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> é uma alternativa leve para <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="39b50-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="39b50-186">No Windows, você pode usar <xref:System.Threading.EventWaitHandle> para a sincronização entre processos.</span><span class="sxs-lookup"><span data-stu-id="39b50-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="39b50-187">Para fazer isso, crie uma instância <xref:System.Threading.EventWaitHandle> que representa um evento de sincronização do sistema nomeado usando um dos [construtores EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) que especificam um nome ou o método <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="39b50-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="39b50-188">Para obter mais informações, confira o artigo [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="39b50-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="39b50-189">Para a referência de API, veja <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> e <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="39b50-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="39b50-190">Classe CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="39b50-190">CountdownEvent class</span></span>

<span data-ttu-id="39b50-191">A classe <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> representa um evento definido quando a contagem é zero.</span><span class="sxs-lookup"><span data-stu-id="39b50-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="39b50-192">Embora <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> seja maior que zero, um thread que chama <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> é bloqueado.</span><span class="sxs-lookup"><span data-stu-id="39b50-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="39b50-193">Chame <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> para diminuir a contagem de um evento.</span><span class="sxs-lookup"><span data-stu-id="39b50-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="39b50-194">Em contraste com <xref:System.Threading.ManualResetEvent> ou <xref:System.Threading.ManualResetEventSlim>, que você pode usar para desbloquear vários threads com um sinal de um thread, você pode usar <xref:System.Threading.CountdownEvent> para desbloquear um ou mais threads com sinais de vários threads.</span><span class="sxs-lookup"><span data-stu-id="39b50-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="39b50-195">Para obter mais informações, veja o artigo [CountdownEvent](countdownevent.md) e a referência à API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="39b50-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="39b50-196">Classe de barreira</span><span class="sxs-lookup"><span data-stu-id="39b50-196">Barrier class</span></span>

<span data-ttu-id="39b50-197">A classe <xref:System.Threading.Barrier?displayProperty=nameWithType> representa uma barreira de execução do thread.</span><span class="sxs-lookup"><span data-stu-id="39b50-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="39b50-198">Um thread que chama o método <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> sinaliza que atingiu a barreira e aguarda até que outros threads participantes atinjam a barreira.</span><span class="sxs-lookup"><span data-stu-id="39b50-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="39b50-199">Quando todos os threads participantes atingem a barreira, eles prosseguem e a barreira é redefinida e pode ser usada novamente.</span><span class="sxs-lookup"><span data-stu-id="39b50-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="39b50-200">Você pode usar <xref:System.Threading.Barrier> quando um ou mais threads exigirem os resultados de outros threads antes de prosseguir para a próxima fase de cálculo.</span><span class="sxs-lookup"><span data-stu-id="39b50-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="39b50-201">Para obter mais informações, veja o artigo [Barreira](barrier.md) e a referência da API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="39b50-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="39b50-202">Classe Interlocked</span><span class="sxs-lookup"><span data-stu-id="39b50-202">Interlocked class</span></span>

<span data-ttu-id="39b50-203">A classe <xref:System.Threading.Interlocked?displayProperty=nameWithType> fornece métodos estáticos que executam operações atômicas simples em uma variável.</span><span class="sxs-lookup"><span data-stu-id="39b50-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="39b50-204">Essas operações atômicas incluem adição, incremento e decremento, troca e troca condicional que depende de uma comparação e operação de leitura de um valor inteiro de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="39b50-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="39b50-205">Para obter mais informações, veja a referência de API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="39b50-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="39b50-206">Estrutura SpinWait</span><span class="sxs-lookup"><span data-stu-id="39b50-206">SpinWait structure</span></span>

<span data-ttu-id="39b50-207">A estrutura <xref:System.Threading.SpinWait?displayProperty=nameWithType> oferece suporte para espera baseada em rotação.</span><span class="sxs-lookup"><span data-stu-id="39b50-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="39b50-208">Você pode usá-la quando um thread tiver de esperar pela sinalização de um evento ou por uma condição específica. No entanto, quando o tempo de espera real for menor do que o tempo necessário, use um identificador de espera ou bloqueie o thread.</span><span class="sxs-lookup"><span data-stu-id="39b50-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="39b50-209">Usando o <xref:System.Threading.SpinWait>, você pode especificar um curto período de tempo para girar enquanto espera e, em seguida, gerar (por exemplo, aguardando ou em espera) somente se a condição não for atendida no tempo especificado.</span><span class="sxs-lookup"><span data-stu-id="39b50-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="39b50-210">Para obter mais informações, veja o artigo [SpinWait](spinwait.md) e a referência da API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="39b50-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="39b50-211">Consulte também</span><span class="sxs-lookup"><span data-stu-id="39b50-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="39b50-212">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="39b50-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="39b50-213">Objetos e recursos de threading</span><span class="sxs-lookup"><span data-stu-id="39b50-213">Threading objects and features</span></span>](threading-objects-and-features.md)
