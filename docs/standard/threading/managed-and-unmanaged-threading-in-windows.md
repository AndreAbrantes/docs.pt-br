---
title: Threading gerenciado e não gerenciado no Windows
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7834df6c987e94e59357c7c60db2627d107bffc3
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/06/2018
ms.locfileid: "43864544"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="4c74b-102">Threading gerenciado e não gerenciado no Windows</span><span class="sxs-lookup"><span data-stu-id="4c74b-102">Managed and Unmanaged Threading in Windows</span></span>
<span data-ttu-id="4c74b-103">O gerenciamento de todos os threads, inclusive de threads criados pelo Common Language Runtime e fora do tempo de execução que ingressam no ambiente gerenciado para executar o código, é feito pela classe <xref:System.Threading.Thread>.</span><span class="sxs-lookup"><span data-stu-id="4c74b-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="4c74b-104">O tempo de execução monitora todos os threads de seu processo que já executaram o código no ambiente de execução gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4c74b-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="4c74b-105">Ele não rastreia nenhum outro thread.</span><span class="sxs-lookup"><span data-stu-id="4c74b-105">It does not track any other threads.</span></span> <span data-ttu-id="4c74b-106">Os threads podem ingressar no ambiente de execução gerenciado por meio da interoperabilidade COM (porque o tempo de execução expõe os objetos gerenciados como objetos COM ao mundo não gerenciado), da função COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) e da invocação de plataforma.</span><span class="sxs-lookup"><span data-stu-id="4c74b-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="4c74b-107">Quando um thread não gerenciado, por exemplo, um COM Callable Wrapper, ingressa no tempo de execução, o sistema verifica o repositório de threads locais do thread em questão para procurar um objeto <xref:System.Threading.Thread> interno gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4c74b-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="4c74b-108">Caso o sistema encontre um thread desse tipo, o tempo de execução fica ciente sobre ele.</span><span class="sxs-lookup"><span data-stu-id="4c74b-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="4c74b-109">Caso contrário, o tempo de execução compila um novo objeto <xref:System.Threading.Thread> e o instala no repositório de threads locais do thread em questão.</span><span class="sxs-lookup"><span data-stu-id="4c74b-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="4c74b-110">No threading gerenciado, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> é a identificação estável do thread gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4c74b-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="4c74b-111">Durante seu tempo de vida, o thread não colidirá com os valores de outros threads, independente do domínio do aplicativo para o qual você obtém esse valor.</span><span class="sxs-lookup"><span data-stu-id="4c74b-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c74b-112">Um **ThreadId** do sistema operacional não tem relação fixa com um thread gerenciado porque hosts não gerenciados podem controlar a relação entre threads gerenciados e não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="4c74b-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="4c74b-113">Mais especificamente, hosts sofisticados podem usar a API Fiber para agendar muitos threads gerenciados no mesmo thread do sistema operacional ou para mover um thread gerenciado por diferentes threads do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4c74b-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="4c74b-114">Mapeando do threading do Win32 para o threading gerenciado</span><span class="sxs-lookup"><span data-stu-id="4c74b-114">Mapping from Win32 Threading to Managed Threading</span></span>  
 <span data-ttu-id="4c74b-115">A tabela a seguir mapeia os elementos do threading do Win32 com seu equivalente aproximado no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4c74b-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="4c74b-116">Esse mapeamento não representa uma funcionalidade idêntica.</span><span class="sxs-lookup"><span data-stu-id="4c74b-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="4c74b-117">Por exemplo, **TerminateThread** não executa cláusulas **finally** nem libera recursos, e não é possível evitá-lo.</span><span class="sxs-lookup"><span data-stu-id="4c74b-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="4c74b-118">No entanto, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executa todo o código de reversão, recupera todos os recursos e pode ser negado com <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c74b-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="4c74b-119">Leia a documentação com atenção e não faça deduções sobre a funcionalidade.</span><span class="sxs-lookup"><span data-stu-id="4c74b-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="4c74b-120">No Win32</span><span class="sxs-lookup"><span data-stu-id="4c74b-120">In Win32</span></span>|<span data-ttu-id="4c74b-121">No Common Language Runtime</span><span class="sxs-lookup"><span data-stu-id="4c74b-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="4c74b-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="4c74b-122">**CreateThread**</span></span>|<span data-ttu-id="4c74b-123">Combinação de **Thread** e <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="4c74b-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="4c74b-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="4c74b-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="4c74b-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="4c74b-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-127">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="4c74b-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-128">**WaitForSingleObject** no identificador de thread</span><span class="sxs-lookup"><span data-stu-id="4c74b-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="4c74b-129">**ExitThread**</span></span>|<span data-ttu-id="4c74b-130">Não há equivalência</span><span class="sxs-lookup"><span data-stu-id="4c74b-130">No equivalent</span></span>|  
|<span data-ttu-id="4c74b-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="4c74b-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="4c74b-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-133">Não há equivalência</span><span class="sxs-lookup"><span data-stu-id="4c74b-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-134">Não há equivalência</span><span class="sxs-lookup"><span data-stu-id="4c74b-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4c74b-135">Próximo a **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="4c74b-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="4c74b-136">Threads gerenciados e apartments COM</span><span class="sxs-lookup"><span data-stu-id="4c74b-136">Managed Threads and COM Apartments</span></span>  
 <span data-ttu-id="4c74b-137">Um thread gerenciado pode ser marcado para indicar que ele irá hospedar um [single-threaded apartament](/windows/desktop/com/single-threaded-apartments) ou um [multithread apartament](/windows/desktop/com/multithreaded-apartments).</span><span class="sxs-lookup"><span data-stu-id="4c74b-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="4c74b-138">(Para obter mais informações sobre a arquitetura de threading COM, confira [Processos, threads e apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) Os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A> da classe <xref:System.Threading.Thread> retornam e atribuem o estado de apartment de um thread.</span><span class="sxs-lookup"><span data-stu-id="4c74b-138">(For more information on the COM threading architecture, see [Processes, threads, and Apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="4c74b-139">Se o estado não tiver sido definido, <xref:System.Threading.Thread.GetApartmentState%2A> retorna <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c74b-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4c74b-140">Você só pode definir uma propriedade quando o thread estiver no estado <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>; ela só pode ser definida uma vez por thread.</span><span class="sxs-lookup"><span data-stu-id="4c74b-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="4c74b-141">Se o estado do apartment não for definido antes do início do thread, o thread será iniciado como MTA (multithreaded apartment).</span><span class="sxs-lookup"><span data-stu-id="4c74b-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="4c74b-142">O thread finalizador e todos os threads controlados por <xref:System.Threading.ThreadPool> são do tipo MTA.</span><span class="sxs-lookup"><span data-stu-id="4c74b-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4c74b-143">No caso do código de inicialização do aplicativo, a única forma de controlar o estado do apartment é aplicar <xref:System.MTAThreadAttribute> ou <xref:System.STAThreadAttribute> ao procedimento do ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="4c74b-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="4c74b-144">No .NET Framework 1.0 e 1.1, você pode definir a propriedade <xref:System.Threading.Thread.ApartmentState%2A> como a primeira linha de código.</span><span class="sxs-lookup"><span data-stu-id="4c74b-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="4c74b-145">Isso não é permitido no .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="4c74b-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="4c74b-146">Os objetos gerenciados que são expostos ao comportamento COM comportam-se como se houvesse um marshaler de thread livre agregado a eles.</span><span class="sxs-lookup"><span data-stu-id="4c74b-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="4c74b-147">Em outras palavras, eles podem ser chamados por qualquer apartment COM no modo de threading livre.</span><span class="sxs-lookup"><span data-stu-id="4c74b-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="4c74b-148">Os únicos objetos gerenciados que não apresentam esse comportamento são os objetos derivados de <xref:System.EnterpriseServices.ServicedComponent> ou <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="4c74b-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="4c74b-149">No mundo gerenciado, não há suporte a <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>, a menos que você use contextos e instâncias gerenciadas vinculadas a um contexto.</span><span class="sxs-lookup"><span data-stu-id="4c74b-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="4c74b-150">Se você estiver usando o Enterprise Services, seu objeto deve ser derivado de <xref:System.EnterpriseServices.ServicedComponent> (que, por sua vez, é derivado de <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="4c74b-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="4c74b-151">Quando o código gerenciado chama objetos COM, ele sempre segue as regras COM.</span><span class="sxs-lookup"><span data-stu-id="4c74b-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="4c74b-152">Em outras palavras, ele faz a chamada por meio de proxies de apartment COM e COM+ 1.0 context wrappers, como ditado por OLE32.</span><span class="sxs-lookup"><span data-stu-id="4c74b-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="4c74b-153">Problemas de bloqueio</span><span class="sxs-lookup"><span data-stu-id="4c74b-153">Blocking Issues</span></span>  
 <span data-ttu-id="4c74b-154">Se um thread fizer uma chamada não gerenciada no sistema operacional que bloqueou o thread no código não gerenciado, o tempo de execução não assumirá o controle para <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> nem <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c74b-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4c74b-155">No caso do <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, o tempo de execução marca o thread como **Abortar** e assume o controle dele quando esse ingressa no código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4c74b-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="4c74b-156">Recomendamos que você use bloqueios gerenciados, em vez de não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="4c74b-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="4c74b-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, entre outros, respondem a <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> e a <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c74b-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4c74b-158">Além disso, se seu thread estiver em um single-threaded apartment, todas essas operações de bloqueio gerenciado enviarão mensagens para seu apartment enquanto o thread estiver bloqueado.</span><span class="sxs-lookup"><span data-stu-id="4c74b-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4c74b-159">Consulte também</span><span class="sxs-lookup"><span data-stu-id="4c74b-159">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>  
- <xref:System.Threading.ThreadState>  
- <xref:System.EnterpriseServices.ServicedComponent>  
- <xref:System.Threading.Thread>  
- <xref:System.Threading.Monitor>
