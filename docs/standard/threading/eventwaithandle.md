---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="ec723-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="ec723-102">EventWaitHandle</span></span>
<span data-ttu-id="ec723-103">O <xref:System.Threading.EventWaitHandle> classe permite que os threads para se comunicar entre si por sinalização e aguardando sinais.</span><span class="sxs-lookup"><span data-stu-id="ec723-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="ec723-104">Identificadores de espera de eventos (também conhecidas simplesmente como eventos) são identificadores de espera que podem ser sinalizados para liberar um ou mais threads de espera.</span><span class="sxs-lookup"><span data-stu-id="ec723-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="ec723-105">Depois que ela foi sinalizada, um identificador de espera de eventos é redefinido manualmente ou automaticamente.</span><span class="sxs-lookup"><span data-stu-id="ec723-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="ec723-106">O <xref:System.Threading.EventWaitHandle> classe pode representar qualquer um evento local identificador de espera (evento local) ou um evento do sistema nomeado aguardar o identificador (chamado de evento ou evento do sistema, visível para todos os processos).</span><span class="sxs-lookup"><span data-stu-id="ec723-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ec723-107">Identificadores de espera de eventos não são eventos no sentido geralmente significa palavra no .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ec723-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="ec723-108">Não há nenhum delegados ou manipuladores de eventos envolvidos.</span><span class="sxs-lookup"><span data-stu-id="ec723-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="ec723-109">"Evento" é usado para descrevê-los, pois eles têm sido conhecidos tradicionalmente como eventos do sistema operacional e o ato de sinalização do identificador de espera indica para threads de espera que um evento ocorreu.</span><span class="sxs-lookup"><span data-stu-id="ec723-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="ec723-110">Ambos os identificadores de espera de eventos local e nomeado usam objetos de sincronização do sistema, que são protegidos pelo <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers para garantir que os recursos são liberados.</span><span class="sxs-lookup"><span data-stu-id="ec723-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="ec723-111">Você pode usar o <xref:System.Threading.WaitHandle.Dispose%2A> método para liberar os recursos imediatamente quando você terminar de usar o objeto.</span><span class="sxs-lookup"><span data-stu-id="ec723-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="ec723-112">Identificadores de espera de eventos que redefinirem automaticamente</span><span class="sxs-lookup"><span data-stu-id="ec723-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="ec723-113">Criar um evento de redefinição automática especificando <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> quando você cria o <xref:System.Threading.EventWaitHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="ec723-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="ec723-114">Como o nome sugere, esse evento de sincronização redefine automaticamente quando sinalizado, após o lançamento de um único thread de espera.</span><span class="sxs-lookup"><span data-stu-id="ec723-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="ec723-115">Sinalizar o evento chamando seu <xref:System.Threading.EventWaitHandle.Set%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ec723-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="ec723-116">Eventos de redefinição automática geralmente são usados para fornecer acesso exclusivo a um recurso para um único thread por vez.</span><span class="sxs-lookup"><span data-stu-id="ec723-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="ec723-117">Um thread de solicita o recurso ao chamar o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ec723-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="ec723-118">Se nenhum outro thread está mantendo o identificador de espera, o método retorna `true` e o thread de chamada tem o controle do recurso.</span><span class="sxs-lookup"><span data-stu-id="ec723-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ec723-119">Assim como acontece com todos os mecanismos de sincronização, você deve garantir que todos os caminhos de código aguardar o identificador de espera apropriado antes de acessar um recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="ec723-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="ec723-120">Sincronização de threads é cooperativa.</span><span class="sxs-lookup"><span data-stu-id="ec723-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="ec723-121">Se um evento de redefinição automática é sinalizado quando não há threads estão esperando, ele permanecerá sinalizado até que um thread tente esperar.</span><span class="sxs-lookup"><span data-stu-id="ec723-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="ec723-122">O evento libera o thread e redefine imediatamente, bloqueando threads subsequentes.</span><span class="sxs-lookup"><span data-stu-id="ec723-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="ec723-123">Identificadores de espera de eventos que redefinir manualmente</span><span class="sxs-lookup"><span data-stu-id="ec723-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="ec723-124">Criar um evento de redefinição manual especificando <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> quando você cria o <xref:System.Threading.EventWaitHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="ec723-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="ec723-125">Como o nome sugere, esse evento de sincronização deve ser redefinido manualmente depois que ele tiver sido sinalizado.</span><span class="sxs-lookup"><span data-stu-id="ec723-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="ec723-126">Até que ela seja redefinida, chamando seu <xref:System.Threading.EventWaitHandle.Reset%2A> método, os threads que aguardar o identificador de evento continuar imediatamente sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="ec723-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="ec723-127">Redefinição de um manual atos de evento como a porta de um corral.</span><span class="sxs-lookup"><span data-stu-id="ec723-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="ec723-128">Quando o evento não será sinalizado, bloqueiam threads que esperam nele, como cavalos de um corral.</span><span class="sxs-lookup"><span data-stu-id="ec723-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="ec723-129">Quando o evento é sinalizado, chamando seu <xref:System.Threading.EventWaitHandle.Set%2A> método, todos os threads de espera estão livres para continuar.</span><span class="sxs-lookup"><span data-stu-id="ec723-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="ec723-130">O evento permanece sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="ec723-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="ec723-131">Isso torna o evento de redefinição manual de maneira ideal de threads que seja necessário aguardar até que um thread conclui uma tarefa em espera.</span><span class="sxs-lookup"><span data-stu-id="ec723-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="ec723-132">Como cavalos de deixar um corral leva tempo para os lançamento threads sejam agendadas pelo sistema operacional e continuar a execução.</span><span class="sxs-lookup"><span data-stu-id="ec723-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="ec723-133">Se o <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado antes de todos os threads têm voltou a operar, os segmentos restantes bloqueiam novamente.</span><span class="sxs-lookup"><span data-stu-id="ec723-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="ec723-134">Retomar os threads e o bloco de threads depende aleatórios fatores como a carga no sistema, o número de threads aguardando para o Agendador e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="ec723-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="ec723-135">Isso não é um problema se o thread que sinaliza o evento terminar depois de sinalizar, que é o padrão de uso mais comum.</span><span class="sxs-lookup"><span data-stu-id="ec723-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="ec723-136">Se você quiser thread sinalizado o evento para iniciar uma nova tarefa depois que todos os aguardando threads retomou o funcionamento, você deve bloqueá-lo até que todos os threads de espera tem retomado.</span><span class="sxs-lookup"><span data-stu-id="ec723-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="ec723-137">Caso contrário, você tem uma condição de corrida, e o comportamento do seu código é imprevisível.</span><span class="sxs-lookup"><span data-stu-id="ec723-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="ec723-138">Recursos comuns a eventos automáticos e Manual</span><span class="sxs-lookup"><span data-stu-id="ec723-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="ec723-139">Normalmente, um ou mais threads bloqueiam um <xref:System.Threading.EventWaitHandle> até que um thread desbloqueado chama o <xref:System.Threading.EventWaitHandle.Set%2A> método, o que libera um dos threads de espera (no caso de eventos de reinicialização automática) ou todos eles (no caso de manual redefinir eventos).</span><span class="sxs-lookup"><span data-stu-id="ec723-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="ec723-140">Um thread pode sinalizar um <xref:System.Threading.EventWaitHandle> e, em seguida, bloquear, como uma operação atômica, chamando estático <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="ec723-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ec723-141"><xref:System.Threading.EventWaitHandle>objetos podem ser usados com estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="ec723-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="ec723-142">Porque o <xref:System.Threading.EventWaitHandle> e <xref:System.Threading.Mutex> derivam de classes <xref:System.Threading.WaitHandle>, você pode usar ambas as classes com esses métodos.</span><span class="sxs-lookup"><span data-stu-id="ec723-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="ec723-143">Eventos nomeados</span><span class="sxs-lookup"><span data-stu-id="ec723-143">Named Events</span></span>  
 <span data-ttu-id="ec723-144">O sistema operacional Windows permite que os identificadores de espera do evento ter nomes.</span><span class="sxs-lookup"><span data-stu-id="ec723-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="ec723-145">Um evento nomeado é todo o sistema.</span><span class="sxs-lookup"><span data-stu-id="ec723-145">A named event is system wide.</span></span> <span data-ttu-id="ec723-146">Ou seja, quando o evento nomeado é criado, é visível para todos os threads em todos os processos.</span><span class="sxs-lookup"><span data-stu-id="ec723-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="ec723-147">Assim, os eventos nomeados podem ser usados para sincronizar as atividades de processos, bem como os threads.</span><span class="sxs-lookup"><span data-stu-id="ec723-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="ec723-148">Você pode criar um <xref:System.Threading.EventWaitHandle> objeto que representa um evento do sistema nomeado usando um dos construtores que especifica um nome de evento.</span><span class="sxs-lookup"><span data-stu-id="ec723-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ec723-149">Como os eventos nomeados são todo o sistema, é possível ter vários <xref:System.Threading.EventWaitHandle> denominado de objetos que representam o mesmo evento.</span><span class="sxs-lookup"><span data-stu-id="ec723-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="ec723-150">Cada vez que você chamar um construtor, ou o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método, um novo <xref:System.Threading.EventWaitHandle> objeto é criado.</span><span class="sxs-lookup"><span data-stu-id="ec723-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="ec723-151">Especificando o mesmo nome repetidamente cria vários objetos que representam o mesmo evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="ec723-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="ec723-152">Tenha cuidado usando eventos nomeados.</span><span class="sxs-lookup"><span data-stu-id="ec723-152">Caution is advised in using named events.</span></span> <span data-ttu-id="ec723-153">Porque eles estão no sistema, outro processo que usa o mesmo nome pode bloquear seu threads inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="ec723-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="ec723-154">Código mal-intencionado em execução no mesmo computador pode usar isso como base de um ataque de negação de serviço.</span><span class="sxs-lookup"><span data-stu-id="ec723-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="ec723-155">Usar controle de acesso de segurança para proteger um <xref:System.Threading.EventWaitHandle> objeto que representa um evento nomeado, preferencialmente com um construtor que especifica um <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto.</span><span class="sxs-lookup"><span data-stu-id="ec723-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="ec723-156">Você também pode aplicar a segurança de controle de acesso usando o <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> método, mas isso deixa uma janela de vulnerabilidade entre a hora em que o identificador de espera de eventos é criado e a hora em que ele está protegido.</span><span class="sxs-lookup"><span data-stu-id="ec723-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="ec723-157">Protegendo os eventos com controle de acesso de segurança ajuda a impedir ataques maliciosos, mas não resolver o problema de conflitos de nome não intencionais.</span><span class="sxs-lookup"><span data-stu-id="ec723-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ec723-158">Ao contrário de <xref:System.Threading.EventWaitHandle> classe, as classes derivadas <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> pode representar local somente identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="ec723-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="ec723-159">Eles não podem representar eventos do sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="ec723-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ec723-160">Consulte também</span><span class="sxs-lookup"><span data-stu-id="ec723-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="ec723-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="ec723-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
