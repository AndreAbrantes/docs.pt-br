---
title: Assemblies de referência
description: Saiba mais sobre montagens de referência, um tipo especial de montagens em .NET que contêm apenas a superfície pública da API da biblioteca
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 938942caf81c54a8aa9207dbe87559438ffb252e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/15/2020
ms.locfileid: "79141062"
---
# <a name="reference-assemblies"></a><span data-ttu-id="f2a83-103">Assemblies de referência</span><span class="sxs-lookup"><span data-stu-id="f2a83-103">Reference assemblies</span></span>

<span data-ttu-id="f2a83-104">*Os conjuntos de referência* são um tipo especial de montagem que contém apenas a quantidade mínima de metadados necessários para representar a superfície pública da API da biblioteca.</span><span class="sxs-lookup"><span data-stu-id="f2a83-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="f2a83-105">Eles incluem declarações para todos os membros que são significativas ao fazer referência a uma assembléia em ferramentas de construção, mas excluem todas as implementações de membros membros e declarações de membros privados que não tenham impacto observável em seu contrato de API.</span><span class="sxs-lookup"><span data-stu-id="f2a83-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="f2a83-106">Em contraste, as assembléias regulares são chamadas *de assembléias de implementação.*</span><span class="sxs-lookup"><span data-stu-id="f2a83-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="f2a83-107">Os conjuntos de referência não podem ser carregados para execução, mas podem ser aprovados como entrada de compilador da mesma forma que os conjuntos de implementação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="f2a83-108">Os conjuntos de referência são geralmente distribuídos com o Kit de Desenvolvimento de Software (SDK) de uma determinada plataforma ou biblioteca.</span><span class="sxs-lookup"><span data-stu-id="f2a83-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="f2a83-109">O uso de um conjunto de referência permite que os desenvolvedores construam programas que visam uma versão específica da biblioteca sem ter o conjunto completo de implementação para essa versão.</span><span class="sxs-lookup"><span data-stu-id="f2a83-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="f2a83-110">Suponha que você tenha apenas a versão mais recente de alguma biblioteca em sua máquina, mas você quer construir um programa que visa uma versão anterior dessa biblioteca.</span><span class="sxs-lookup"><span data-stu-id="f2a83-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="f2a83-111">Se você compilar diretamente contra a montagem de implementação, você pode usar inadvertidamente membros da API que não estão disponíveis na versão anterior.</span><span class="sxs-lookup"><span data-stu-id="f2a83-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="f2a83-112">Você só vai encontrar este erro ao testar o programa na máquina alvo.</span><span class="sxs-lookup"><span data-stu-id="f2a83-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="f2a83-113">Se você compilar contra o conjunto de referência para a versão anterior, você receberá imediatamente um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="f2a83-114">Uma montagem de referência também pode representar um contrato, ou seja, um conjunto de APIs que não correspondem à montagem concreta da implementação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="f2a83-115">Tais conjuntos de referência, chamados *de conjunto de contratos,* podem ser usados para atingir várias plataformas que suportam o mesmo conjunto de APIs.</span><span class="sxs-lookup"><span data-stu-id="f2a83-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="f2a83-116">Por exemplo, o .NET Standard fornece o conjunto de *contratos, netstandard.dll,* que representa o conjunto de APIs comuns compartilhadas entre diferentes plataformas .NET.</span><span class="sxs-lookup"><span data-stu-id="f2a83-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="f2a83-117">As implementações dessas APIs estão contidas em diferentes assembléias em diferentes plataformas, como *mscorlib.dll* no .NET Framework ou *System.Private.CoreLib.dll* no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="f2a83-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="f2a83-118">Uma biblioteca que tem como alvo o .NET Standard pode ser executada em todas as plataformas que suportam o .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="f2a83-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="f2a83-119">Usando conjuntos de referência</span><span class="sxs-lookup"><span data-stu-id="f2a83-119">Using reference assemblies</span></span>

<span data-ttu-id="f2a83-120">Para usar certas APIs do seu projeto, você deve adicionar referências às suas assembléias.</span><span class="sxs-lookup"><span data-stu-id="f2a83-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="f2a83-121">Você pode adicionar referências a conjuntos de implementação ou a assembléias de referência.</span><span class="sxs-lookup"><span data-stu-id="f2a83-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="f2a83-122">Recomenda-se que você use conjuntos de referência sempre que estiverem disponíveis.</span><span class="sxs-lookup"><span data-stu-id="f2a83-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="f2a83-123">Isso garante que você esteja usando apenas os membros da API suportados na versão de destino, destinado a ser usado por designers de API.</span><span class="sxs-lookup"><span data-stu-id="f2a83-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="f2a83-124">O uso do conjunto de referência garante que você não esteja dependendo dos detalhes da implementação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="f2a83-125">As montagens de referência para as bibliotecas .NET Framework são distribuídas com pacotes de segmentação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="f2a83-126">Você pode obtê-los baixando um instalador autônomo ou selecionando um componente no instalador do Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="f2a83-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="f2a83-127">Para obter mais informações, consulte [Instalar o .NET Framework para desenvolvedores](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="f2a83-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="f2a83-128">Para .NET Core e .NET Standard, os conjuntos de referência são automaticamente baixados conforme necessário (via NuGet) e referenciados.</span><span class="sxs-lookup"><span data-stu-id="f2a83-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="f2a83-129">Para .NET Core 3.0 ou superior, os conjuntos de referência para a estrutura principal estão no pacote [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (o pacote [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) é usado em vez de versões antes de 3.0).</span><span class="sxs-lookup"><span data-stu-id="f2a83-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="f2a83-130">Para obter mais informações, consulte [Pacotes, metapacotes e frameworks](../../core/packages.md) no Guia de Núcleo .NET.</span><span class="sxs-lookup"><span data-stu-id="f2a83-130">For more information, see [Packages, metapackages, and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="f2a83-131">Quando você adiciona referências aos conjuntos .NET Framework no Visual Studio usando a caixa de **diálogo Adicionar referência,** você seleciona um conjunto da lista e o Visual Studio encontra automaticamente conjuntos de referência que correspondem à versão de framework de destino selecionada em seu projeto.</span><span class="sxs-lookup"><span data-stu-id="f2a83-131">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="f2a83-132">O mesmo se aplica à adição de referências diretamente no projeto MSBuild usando o item do projeto [Referência:](/visualstudio/msbuild/common-msbuild-project-items#reference) você só precisa especificar o nome do conjunto, não o caminho completo do arquivo.</span><span class="sxs-lookup"><span data-stu-id="f2a83-132">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="f2a83-133">Quando você adiciona referências a esses conjuntos `-reference` na linha de comando usando a opção compilador <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> [(em C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) e no [Visual Basic)](../../visual-basic/reference/command-line-compiler/reference.md)ou usando o método na API Roslyn, você deve especificar manualmente arquivos de montagem de referência para a versão correta da plataforma de destino.</span><span class="sxs-lookup"><span data-stu-id="f2a83-133">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="f2a83-134">Os arquivos de montagem de referência do Framework .NET estão localizados no *%ProgramFiles(x86)%\\do Reference Assemblys\\Microsoft\\Framework\\. Diretório NETFramework.*</span><span class="sxs-lookup"><span data-stu-id="f2a83-134">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="f2a83-135">Para o .NET Core, você pode forçar a operação de publicação a copiar conjuntos de referência para `PreserveCompilationContext` sua `true`plataforma de destino no subdiretório *de publicação/refs* do diretório de saída, definindo a propriedade do projeto para .</span><span class="sxs-lookup"><span data-stu-id="f2a83-135">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="f2a83-136">Então você pode passar esses arquivos de montagem de referência para o compilador.</span><span class="sxs-lookup"><span data-stu-id="f2a83-136">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="f2a83-137">O `DependencyContext` uso do pacote [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) pode ajudar a localizar seus caminhos.</span><span class="sxs-lookup"><span data-stu-id="f2a83-137">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="f2a83-138">Por não conterem nenhuma implementação, as assembléias de referência não podem ser carregadas para execução.</span><span class="sxs-lookup"><span data-stu-id="f2a83-138">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="f2a83-139">Tentar fazer isso resulta <xref:System.BadImageFormatException?displayProperty=nameWithType>em um .</span><span class="sxs-lookup"><span data-stu-id="f2a83-139">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f2a83-140">Se você quiser examinar o conteúdo de um conjunto de referência, você pode carregá-lo no contexto somente de reflexão no .NET Framework (usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> método) ou no <xref:System.Reflection.MetadataLoadContext> núcleo .NET.</span><span class="sxs-lookup"><span data-stu-id="f2a83-140">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="f2a83-141">Gerando montagens de referência</span><span class="sxs-lookup"><span data-stu-id="f2a83-141">Generating reference assemblies</span></span>

<span data-ttu-id="f2a83-142">Gerar montagens de referência para suas bibliotecas pode ser útil quando os consumidores de sua biblioteca precisam construir seus programas contra muitas versões diferentes da biblioteca.</span><span class="sxs-lookup"><span data-stu-id="f2a83-142">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="f2a83-143">Distribuir conjuntos de implementação para todas essas versões pode ser impraticável devido ao seu grande tamanho.</span><span class="sxs-lookup"><span data-stu-id="f2a83-143">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="f2a83-144">Os conjuntos de referência são menores em tamanho, e distribuí-los como parte do SDK da sua biblioteca reduz o tamanho do download e economiza espaço em disco.</span><span class="sxs-lookup"><span data-stu-id="f2a83-144">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="f2a83-145">IDEs e ferramentas de construção também podem aproveitar os conjuntos de referência para reduzir os tempos de compilação no caso de grandes soluções que consistem em várias bibliotecas de classe.</span><span class="sxs-lookup"><span data-stu-id="f2a83-145">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="f2a83-146">Normalmente, em cenários de construção incremental, um projeto é reconstruído quando qualquer um de seus arquivos de entrada são alterados, incluindo os conjuntos de que depende.</span><span class="sxs-lookup"><span data-stu-id="f2a83-146">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="f2a83-147">A montagem da implementação muda sempre que o programador altera a implementação de qualquer membro.</span><span class="sxs-lookup"><span data-stu-id="f2a83-147">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="f2a83-148">A montagem de referência só muda quando sua API pública é afetada.</span><span class="sxs-lookup"><span data-stu-id="f2a83-148">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="f2a83-149">Assim, usar o conjunto de referência como um arquivo de entrada em vez da montagem de implementação permite pular a construção do projeto dependente em alguns casos.</span><span class="sxs-lookup"><span data-stu-id="f2a83-149">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="f2a83-150">Você pode gerar conjuntos de referência:</span><span class="sxs-lookup"><span data-stu-id="f2a83-150">You can generate reference assemblies:</span></span>

- <span data-ttu-id="f2a83-151">Em um projeto MSBuild, usando a propriedade do [ `ProduceReferenceAssembly` projeto.](/visualstudio/msbuild/common-msbuild-project-properties)</span><span class="sxs-lookup"><span data-stu-id="f2a83-151">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="f2a83-152">Ao compilar o programa a partir da `-refonly` linha de comando, `-refout` especificando[(C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / Visual[Basic)](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ou[(C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic)](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)opções de compilador.</span><span class="sxs-lookup"><span data-stu-id="f2a83-152">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="f2a83-153">Ao usar a API Roslyn, <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> `false` definindo <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> para `true` e <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> para em um objeto passado para o método.</span><span class="sxs-lookup"><span data-stu-id="f2a83-153">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="f2a83-154">Se você quiser distribuir conjuntos de referência com pacotes NuGet, você deve incluí-los no subdiretório \*de ref\\ \* o diretório de pacotes em vez de no subdiretório \*lib\\ \* usado para conjuntos de implementação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-154">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="f2a83-155">Estrutura de montagens de referência</span><span class="sxs-lookup"><span data-stu-id="f2a83-155">Reference assemblies structure</span></span>

<span data-ttu-id="f2a83-156">Os conjuntos de referência são uma expansão do conceito relacionado, *conjuntos somente de metadados*.</span><span class="sxs-lookup"><span data-stu-id="f2a83-156">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="f2a83-157">Os assemblies somente de metadados têm seus corpos de método substituídos por um único corpo `throw null`, mas incluem todos os membros, exceto tipos anônimos.</span><span class="sxs-lookup"><span data-stu-id="f2a83-157">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="f2a83-158">A razão `throw null` para o uso de corpos (ao contrário de nenhum corpo) é para que **o PEVerify** possa ser executado e passar (validando assim a completitude dos metadados).</span><span class="sxs-lookup"><span data-stu-id="f2a83-158">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="f2a83-159">Os assemblies de referência removem ainda mais metadados (membros particulares) de assemblies somente de metadados:</span><span class="sxs-lookup"><span data-stu-id="f2a83-159">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="f2a83-160">Um assembly de referência tem somente referências para o que ele precisa na superfície de API.</span><span class="sxs-lookup"><span data-stu-id="f2a83-160">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="f2a83-161">Talvez o assembly real tenha outras referências relacionadas a implementações específicas.</span><span class="sxs-lookup"><span data-stu-id="f2a83-161">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="f2a83-162">Por exemplo, o `class C { private void M() { dynamic d = 1; ... } }` conjunto de referência para `dynamic`não faz referência a nenhum tipo necessário para .</span><span class="sxs-lookup"><span data-stu-id="f2a83-162">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="f2a83-163">Membros de função privados (métodos, propriedades e eventos) são removidos nos casos em que sua remoção não afeta nitidamente a compilação.</span><span class="sxs-lookup"><span data-stu-id="f2a83-163">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="f2a83-164">Se não houver [atributos InternalsVisibleTo,](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) os membros da função interna também serão removidos.</span><span class="sxs-lookup"><span data-stu-id="f2a83-164">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="f2a83-165">Os metadados em conjuntos de referência continuam a manter as seguintes informações:</span><span class="sxs-lookup"><span data-stu-id="f2a83-165">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="f2a83-166">Todos os tipos, incluindo tipos privados e aninhados.</span><span class="sxs-lookup"><span data-stu-id="f2a83-166">All types, including private and nested types.</span></span>
- <span data-ttu-id="f2a83-167">Todos os atributos, mesmo os internos.</span><span class="sxs-lookup"><span data-stu-id="f2a83-167">All attributes, even internal ones.</span></span>
- <span data-ttu-id="f2a83-168">Todos os métodos virtuais.</span><span class="sxs-lookup"><span data-stu-id="f2a83-168">All virtual methods.</span></span>
- <span data-ttu-id="f2a83-169">Implementações explícitas de interface.</span><span class="sxs-lookup"><span data-stu-id="f2a83-169">Explicit interface implementations.</span></span>
- <span data-ttu-id="f2a83-170">Propriedades e eventos explicitamente implementados, porque seus acessórios são virtuais.</span><span class="sxs-lookup"><span data-stu-id="f2a83-170">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="f2a83-171">Todos os campos de estruturas.</span><span class="sxs-lookup"><span data-stu-id="f2a83-171">All fields of structures.</span></span>

<span data-ttu-id="f2a83-172">Os conjuntos de referência incluem um atributo [Assembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) de referência em nível de montagem.</span><span class="sxs-lookup"><span data-stu-id="f2a83-172">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="f2a83-173">Este atributo pode ser especificado na fonte; então o compilador não precisará sintetizá-lo.</span><span class="sxs-lookup"><span data-stu-id="f2a83-173">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="f2a83-174">Por causa desse atributo, os tempos de execução se recusarão a carregar conjuntos de referência para execução (mas eles podem ser carregados no modo somente de reflexão).</span><span class="sxs-lookup"><span data-stu-id="f2a83-174">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="f2a83-175">Os detalhes exatos da estrutura de montagem de referência dependem da versão do compilador.</span><span class="sxs-lookup"><span data-stu-id="f2a83-175">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="f2a83-176">Versões mais recentes podem optar por excluir mais metadados se fordeterminado como não afetando a superfície da API pública.</span><span class="sxs-lookup"><span data-stu-id="f2a83-176">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="f2a83-177">As informações nesta seção são aplicáveis apenas aos conjuntos de referência gerados pelos compiladores roslyn a partir da versão C# 7.1 ou Visual Basic versão 15.3.</span><span class="sxs-lookup"><span data-stu-id="f2a83-177">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="f2a83-178">A estrutura de montagens de referência para bibliotecas .NET Framework e .NET Core pode diferir em alguns detalhes, pois eles usam seu próprio mecanismo de geração de montagens de referência.</span><span class="sxs-lookup"><span data-stu-id="f2a83-178">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="f2a83-179">Por exemplo, eles podem ter corpos `throw null` de método totalmente vazios em vez do corpo.</span><span class="sxs-lookup"><span data-stu-id="f2a83-179">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="f2a83-180">Mas o princípio geral ainda se aplica: eles não têm implementações de métodos utilizáveis e contêm metadados apenas para membros que têm um impacto observável a partir de uma perspectiva pública de API.</span><span class="sxs-lookup"><span data-stu-id="f2a83-180">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="f2a83-181">Confira também</span><span class="sxs-lookup"><span data-stu-id="f2a83-181">See also</span></span>

- [<span data-ttu-id="f2a83-182">Assemblies no .NET</span><span class="sxs-lookup"><span data-stu-id="f2a83-182">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="f2a83-183">Visão geral do direcionamento de estrutura</span><span class="sxs-lookup"><span data-stu-id="f2a83-183">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="f2a83-184">Como: Adicionar ou remover referências usando o Gerenciador de Referência</span><span class="sxs-lookup"><span data-stu-id="f2a83-184">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
