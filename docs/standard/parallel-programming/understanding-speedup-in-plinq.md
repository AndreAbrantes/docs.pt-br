---
title: "Noções básicas sobre agilização em PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="8212b-102">Noções básicas sobre agilização em PLINQ</span><span class="sxs-lookup"><span data-stu-id="8212b-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="8212b-103">O objetivo principal do PLINQ é acelerar a execução do LINQ para consultas de objetos, executando os delegados de consulta em paralelo em computadores com vários núcleos.</span><span class="sxs-lookup"><span data-stu-id="8212b-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="8212b-104">PLINQ funciona melhor quando o processamento de cada elemento em uma coleção de origem é independente, sem estado compartilhado envolvidas entre os delegados individuais.</span><span class="sxs-lookup"><span data-stu-id="8212b-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="8212b-105">Essas operações são comuns em LINQ para objetos e em PLINQ e são chamadas de "*agradavelmente paralelo*" porque elas se prestam facilmente para o planejamento de vários threads.</span><span class="sxs-lookup"><span data-stu-id="8212b-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="8212b-106">No entanto, nem todas as consultas consistem inteiramente em operações agradavelmente paralelo; Na maioria dos casos, uma consulta envolve alguns operadores que o não pode ser paralelizado ou que lenta a execução paralela.</span><span class="sxs-lookup"><span data-stu-id="8212b-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="8212b-107">E até mesmo com consultas que são totalmente agradavelmente paralelas, PLINQ deve ainda dividir a fonte de dados e agendar o trabalho em threads e geralmente mesclar os resultados quando a consulta é concluída.</span><span class="sxs-lookup"><span data-stu-id="8212b-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="8212b-108">Todas essas operações adicionar ao custo computacional de paralelização; Esses custos de adição de paralelização são chamados *sobrecarga*.</span><span class="sxs-lookup"><span data-stu-id="8212b-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="8212b-109">Para obter um desempenho ideal em uma consulta PLINQ, o objetivo é maximizar as partes agradavelmente paralelas e minimizar as partes que exigem a sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="8212b-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="8212b-110">Este artigo fornece informações que ajudarão você a escrever consultas PLINQ que são mais eficientes possível, enquanto ainda produzindo resultados corretos.</span><span class="sxs-lookup"><span data-stu-id="8212b-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="8212b-111">Fatores que afetam o desempenho da consulta PLINQ</span><span class="sxs-lookup"><span data-stu-id="8212b-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="8212b-112">As seções a seguir lista alguns dos principais fatores que afetam o desempenho consulta paralela.</span><span class="sxs-lookup"><span data-stu-id="8212b-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="8212b-113">Essas são instruções gerais que, por si só, não são suficientes para prever o desempenho de consulta em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="8212b-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="8212b-114">Como sempre, é importante medir o desempenho real de consultas específicas em computadores com uma variedade de configurações de representante e carrega.</span><span class="sxs-lookup"><span data-stu-id="8212b-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="8212b-115">Custo computacional geral do trabalho.</span><span class="sxs-lookup"><span data-stu-id="8212b-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="8212b-116">Para obter o aumento de velocidade, uma consulta PLINQ deve ter suficiente trabalho agradavelmente paralelo para deslocar a sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="8212b-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="8212b-117">O trabalho pode ser expresso como o custo computacional de cada representante multiplicado pelo número de elementos na coleção de origem.</span><span class="sxs-lookup"><span data-stu-id="8212b-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="8212b-118">Supondo que uma operação pode ser colocado em paralelo, computacionalmente mais caro é, maior a possibilidade de aumento de velocidade.</span><span class="sxs-lookup"><span data-stu-id="8212b-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="8212b-119">Por exemplo, se uma função usa um milissegundo para executar, uma consulta sequencial em 1000 elementos levará um segundo para executar essa operação, enquanto um paralelo de consulta em um computador com quatro núcleos pode levar apenas 250 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="8212b-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="8212b-120">Isso resulta em um aumento de velocidade de 750 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="8212b-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="8212b-121">Se a função necessário um segundo a ser executada para cada elemento, o aumento de velocidade seria 750 segundos.</span><span class="sxs-lookup"><span data-stu-id="8212b-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="8212b-122">Se o representante é muito dispendioso, PLINQ pode oferecer um aumento de velocidade significativo com apenas alguns itens na coleção de origem.</span><span class="sxs-lookup"><span data-stu-id="8212b-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="8212b-123">Por outro lado, coleções de origem pequeno com delegados triviais geralmente não são bons candidatos para PLINQ.</span><span class="sxs-lookup"><span data-stu-id="8212b-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="8212b-124">No exemplo a seguir, queryA provavelmente é uma boa candidata para PLINQ, supondo que sua função Select envolve uma grande parte do trabalho.</span><span class="sxs-lookup"><span data-stu-id="8212b-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="8212b-125">queryB provavelmente não é um bom candidato porque não há suficiente trabalho na instrução Select, e a sobrecarga de paralelização serão deslocadas a maior parte ou todo o aumento de velocidade.</span><span class="sxs-lookup"><span data-stu-id="8212b-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="8212b-126">O número de núcleos lógicos no sistema (grau de paralelismo).</span><span class="sxs-lookup"><span data-stu-id="8212b-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="8212b-127">Esse ponto é um resultado óbvio para a seção anterior, consultas paralelas agradavelmente executadas mais rapidamente em computadores com mais núcleos porque o trabalho pode ser dividido entre mais threads simultâneos.</span><span class="sxs-lookup"><span data-stu-id="8212b-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="8212b-128">A quantidade geral de aumento de velocidade depende de qual porcentagem do trabalho geral da consulta é paralelizável.</span><span class="sxs-lookup"><span data-stu-id="8212b-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="8212b-129">No entanto, não presuma que todas as consultas serão executado duas vezes mais rápida em um computador com oito núcleos como um computador de quatro núcleos.</span><span class="sxs-lookup"><span data-stu-id="8212b-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="8212b-130">Quando o ajuste de consultas para otimizar o desempenho, é importante medir os resultados reais em computadores com vários números de núcleos.</span><span class="sxs-lookup"><span data-stu-id="8212b-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="8212b-131">Esse ponto está relacionado ao ponto #1: grandes conjuntos de dados são necessários para tirar proveito dos recursos de computação maiores.</span><span class="sxs-lookup"><span data-stu-id="8212b-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="8212b-132">O número e tipo de operações.</span><span class="sxs-lookup"><span data-stu-id="8212b-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="8212b-133">PLINQ fornece o operador AsOrdered para situações em que é necessário para manter a ordem dos elementos na sequência de origem.</span><span class="sxs-lookup"><span data-stu-id="8212b-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="8212b-134">Há um custo associado com a ordenação, mas esse custo é geralmente pequena.</span><span class="sxs-lookup"><span data-stu-id="8212b-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="8212b-135">Da mesma forma, operações de GroupBy e Join causar sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="8212b-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="8212b-136">PLINQ funciona melhor quando é permitido para processar os elementos na coleção de origem em qualquer ordem e passá-las para o próximo operador assim que estiverem prontas.</span><span class="sxs-lookup"><span data-stu-id="8212b-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="8212b-137">Para saber mais, veja [Preservação da ordem em PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="8212b-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="8212b-138">O formulário da execução da consulta.</span><span class="sxs-lookup"><span data-stu-id="8212b-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="8212b-139">Se você estiver armazenando os resultados de uma consulta chamando ToArray ou ToList, os resultados de todos os threads paralelos devem ser mesclados na estrutura de dados único.</span><span class="sxs-lookup"><span data-stu-id="8212b-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="8212b-140">Isso envolve um custo computacional inevitável.</span><span class="sxs-lookup"><span data-stu-id="8212b-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="8212b-141">Da mesma forma, se você iterar os resultados usando um loop foreach (para cada um no Visual Basic), os resultados de threads de trabalho precisam ser serializados para o thread de enumerador.</span><span class="sxs-lookup"><span data-stu-id="8212b-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="8212b-142">Mas se você quiser executar alguma ação com base no resultado de cada thread, você pode usar o método ForAll para executar esse trabalho em vários threads.</span><span class="sxs-lookup"><span data-stu-id="8212b-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="8212b-143">O tipo de opções de mesclagem.</span><span class="sxs-lookup"><span data-stu-id="8212b-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="8212b-144">PLINQ pode ser configurado para o buffer de saída e produzi-las em partes ou todos de uma vez, depois que o conjunto de resultados inteiro é produzido, ou se encontram aos resultados individuais de fluxo como eles são produzidos.</span><span class="sxs-lookup"><span data-stu-id="8212b-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="8212b-145">O primeiro resultado é o menor tempo de execução geral e a último resulta em menor latência entre elementos gerou.</span><span class="sxs-lookup"><span data-stu-id="8212b-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="8212b-146">Enquanto as opções de mesclagem nem sempre têm um grande impacto no desempenho geral da consulta, elas podem afetar o desempenho percebido porque eles controlam quanto tempo um usuário deve aguardar para ver os resultados.</span><span class="sxs-lookup"><span data-stu-id="8212b-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="8212b-147">Para saber mais, veja [Opções de mesclagem em PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="8212b-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="8212b-148">O tipo de particionamento.</span><span class="sxs-lookup"><span data-stu-id="8212b-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="8212b-149">Em alguns casos, uma consulta PLINQ em uma coleção de origem indexável pode resultar em uma carga de trabalho desbalanceada.</span><span class="sxs-lookup"><span data-stu-id="8212b-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="8212b-150">Quando isso ocorrer, você poderá aumentar o desempenho da consulta ao criar um particionador personalizado.</span><span class="sxs-lookup"><span data-stu-id="8212b-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="8212b-151">Para saber mais, veja [Particionadores personalizados para PLINQ e TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="8212b-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="8212b-152">Quando o PLINQ escolhe modo sequencial</span><span class="sxs-lookup"><span data-stu-id="8212b-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="8212b-153">PLINQ sempre tenta executar uma consulta de pelo menos tão rápida como a consulta executaria sequencialmente.</span><span class="sxs-lookup"><span data-stu-id="8212b-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="8212b-154">Embora PLINQ não examinar como computacionalmente caras de representantes de usuário são ou grande como a fonte de entrada é, ele parecerá para determinada consulta "formas".</span><span class="sxs-lookup"><span data-stu-id="8212b-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="8212b-155">Especificamente, ele procura por operadores de consulta ou combinações de operadores que causam normalmente uma consulta para executar mais lentamente no modo paralelo.</span><span class="sxs-lookup"><span data-stu-id="8212b-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="8212b-156">Quando encontra essas formas, PLINQ por padrão reverterá ao modo sequencial.</span><span class="sxs-lookup"><span data-stu-id="8212b-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="8212b-157">No entanto, após a medir o desempenho de consulta específico, você pode determinar que ele é realmente executado mais rapidamente no modo paralelo.</span><span class="sxs-lookup"><span data-stu-id="8212b-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="8212b-158">Nesses casos, você pode usar o <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> sinalizador por meio de <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> método para instruir o PLINQ para paralelizar a consulta.</span><span class="sxs-lookup"><span data-stu-id="8212b-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="8212b-159">Para saber mais, veja [Como especificar o modo de execução em PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="8212b-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="8212b-160">A lista a seguir descreve as formas de consulta PLINQ por padrão será executado em modo sequencial:</span><span class="sxs-lookup"><span data-stu-id="8212b-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="8212b-161">Consultas que contêm um Select, Where, indexada SelectMany indexada, ou cláusula de ElementAt após um operador de classificação ou filtragem removidos ou reorganizados índices originais.</span><span class="sxs-lookup"><span data-stu-id="8212b-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="8212b-162">Consultas que contêm um salto Take, TakeWhile, operador SkipWhile e onde índices na sequência de origem não estão na ordem original.</span><span class="sxs-lookup"><span data-stu-id="8212b-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="8212b-163">As consultas que contêm Zip ou SequenceEquals, a menos que uma das fontes de dados tem um índice solicitado originalmente e fonte de dados é indexável (ou seja, uma matriz ou IList(T)).</span><span class="sxs-lookup"><span data-stu-id="8212b-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="8212b-164">Consultas que contêm Concat, a menos que ela é aplicada a fontes de dados indexáveis.</span><span class="sxs-lookup"><span data-stu-id="8212b-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="8212b-165">Consultas que contêm inversa, a menos que aplicado a uma fonte de dados indexáveis.</span><span class="sxs-lookup"><span data-stu-id="8212b-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8212b-166">Consulte também</span><span class="sxs-lookup"><span data-stu-id="8212b-166">See Also</span></span>  
 [<span data-ttu-id="8212b-167">PLINQ (LINQ paralelo)</span><span class="sxs-lookup"><span data-stu-id="8212b-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
