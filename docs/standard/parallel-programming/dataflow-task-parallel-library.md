---
title: Fluxo de dados (Task Parallel Library)
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: "22"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 73933c5f171881b5b3a2479aabdb26d1abd58cfc
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="dataflow-task-parallel-library"></a>Fluxo de dados (Task Parallel Library)
<a name="top"></a> A TPL (biblioteca de paralelismo de tarefas) fornece componentes de fluxo de dados para ajudar a aumentar a robustez de aplicativos habilitados para simultaneidade. Esses componentes de fluxo de dados são coletivamente chamados de *biblioteca de fluxos de dados TPL*. Esse modelo de fluxo de dados promove programação baseada em ator que fornece transmissão de mensagem no processo para fluxo de dados de alta granularidade e tarefas de pipelining. Os componentes de fluxo de dados usam como base os tipos e infraestrutura de programação da TPL e integram-se ao suporte às linguagens C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)] e F# para programação assíncrona. Esses componentes do fluxo de dados são úteis quando você tem várias operações que devem se comunicar umas com as outras de modo assíncrono ou quando você deseja processar dados à medida que são disponibilizados. Por exemplo, considere um aplicativo que processa dados de imagem de uma webcam. Usando o modelo de fluxo de dados, o aplicativo pode processar quadros de imagem assim que eles se tornarem disponíveis. Se o aplicativo aprimora os quadros de imagem, por exemplo, executando a redução de olhos vermelhos ou correção de luz, você pode criar um *pipeline* dos componentes de fluxo de dados. Cada estágio do pipeline pode usar mais funcionalidade de paralelismo de alta granularidade, assim como a funcionalidade fornecida pela TPL, para transformar a imagem.  
  
 Este documento fornece uma visão geral da biblioteca de fluxos de dados TPL. Ele descreve o modelo de programação, os tipos de blocos de fluxo de dados predefinidos e como configurar os blocos de fluxo de dados para atender os requisitos específicos de seus aplicativos.  
  
> [!TIP]
>  A biblioteca de fluxo de dados TPL (<xref:System.Threading.Tasks.Dataflow?displayProperty=nameWithType> namespace) não é distribuído com o [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Para instalar o <xref:System.Threading.Tasks.Dataflow> namespace, abra seu projeto no [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], escolha **gerenciar pacotes NuGet** no menu projeto e pesquise online o `Microsoft.Tpl.Dataflow` pacote.  
  
 Este documento contém as seguintes seções:  
  
-   [Modelo de programação](#model)  
  
-   [Tipos de bloco de fluxo de dados predefinidos](#predefined_types)  
  
-   [Configurar o comportamento de bloco de fluxo de dados](#behavior)  
  
-   [Blocos de fluxo de dados personalizados](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Modelo de Programação  
 A biblioteca de fluxos de dados TPL fornece uma base para a transmissão de mensagens e a paralelização de aplicativos com uso intensivo de CPU e de E/S que têm alta taxa de transferência e baixa latência. Ela também fornece controle explícito sobre como os dados são armazenados em buffer e se movem pelo sistema. Para entender melhor o modelo de programação de fluxo de dados, considere um aplicativo que carrega imagens do disco de forma assíncrona e cria uma composição dessas imagens. Modelos de programação tradicionais normalmente exigem que você use retornos de chamada e objetos de sincronização, tais como bloqueios, para coordenar tarefas e acesso a dados compartilhados. Usando o modelo de programação de fluxo de dados, você pode criar objetos de fluxo de dados que processam imagens conforme elas são lidas do disco. No modelo de fluxo de dados, você declara como os dados serão manipulados quando se tornarem disponíveis e também quaisquer eventuais dependências entre os dados. Já que o tempo de execução gerencia as dependências entre os dados, muitas vezes você pode evitar a necessidade de sincronizar o acesso aos dados compartilhados. Além disso, já que o tempo de execução agenda o trabalho com base na chegada assíncrona de dados, o fluxo de dados pode aumentar a capacidade de resposta e a taxa de transferência ao gerenciar com eficiência os threads subjacentes. Para obter um exemplo que usa o modelo de programação de fluxo de dados para implementar o processamento de imagens em um aplicativo Windows Forms, consulte [Passo a passo: usando um fluxo de dados em um Aplicativo do Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Origens e Destinos  
 A biblioteca de fluxos de dados TPL consiste em *blocos de fluxo de dados*, que são estruturas de dados que armazenam dados em buffer e os processam. A TPL define três tipos de blocos de fluxo de dados: *blocos de origem*, *blocos de destino* e *blocos propagadores*. Um bloco de origem atua como uma fonte de dados e possibilita a leitura de dados presentes nele. Um bloco de destino atua como um receptor de dados e possibilita que nele sejam gravados dados. Um bloco propagador atua como um bloco de origem e um bloco de destino e possibilita tanto leitura quanto gravação. Define a TPL o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interface para representar fontes, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> representar destinos, e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> representar propagadores. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>herda de ambos <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, e <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 A biblioteca de fluxo de dados TPL fornece vários tipos de bloco de fluxo de dados predefinidos que implementam o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces. Esses tipos de bloco de fluxo de dados são descritos neste documento na seção [Tipos de bloco de fluxo de dados predefinidos](#predefined_types).  
  
### <a name="connecting-blocks"></a>Conectar blocos  
 Você pode conectar blocos de fluxo de dados para formar *pipelines*, que são sequências lineares de blocos de fluxo de dados, ou então *redes*, que são gráficos de blocos de fluxo de dados. Um pipeline é uma forma de rede. Em uma rede ou pipeline, origens propagam dados assincronamente para destinos assim que os dados ficam disponíveis. O <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> método vincula um bloco de fluxo de dados de origem para um bloco de destino. Uma origem pode ser vinculada a zero ou mais destinos, enquanto os destinos podem ser vinculados de zero ou mais origens. Você pode adicionar ou remover blocos de fluxo de dados para ou de um pipeline ou rede simultaneamente. Os tipos de bloco de fluxo de dados predefinidos tratam de todos os aspectos de acesso thread-safe de vincular e desvincular.  
  
 Para obter um exemplo que conecta os blocos de fluxo de dados para formar um pipeline básico, consulte [Passo a passo: criando um pipeline de fluxo de dados](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Para obter um exemplo que conecta os blocos de fluxo de dados para formar uma rede mais complexa, consulte [Passo a passo: usando o fluxo de dados em um Aplicativo do Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Para obter um exemplo que desvincula um destino de uma origem depois que a origem oferece uma mensagem ao destino, consulte [Como desvincular blocos de fluxo de dados](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtragem  
 Quando você chama o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> método para vincular a uma fonte para um destino, você pode fornecer um representante que determina se o bloco de destino aceita ou rejeita uma mensagem com base no valor da mensagem. Esse mecanismo de filtragem é uma maneira útil para garantir que um bloco de fluxo de dados receba apenas determinados valores. Para a maioria dos tipos de bloco de fluxo de dados predefinidos, se um bloco de origem estiver conectado a vários blocos de destino, quando um bloco de destino rejeitar uma mensagem, a origem oferecerá essa mensagem para o próximo destino. A ordem em que uma origem oferece mensagens para destinos é definida pela origem e pode variar de acordo com o tipo da origem. A maioria dos tipos de blocos de origem para de oferecer uma mensagem depois que um destino aceita essa mensagem. Uma exceção a essa regra é o <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe, que oferece a cada mensagem para todos os destinos, mesmo se alguns destinos rejeitar a mensagem. Para obter um exemplo que usa a filtragem para processar apenas mensagens específicas, consulte [Passo a passo: usando o fluxo de dados em um Aplicativo do Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Já que cada tipo de bloco de fluxo de dados de origem predefinido garante que as mensagens sejam propagadas na ordem em que são recebidas, toda mensagem deve ser lida do bloco de origem antes que o bloco de origem possa processar a próxima mensagem. Portanto, quando você usa a filtragem para conectar vários destinos a uma origem, certifique-se de que pelo menos um bloco de destino receba cada mensagem. Caso contrário, seu aplicativo poderá sofrer deadlock.  
  
### <a name="message-passing"></a>Transmissão de mensagens  
 O modelo de programação de fluxo de dados está relacionado ao conceito de *transmissão de mensagens*, em que componentes independentes de um programa se comunicam uns com os outros pelo envio de mensagens. Uma maneira para propagar as mensagens entre componentes de aplicativos é chamar o <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> métodos para enviar mensagens a postagem de blocos de fluxo de dados de destino (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> age de forma síncrona; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> age de forma assíncrona) e o <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> métodos para receber mensagens de blocos de código-fonte. Você pode combinar esses métodos com redes ou pipelines de fluxo de dados por meio do envio de dados de entrada para o nó de cabeçalho (um bloco de destino) e receber dados de saída do nó terminal do pipeline ou nós terminais da rede (um ou mais blocos de origem). Você também pode usar o <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> método de leitura da primeira das fontes de fornecido que tem dados disponíveis e executar ação nos dados.  
  
 Blocos de código-fonte oferecem dados ao blocos de destino chamando o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> método. O bloco de destino responde a uma mensagem oferecida em uma destas três maneiras: ele pode aceitar a mensagem, recusá-la ou adiá-la. Quando o destino aceita a mensagem, o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> método retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Quando o destino recusa a mensagem, o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> método retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Quando o destino exige que não recebe as mensagens da origem, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retorna <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Os tipos de bloco de origem predefinidos não oferecem mensagens para destinos vinculados após o recebimento desse valor retornado e eles se desvinculam automaticamente desses destinos.  
  
 Quando um bloco de destino adia a mensagem para uso posterior, o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> método retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Um bloco de destino que adia uma mensagem pode chamadas posteriores a <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> método para tentar reservar a mensagem oferecida. Neste ponto, é possível que a mensagem ainda esteja disponível e possa ser usada pelo bloco de destino ou então que a mensagem tenha sido tomada por outro destino. Quando o bloco de destino requer que a mensagem mais tarde ou não precisa mais a mensagem, ele chama o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> método, respectivamente. Reserva de mensagem normalmente é usada pelos tipos de bloco de fluxo de dados que operam em modo não greedy. O modo não greedy é explicado mais adiante neste documento. Em vez de reservar uma mensagem adiada, um bloco de destino também pode usar o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> método para tentar consumir diretamente a mensagem adiada.  
  
### <a name="dataflow-block-completion"></a>Conclusão do bloco de fluxo de dados  
 Blocos de fluxo de dados também dão suporte ao conceito de *conclusão*. Um bloco de fluxo de dados que está no estado concluído não executa nenhum trabalho adicional. Cada bloco de fluxo de dados possui um tipo de <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objeto, conhecido como um *tarefa conclusão*, que representa o status de conclusão do bloco. Como você pode esperar um <xref:System.Threading.Tasks.Task> de objeto para concluir, usando as tarefas de conclusão, você pode esperar por um ou mais nós terminais de um fluxo de dados de rede para concluir. O <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface define o <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> método, que informa o bloco de fluxo de dados de uma solicitação para que ela seja concluída, e o <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriedade, que retorna a tarefa de conclusão para o bloco de fluxo de dados. Ambos <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> e <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> herdam o <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface.  
  
 Há duas maneiras de determinar se um bloco de fluxo de dados foi concluído sem erros, encontrou um ou mais erros ou foi cancelado. O primeiro modo é chamar o <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método na tarefa de conclusão em um `try` - `catch` bloco (`Try` - `Catch` no Visual Basic). O exemplo a seguir cria um <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto que gera <xref:System.ArgumentOutOfRangeException> se o valor de entrada é menor que zero. <xref:System.AggregateException>é gerada quando este exemplo chama <xref:System.Threading.Tasks.Task.Wait%2A> na tarefa de conclusão. O <xref:System.ArgumentOutOfRangeException> é acessada por meio de <xref:System.AggregateException.InnerExceptions%2A> propriedade do <xref:System.AggregateException> objeto.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 Este exemplo demonstra o caso em que uma exceção fica sem tratamento no delegado de um bloco de fluxo de dados de execução. É recomendável que você trate exceções nos corpos de tais blocos. No entanto, se não for possível fazer isso, o bloco se comportará como se tivesse sido cancelado e não processará mensagens de entrada.  
  
 Quando um bloco de fluxo de dados é cancelado explicitamente, o <xref:System.AggregateException> objeto contém <xref:System.OperationCanceledException> no <xref:System.AggregateException.InnerExceptions%2A> propriedade. Para obter mais informações sobre o cancelamento de fluxo de dados, consulte Habilitando o cancelamento, posteriormente neste documento.  
  
 A segunda maneira de determinar o status de conclusão de um bloco de fluxo de dados é usar uma continuação fora da tarefa de conclusão ou então usar os recursos de linguagem assíncrona do C# e Visual Basic para aguardar de modo assíncrono a tarefa de conclusão. O representante que você fornecer para o <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> leva um <xref:System.Threading.Tasks.Task> objeto que representa a tarefa antecedente. No caso do <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriedade, o representante para a continuação tem a tarefa de conclusão em si. O exemplo a seguir assemelha-se à anterior, exceto que ele também usa o <xref:System.Threading.Tasks.Task.ContinueWith%2A> método para criar uma tarefa de conclusão que imprime o status da operação de fluxo de dados geral.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Você também pode usar propriedades como <xref:System.Threading.Tasks.Task.IsCanceled%2A> no corpo da tarefa de continuação para determinar informações adicionais sobre o status de conclusão de um bloco de fluxo de dados. Para obter mais informações sobre tarefas de continuação e como elas se relacionam com cancelamento e tratamento de erro, consulte [Encadeamento de tarefas pelo uso de tarefas de continuação](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Cancelamento de tarefas](../../../docs/standard/parallel-programming/task-cancellation.md), [Tratamento de exceções](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) e [NIB: como manipular exceções lançadas por tarefas](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[ir para o topo](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Tipos de bloco de fluxo de dados predefinidos  
 A biblioteca de fluxos de dados TPL fornece vários tipos de bloco de fluxo de dados predefinidos. Esses tipos são divididos em três categorias: *blocos de buffer*, *blocos de execução* e *blocos de agrupamento*. As seções a seguir descrevem os tipos de bloco que compõem essas categorias.  
  
### <a name="buffering-blocks"></a>Blocos de buffer  
 Blocos de buffer armazenam dados para uso pelos consumidores de dados. A biblioteca de fluxo de dados TPL fornece três tipos de bloco de buffer: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, e <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 O <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> classe representa uma estrutura de mensagens assíncrona para fins gerais. Essa classe armazena uma fila PEPS (primeiro a entrar, primeiro a sair) de mensagens que podem ser gravadas por várias origens ou lidas por vários destinos. Quando um destino recebe uma mensagem de um <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> de objeto, essa mensagem é removida da fila de mensagens. Portanto, embora um <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objeto pode ter vários destinos, cada mensagem será exibida apenas um destino. O <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> classe é útil quando você deseja passar várias mensagens para outro componente, e esse componente deve receber a cada mensagem.  
  
 O exemplo a seguir básico envia vários <xref:System.Int32> valores para um <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> do objeto e, em seguida, lê os valores do objeto.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Para obter um exemplo completo que demonstra como gravar mensagens e ler mensagens de uma <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> de objeto, consulte [como: escrever mensagens para e leitura de um Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 O <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe é útil quando você deve passar várias mensagens para outro componente, mas esse componente precisa apenas o valor mais recente. Essa classe também é útil quando você deseja difundir uma mensagem para vários componentes.  
  
 As postagens de exemplo básico a seguir um <xref:System.Double> valor para um <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objeto e, em seguida, leituras de fazer o valor do objeto várias vezes. Porque valores não são removidos do <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objetos depois que eles são lidos, o mesmo valor está disponível sempre.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Para obter um exemplo completo que demonstra como usar <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> para difundir uma mensagem para vários blocos de destino, consulte [como: especificar um agendador de tarefas em um Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 O <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> é semelhante a <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe, exceto que um <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto pode ser gravado apenas uma vez. Você pode pensar <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> como sendo similares do c# [readonly](~/docs/csharp/language-reference/keywords/readonly.md) ([ReadOnly](~/docs/visual-basic/language-reference/modifiers/readonly.md) na [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) palavra-chave, exceto que um <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto se torna imutável depois de receber um valor em vez de em construção. Como o <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe, quando um destino recebe uma mensagem de um <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> de objeto, essa mensagem não é removida do objeto. Portanto, vários destinos recebem uma cópia da mensagem. O <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> classe é útil quando você deseja propagar apenas a primeira de várias mensagens.  
  
 O exemplo a seguir básico envia vários <xref:System.String> valores para um <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto e, em seguida, leituras de volta o valor do objeto. Porque um <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto pode ser gravado em uma vez somente após um <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto recebe uma mensagem, descarta mensagens subsequentes.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Para obter um exemplo completo que demonstra como usar <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> para receber o valor da primeira operação que termina, consulte [como: desvincular blocos de fluxo de dados](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blocos de execução  
 Blocos de execução chamam um delegado fornecido pelo usuário para cada parte dos dados recebidos. A biblioteca de fluxo de dados TPL fornece três tipos de bloco de execução: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 O <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> classe é um bloco de destino que chama um delegado ao receber dados. Imagine um <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto como um delegado que executa de forma assíncrona quando os dados ficarão disponíveis. O representante que você fornecer para um <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto pode ser do tipo <xref:System.Action> ou tipo `System.Func\<TInput, Task>`. Quando você usa um <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> do objeto com <xref:System.Action>, processamento de cada elemento de entrada é considerado concluída quando o delegado retorna. Quando você usa um <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> do objeto com `System.Func\<TInput, Task>`, processamento de cada elemento de entrada é considerado concluído somente quando retornado <xref:System.Threading.Tasks.Task> objeto é concluído. Usando esses dois mecanismos, você pode usar <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> para processamento síncrono e assíncrono de cada elemento de entrada.  
  
 O exemplo a seguir básico envia vários <xref:System.Int32> valores para um <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto. O <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto imprime esses valores para o console. Este exemplo, em seguida, define o bloco para o estado concluído e aguarda que todas as tarefas de fluxo de dados sejam concluídas.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Para concluir exemplos que demonstram como usar representantes com o <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> de classe, consulte [como: executar ação quando um fluxo de dados recebe dados do bloco de](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 O <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> é semelhante a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> classe, exceto que ele atue como ambos os uma fonte e como um destino. O representante que você passa para um <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto retorna um valor do tipo `TOutput`. O representante que você fornecer para um <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto pode ser do tipo `System.Func<TInput, TOutput>` ou tipo `System.Func<TInput, Task>`. Quando você usa um <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> do objeto com `System.Func\<TInput, TOutput>`, processamento de cada elemento de entrada é considerado concluída quando o delegado retorna. Quando você usa um <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto usado com `System.Func<TInput, Task<TOutput>>`, processamento de cada elemento de entrada é considerado concluído somente quando retornado <xref:System.Threading.Tasks.Task> objeto é concluído. Assim como acontece com <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, usando esses dois mecanismos, você pode usar <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> para processamento síncrono e assíncrono de cada elemento de entrada.  
  
 O exemplo básico a seguir cria um <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto que calcula a raiz quadrada de sua entrada. O <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto usa <xref:System.Int32> valores como entrada e produz <xref:System.Double> valores de saída.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Para obter exemplos de conclusão que usa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> em uma rede de blocos de fluxo de dados que executa o processamento de imagem em um aplicativo de formulários do Windows, consulte [passo a passo: usando o fluxo de dados em um aplicativo do Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 O <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> é semelhante a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> classe, exceto que <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produz zero ou mais valores de saída para cada valor de entrada, em vez de apenas um valor para cada valor de entrada de saída. O representante que você fornecer para um <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto pode ser do tipo `System.Func<TInput, IEnumerable<TOutput>>` ou `type System.Func<TInput, Task<IEnumerable<TOutput>>>`. Quando você usa um <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> do objeto com `System.Func<TInput, IEnumerable<TOutput>>`, processamento de cada elemento de entrada é considerado concluída quando o delegado retorna. Quando você usa um <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> do objeto com `System.Func<TInput, Task<IEnumerable<TOutput>>>`, processamento de cada elemento de entrada é considerado concluído somente quando retornado `System.Threading.Tasks.Task<IEnumerable<TOutput>>` objeto é concluído.  
  
 O exemplo básico a seguir cria um <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto que divide cadeias de caracteres em suas sequências de caracteres individuais. O <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto usa <xref:System.String> valores como entrada e produz <xref:System.Char> valores de saída.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Para obter exemplos de conclusão que usam <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> para produzir várias saídas independentes para cada entrada em um pipeline de fluxo de dados, consulte [passo a passo: Criando um Pipeline de fluxo de dados](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Grau de Paralelismo  
 Cada <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> mensagens de entrada de buffers do objeto até que o bloco está pronto para processá-las. Por padrão, essas classes processam mensagens na ordem em que elas são recebidas, uma mensagem por vez. Você também pode especificar o grau de paralelismo para habilitar <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objetos a processar várias mensagens simultaneamente. Para obter mais informações sobre a execução simultânea, consulte a seção Especificando o grau de paralelismo, presente neste documento. Para obter um exemplo que define o grau de paralelismo para habilitar um bloco de fluxo de dados de execução a processar mais de uma mensagem por vez, consulte [Como especificar o grau de paralelismo em um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Resumo de tipos de delegados  
 A tabela a seguir resume os tipos de delegado que você pode fornecer a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objetos. Esta tabela também especifica se o tipo de delegado opera de forma síncrona ou assíncrona.  
  
|Tipo|Tipo de delegado síncrono|Tipo de delegado assíncrono|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Você também pode usar expressões lambda ao trabalhar com tipos de blocos de execução. Para obter um exemplo que mostra como usar uma expressão lambda com um bloco de execução, consulte [Como executar ações quando um bloco de fluxo de dados recebe dados](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Blocos de agrupamento  
 Blocos de agrupamento combinam dados de uma ou mais origens e sob várias restrições. A biblioteca de fluxo de dados TPL fornece três tipos de bloco de junção: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 O <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe combina os conjuntos de dados de entrada, que são conhecidos como lotes, em conjuntos de dados de saída. Especifique o tamanho de cada lote quando você cria um <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto. Quando o <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto recebe a contagem especificada dos elementos de entrada, ele propaga assincronamente saída uma matriz que contém esses elementos. Se um <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto é definido como o estado concluído, mas não contém elementos suficientes para formar um lote, ele propaga saída uma matriz final que contém os elementos restantes da entrada.  
  
 O <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe opera no modo *greedy* ou *não greedy* modo. No modo greedy, que é o padrão, um <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto aceita todas as mensagens que são oferecido e propaga a uma matriz depois de receber a contagem especificada de elementos. No modo não greedy, um <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto adia todas as mensagens recebidas até suficiente fontes ofereciam mensagens para o bloco para formar um lote. O modo greedy normalmente tem melhor desempenho do que o modo não greedy porque ele requer menos sobrecarga de processamento. No entanto, você pode usar o modo não greedy quando você deve coordenar o consumo de várias origens de maneira atômica. Especifique o modo não greedy definindo <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> para `False` no `dataflowBlockOptions` parâmetro no <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> construtor.  
  
 O exemplo a seguir básico envia vários <xref:System.Int32> valores para um <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto que contém dez elementos em um lote. Para garantir que todos os valores se propaga do <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, este exemplo chama o <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> método. O <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> método define o <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto para o estado concluído e, portanto, o <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto propaga quaisquer elementos restantes como um lote final.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Para obter um exemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> para melhorar a eficiência das operações de inserção do banco de dados, consulte [passo a passo: usando BatchBlock e BatchedJoinBlock para melhorar a eficiência](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 O <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes coletar elementos de entrada e propagadas <xref:System.Tuple%602?displayProperty=nameWithType> ou <xref:System.Tuple%603?displayProperty=nameWithType> objetos que contêm esses elementos. O <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes não herdam a <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Em vez disso, eles fornecem propriedades, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, que implementam <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Como <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operar em modo greedy ou não greedy. No modo greedy, que é o padrão, um <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto aceita todas as mensagens que são oferecido e propaga a uma tupla depois que cada um de seus destinos recebe pelo menos uma mensagem. No modo não greedy, um <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto adia todas as mensagens recebidas até que todos os destinos tem sido oferecidos os dados que são necessários para criar uma coleção de itens. Neste ponto, o bloco se envolve em um protocolo 2PC para recuperar atomicamente todos os itens obrigatórios das origens. Este adiamento possibilita que outra entidade consuma os dados e, enquanto isso, permite que o sistema em geral avance.  
  
 O exemplo básico a seguir demonstra um caso em que um <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto requer vários dados para calcular um valor. Este exemplo cria um <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto que requer dois <xref:System.Int32> valores e um <xref:System.Char> valor para executar uma operação aritmética.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Para obter um exemplo completo que usa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objetos no modo não greedy de forma cooperativa compartilhar um recurso, consulte [como: usar JoinBlock para ler dados de várias fontes](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 O <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes coletar lotes dos elementos de entrada e propagadas `System.Tuple(IList(T1), IList(T2))` ou `System.Tuple(IList(T1), IList(T2), IList(T3))` objetos que contêm esses elementos. Pense <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> como uma combinação de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Especifique o tamanho de cada lote quando você cria um <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>fornece propriedades, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, que implementam <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Quando a contagem especificada dos elementos de entrada são recebidas em todos os destinos, o <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto assincronamente propaga um `System.Tuple(IList(T1), IList(T2))` objeto que contém esses elementos.  
  
 O exemplo básico a seguir cria um <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto que contém os resultados, <xref:System.Int32> valores e erros são <xref:System.Exception> objetos. Este exemplo executa várias operações e grava os resultados para o <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> propriedade e erros para o <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> propriedade, do <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto. Como a contagem de operações bem-sucedidas e com falhas é desconhecida com antecedência, o <xref:System.Collections.Generic.IList%601> objetos habilitar cada destino receber zero ou mais valores.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Para obter um exemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> para capturar os resultados e todas as exceções que ocorrem enquanto o programa lê de um banco de dados, consulte [passo a passo: usando BatchBlock e BatchedJoinBlock para melhorar a eficiência](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
 [[ir para o topo](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Configurar o comportamento de bloco de fluxo de dados  
 Você pode habilitar as opções adicionais, fornecendo um <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> objeto para o construtor de tipos de bloco de fluxo de dados. Essas opções controlam comportamentos como o do agendador que gerencia a tarefa subjacente e o grau de paralelismo. O <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> também tem os tipos que especificam o comportamento que é específico a determinados tipos de bloco de fluxo de dados derivados. A tabela a seguir resume que tipo de opções é associado a cada tipo de bloco de fluxo de dados.  
  
|Tipo de bloco de fluxo de dados|Tipo <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 As seções a seguir fornecem informações adicionais sobre os tipos importantes de fluxo de dados opções de bloco que estão disponíveis por meio de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, e <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> classes.  
  
### <a name="specifying-the-task-scheduler"></a>Especificando o Agendador de Tarefas  
 Cada bloco de fluxo de dados predefinidos usa o mecanismo de agendamento de tarefas TPL para executar atividades como a propagação de dados para um destino, o recebimento de dados de uma origem e a execução de delegados definidos pelo usuário quando os dados tornam-se disponíveis. <xref:System.Threading.Tasks.TaskScheduler>é uma classe abstrata que representa um agendador de tarefas que filas as tarefas em threads. O Agendador de tarefas padrão, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, usa o <xref:System.Threading.ThreadPool> classe fila e executar o trabalho. Você pode substituir o Agendador de tarefas padrão definindo o <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> propriedade ao construir um objeto de bloco de fluxo de dados.  
  
 Quando o mesmo agendador de tarefas gerencia vários blocos de fluxo de dados, ele pode impor políticas entre eles. Por exemplo, se cada vários blocos de fluxo de dados são configurados para direcionar o Agendador exclusivo do mesmo <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> do objeto, todos eles funcionam que é executado entre esses blocos é serializado. Da mesma forma, se esses blocos são configurados para direcionar o Agendador simultâneo do mesmo <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> objeto e que o Agendador está configurado para ter um nível de simultaneidade máximo, todo o trabalho desses blocos é limitado ao número de operações simultâneas. Para obter um exemplo que usa o <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> classe para permitir operações de leitura para ocorrer em paralelo, mas gravar operações ocorrem exclusivamente em vez de todas as outras operações, consulte [como: especificar um agendador de tarefas em um Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Para obter mais informações sobre os agendadores de tarefas na TPL, consulte o <xref:System.Threading.Tasks.TaskScheduler> tópico sobre a classe.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Especificando o grau de paralelismo  
 Por padrão, os tipos de bloco de três execução fornece a biblioteca de fluxo de dados TPL, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, processar uma mensagem por vez. Esses tipos de bloco de fluxo de dados também processam mensagens na ordem em que elas são recebidas. Para habilitar esses blocos de fluxo de dados processar mensagens simultaneamente, defina o <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> propriedade ao construir o objeto de bloco de fluxo de dados.  
  
 O valor padrão de <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> é 1, o que garante que o bloco de fluxo de dados processa uma mensagem por vez. Definir essa propriedade como um valor maior que 1 permite que o bloco de fluxo de dados processe várias mensagens simultaneamente. Definir essa propriedade como <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> permite que o Agendador de tarefas subjacente gerenciar o grau máximo de simultaneidade.  
  
> [!IMPORTANT]
>  Quando você especifica um grau máximo de paralelismo maior do que 1, várias mensagens são processadas simultaneamente e, portanto, as mensagens talvez não sejam processadas na ordem em que são recebidas. A saída das mensagens do bloco, no entanto, ocorrerá na ordem correta.  
  
 Porque o <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propriedade representa o grau máximo de paralelismo, o bloco de fluxo de dados pode executar com um grau de paralelismo menor do que você especificar. O bloco de fluxo de dados pode usar um grau menor de paralelismo para atender aos seus requisitos funcionais ou porque há uma falta de recursos do sistema disponíveis. Um bloco de fluxo de dados nunca escolherá mais paralelismo do que você especificar.  
  
 O valor de <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propriedade é exclusiva para cada objeto de bloco de fluxo de dados. Por exemplo, se cada um de quatro objetos de bloco de fluxo de dados especificar 1 para o grau máximo de paralelismo, todos esses objetos poderão potencialmente ser executados em paralelo.  
  
 Para obter um exemplo que define o grau máximo de paralelismo para permitir que operações demoradas ocorram em paralelo, consulte [Como especificar o grau de paralelismo em um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Especificando o número de mensagens por tarefa  
 Os tipos de bloco de fluxo de dados predefinidos usam tarefas para processar vários elementos de entrada. Isso ajuda a minimizar o número de objetos de tarefa que são necessários para processar dados, o que permite que aplicativos sejam executados com mais eficiência. No entanto, quando as tarefas de um conjunto de blocos de fluxo de dados estão processando dados, talvez seja necessário que as tarefas de outros blocos de fluxo de dados esperem o tempo de processamento colocando mensagens na fila. Para permitir melhor integridade entre tarefas de fluxo de dados, defina o <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> propriedade. Quando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> é definido como <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, que é o padrão, a tarefa usada por um bloco de fluxo de dados processa quantas mensagens que estiverem disponíveis. Quando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> é definida como um valor diferente de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, o bloco de fluxo de dados no máximo processa esse número de mensagens por <xref:System.Threading.Tasks.Task> objeto. Embora a configuração de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> propriedade pode aumentar a igualdade entre tarefas, ele pode causar o sistema para criar mais tarefas que são necessárias, que pode diminuir o desempenho.  
  
### <a name="enabling-cancellation"></a>Habilitando o cancelamento  
 A TPL fornece um mecanismo que permite que as tarefas coordenem o cancelamento de forma cooperativa. Para habilitar os blocos de fluxo de dados participar esse mecanismo de cancelamento, defina o <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> propriedade. Quando isso <xref:System.Threading.CancellationToken> objeto é definido como o estado cancelado, todos os blocos de fluxo de dados que monitora esse token concluir a execução do seu item atual, mas não iniciar o processamento de itens subsequentes. Esses blocos de fluxo de dados também limpam quaisquer mensagens armazenadas em buffer, cancelam as conexões com quaisquer blocos de origem e de destino e fazem a transição para o estado cancelado. Fazendo a transição para o estado cancelado, o <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriedade tem o <xref:System.Threading.Tasks.Task.Status%2A> propriedade definida como <xref:System.Threading.Tasks.TaskStatus.Canceled>, a menos que uma exceção ocorreu durante o processamento. Nesse caso, <xref:System.Threading.Tasks.Task.Status%2A> é definido como <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Para obter um exemplo que demonstra como usar cancelamento em um aplicativo Windows Forms, consulte [Como cancelar um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Para obter mais informações sobre cancelamento na TPL, consulte [Cancelamento da tarefa](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Especificando comportamento greedy versus não greedy  
 Vários tipos de bloco de fluxo de dados de agrupamento podem operar em qualquer um dos modos *greedy* ou *não greedy*. Por padrão, os tipos de bloco de fluxo de dados predefinidos operam em modo greedy.  
  
 Para a junção bloquear tipos como <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, modo greedy significa que o bloco imediatamente aceita dados mesmo se os dados correspondentes com a qual se unir ainda não estão disponíveis. O modo não greedy significa que o bloco adia todas as mensagens de entrada até que uma esteja disponível em cada um de seus destinos para concluir a junção. Se qualquer uma das mensagens adiadas não estiver mais disponível, o bloco de junção liberará todas as mensagens adiadas e reiniciará o processo. Para o <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe greedy e não greedy comportamento é semelhante, exceto que no modo não greedy, um <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto adia todas as mensagens recebidas até suficientes estejam disponíveis de fontes distintos para concluir um lote.  
  
 Para especificar o modo não greedy para um bloco de fluxo de dados, defina <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> para `False`. Para obter um exemplo que demonstra como usar o modo não greedy para habilitar vários blocos de junção compartilhar uma fonte de dados com mais eficiência, consulte [Como usar JoinBlock para ler dados de várias fontes](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[ir para o topo](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Blocos de fluxo de dados personalizados  
 Embora a biblioteca de fluxo de dados TPL forneça muitos tipos de bloco predefinidos, você pode criar tipos de bloco adicionais que tenham um comportamento personalizado. Implementar o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> ou <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces diretamente ou usar o <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> método para criar um bloco complexas que encapsula o comportamento de tipos de bloco existentes. Para obter exemplos que mostram como implementar a funcionalidade de bloco de fluxo de dados personalizado, consulte [Passo a passo: criando um tipo de bloco de fluxo de dados personalizado](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[ir para o topo](#top)]  
  
## <a name="related-topics"></a>Tópicos relacionados  
  
|Título|Descrição|  
|-----------|-----------------|  
|[Como gravar mensagens em um bloco de fluxo de dados e ler mensagens de um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Demonstra como gravar mensagens e ler mensagens de uma <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objeto.|  
|[Como implementar um padrão de fluxo de dados de produtor-consumidor](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Descreve como usar o modelo de fluxo de dados para implementar um padrão de produtor-consumidor, no qual o produtor envia mensagens para um bloco de fluxo de dados e o consumidor lê as mensagens desse bloco.|  
|[Como executar ações quando um bloco de fluxo de dados recebe dados](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Descreve como fornecer delegados para os tipos de bloco de fluxo de dados de execução, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Passo a passo: criando um pipeline de fluxo de dados](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Descreve como criar um pipeline de fluxo de dados que baixa texto da Web e executa operações nesse texto.|  
|[Como desvincular blocos de fluxo de dados](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Demonstra como usar o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> método desvincular um bloco de destino de sua origem depois que a origem oferece uma mensagem para o destino.|  
|[Passo a passo: usando um fluxo de dados em um Aplicativo do Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Demonstra como criar uma rede de blocos de fluxo de dados que executam o processamento de imagens em um Aplicativo do Windows Forms.|  
|[Como cancelar um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Demonstra como usar cancelamento em um Aplicativo do Windows Forms.|  
|[Como usar JoinBlock para ler dados de várias fontes](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explica como usar o <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> classe para executar uma operação quando os dados estão disponíveis de várias fontes e como usar o modo não greedy para habilitar vários blocos de junção compartilhar uma fonte de dados com mais eficiência.|  
|[Como especificar o grau de paralelismo em um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Descreve como definir o <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propriedade para habilitar um bloco de fluxo de dados de execução processar mais de uma mensagem de uma vez.|  
|[Como especificar um agendador de tarefas em um bloco de fluxo de dados](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Demonstra como associar um agendador de tarefas específico quando você usa o fluxo de dados em seu aplicativo.|  
|[Passo a passo: usando BatchBlock e BatchedJoinBlock para aumentar a eficiência](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Descreve como usar o <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe para melhorar a eficiência do banco de dados inserir operações e como usar o <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> classe para capturar os resultados e todas as exceções que ocorrem enquanto o programa lê de um banco de dados.|  
|[Passo a passo: criando um tipo de bloco de fluxo de dados personalizado](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Demonstra duas maneiras de criar um tipo de bloco de fluxo de dados que implementa o comportamento personalizado.|  
|[TPL (Biblioteca de Paralelismo de Tarefas)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Apresenta a TPL, uma biblioteca que simplifica a programação paralela e simultânea em aplicativos [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].|
