---
title: "Tratamento de exceções (biblioteca de tarefas paralelas)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 86b4d105b7d79abbd25b342774705866119ada68
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/23/2017
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="f2dc6-102">Tratamento de exceções (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="f2dc6-102">Exception Handling (Task Parallel Library)</span></span>
<span data-ttu-id="f2dc6-103">As exceções sem tratamento que são lançadas pelo código de usuário que está sendo executado dentro de uma tarefa são propagadas de volta para o thread de chamada, exceto em certos cenários que são descritos mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-103">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="f2dc6-104">As exceções são propagadas quando você usa um dos métodos estáticos ou de instância de <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ou <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait`, e você lida com eles ao incluir a chamada em uma instrução `try` / `catch`.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-104">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="f2dc6-105">Se uma tarefa é o pai das tarefas filho anexadas, ou se você está esperando várias tarefas, várias exceções podem ser lançadas.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-105">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>  
  
 <span data-ttu-id="f2dc6-106">Para propagar todas as exceções de volta ao thread de chamada, a infraestrutura da Tarefa envolve-as em uma instância de <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-106">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="f2dc6-107">A exceção <xref:System.AggregateException> tem uma propriedade <xref:System.AggregateException.InnerExceptions%2A> que pode ser enumerada para examinar todas as exceções originais que foram lançadas e manipular (ou não manipular) cada uma individualmente.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-107">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="f2dc6-108">Você também pode manipular as exceções originais usando o método <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-108">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f2dc6-109">Mesmo que apenas uma exceção seja lançada, ela ainda está envolvida em uma exceção <xref:System.AggregateException>, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-109">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
 [!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]  
  
 <span data-ttu-id="f2dc6-110">Você poderia evitar uma exceção sem tratamento apenas pegando o <xref:System.AggregateException> e não observando nenhuma das exceções internas.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-110">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="f2dc6-111">No entanto, recomendamos que você não faça isso, pois é análogo o capturar o tipo base <xref:System.Exception> em cenários não paralelos.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-111">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="f2dc6-112">Capturar uma exceção sem tomar medidas específicas para se recuperar pode deixar seu programa em um estado indeterminado.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-112">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>  
  
 <span data-ttu-id="f2dc6-113">Se você não quiser chamar o método <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ou <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` para aguardar a conclusão de uma tarefa, você também pode recuperar a exceção <xref:System.AggregateException> da propriedade <xref:System.Threading.Tasks.Task.Exception%2A> da tarefa, conforme mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-113">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="f2dc6-114">Para obter mais informações, confira a seção [Observar exceções usando a propriedade Task.Exception](#ExceptionProp) neste tópico.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-114">For more information, see the [Observing Exceptions By Using the Task.Exception Property](#ExceptionProp) section in this topic.</span></span>  
  
 [!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
 [!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]  
  
 <span data-ttu-id="f2dc6-115">Se você não aguardar uma tarefa que propaga uma exceção ou acessar sua propriedade <xref:System.Threading.Tasks.Task.Exception%2A>, a exceção será escalada de acordo com a política de exceção .NET quando a tarefa for coletada como lixo.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-115">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>  
  
 <span data-ttu-id="f2dc6-116">Quando as exceções tiverem permissão de emergirem novamente para o thread de associação, será possível que uma tarefa continue a processar alguns itens após a geração da exceção.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-116">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f2dc6-117">Se a opção "Apenas Meu Código" estiver habilitada, o Visual Studio em alguns casos interromperá na linha que lança a exceção e exibirá uma mensagem de erro que diz "exceção não tratada pelo código do usuário".</span><span class="sxs-lookup"><span data-stu-id="f2dc6-117">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="f2dc6-118">Esse erro é benigno.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-118">This error is benign.</span></span> <span data-ttu-id="f2dc6-119">Você pode pressionar F5 para continuar e ver o comportamento de tratamento de exceção, demonstrado nos exemplos a seguir.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-119">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="f2dc6-120">Para impedir que o Visual Studio seja interrompido no primeiro erro, basta desmarcar a caixa de seleção **Habilitar Apenas Meu Código** em **Ferramentas, Opções, Depuração, Geral**.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-120">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>  
  
## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="f2dc6-121">Tarefas filho anexadas e AggregateExceptions aninhadas</span><span class="sxs-lookup"><span data-stu-id="f2dc6-121">Attached Child Tasks and Nested AggregateExceptions</span></span>  
 <span data-ttu-id="f2dc6-122">Se uma tarefa tiver uma tarefa filho anexada que lança uma exceção, essa exceção é enrolada em um <xref:System.AggregateException> antes de se propagar para a tarefa pai, que envolve essa exceção em sua própria <xref:System.AggregateException> antes de propagá-la de volta ao thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-122">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="f2dc6-123">Nesses casos, a propriedade <xref:System.AggregateException.InnerExceptions%2A> da exceção <xref:System.AggregateException> que é captada nos métodos <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ou <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` ou <xref:System.Threading.Tasks.Task.WaitAny%2A> ou <xref:System.Threading.Tasks.Task.WaitAll%2A> contém uma ou mais instâncias de <xref:System.AggregateException>, e não as exceções originais que causaram a falha.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-123">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` or <xref:System.Threading.Tasks.Task.WaitAny%2A> or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="f2dc6-124">Para evitar ter que iterar sobre exceções aninhadas <xref:System.AggregateException>, você pode usar o método <xref:System.AggregateException.Flatten%2A> para remover todas as exceções aninhadas <xref:System.AggregateException>, de modo que a propriedade <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> contenha as exceções originais.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-124">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="f2dc6-125">No exemplo a seguir, as instâncias de <xref:System.AggregateException> aninhadas são achatadas e manipuladas em apenas um loop.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-125">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>  
  
 [!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
 [!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]  
  
 <span data-ttu-id="f2dc6-126">Você também pode usar o método <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> para relançar as exceções internas de múltiplas instâncias de <xref:System.AggregateException> lançadas por várias tarefas em uma única instância <xref:System.AggregateException>, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-126">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
 [!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]  
  
## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="f2dc6-127">Exceções de tarefas filho desanexadas</span><span class="sxs-lookup"><span data-stu-id="f2dc6-127">Exceptions from Detached Child Tasks</span></span>  
 <span data-ttu-id="f2dc6-128">Por padrão, as tarefas filho são criadas como desanexadas.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-128">By default, child tasks are created as detached.</span></span> <span data-ttu-id="f2dc6-129">As exceções lançadas a partir de tarefas separadas devem ser tratadas ou revogadas na tarefa pai imediata; elas não são propagadas de volta para o tópico de chamada da mesma maneira que as tarefas filho anexadas são propagadas de volta.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-129">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="f2dc6-130">O pai mais alto pode relançar manualmente uma exceção de uma tarefa filho separada para fazer com que ela seja encapsulada em um <xref:System.AggregateException> e propagada de volta para o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-130">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>  
  
 [!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
 [!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]  
  
 <span data-ttu-id="f2dc6-131">Mesmo que você use uma continuação para observar uma exceção em uma tarefa filho, a exceção ainda deve ser observada pela tarefa pai.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-131">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>  
  
## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="f2dc6-132">Exceções que indicam o cancelamento cooperativo</span><span class="sxs-lookup"><span data-stu-id="f2dc6-132">Exceptions That Indicate Cooperative Cancellation</span></span>  
 <span data-ttu-id="f2dc6-133">Quando o código do usuário em uma tarefa responde a uma solicitação de cancelamento, o procedimento correto é lançar um <xref:System.OperationCanceledException> no token de cancelamento no qual a solicitação foi comunicada.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-133">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="f2dc6-134">Antes de tentar propagar a exceção, a instância da tarefa compara o token na exceção ao que foi passado para ela quando foi criada.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-134">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="f2dc6-135">Se eles são iguais, a tarefa propaga um <xref:System.Threading.Tasks.TaskCanceledException> encapsulado no <xref:System.AggregateException>, e pode ser visto quando as exceções internas são examinadas.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-135">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="f2dc6-136">No entanto, se o thread de chamada não estiver aguardando a tarefa, essa exceção específica não será propagada.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-136">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="f2dc6-137">Para obter mais informações, consulte [Cancelamento de tarefas](../../../docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="f2dc6-137">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 [!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
 [!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]  
  
## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="f2dc6-138">Usar o método Handle para filtrar exceções internas</span><span class="sxs-lookup"><span data-stu-id="f2dc6-138">Using the Handle Method to Filter Inner Exceptions</span></span>  
 <span data-ttu-id="f2dc6-139">Você pode usar o método <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> para filtrar exceções que você pode tratar como "manipuladas" sem usar qualquer lógica adicional.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-139">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="f2dc6-140">No delegado de usuário que é fornecido ao método <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType>, você pode examinar o tipo de exceção, sua propriedade <xref:System.Exception.Message%2A> ou qualquer outra informação sobre isso que permitirá determinar se é benigno.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-140">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="f2dc6-141">Quaisquer exceções para as quais o delegado retorna `false` são relançadas em uma nova instância do <xref:System.AggregateException> imediatamente após o retorno do método <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-141">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>  
  
 <span data-ttu-id="f2dc6-142">O exemplo a seguir é funcionalmente equivalente ao primeiro exemplo neste tópico, que examina cada exceção na coleção <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-142">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="f2dc6-143">Em vez disso, esse manipulador de exceção chama o objeto de método <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> para cada exceção, e lança novamente apenas exceções que não são instâncias de `CustomException`.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-143">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>  
  
 [!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
 [!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]  
  
 <span data-ttu-id="f2dc6-144">O seguinte é um exemplo mais completo que usa o método <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> para fornecer tratamento especial para uma exceção <xref:System.UnauthorizedAccessException> ao enumerar arquivos.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-144">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>  
  
 [!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
 [!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]  
  
<a name="ExceptionProp"></a>   
## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="f2dc6-145">Observar exceções usando a propriedade Task.Exception</span><span class="sxs-lookup"><span data-stu-id="f2dc6-145">Observing Exceptions by Using the Task.Exception Property</span></span>  
 <span data-ttu-id="f2dc6-146">Se uma tarefa for concluída no estado <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>, sua propriedade <xref:System.Threading.Tasks.Task.Exception%2A> pode ser examinada para descobrir qual exceção específica causou a falha.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-146">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="f2dc6-147">Uma boa forma de observar a propriedade <xref:System.Threading.Tasks.Task.Exception%2A> é usar uma continuação que seja executada somente se a tarefa anterior falhar, como mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-147">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
 [!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]  
  
 <span data-ttu-id="f2dc6-148">Em um aplicativo real, o delegado de continuação poderia registrar informações detalhadas sobre a exceção e possivelmente gerar novas tarefas para se recuperar da exceção.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-148">In a real application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span>  
  
## <a name="unobservedtaskexception-event"></a><span data-ttu-id="f2dc6-149">Evento UnobservedTaskException</span><span class="sxs-lookup"><span data-stu-id="f2dc6-149">UnobservedTaskException Event</span></span>  
 <span data-ttu-id="f2dc6-150">Em alguns cenários, como ao hospedar plug-ins não confiáveis, exceções benignas podem ser comuns, e pode ser muito difícil observar todas manualmente.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-150">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="f2dc6-151">Nesses casos, você pode lidar com o evento <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-151">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f2dc6-152">A instância do <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> que é passada para seu manipulador pode ser usada para evitar que a exceção não observada seja propagada de volta para o thread de junção.</span><span class="sxs-lookup"><span data-stu-id="f2dc6-152">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f2dc6-153">Consulte também</span><span class="sxs-lookup"><span data-stu-id="f2dc6-153">See Also</span></span>  
 [<span data-ttu-id="f2dc6-154">TPL (Biblioteca de Paralelismo de Tarefas)</span><span class="sxs-lookup"><span data-stu-id="f2dc6-154">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
