---
title: Particionadores personalizados para PLINQ e TPL
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bc409a528dd095d3defb0026a48430b10a3ba6f3
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/23/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="b929c-102">Particionadores personalizados para PLINQ e TPL</span><span class="sxs-lookup"><span data-stu-id="b929c-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="b929c-103">Para paralelizar a uma operação em uma fonte de dados, uma das etapas essenciais é *particionar* a fonte em várias seções que possam ser acessadas simultaneamente por vários threads.</span><span class="sxs-lookup"><span data-stu-id="b929c-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="b929c-104">O PLINQ e a TPL (Biblioteca de Paralelismo de Tarefas) fornecem particionadores padrão que funcionam de forma transparente quando você escreve uma consulta paralela ou um loop <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="b929c-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="b929c-105">Para cenários mais avançados, você pode conectar seu próprio particionador.</span><span class="sxs-lookup"><span data-stu-id="b929c-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="b929c-106">Tipos de particionamento</span><span class="sxs-lookup"><span data-stu-id="b929c-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="b929c-107">Há muitas maneiras de particionar uma fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="b929c-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="b929c-108">Nas abordagens mais eficientes, vários threads cooperam para processar a sequência de origem original, em vez de separar fisicamente a origem em várias subsequências.</span><span class="sxs-lookup"><span data-stu-id="b929c-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="b929c-109">Para matrizes e outras fontes indexadas como coleções <xref:System.Collections.IList> em que o tamanho é conhecido com antecedência, o *particionamento por intervalos* é o tipo mais simples de particionamento.</span><span class="sxs-lookup"><span data-stu-id="b929c-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="b929c-110">Cada thread recebe índices exclusivos de abertura e fechamento, para que possa processar seu intervalo da origem sem substituir ou ser substituído por qualquer outro thread.</span><span class="sxs-lookup"><span data-stu-id="b929c-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="b929c-111">A única sobrecarga envolvida no particionamento por intervalos é o trabalho inicial de criação de intervalos. Nenhuma sincronização adicional é necessária depois disso.</span><span class="sxs-lookup"><span data-stu-id="b929c-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="b929c-112">Portanto, pode fornecer bom desempenho, desde que a carga de trabalho seja dividida igualmente.</span><span class="sxs-lookup"><span data-stu-id="b929c-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="b929c-113">Uma desvantagem do particionamento por intervalos é que se um thread termina cedo, não pode ajudar os outros threads a concluírem seu trabalho.</span><span class="sxs-lookup"><span data-stu-id="b929c-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="b929c-114">Para listas vinculadas ou outras coleções cujo comprimento não é conhecido, você pode usar o *particionamento por partes*.</span><span class="sxs-lookup"><span data-stu-id="b929c-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="b929c-115">Na parte de particionamento, cada thread ou tarefa em uma consulta ou um loop paralelo consome alguns elementos de origem em um bloco, processa-os e volta para recuperar elementos adicionais.</span><span class="sxs-lookup"><span data-stu-id="b929c-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="b929c-116">O particionador garante que todos os elementos sejam distribuídos e que não haja duplicatas.</span><span class="sxs-lookup"><span data-stu-id="b929c-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="b929c-117">Uma parte pode ser de qualquer tamanho.</span><span class="sxs-lookup"><span data-stu-id="b929c-117">A chunk may be any size.</span></span> <span data-ttu-id="b929c-118">Por exemplo, o particionador que é demonstrado em [Como implementar partições dinâmicas](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) cria blocos que contêm apenas um elemento.</span><span class="sxs-lookup"><span data-stu-id="b929c-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="b929c-119">Como as partes não são muito grandes, esse tipo de particionamento é, inerentemente, um balanceamento de carga, pois a atribuição de elementos a threads não é predeterminada.</span><span class="sxs-lookup"><span data-stu-id="b929c-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="b929c-120">No entanto, o particionador causa sobrecarga de sincronização sempre que o thread precisa obter outro bloco.</span><span class="sxs-lookup"><span data-stu-id="b929c-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="b929c-121">A quantidade de sincronização que ocorre nesses casos é inversamente proporcional ao tamanho das partes.</span><span class="sxs-lookup"><span data-stu-id="b929c-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="b929c-122">Em geral, a partição de intervalo só é mais rápida quando o tempo de execução do representante é pequeno a médio e a origem tem um grande número de elementos e o trabalho total de cada partição é aproximadamente equivalente.</span><span class="sxs-lookup"><span data-stu-id="b929c-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="b929c-123">Portanto, o particionamento de bloco geralmente é mais rápido na maioria dos casos.</span><span class="sxs-lookup"><span data-stu-id="b929c-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="b929c-124">Em origens com um pequeno número de elementos ou tempos de execução maiores para o representante, o desempenho de bloco e particionamento por intervalos é mais ou menos igual.</span><span class="sxs-lookup"><span data-stu-id="b929c-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="b929c-125">Os particionadores de TPL também dão suporte a um número dinâmico de partições.</span><span class="sxs-lookup"><span data-stu-id="b929c-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="b929c-126">Isso significa que podem criar partições imediatamente, por exemplo, quando o loop <xref:System.Threading.Tasks.Parallel.ForEach%2A> gera uma nova tarefa.</span><span class="sxs-lookup"><span data-stu-id="b929c-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="b929c-127">Esse recurso permite que o particionador seja dimensionado junto com o próprio loop.</span><span class="sxs-lookup"><span data-stu-id="b929c-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="b929c-128">Os particionadores dinâmicos também realizam, inerentemente, o balanceamento de carga.</span><span class="sxs-lookup"><span data-stu-id="b929c-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="b929c-129">Ao criar um particionador personalizado, você deve dar suporte ao particionamento dinâmico para ser consumível de um loop <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="b929c-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="b929c-130">Configuração de particionadores de balanceamento de carga para PLINQ</span><span class="sxs-lookup"><span data-stu-id="b929c-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="b929c-131">Algumas sobrecargas do método <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> permitem que você crie um particionador para uma matriz ou origem <xref:System.Collections.IList> e especifique se deve tentar equilibrar a carga de trabalho entre os threads.</span><span class="sxs-lookup"><span data-stu-id="b929c-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="b929c-132">Quando o particionador está configurado para balanceamento de carga, o particionamento por partes é usado, e os elementos são enviados para cada partição em pequenas partes conforme são solicitados.</span><span class="sxs-lookup"><span data-stu-id="b929c-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="b929c-133">Essa abordagem ajuda a garantir que todas as partições tenham elementos para processar até que a consulta ou o loop inteiro seja concluído.</span><span class="sxs-lookup"><span data-stu-id="b929c-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="b929c-134">Uma sobrecarga adicional pode ser usada para fornecer particionamento de balanceamento de carga de qualquer origem de <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="b929c-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="b929c-135">Em geral, o balanceamento de carga requer que as partições solicitem elementos relativamente com frequência do particionador.</span><span class="sxs-lookup"><span data-stu-id="b929c-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="b929c-136">Por outro lado, um particionador que faz o particionamento estático pode atribuir os elementos a cada particionador de uma só vez usando o particionamento por intervalos ou bloco.</span><span class="sxs-lookup"><span data-stu-id="b929c-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="b929c-137">Isso requer menos sobrecarga de balanceamento de carga, mas pode levar mais tempo para ser executado se um thread acaba com significativamente mais trabalho do que os outros.</span><span class="sxs-lookup"><span data-stu-id="b929c-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="b929c-138">Por padrão, quando recebe uma IList ou uma matriz, o PLINQ sempre usa o particionamento por intervalos sem balanceamento de carga.</span><span class="sxs-lookup"><span data-stu-id="b929c-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="b929c-139">Para habilitar o balanceamento de carga para o PLINQ, use o método `Partitioner.Create`, conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="b929c-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="b929c-140">A melhor maneira de determinar se é preciso usar o balanceamento de carga em qualquer cenário específico é testar e medir o tempo necessário para concluir operações em cargas representativas e configurações de computador.</span><span class="sxs-lookup"><span data-stu-id="b929c-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="b929c-141">Por exemplo, o particionamento estático pode fornecer um aumento de velocidade significativo em um computador com vários núcleos que tenha apenas alguns núcleos, mas pode resultar em lentidão em computadores que têm relativamente muitos núcleos.</span><span class="sxs-lookup"><span data-stu-id="b929c-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="b929c-142">A tabela a seguir lista as sobrecargas disponíveis do método <xref:System.Collections.Concurrent.Partitioner.Create%2A>.</span><span class="sxs-lookup"><span data-stu-id="b929c-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="b929c-143">Essas particionadores não estão limitados ao uso somente com PLINQ ou <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="b929c-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="b929c-144">Também podem ser usados com qualquer constructo paralelo personalizado.</span><span class="sxs-lookup"><span data-stu-id="b929c-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="b929c-145">Sobrecarga</span><span class="sxs-lookup"><span data-stu-id="b929c-145">Overload</span></span>|<span data-ttu-id="b929c-146">Usa o balanceamento de carga</span><span class="sxs-lookup"><span data-stu-id="b929c-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="b929c-147">Sempre</span><span class="sxs-lookup"><span data-stu-id="b929c-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="b929c-148">Quando o argumento Boolean é especificado como true</span><span class="sxs-lookup"><span data-stu-id="b929c-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="b929c-149">Quando o argumento Boolean é especificado como true</span><span class="sxs-lookup"><span data-stu-id="b929c-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="b929c-150">Nunca</span><span class="sxs-lookup"><span data-stu-id="b929c-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="b929c-151">Nunca</span><span class="sxs-lookup"><span data-stu-id="b929c-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="b929c-152">Nunca</span><span class="sxs-lookup"><span data-stu-id="b929c-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="b929c-153">Nunca</span><span class="sxs-lookup"><span data-stu-id="b929c-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="b929c-154">Configurando particionadores de intervalo estático para Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="b929c-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="b929c-155">Em um loop <xref:System.Threading.Tasks.Parallel.For%2A>, o corpo do loop é fornecido para o método como um representante.</span><span class="sxs-lookup"><span data-stu-id="b929c-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="b929c-156">O custo de invocar esse representante é quase o mesmo que o de uma chamada de método virtual.</span><span class="sxs-lookup"><span data-stu-id="b929c-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="b929c-157">Em alguns cenários, o corpo de um loop paralelo pode ser pequeno o suficiente para que o custo da invocação do representante em cada iteração do loop se torne significativo.</span><span class="sxs-lookup"><span data-stu-id="b929c-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="b929c-158">Nessas situações, você pode usar uma das sobrecargas <xref:System.Collections.Concurrent.Partitioner.Create%2A> para criar um <xref:System.Collections.Generic.IEnumerable%601> de partições de intervalo sobre os elementos de origem.</span><span class="sxs-lookup"><span data-stu-id="b929c-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="b929c-159">Em seguida, você pode passar essa coleção de intervalos para um método <xref:System.Threading.Tasks.Parallel.ForEach%2A> cujo corpo consiste em um loop `for` regular.</span><span class="sxs-lookup"><span data-stu-id="b929c-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="b929c-160">A vantagem dessa abordagem é que o custo de invocação do representante é incorrido apenas uma vez por intervalo, em vez de uma vez por elemento.</span><span class="sxs-lookup"><span data-stu-id="b929c-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="b929c-161">O exemplo a seguir demonstra o padrão básico.</span><span class="sxs-lookup"><span data-stu-id="b929c-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="b929c-162">Cada thread no loop recebe seu próprio <xref:System.Tuple%602>, que contém os valores de índice inicial e final no subintervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="b929c-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="b929c-163">O loop interno `for` usa os valores `fromInclusive` e `toExclusive` para executar um loop sobre a matriz ou o <xref:System.Collections.IList> diretamente.</span><span class="sxs-lookup"><span data-stu-id="b929c-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="b929c-164">Uma das sobrecargas <xref:System.Collections.Concurrent.Partitioner.Create%2A> permite especificar o tamanho de partições e o número delas.</span><span class="sxs-lookup"><span data-stu-id="b929c-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="b929c-165">Essa sobrecarga pode ser usada em cenários em que o trabalho por elemento é tão baixo que até mesmo uma chamada de método virtual por elemento tem impacto significativo sobre o desempenho.</span><span class="sxs-lookup"><span data-stu-id="b929c-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="b929c-166">Particionadores Personalizados</span><span class="sxs-lookup"><span data-stu-id="b929c-166">Custom Partitioners</span></span>  
 <span data-ttu-id="b929c-167">Em alguns cenários, talvez seja útil ou até mesmo necessário implementar seu próprio particionador.</span><span class="sxs-lookup"><span data-stu-id="b929c-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="b929c-168">Por exemplo, você pode ter uma classe de coleção personalizada que pode particionar de forma mais eficiente do que os particionadores padrão, com base em seu conhecimento sobre a estrutura interna da classe.</span><span class="sxs-lookup"><span data-stu-id="b929c-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="b929c-169">Ou, talvez, você queira criar partições de intervalo de tamanhos variados com base em seu conhecimento de quanto tempo levará para processar elementos em locais diferentes na coleção de origem.</span><span class="sxs-lookup"><span data-stu-id="b929c-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="b929c-170">Para criar um particionador personalizado básico, derive uma classe de <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> e substitua os métodos virtuais, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="b929c-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="b929c-171">Esse método é chamado uma vez pelo thread principal e retorna um IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="b929c-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="b929c-172">Cada thread de trabalho na consulta ou no loop pode chamar `GetEnumerator` na lista para recuperar um <xref:System.Collections.Generic.IEnumerator%601> por uma partição distinta.</span><span class="sxs-lookup"><span data-stu-id="b929c-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="b929c-173">Retorne `true` se você implementar <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>; caso contrário, `false`.</span><span class="sxs-lookup"><span data-stu-id="b929c-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="b929c-174">Se <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> for `true`, esse método poderá ser opcionalmente chamado, em vez de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="b929c-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="b929c-175">Se os resultados precisarem ser classificáveis ou exigirem acesso indexado aos elementos, derive de <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> e substitua seus métodos virtuais, conforme descrito na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="b929c-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="b929c-176">Esse método é chamado uma vez pelo thread principal e retorna um `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="b929c-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="b929c-177">Cada thread de trabalho na consulta ou no loop pode chamar `GetEnumerator` na lista para recuperar um <xref:System.Collections.Generic.IEnumerator%601> por uma partição distinta.</span><span class="sxs-lookup"><span data-stu-id="b929c-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="b929c-178">Retorne `true` se você implementar <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; caso contrário, false.</span><span class="sxs-lookup"><span data-stu-id="b929c-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="b929c-179">Normalmente, isso apenas chama <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="b929c-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="b929c-180">Se <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> for `true`, esse método poderá ser opcionalmente chamado, em vez de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="b929c-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="b929c-181">A tabela a seguir fornece detalhes adicionais sobre como os três tipos de particionadores de balanceamento de carga implementam a classe <xref:System.Collections.Concurrent.OrderablePartitioner%601>.</span><span class="sxs-lookup"><span data-stu-id="b929c-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="b929c-182">Método/propriedade</span><span class="sxs-lookup"><span data-stu-id="b929c-182">Method/Property</span></span>|<span data-ttu-id="b929c-183">IList/matriz sem balanceamento de carga</span><span class="sxs-lookup"><span data-stu-id="b929c-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="b929c-184">IList/matriz com balanceamento de carga</span><span class="sxs-lookup"><span data-stu-id="b929c-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="b929c-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="b929c-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="b929c-186">Usa o particionamento por intervalos</span><span class="sxs-lookup"><span data-stu-id="b929c-186">Uses range partitioning</span></span>|<span data-ttu-id="b929c-187">Usa o particionamento por partes otimizado para Listas para o partitionCount especificado</span><span class="sxs-lookup"><span data-stu-id="b929c-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="b929c-188">Usa o particionamento por partes por meio da criação de um número estático de partições.</span><span class="sxs-lookup"><span data-stu-id="b929c-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="b929c-189">Gera uma exceção sem suporte</span><span class="sxs-lookup"><span data-stu-id="b929c-189">Throws not-supported exception</span></span>|<span data-ttu-id="b929c-190">Usa o particionamento por partes otimizado para Listas e partições dinâmicas</span><span class="sxs-lookup"><span data-stu-id="b929c-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="b929c-191">Usa o particionamento por partes por meio da criação de um número dinâmico de partições.</span><span class="sxs-lookup"><span data-stu-id="b929c-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="b929c-192">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-192">Returns `true`</span></span>|<span data-ttu-id="b929c-193">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-193">Returns `true`</span></span>|<span data-ttu-id="b929c-194">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="b929c-195">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-195">Returns `true`</span></span>|<span data-ttu-id="b929c-196">Retorna `false`</span><span class="sxs-lookup"><span data-stu-id="b929c-196">Returns `false`</span></span>|<span data-ttu-id="b929c-197">Retorna `false`</span><span class="sxs-lookup"><span data-stu-id="b929c-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="b929c-198">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-198">Returns `true`</span></span>|<span data-ttu-id="b929c-199">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-199">Returns `true`</span></span>|<span data-ttu-id="b929c-200">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="b929c-201">Retorna `false`</span><span class="sxs-lookup"><span data-stu-id="b929c-201">Returns `false`</span></span>|<span data-ttu-id="b929c-202">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-202">Returns `true`</span></span>|<span data-ttu-id="b929c-203">Retorna `true`</span><span class="sxs-lookup"><span data-stu-id="b929c-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="b929c-204">Partições dinâmicas</span><span class="sxs-lookup"><span data-stu-id="b929c-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="b929c-205">Se desejar que o particionador seja usado em um método <xref:System.Threading.Tasks.Parallel.ForEach%2A>, você deverá ser capaz de retornar um número dinâmico de partições.</span><span class="sxs-lookup"><span data-stu-id="b929c-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="b929c-206">Isso significa que o particionador pode fornecer um enumerador para uma nova partição sob demanda a qualquer momento durante a execução do loop.</span><span class="sxs-lookup"><span data-stu-id="b929c-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="b929c-207">Basicamente, sempre que o loop adicionar uma nova tarefa paralela, solicitará uma nova partição para a tarefa.</span><span class="sxs-lookup"><span data-stu-id="b929c-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="b929c-208">Se for preciso que os dados sejam ordenáveis, derive <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> para que seja atribuído um índice exclusivo a cada item em cada partição.</span><span class="sxs-lookup"><span data-stu-id="b929c-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="b929c-209">Para saber mais e obter um exemplo, confira [Como implementar partições dinâmicas](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="b929c-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="b929c-210">Contrato para particionadores</span><span class="sxs-lookup"><span data-stu-id="b929c-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="b929c-211">Ao implementar um particionador personalizado, siga estas diretrizes para garantir a interação correta com PLINQ e <xref:System.Threading.Tasks.Parallel.ForEach%2A> na TPL:</span><span class="sxs-lookup"><span data-stu-id="b929c-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="b929c-212">Se <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> for chamado com um argumento de zero ou menos para `partitionsCount`, gere <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="b929c-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="b929c-213">Embora o PLINQ e o TPL nunca passem um `partitionCount` igual a 0, mesmo assim, recomendamos que você proteja contra a possibilidade.</span><span class="sxs-lookup"><span data-stu-id="b929c-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="b929c-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> e <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> devem retornar sempre `partitionsCount` partições.</span><span class="sxs-lookup"><span data-stu-id="b929c-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="b929c-215">Se o particionador ficar sem dados e não puder criar tantas partições quantas foram solicitadas, o método deverá retornar um enumerador vazio para cada uma das partições restantes.</span><span class="sxs-lookup"><span data-stu-id="b929c-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="b929c-216">Caso contrário, o PLINQ e o TPL gerarão um <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="b929c-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="b929c-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> e <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> nunca devem retornar `null` (`Nothing` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b929c-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="b929c-218">Se isso ocorrer, PLINQ/TPL gerará um <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="b929c-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="b929c-219">Os métodos que retornam partições devem retornar sempre partições que podem enumerar total e exclusivamente a fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="b929c-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="b929c-220">Não deve haver nenhuma duplicação na fonte de dados nem itens ignorados, a menos que isso seja especificamente necessário para o design do particionador.</span><span class="sxs-lookup"><span data-stu-id="b929c-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="b929c-221">Se essa regra não for seguida, a ordem de saída poderá ser embaralhada.</span><span class="sxs-lookup"><span data-stu-id="b929c-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="b929c-222">Os seguintes getters boolianos devem sempre retornar com precisão os seguintes valores para que a ordem de saída não seja embaralhada:</span><span class="sxs-lookup"><span data-stu-id="b929c-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="b929c-223">`KeysOrderedInEachPartition`: cada partição retorna elementos com índices de chave crescentes.</span><span class="sxs-lookup"><span data-stu-id="b929c-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="b929c-224">`KeysOrderedAcrossPartitions`: para todas as partições que são retornadas, os índices de chave na partição *i* são maiores do que os índices de chave na partição *i*-1.</span><span class="sxs-lookup"><span data-stu-id="b929c-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="b929c-225">`KeysNormalized`: todos os índices de chave aumentam de forma monotônica sem lacunas, a partir de zero.</span><span class="sxs-lookup"><span data-stu-id="b929c-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="b929c-226">Todos os índices devem ser exclusivos.</span><span class="sxs-lookup"><span data-stu-id="b929c-226">All indices must be unique.</span></span> <span data-ttu-id="b929c-227">Não pode haver índices duplicados.</span><span class="sxs-lookup"><span data-stu-id="b929c-227">There may not be duplicate indices.</span></span> <span data-ttu-id="b929c-228">Se essa regra não for seguida, a ordem de saída poderá ser embaralhada.</span><span class="sxs-lookup"><span data-stu-id="b929c-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="b929c-229">Todos os índices devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="b929c-229">All indices must be nonnegative.</span></span> <span data-ttu-id="b929c-230">Se essa regra não for seguida, PLINQ/TPL poderão gerar exceções.</span><span class="sxs-lookup"><span data-stu-id="b929c-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b929c-231">Consulte também</span><span class="sxs-lookup"><span data-stu-id="b929c-231">See Also</span></span>  
 [<span data-ttu-id="b929c-232">Programação paralela</span><span class="sxs-lookup"><span data-stu-id="b929c-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="b929c-233">Como implementar partições dinâmicas</span><span class="sxs-lookup"><span data-stu-id="b929c-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="b929c-234">Como implementar um particionador para particionamento estático</span><span class="sxs-lookup"><span data-stu-id="b929c-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
