---
title: Formatos de caminho de arquivo em sistemas Windows
description: Neste artigo, saiba mais sobre formatos de caminho de arquivo em sistemas Windows, como caminhos de DOS tradicionais, caminhos de dispositivo DOS e caminhos UNC (Convenção de nomenclatura universal).
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: e24772ee9c9d22786c9cfece43017f8526434601
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188049"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="c44d0-103">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="c44d0-103">File path formats on Windows systems</span></span>

<span data-ttu-id="c44d0-104">Membros de muitos dos tipos no namespace <xref:System.IO> incluem um parâmetro `path` que permite que você especifique um caminho absoluto ou relativo para um recurso do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="c44d0-104">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="c44d0-105">Em seguida, esse caminho é passado para as [APIs do sistema de arquivos do Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="c44d0-105">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="c44d0-106">Este tópico discute os formatos de caminhos de arquivo que podem ser usados em sistemas do Windows.</span><span class="sxs-lookup"><span data-stu-id="c44d0-106">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="c44d0-107">Caminhos DOS tradicionais</span><span class="sxs-lookup"><span data-stu-id="c44d0-107">Traditional DOS paths</span></span>

<span data-ttu-id="c44d0-108">Um caminho DOS padrão pode consistir em três componentes:</span><span class="sxs-lookup"><span data-stu-id="c44d0-108">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="c44d0-109">Um volume ou letra da unidade seguidos pelo separador de volume (`:`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-109">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="c44d0-110">Um nome de diretório.</span><span class="sxs-lookup"><span data-stu-id="c44d0-110">A directory name.</span></span> <span data-ttu-id="c44d0-111">O [caractere separador de diretório](<xref:System.IO.Path.DirectorySeparatorChar>) separa subdiretórios dentro da hierarquia aninhada do diretório.</span><span class="sxs-lookup"><span data-stu-id="c44d0-111">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="c44d0-112">Um nome de arquivo opcional.</span><span class="sxs-lookup"><span data-stu-id="c44d0-112">An optional filename.</span></span> <span data-ttu-id="c44d0-113">O [caractere separador de diretório](<xref:System.IO.Path.DirectorySeparatorChar>) separa o caminho do arquivo e o nome do arquivo.</span><span class="sxs-lookup"><span data-stu-id="c44d0-113">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="c44d0-114">Se todos os três componentes estiverem presentes, o caminho será absoluto.</span><span class="sxs-lookup"><span data-stu-id="c44d0-114">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="c44d0-115">Se nenhum volume ou letra da unidade for especificado e o nome do diretório começar com o [caractere separador de diretório](<xref:System.IO.Path.DirectorySeparatorChar>), o caminho será relativo na raiz da unidade atual.</span><span class="sxs-lookup"><span data-stu-id="c44d0-115">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="c44d0-116">Caso contrário, o caminho será relativo ao diretório atual.</span><span class="sxs-lookup"><span data-stu-id="c44d0-116">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="c44d0-117">A tabela a seguir mostra alguns possíveis caminhos de arquivo e diretório.</span><span class="sxs-lookup"><span data-stu-id="c44d0-117">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="c44d0-118">Caminho</span><span class="sxs-lookup"><span data-stu-id="c44d0-118">Path</span></span>  |<span data-ttu-id="c44d0-119">Descrição</span><span class="sxs-lookup"><span data-stu-id="c44d0-119">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="c44d0-120">Um caminho de arquivo absoluto da raiz da unidade `C:` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-120">An absolute file path from the root of drive `C:`.</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="c44d0-121">Um caminho absoluto da raiz da unidade atual.</span><span class="sxs-lookup"><span data-stu-id="c44d0-121">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="c44d0-122">Um caminho relativo para um arquivo em um subdiretório do diretório atual.</span><span class="sxs-lookup"><span data-stu-id="c44d0-122">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="c44d0-123">Um caminho relativo para um arquivo em um diretório par do diretório atual.</span><span class="sxs-lookup"><span data-stu-id="c44d0-123">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="c44d0-124">Um caminho absoluto para um arquivo da raiz da unidade `C:` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-124">An absolute path to a file from the root of drive `C:`.</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="c44d0-125">Um caminho relativo do diretório atual da `C:` unidade.</span><span class="sxs-lookup"><span data-stu-id="c44d0-125">A relative path from the current directory of the `C:` drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="c44d0-126">Observe a diferença entre os últimos dois caminhos.</span><span class="sxs-lookup"><span data-stu-id="c44d0-126">Note the difference between the last two paths.</span></span> <span data-ttu-id="c44d0-127">Ambos especificam o especificador de volume opcional ( `C:` em ambos os casos), mas o primeiro começa com a raiz do volume especificado, enquanto o segundo não.</span><span class="sxs-lookup"><span data-stu-id="c44d0-127">Both specify the optional volume specifier (`C:` in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="c44d0-128">Como resultado, o primeiro é um caminho absoluto do diretório raiz da unidade `C:` , enquanto o segundo é um caminho relativo do diretório atual da unidade `C:` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-128">As result, the first is an absolute path from the root directory of drive `C:`, whereas the second is a relative path from the current directory of drive `C:`.</span></span> <span data-ttu-id="c44d0-129">Uso do segundo formulário quando o primeiro é uma fonte comum de bugs que envolvem caminhos de arquivo do Windows.</span><span class="sxs-lookup"><span data-stu-id="c44d0-129">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="c44d0-130">É possível determinar se um caminho de arquivo é totalmente qualificado (ou seja, se o caminho é independente do diretório atual e não se altera quando o diretório atual é alterado) chamando o método <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c44d0-130">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c44d0-131">Esse tipo de caminho poderá incluir segmentos de diretório relativo (`.` e `..`) e ainda ser totalmente qualificado se o caminho resolvido sempre apontar para o mesmo local.</span><span class="sxs-lookup"><span data-stu-id="c44d0-131">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="c44d0-132">O exemplo a seguir ilustra a diferença entre caminhos absolutos e relativos.</span><span class="sxs-lookup"><span data-stu-id="c44d0-132">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="c44d0-133">Ele pressupõe que o diretório `D:\FY2018\` existe e que você não definiu nenhum diretório atual para `D:\` o no prompt de comando antes de executar o exemplo.</span><span class="sxs-lookup"><span data-stu-id="c44d0-133">It assumes that the directory `D:\FY2018\` exists, and that you haven't set any current directory for `D:\` from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="c44d0-134">Caminhos UNC</span><span class="sxs-lookup"><span data-stu-id="c44d0-134">UNC paths</span></span>

<span data-ttu-id="c44d0-135">Os caminhos UNC (convenção de nomenclatura universal), usados para acessar recursos de rede, têm o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="c44d0-135">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="c44d0-136">Um nome do host ou servidor, que é precedido por `\\`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-136">A server or host name, which is prefaced by `\\`.</span></span> <span data-ttu-id="c44d0-137">O nome do servidor pode ser um nome de computador NetBIOS ou um endereço IP/FQDN (IPv4 e v6 são compatíveis).</span><span class="sxs-lookup"><span data-stu-id="c44d0-137">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="c44d0-138">Um nome do compartilhamento, separado do nome do host por `\`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-138">A share name, which is separated from the host name by `\`.</span></span> <span data-ttu-id="c44d0-139">Juntos, o servidor e o nome do compartilhamento compõem o volume.</span><span class="sxs-lookup"><span data-stu-id="c44d0-139">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="c44d0-140">Um nome de diretório.</span><span class="sxs-lookup"><span data-stu-id="c44d0-140">A directory name.</span></span> <span data-ttu-id="c44d0-141">O [caractere separador de diretório](<xref:System.IO.Path.DirectorySeparatorChar>) separa subdiretórios dentro da hierarquia aninhada do diretório.</span><span class="sxs-lookup"><span data-stu-id="c44d0-141">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="c44d0-142">Um nome de arquivo opcional.</span><span class="sxs-lookup"><span data-stu-id="c44d0-142">An optional filename.</span></span> <span data-ttu-id="c44d0-143">O [caractere separador de diretório](<xref:System.IO.Path.DirectorySeparatorChar>) separa o caminho do arquivo e o nome do arquivo.</span><span class="sxs-lookup"><span data-stu-id="c44d0-143">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="c44d0-144">Veja alguns exemplos de caminhos UNC:</span><span class="sxs-lookup"><span data-stu-id="c44d0-144">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="c44d0-145">Caminho</span><span class="sxs-lookup"><span data-stu-id="c44d0-145">Path</span></span>  |<span data-ttu-id="c44d0-146">Descrição</span><span class="sxs-lookup"><span data-stu-id="c44d0-146">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="c44d0-147">O diretório raiz da `C:` unidade em `system07` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-147">The root directory of the `C:` drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="c44d0-148">O `Foo.txt` arquivo no diretório de teste do `\\Server2\Share` volume.</span><span class="sxs-lookup"><span data-stu-id="c44d0-148">The `Foo.txt` file in the Test directory of the `\\Server2\Share` volume.</span></span>|

<span data-ttu-id="c44d0-149">Caminhos UNC devem sempre ser totalmente qualificados.</span><span class="sxs-lookup"><span data-stu-id="c44d0-149">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="c44d0-150">Podem incluir segmentos de diretório relativo (`.` e `..`), mas esses precisam ser parte de um caminho totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="c44d0-150">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="c44d0-151">É possível usar caminhos relativos somente mapeando um caminho UNC para uma letra da unidade.</span><span class="sxs-lookup"><span data-stu-id="c44d0-151">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="c44d0-152">Caminhos de dispositivo DOS</span><span class="sxs-lookup"><span data-stu-id="c44d0-152">DOS device paths</span></span>

<span data-ttu-id="c44d0-153">O sistema operacional Windows tem um modelo de objeto unificado que aponta para todos os recursos, incluindo arquivos.</span><span class="sxs-lookup"><span data-stu-id="c44d0-153">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="c44d0-154">Esses caminhos de objeto podem ser acessados na janela do console e estão expostos à camada Win32 por meio de uma pasta especial de links simbólicos para as quais o DOS herdado e os caminhos UNC estão mapeados.</span><span class="sxs-lookup"><span data-stu-id="c44d0-154">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="c44d0-155">Essa pasta especial é acessada pela sintaxe do caminho de dispositivo DOS, que é uma das opções a seguir:</span><span class="sxs-lookup"><span data-stu-id="c44d0-155">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="c44d0-156">Além de identificar uma unidade pela letra, você pode identificar um volume usando a GUID do volume.</span><span class="sxs-lookup"><span data-stu-id="c44d0-156">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="c44d0-157">Ela assume o formato:</span><span class="sxs-lookup"><span data-stu-id="c44d0-157">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="c44d0-158">A sintaxe do caminho de dispositivo DOS é compatível com implementações do .NET executadas no Windows, a partir do .NET Core 1.1 e .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="c44d0-158">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="c44d0-159">O caminho de dispositivo DOS tem os seguintes componentes:</span><span class="sxs-lookup"><span data-stu-id="c44d0-159">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="c44d0-160">O especificador de caminho do dispositivo (`\\.\` ou `\\?\`), que identifica o caminho como um caminho de dispositivo DOS.</span><span class="sxs-lookup"><span data-stu-id="c44d0-160">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="c44d0-161">O `\\?\` tem suporte em todas as versões do .NET Core e do .NET 5 + e no .NET Framework a partir da versão 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="c44d0-161">The `\\?\` is supported in all versions of .NET Core and .NET 5+ and in .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="c44d0-162">Um link simbólico para o objeto de dispositivo "real" (C: no caso de um nome de unidade ou Volume{b75e2c83-0000-0000-0000-602f00000000} no caso de um GUID de volume).</span><span class="sxs-lookup"><span data-stu-id="c44d0-162">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="c44d0-163">O primeiro segmento do caminho de dispositivo DOS depois do especificador de caminho do dispositivo identifica o volume ou a unidade.</span><span class="sxs-lookup"><span data-stu-id="c44d0-163">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="c44d0-164">Por exemplo, `\\?\C:\` e `\\.\BootPartition\`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-164">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="c44d0-165">Há um link específico para UNCs que é chamado, não surpreendentemente, `UNC`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-165">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="c44d0-166">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="c44d0-166">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="c44d0-167">Para UNCs de dispositivo, a parte do servidor/compartilhamento forma o volume.</span><span class="sxs-lookup"><span data-stu-id="c44d0-167">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="c44d0-168">Por exemplo, no `\\?\server1\e:\utilities\\filecomparer\` , a parte de servidor/compartilhamento é `server1\utilities` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-168">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is `server1\utilities`.</span></span> <span data-ttu-id="c44d0-169">Isso é importante ao chamar um método como <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> com segmentos de diretório relativo. Não é possível navegar além desse volume.</span><span class="sxs-lookup"><span data-stu-id="c44d0-169">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="c44d0-170">Caminhos de dispositivo DOS são totalmente qualificados por definição.</span><span class="sxs-lookup"><span data-stu-id="c44d0-170">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="c44d0-171">Os segmento de diretório relativo (`.` e `..`) não são permitidos.</span><span class="sxs-lookup"><span data-stu-id="c44d0-171">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="c44d0-172">Os diretórios atuais nunca são inseridos no uso deles.</span><span class="sxs-lookup"><span data-stu-id="c44d0-172">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="c44d0-173">Exemplo: maneiras de se referir ao mesmo arquivo</span><span class="sxs-lookup"><span data-stu-id="c44d0-173">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="c44d0-174">O exemplo a seguir mostra algumas maneiras de se referir ao arquivo ao usar as APIs do namespace <xref:System.IO>.</span><span class="sxs-lookup"><span data-stu-id="c44d0-174">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="c44d0-175">O exemplo cria uma instância de um objeto <xref:System.IO.FileInfo> e usa suas propriedades <xref:System.IO.FileInfo.Name> e <xref:System.IO.FileInfo.Length> para exibir o nome do arquivo e seu tamanho.</span><span class="sxs-lookup"><span data-stu-id="c44d0-175">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="c44d0-176">Normalização de caminho</span><span class="sxs-lookup"><span data-stu-id="c44d0-176">Path normalization</span></span>

<span data-ttu-id="c44d0-177">Quase todos os caminhos passados para APIs do Windows são normalizados.</span><span class="sxs-lookup"><span data-stu-id="c44d0-177">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="c44d0-178">Durante a normalização, o Windows executa as seguintes etapas:</span><span class="sxs-lookup"><span data-stu-id="c44d0-178">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="c44d0-179">Identifica o caminho.</span><span class="sxs-lookup"><span data-stu-id="c44d0-179">Identifies the path.</span></span>
- <span data-ttu-id="c44d0-180">Aplica o diretório atual a caminhos (relativos) parcialmente qualificados.</span><span class="sxs-lookup"><span data-stu-id="c44d0-180">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="c44d0-181">Canoniza os separadores de diretório e componente.</span><span class="sxs-lookup"><span data-stu-id="c44d0-181">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="c44d0-182">Avalia os componentes do diretório relativo (`.` para o diretório atual e `..` para o diretório pai).</span><span class="sxs-lookup"><span data-stu-id="c44d0-182">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="c44d0-183">Corta alguns caracteres.</span><span class="sxs-lookup"><span data-stu-id="c44d0-183">Trims certain characters.</span></span>

<span data-ttu-id="c44d0-184">Essa normalização ocorre de maneira implícita, mas é possível fazê-la explicitamente chamando o método <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType>, que encapsula uma chamada para a [função GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="c44d0-184">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="c44d0-185">Também é possível chamar a [função GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) do Windows diretamente usando P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="c44d0-185">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identify-the-path"></a><span data-ttu-id="c44d0-186">Identificar o caminho</span><span class="sxs-lookup"><span data-stu-id="c44d0-186">Identify the path</span></span>

<span data-ttu-id="c44d0-187">O primeiro passo na normalização do caminho é identificar o tipo do caminho.</span><span class="sxs-lookup"><span data-stu-id="c44d0-187">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="c44d0-188">Os caminhos são classificados em uma dentre algumas categorias:</span><span class="sxs-lookup"><span data-stu-id="c44d0-188">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="c44d0-189">São caminhos de dispositivo, ou seja, começam com dois separadores e um ponto de interrogação ou ponto final (`\\?` ou `\\.`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-189">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="c44d0-190">São caminhos UNC, ou seja, começam com dois separadores sem um ponto de interrogação ou ponto final.</span><span class="sxs-lookup"><span data-stu-id="c44d0-190">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="c44d0-191">São caminhos DOS totalmente qualificados, ou seja, começam com uma letra da unidade, um separador de volume e um separador de componente (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-191">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="c44d0-192">Designam um dispositivo herdado (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-192">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="c44d0-193">Estão relacionados com a raiz da unidade atual, ou seja, começam com um separador de componente único (`\`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-193">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="c44d0-194">Estão relacionados com o diretório atual de uma unidade especificada, ou seja, começam com uma letra da unidade, um separador de volume e sem um separador de componente (`C:`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-194">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="c44d0-195">Estão relacionados com o diretório atual, ou seja, começam com qualquer outra coisa (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-195">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="c44d0-196">O tipo do caminho determina se o diretório atual é aplicado de alguma maneira ou não.</span><span class="sxs-lookup"><span data-stu-id="c44d0-196">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="c44d0-197">Também determina qual é a "raiz" do caminho.</span><span class="sxs-lookup"><span data-stu-id="c44d0-197">It also determines what the "root" of the path is.</span></span>

### <a name="handle-legacy-devices"></a><span data-ttu-id="c44d0-198">Manipular dispositivos herdados</span><span class="sxs-lookup"><span data-stu-id="c44d0-198">Handle legacy devices</span></span>

<span data-ttu-id="c44d0-199">Se o caminho for um dispositivo DOS herdado como `CON`, `COM1` ou `LPT1`, será convertido em um caminho de dispositivo pelo `\\.\` precedente e retornado.</span><span class="sxs-lookup"><span data-stu-id="c44d0-199">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="c44d0-200">Um caminho que começa com um nome do dispositivo herdado sempre é interpretado como um dispositivo herdado pelo método <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c44d0-200">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c44d0-201">Por exemplo, o caminho de dispositivo DOS de `CON.TXT` é `\\.\CON`, e o caminho de dispositivo DOS de `COM1.TXT\file1.txt` é `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-201">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="apply-the-current-directory"></a><span data-ttu-id="c44d0-202">Aplicar o diretório atual</span><span class="sxs-lookup"><span data-stu-id="c44d0-202">Apply the current directory</span></span>

<span data-ttu-id="c44d0-203">Se o caminho não for totalmente qualificado, o Windows aplicará o diretório atual a ele.</span><span class="sxs-lookup"><span data-stu-id="c44d0-203">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="c44d0-204">O diretório atual não foi aplicado a UNCs e caminhos de dispositivo.</span><span class="sxs-lookup"><span data-stu-id="c44d0-204">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="c44d0-205">Nenhuma unidade completa com separador `C:\` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-205">Neither does a full drive with separator `C:\`.</span></span>

<span data-ttu-id="c44d0-206">Se o caminho começar com um único separador de componente, a unidade do diretório atual será aplicada.</span><span class="sxs-lookup"><span data-stu-id="c44d0-206">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="c44d0-207">Por exemplo, se o caminho do arquivo for `\utilities` e o diretório atual for `C:\temp\`, a normalização produzirá `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-207">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="c44d0-208">Se o caminho começar com uma letra da unidade, um separador de volume e sem um separador de componente, o último diretório atual definido do shell de comando para a unidade especificada será aplicado.</span><span class="sxs-lookup"><span data-stu-id="c44d0-208">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="c44d0-209">Se o último diretório atual não tiver sido definido, a unidade isolada será aplicada.</span><span class="sxs-lookup"><span data-stu-id="c44d0-209">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="c44d0-210">Por exemplo, se o caminho de arquivo for `D:sources`, o diretório atual for `C:\Documents\` e o último diretório atual na unidade D: for `D:\sources\`, o resultado será `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-210">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="c44d0-211">Esses caminhos "relativos à unidade" são uma fonte comum de erros lógicos de script e programas.</span><span class="sxs-lookup"><span data-stu-id="c44d0-211">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="c44d0-212">Assumir que um caminho iniciado com uma letra e dois-pontos não é relativo é claramente incorreto.</span><span class="sxs-lookup"><span data-stu-id="c44d0-212">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="c44d0-213">Se o caminho começar com algo diferente de um separador, a unidade e o diretório atuais serão aplicados.</span><span class="sxs-lookup"><span data-stu-id="c44d0-213">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="c44d0-214">Por exemplo, se o caminho for `filecompare` e o diretório atual for `C:\utilities\`, o resultado será `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="c44d0-214">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c44d0-215">Os caminhos relativos são perigosos em aplicativos multi-threaded (ou seja, a maioria), porque o diretório atual tem uma configuração por processo.</span><span class="sxs-lookup"><span data-stu-id="c44d0-215">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="c44d0-216">Qualquer thread pode alterar o diretório atual a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="c44d0-216">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="c44d0-217">A partir do .NET Core 2.1, é possível chamar o método <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> para obter um caminho absoluto de um caminho relativo, bem como o caminho base (o diretório atual) que você precisa para resolvê-lo.</span><span class="sxs-lookup"><span data-stu-id="c44d0-217">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalize-separators"></a><span data-ttu-id="c44d0-218">Tornar os separadores canônicos</span><span class="sxs-lookup"><span data-stu-id="c44d0-218">Canonicalize separators</span></span>

<span data-ttu-id="c44d0-219">Todas as barras (`/`) são convertidas no separador padrão do Windows, a barra invertida (`\`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-219">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="c44d0-220">Se estiverem presentes, uma série de barras que segue as duas primeiras barras serão ocultadas e exibidas como uma barra só.</span><span class="sxs-lookup"><span data-stu-id="c44d0-220">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluate-relative-components"></a><span data-ttu-id="c44d0-221">Avaliar componentes relativos</span><span class="sxs-lookup"><span data-stu-id="c44d0-221">Evaluate relative components</span></span>

<span data-ttu-id="c44d0-222">Conforme o caminho é processado, quaisquer componentes ou segmentos compostos de um ponto final ou ponto duplo (`.` ou `..`) serão avaliados:</span><span class="sxs-lookup"><span data-stu-id="c44d0-222">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="c44d0-223">No caso do ponto final, o segmento atual será removido, pois se refere ao diretório atual.</span><span class="sxs-lookup"><span data-stu-id="c44d0-223">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="c44d0-224">No caso do ponto duplo, o segmento atual e o segmento pai serão removidos, pois o ponto duplo se refere ao diretório pai.</span><span class="sxs-lookup"><span data-stu-id="c44d0-224">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="c44d0-225">Os diretórios pais só serão removidos se não forem maiores que a raiz do caminho.</span><span class="sxs-lookup"><span data-stu-id="c44d0-225">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="c44d0-226">A raiz do caminho depende do tipo do caminho.</span><span class="sxs-lookup"><span data-stu-id="c44d0-226">The root of the path depends on the type of path.</span></span> <span data-ttu-id="c44d0-227">É a unidade (`C:\`) dos caminhos DOS, o servidor/compartilhamento de UNCs (`\\Server\Share`) e o prefixo do caminho de dispositivo dos caminhos de dispositivo (`\\?\` ou `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="c44d0-227">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trim-characters"></a><span data-ttu-id="c44d0-228">Caracteres de corte</span><span class="sxs-lookup"><span data-stu-id="c44d0-228">Trim characters</span></span>

<span data-ttu-id="c44d0-229">Alguns outros caracteres são removidos durante a normalização junto com os separadores e segmentos relativos removidos anteriormente:</span><span class="sxs-lookup"><span data-stu-id="c44d0-229">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="c44d0-230">Se um segmento terminar em ponto final, esse ponto final será removido.</span><span class="sxs-lookup"><span data-stu-id="c44d0-230">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="c44d0-231">Um segmento com ponto final ou ponto duplo foi normalizado na etapa anterior.</span><span class="sxs-lookup"><span data-stu-id="c44d0-231">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="c44d0-232">Um segmento com três ou mais pontos não será normalizado e, na verdade, é um nome de arquivo/diretório válido.</span><span class="sxs-lookup"><span data-stu-id="c44d0-232">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="c44d0-233">Se o caminho não terminar em um separador, todos os pontos e espaços à direita (U+0020) serão removidos.</span><span class="sxs-lookup"><span data-stu-id="c44d0-233">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="c44d0-234">Se o último segmento for simplesmente um ponto final ou duplo, será aplicada a regra de componentes relativos já mencionada.</span><span class="sxs-lookup"><span data-stu-id="c44d0-234">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="c44d0-235">Essa regra significa que é possível criar um nome de diretório com um espaço à direita ao adicionar um separador à direita após o espaço.</span><span class="sxs-lookup"><span data-stu-id="c44d0-235">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="c44d0-236">**Nunca** crie um diretório ou nome de arquivo com um espaço à direita.</span><span class="sxs-lookup"><span data-stu-id="c44d0-236">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="c44d0-237">Os espaços à direita podem dificultar ou impossibilitar o acesso ao diretório e, normalmente, os aplicativos apresentam falha nas tentativas de tratar diretórios ou arquivos com nomes que contêm espaços à direita.</span><span class="sxs-lookup"><span data-stu-id="c44d0-237">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skip-normalization"></a><span data-ttu-id="c44d0-238">Ignorar normalização</span><span class="sxs-lookup"><span data-stu-id="c44d0-238">Skip normalization</span></span>

<span data-ttu-id="c44d0-239">Normalmente, qualquer caminho passado para uma API do Windows é (efetivamente) passado para a [função GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) e normalizado.</span><span class="sxs-lookup"><span data-stu-id="c44d0-239">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="c44d0-240">Há uma exceção importante: um caminho de dispositivo que começa com um ponto de interrogação em vez de um ponto final.</span><span class="sxs-lookup"><span data-stu-id="c44d0-240">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="c44d0-241">A menos que o caminho comece exatamente com `\\?\` (observe o uso da barra invertida canônica), ele é normalizado.</span><span class="sxs-lookup"><span data-stu-id="c44d0-241">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="c44d0-242">Por que ignorar a normalização?</span><span class="sxs-lookup"><span data-stu-id="c44d0-242">Why would you want to skip normalization?</span></span> <span data-ttu-id="c44d0-243">Existem três motivos principais:</span><span class="sxs-lookup"><span data-stu-id="c44d0-243">There are three major reasons:</span></span>

1. <span data-ttu-id="c44d0-244">Para ter acesso a caminhos normalmente não disponíveis, mas legais.</span><span class="sxs-lookup"><span data-stu-id="c44d0-244">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="c44d0-245">Um arquivo ou diretório chamado `hidden.`, por exemplo, não pode ser acessado de outra maneira.</span><span class="sxs-lookup"><span data-stu-id="c44d0-245">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="c44d0-246">Para melhorar o desempenho ignorando a normalização, se você já tiver normalizado.</span><span class="sxs-lookup"><span data-stu-id="c44d0-246">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="c44d0-247">Somente no .NET Framework, para ignorar a `MAX_PATH` verificação do comprimento do caminho para permitir caminhos maiores que 259 caracteres.</span><span class="sxs-lookup"><span data-stu-id="c44d0-247">On .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="c44d0-248">A maioria das APIs permitem isso, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="c44d0-248">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="c44d0-249">O .NET Core e o .NET 5 + manipulam caminhos longos implicitamente e não realiza uma `MAX_PATH` verificação.</span><span class="sxs-lookup"><span data-stu-id="c44d0-249">.NET Core and .NET 5+ handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="c44d0-250">A `MAX_PATH` verificação se aplica somente a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c44d0-250">The `MAX_PATH` check applies only to .NET Framework.</span></span>

<span data-ttu-id="c44d0-251">Ignorar a normalização e as verificações de tamanho do caminho é a única diferença entre as duas sintaxes de caminho de dispositivo. Caso contrário, elas serão idênticas.</span><span class="sxs-lookup"><span data-stu-id="c44d0-251">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="c44d0-252">Tenha cuidado ao ignorar a normalização, pois é fácil criar caminhos de difícil tratamento para aplicativos "normais".</span><span class="sxs-lookup"><span data-stu-id="c44d0-252">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="c44d0-253">Os caminhos que começam com `\\?\` ainda serão normalizados se você os passar explicitamente para a [função GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="c44d0-253">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="c44d0-254">Você pode passar caminhos com mais de `MAX_PATH` caracteres para [getfullpathname](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) sem `\\?\` .</span><span class="sxs-lookup"><span data-stu-id="c44d0-254">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="c44d0-255">Ele dá suporte caminhos de tamanho arbitrário, até o tamanho máximo da cadeia de caracteres que o Windows consegue tratar.</span><span class="sxs-lookup"><span data-stu-id="c44d0-255">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="c44d0-256">Maiúsculas, minúsculas e o sistema de arquivos do Windows</span><span class="sxs-lookup"><span data-stu-id="c44d0-256">Case and the Windows file system</span></span>

<span data-ttu-id="c44d0-257">Uma peculiaridade do sistema de arquivos do Windows que usuários e desenvolvedores que não o utilizam consideram confusa é que os nomes do caminho e do diretório não diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c44d0-257">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="c44d0-258">Isto é, os nomes do caminho e do diretório refletem as cadeias de caracteres utilizadas no momento da criação.</span><span class="sxs-lookup"><span data-stu-id="c44d0-258">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="c44d0-259">Por exemplo, a chamada de método</span><span class="sxs-lookup"><span data-stu-id="c44d0-259">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="c44d0-260">cria um diretório chamado TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="c44d0-260">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="c44d0-261">Se você renomear um diretório ou arquivo para alterar as maiúsculas e minúsculas, o nome do diretório ou do arquivo refletirá a cadeia de caracteres usadas ao renomeá-los.</span><span class="sxs-lookup"><span data-stu-id="c44d0-261">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="c44d0-262">Por exemplo, o código a seguir renomeia o arquivo test.txt como Test.txt:</span><span class="sxs-lookup"><span data-stu-id="c44d0-262">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="c44d0-263">No entanto, as comparações entre o nome do diretório e do arquivo não diferenciam maiúsculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c44d0-263">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="c44d0-264">Se você pesquisar por um arquivo com o nome "test.txt", as APIs do sistema de arquivos do .NET ignorarão a comparação entre maiúsculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c44d0-264">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="c44d0-265">"Test.txt", "TEST.TXT", "test.TXT" e qualquer outra combinação de letras maiúsculas e minúsculas corresponderá a "test.txt".</span><span class="sxs-lookup"><span data-stu-id="c44d0-265">"Test.txt", "TEST.TXT", "test.TXT", and any other combination of uppercase and lowercase letters will match "test.txt".</span></span>
