---
title: Covariância e contravariância em genéricos
description: Saiba mais sobre covariância, que permite usar um tipo mais derivado e contravariância, que permite que você use um tipo menos derivado, em genéricos .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: 1606238b22bd355b997b54cf94e0c28d16ec5cac
ms.sourcegitcommit: b1442669f1982d3a1cb18ea35b5acfb0fc7d93e4
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/30/2020
ms.locfileid: "93063170"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="dfe49-103">Covariância e contravariância em genéricos</span><span class="sxs-lookup"><span data-stu-id="dfe49-103">Covariance and contravariance in generics</span></span>

<span data-ttu-id="dfe49-104">*Covariância* e *contravariância* são termos que se referem à capacidade de usar um tipo mais derivado (mais específico) ou um tipo menos derivado (menos específico) do que o especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="dfe49-104">*Covariance* and *contravariance* are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="dfe49-105">Os parâmetros de tipo genéricos oferecem suporte a covariância e contravariância para fornecer maior flexibilidade na atribuição e no uso de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="dfe49-105">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span>

<span data-ttu-id="dfe49-106">Quando você está fazendo referência a um sistema de tipos, Covariance, contravariância e invariância têm as definições a seguir.</span><span class="sxs-lookup"><span data-stu-id="dfe49-106">When you're referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="dfe49-107">Os exemplos assumem uma classe base chamada `Base` e uma classe derivada chamada `Derived`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-107">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="dfe49-108">Permite usar um tipo mais derivado que o especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="dfe49-108">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="dfe49-109">Você pode atribuir uma instância do `IEnumerable<Derived>` a uma variável do tipo `IEnumerable<Base>` .</span><span class="sxs-lookup"><span data-stu-id="dfe49-109">You can assign an instance of `IEnumerable<Derived>` to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="dfe49-110">Permite a você usar um tipo mais genérico (menos derivado) do que aquele especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="dfe49-110">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="dfe49-111">Você pode atribuir uma instância do `Action<Base>` a uma variável do tipo `Action<Derived>` .</span><span class="sxs-lookup"><span data-stu-id="dfe49-111">You can assign an instance of `Action<Base>` to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="dfe49-112">Significa que você pode usar apenas o tipo especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="dfe49-112">Means that you can use only the type originally specified.</span></span> <span data-ttu-id="dfe49-113">Um parâmetro de tipo genérico invariável não é covariant nem contravariant.</span><span class="sxs-lookup"><span data-stu-id="dfe49-113">An invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="dfe49-114">Não é possível atribuir uma instância do `List<Base>` a uma variável do tipo `List<Derived>` ou vice-versa.</span><span class="sxs-lookup"><span data-stu-id="dfe49-114">You cannot assign an instance of `List<Base>` to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="dfe49-115">Os parâmetros de tipo covariantes permitem fazer atribuições muito semelhantes ao [Polimorfismo](../../csharp/programming-guide/classes-and-structs/polymorphism.md) comum, conforme mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="dfe49-115">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="dfe49-116">A classe <xref:System.Collections.Generic.List%601> implementa a interface <xref:System.Collections.Generic.IEnumerable%601>. Assim, `List<Derived>` (`List(Of Derived)` no Visual Basic) implementa `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-116">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="dfe49-117">O parâmetro de tipo covariante faz o resto.</span><span class="sxs-lookup"><span data-stu-id="dfe49-117">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="dfe49-118">A contravariância, por outro lado, parece não ser intuitiva.</span><span class="sxs-lookup"><span data-stu-id="dfe49-118">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="dfe49-119">O exemplo a seguir cria um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) e, em seguida, atribuir o delegado a uma variável do tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-119">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="dfe49-120">Isso parece ser um retrocesso, mas é esse código de tipo seguro que compila e executa.</span><span class="sxs-lookup"><span data-stu-id="dfe49-120">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="dfe49-121">A expressão lambda corresponde ao delegado ao qual ela está atribuída e, portanto, define um método que usa um parâmetro do tipo `Base` e que não tem nenhum valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="dfe49-121">The lambda expression matches the delegate it's assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="dfe49-122">O delegado resultante pode ser atribuído a uma variável do tipo `Action<Derived>` porque o parâmetro de tipo `T` do delegado <xref:System.Action%601> é contravariante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-122">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="dfe49-123">O código é de tipo seguro porque `T` especifica um tipo de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="dfe49-123">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="dfe49-124">Quando o delegado do tipo `Action<Base>` é invocado como se fosse um delegado do tipo `Action<Derived>`, seu argumento deve ser do tipo `Derived`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-124">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="dfe49-125">Este argumento sempre pode ser passado ao método subjacente com segurança porque o parâmetro do método é do tipo `Base`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-125">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="dfe49-126">Geralmente, um parâmetro de tipo de covariante pode ser usado como o tipo de retorno de um delegado, e os parâmetros de tipo contravariant podem ser usados como tipos de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="dfe49-126">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="dfe49-127">Para uma interface, os parâmetros de tipo covariantes podem ser usados como os tipos de retorno dos métodos da interface, e os parâmetros de tipo contravariantes podem ser usados como os tipos de parâmetro dos métodos da interface.</span><span class="sxs-lookup"><span data-stu-id="dfe49-127">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="dfe49-128">A covariância e a contravariância são referidas coletivamente como *variância* .</span><span class="sxs-lookup"><span data-stu-id="dfe49-128">Covariance and contravariance are collectively referred to as *variance* .</span></span> <span data-ttu-id="dfe49-129">Um parâmetro de tipo genérico que não é covariante ou contravariante é referido como *invariante* .</span><span class="sxs-lookup"><span data-stu-id="dfe49-129">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant* .</span></span> <span data-ttu-id="dfe49-130">Um breve resumo de fatos sobre variância em Common Language Runtime:</span><span class="sxs-lookup"><span data-stu-id="dfe49-130">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="dfe49-131">Os parâmetros de tipo Variant são restritos à interface genérica e tipos de delegado genéricos.</span><span class="sxs-lookup"><span data-stu-id="dfe49-131">Variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="dfe49-132">Uma interface genérica ou um tipo delegado genérico podem ter parâmetros de tipo covariantes e contravariantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-132">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="dfe49-133">A variância aplica-se apenas para referenciar tipos; se você especificar um tipo de valor para um parâmetro de tipo variante, esse parâmetro de tipo será invariante para o tipo construído resultante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-133">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="dfe49-134">A variância não se aplica à combinação de delegado.</span><span class="sxs-lookup"><span data-stu-id="dfe49-134">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="dfe49-135">Ou seja, considerando dois delegados de tipos `Action<Derived>` e `Action<Base>` (`Action(Of Derived)` e `Action(Of Base)` no Visual Basic), você não pode combinar o segundo delegado com o primeiro, ainda que o resultado seja de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="dfe49-135">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="dfe49-136">A variância permite que o segundo delegado seja atribuído a uma variável do tipo `Action<Derived>`, mas os delegados podem ser combinados somente quando seus tipos são exatamente iguais.</span><span class="sxs-lookup"><span data-stu-id="dfe49-136">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

- <span data-ttu-id="dfe49-137">A partir do C# 9, os tipos de retorno covariantes têm suporte.</span><span class="sxs-lookup"><span data-stu-id="dfe49-137">Starting in C# 9, covariant return types are supported.</span></span> <span data-ttu-id="dfe49-138">Um método de substituição pode declarar um tipo de retorno mais derivado do método que ele substitui, e uma propriedade somente leitura de substituição pode declarar um tipo mais derivado.</span><span class="sxs-lookup"><span data-stu-id="dfe49-138">An overriding method can declare a more derived return type the method it overrides, and an overriding, read-only property can declare a more derived type.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="dfe49-139">Interfaces genéricas com parâmetros de tipo covariant</span><span class="sxs-lookup"><span data-stu-id="dfe49-139">Generic interfaces with covariant type parameters</span></span>

<span data-ttu-id="dfe49-140">Várias interfaces genéricas têm parâmetros de tipo covariant, por exemplo,,, <xref:System.Collections.Generic.IEnumerable%601> <xref:System.Collections.Generic.IEnumerator%601> <xref:System.Linq.IQueryable%601> e <xref:System.Linq.IGrouping%602> .</span><span class="sxs-lookup"><span data-stu-id="dfe49-140">Several generic interfaces have covariant type parameters, for example, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="dfe49-141">Todos os parâmetros de tipo dessas interfaces são covariantes, de forma que os parâmetros de tipo são usados apenas para os tipos de retorno dos membros.</span><span class="sxs-lookup"><span data-stu-id="dfe49-141">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="dfe49-142">O exemplo a seguir ilustra parâmetros de tipo covariantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-142">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="dfe49-143">O exemplo define dois tipos: `Base` tem um método estático chamado `PrintBases` que usa um `IEnumerable<Base>` (`IEnumerable(Of Base)` no Visual Basic) e imprime os elementos.</span><span class="sxs-lookup"><span data-stu-id="dfe49-143">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="dfe49-144">`Derived` herda de `Base`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-144">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="dfe49-145">O exemplo cria um `List<Derived>` vazio (`List(Of Derived)` no Visual Basic) e demonstra que esse tipo pode ser passado a `PrintBases` e atribuído a uma variável do tipo `IEnumerable<Base>` sem converter.</span><span class="sxs-lookup"><span data-stu-id="dfe49-145">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="dfe49-146"><xref:System.Collections.Generic.List%601> implementa <xref:System.Collections.Generic.IEnumerable%601>, o qual tem um único parâmetro de tipo covariante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-146"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="dfe49-147">O parâmetro de tipo covariante é a razão pela qual uma instância de `IEnumerable<Derived>` pode ser usada em vez de `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-147">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-type-parameters"></a><span data-ttu-id="dfe49-148">Interfaces genéricas com parâmetros de tipo contravariant</span><span class="sxs-lookup"><span data-stu-id="dfe49-148">Generic interfaces with contravariant type parameters</span></span>

<span data-ttu-id="dfe49-149">Várias interfaces genéricas têm parâmetros de tipo contravariant; por exemplo: <xref:System.Collections.Generic.IComparer%601> , <xref:System.IComparable%601> e <xref:System.Collections.Generic.IEqualityComparer%601> .</span><span class="sxs-lookup"><span data-stu-id="dfe49-149">Several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="dfe49-150">Essas interfaces possuem apenas parâmetros de tipo contravariantes. Assim, os parâmetros de tipo são usados apenas como parâmetros de tipo nos membros das interfaces.</span><span class="sxs-lookup"><span data-stu-id="dfe49-150">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="dfe49-151">O exemplo a seguir ilustra parâmetros de tipo contravariantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-151">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="dfe49-152">O exemplo define uma classe abstrata (`MustInherit` no Visual Basic) `Shape` com uma propriedade `Area`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-152">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="dfe49-153">O exemplo também define uma classe `ShapeAreaComparer` que implementa `IComparer<Shape>` (`IComparer(Of Shape)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dfe49-153">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="dfe49-154">A implementação do método <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> baseia-se no valor da propriedade `Area`, portanto `ShapeAreaComparer` pode ser usado para classificar objetos `Shape` por área.</span><span class="sxs-lookup"><span data-stu-id="dfe49-154">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="dfe49-155">A classe `Circle` herda `Shape` e substitui `Area`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-155">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="dfe49-156">O exemplo cria um <xref:System.Collections.Generic.SortedSet%601> de objetos `Circle` usando um construtor que usa `IComparer<Circle>` (`IComparer(Of Circle)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dfe49-156">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="dfe49-157">Porém, em vez de passar um `IComparer<Circle>`, o exemplo passa um objeto `ShapeAreaComparer` que implementa `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-157">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="dfe49-158">O exemplo pode passar um comparador de um tipo derivado (`Shape`) quando um código chama um comparador de um tipo mais derivado (`Circle`) porque o parâmetro de tipo da interface genérica <xref:System.Collections.Generic.IComparer%601> é contravariante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-158">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="dfe49-159">Quando um novo objeto `Circle` é adicionado a `SortedSet<Circle>`, o método `IComparer<Shape>.Compare` (método `IComparer(Of Shape).Compare` no Visual Basic) do objeto `ShapeAreaComparer` é chamado sempre que um novo elemento é comparado a um elemento existente.</span><span class="sxs-lookup"><span data-stu-id="dfe49-159">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="dfe49-160">O tipo de parâmetro do método (`Shape`) é menos derivado que o tipo que está sendo passado (`Circle`). Assim, a chamada é de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="dfe49-160">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="dfe49-161">A contravariância permite que `ShapeAreaComparer` classifique uma coleção de um único tipo, bem como uma coleção mista de tipos, que deriva de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-161">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="dfe49-162">Delegados genéricos com parâmetros de tipo Variant</span><span class="sxs-lookup"><span data-stu-id="dfe49-162">Generic delegates with variant type parameters</span></span>

<span data-ttu-id="dfe49-163">Os `Func` delegados genéricos, como <xref:System.Func%602> , têm tipos de retorno covariantes e tipos de parâmetro contravariant.</span><span class="sxs-lookup"><span data-stu-id="dfe49-163">The `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="dfe49-164">Os delegados genéricos `Action`, como <xref:System.Action%602>, possuem tipos de parâmetros contravariantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-164">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="dfe49-165">Isso significa que os delegados podem ser atribuídos a variáveis que possuem tipos de parâmetro mais derivados e (no caso dos delegados genéricos `Func`) menos tipos de retorno derivados.</span><span class="sxs-lookup"><span data-stu-id="dfe49-165">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="dfe49-166">O último parâmetro de tipo genérico dos delegados genéricos `Func` especifica o tipo do valor de retorno na assinatura do delegado.</span><span class="sxs-lookup"><span data-stu-id="dfe49-166">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="dfe49-167">É covariante (palavra-chave `out`), enquanto os outros parâmetros de tipo genéricos são contravariantes (palavra-chave `in`).</span><span class="sxs-lookup"><span data-stu-id="dfe49-167">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="dfe49-168">O código a seguir ilustra isso.</span><span class="sxs-lookup"><span data-stu-id="dfe49-168">The following code illustrates this.</span></span> <span data-ttu-id="dfe49-169">O primeiro trecho de código define uma classe chamada `Base`, uma classe chamada `Derived` que herda `Base` e outra classe com um método `static` (`Shared` no Visual Basic) chamado `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-169">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="dfe49-170">O método usa uma instância de `Base` e retorna uma instância de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-170">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="dfe49-171">(Se o argumento for uma instância do `Derived` , o `MyMethod` retornará; se o argumento for uma instância do `Base` , o `MyMethod` retornará uma nova instância do `Derived` .) No `Main()` , o exemplo cria uma instância de `Func<Base, Derived>` ( `Func(Of Base, Derived)` em Visual Basic) que representa `MyMethod` e a armazena na variável `f1` .</span><span class="sxs-lookup"><span data-stu-id="dfe49-171">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="dfe49-172">O segundo trecho de código a seguir mostra que o delegado pode ser atribuído a uma variável do tipo `Func<Base, Base>` (`Func(Of Base, Base)` no Visual Basic) porque o tipo de retorno é covariante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-172">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="dfe49-173">O terceiro trecho de código a seguir mostra que o delegado pode ser atribuído a uma variável do tipo `Func<Derived, Derived>` (`Func(Of Derived, Derived)` no Visual Basic) porque o tipo de parâmetro é contravariante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-173">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="dfe49-174">O trecho final de código mostra que o delegado pode ser atribuído a uma variável de tipo `Func<Derived, Base>` (`Func(Of Derived, Base)` no Visual Basic), combinando os efeitos do tipo de parâmetro contravariante e do tipo de retorno covariante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-174">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-non-generic-delegates"></a><span data-ttu-id="dfe49-175">Variação em delegados não genéricos</span><span class="sxs-lookup"><span data-stu-id="dfe49-175">Variance in non-generic delegates</span></span>

 <span data-ttu-id="dfe49-176">No código anterior, a assinatura de `MyMethod` corresponde exatamente à assinatura do delegado genérico construído: `Func<Base, Derived>` (`Func(Of Base, Derived)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dfe49-176">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="dfe49-177">O exemplo mostra que esse delegado genérico pode ser armazenado em variáveis ou parâmetros do método que têm tipos de parâmetro mais derivados e tipos de retorno menos derivados, desde que todos os tipos de delegados sejam construídos do tipo de delegado genérico <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="dfe49-177">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="dfe49-178">Este é um aspecto importante.</span><span class="sxs-lookup"><span data-stu-id="dfe49-178">This is an important point.</span></span> <span data-ttu-id="dfe49-179">Os efeitos da covariância e da contravariância nos parâmetros de tipo de delegados genéricos são semelhantes aos efeitos da covariância e da contravariância na associação comum de delegação (confira [Variância em delegados (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) e [Variância em delegados (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="dfe49-179">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="dfe49-180">No entanto, a variância na associação de delegados funciona com todos os tipos de delegados, e não apenas com tipos de delegados genéricos com parâmetros de tipo variantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-180">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="dfe49-181">Além disso, a variância na associação de delegados possibilita a um método a ser associado a qualquer delegado que tenha os tipos de parâmetro mais restritivos e um tipo de retorno menos restritivo, enquanto que a atribuição de delegados genéricos só funciona quando ambos os tipos de delegados são construídos da mesma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="dfe49-181">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="dfe49-182">O exemplo a seguir mostra os efeitos combinados da variância na associação de delegados e a variância em parâmetros de tipo genéricos.</span><span class="sxs-lookup"><span data-stu-id="dfe49-182">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="dfe49-183">O exemplo define uma hierarquia de tipo que inclui três tipos, do menos derivado (`Type1`) para o mais derivado (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="dfe49-183">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="dfe49-184">A variância na associação comum de delegados é usada para associar um método a um tipo de parâmetro `Type1` e um tipo de retorno `Type3` a um representante genérico com um tipo de parâmetro `Type2` e um tipo de retorno `Type2`.</span><span class="sxs-lookup"><span data-stu-id="dfe49-184">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="dfe49-185">O delegado genérico resultante é então atribuído a outra variável cujo tipo de delegado genérico possui um parâmetro de tipo `Type3` e tipo de retorno `Type1`, usando a covariância e a contravariância de parâmetros de tipo genéricos.</span><span class="sxs-lookup"><span data-stu-id="dfe49-185">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="dfe49-186">A segunda atribuição requer que o tipo de variável e o tipo de delegado sejam construídos a partir da mesma definição de tipo genérico, nesse caso, <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="dfe49-186">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="define-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="dfe49-187">Definir interfaces e delegados genéricos variantes</span><span class="sxs-lookup"><span data-stu-id="dfe49-187">Define variant generic interfaces and delegates</span></span>

<span data-ttu-id="dfe49-188">Visual Basic e C# têm palavras-chave que permitem marcar os parâmetros de tipo genérico de interfaces e delegados como covariant ou contravariant.</span><span class="sxs-lookup"><span data-stu-id="dfe49-188">Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>
  
 <span data-ttu-id="dfe49-189">Um parâmetro de tipo covariant é marcado com a `out` palavra-chave ( `Out` keyword em Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dfe49-189">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic).</span></span> <span data-ttu-id="dfe49-190">Você pode usar um parâmetro de tipo covariante como o valor de retorno de um método que pertence a uma interface ou como o tipo de retorno de um delegado.</span><span class="sxs-lookup"><span data-stu-id="dfe49-190">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="dfe49-191">Você não pode usar um parâmetro de tipo covariante como uma restrição de tipo genérico para métodos de interface.</span><span class="sxs-lookup"><span data-stu-id="dfe49-191">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="dfe49-192">Se um método de uma interface tem um parâmetro que é um tipo de delegado genérico, um parâmetro de tipo covariante do tipo da interface pode ser usado para especificar um parâmetro de tipo contravariante do tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="dfe49-192">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="dfe49-193">Um parâmetro de tipo contravariant é marcado com a `in` palavra-chave ( `In` palavra-chave em Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dfe49-193">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic).</span></span> <span data-ttu-id="dfe49-194">Você pode usar um parâmetro de tipo contravariante como o tipo de um parâmetro de um método que pertence a uma interface ou como o tipo de um parâmetro de um delegado.</span><span class="sxs-lookup"><span data-stu-id="dfe49-194">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="dfe49-195">Você pode usar um parâmetro de tipo contravariante como uma restrição de tipo genérico para um método de interface.</span><span class="sxs-lookup"><span data-stu-id="dfe49-195">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="dfe49-196">Somente tipos de interfaces e tipos de delegados podem ter parâmetros de tipo variantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-196">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="dfe49-197">Um tipo de delegado ou interface pode ter parâmetros de tipo covariantes e contravariantes.</span><span class="sxs-lookup"><span data-stu-id="dfe49-197">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="dfe49-198">O Visual Basic e o C# e não permitem que você viole as regras de uso de parâmetros de tipo covariantes e contravariantes nem adicionar anotações de covariância e de contravariância aos parâmetros de tipo de tipos que não sejam interfaces e delegados.</span><span class="sxs-lookup"><span data-stu-id="dfe49-198">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span>
  
 <span data-ttu-id="dfe49-199">Para obter mais informações e códigos de exemplo, confira [Variação em interfaces genéricas (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) e [Variação em interfaces genéricas (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="dfe49-199">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-types"></a><span data-ttu-id="dfe49-200">Lista de tipos</span><span class="sxs-lookup"><span data-stu-id="dfe49-200">List of types</span></span>

<span data-ttu-id="dfe49-201">Os seguintes tipos de interface e delegado têm parâmetros de tipo covariant e/ou contravariant.</span><span class="sxs-lookup"><span data-stu-id="dfe49-201">The following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="dfe49-202">Tipo</span><span class="sxs-lookup"><span data-stu-id="dfe49-202">Type</span></span>|<span data-ttu-id="dfe49-203">Parâmetros de tipo covariantes</span><span class="sxs-lookup"><span data-stu-id="dfe49-203">Covariant type parameters</span></span>|<span data-ttu-id="dfe49-204">Parâmetros de tipo contravariantes</span><span class="sxs-lookup"><span data-stu-id="dfe49-204">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="dfe49-205"><xref:System.Action%601> em <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="dfe49-205"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="dfe49-206">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-206">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="dfe49-207">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-207">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="dfe49-208">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-208">Yes</span></span>|<span data-ttu-id="dfe49-209">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-209">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="dfe49-210">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-210">Yes</span></span>||  
|<span data-ttu-id="dfe49-211"><xref:System.Func%602> em <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="dfe49-211"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="dfe49-212">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-212">Yes</span></span>|<span data-ttu-id="dfe49-213">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-213">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="dfe49-214">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-214">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="dfe49-215">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="dfe49-216">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-216">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="dfe49-217">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="dfe49-218">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-218">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="dfe49-219">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-219">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="dfe49-220">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="dfe49-221">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-221">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="dfe49-222">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-222">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="dfe49-223">Sim</span><span class="sxs-lookup"><span data-stu-id="dfe49-223">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="dfe49-224">Consulte também</span><span class="sxs-lookup"><span data-stu-id="dfe49-224">See also</span></span>

- [<span data-ttu-id="dfe49-225">Covariância e contravariância (C#)</span><span class="sxs-lookup"><span data-stu-id="dfe49-225">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="dfe49-226">Covariância e contravariância (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="dfe49-226">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="dfe49-227">Variação em delegados (C#)</span><span class="sxs-lookup"><span data-stu-id="dfe49-227">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="dfe49-228">Variação em delegados (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="dfe49-228">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
