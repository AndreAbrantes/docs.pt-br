---
title: Escolhendo entre a classe e Struct
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: KrzysztofCwalina
ms.openlocfilehash: a47e43b2387362500d46c8e531f16d004d823c4c
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54565859"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="ce73e-102">Escolhendo entre a classe e Struct</span><span class="sxs-lookup"><span data-stu-id="ce73e-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="ce73e-103">Uma das decisões de design básica que faces cada designer de estrutura é se deseja criar um tipo como uma classe (um tipo de referência) ou como um struct (um tipo de valor).</span><span class="sxs-lookup"><span data-stu-id="ce73e-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="ce73e-104">Boa compreensão das diferenças no comportamento dos tipos de referência e tipos de valor é fundamental para fazer essa escolha.</span><span class="sxs-lookup"><span data-stu-id="ce73e-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="ce73e-105">A primeira diferença entre os tipos de referência e tipos de valor, consideraremos é que tipos de referência são alocados no heap e coleta de lixo, ao passo que tipos de valor são alocados na pilha ou embutido no que contém tipos e desalocada quando a pilha esvazia ou quando seu tipo recipiente é desalocado.</span><span class="sxs-lookup"><span data-stu-id="ce73e-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="ce73e-106">Portanto, as alocações e Desalocações de tipos de valor são em geral, mais barato do que as alocações e Desalocações de tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="ce73e-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="ce73e-107">Em seguida, matrizes de referência de tipos são alocados fora de linha, que significa que a matriz de elementos são referências apenas para as instâncias do tipo de referência que residem no heap.</span><span class="sxs-lookup"><span data-stu-id="ce73e-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="ce73e-108">Matrizes de tipo de valor são alocados em linha, que significa que os elementos da matriz são as instâncias reais do tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="ce73e-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="ce73e-109">Portanto, as alocações e Desalocações de matrizes de tipo de valor são muito mais baratas do que as alocações e Desalocações de matrizes de tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="ce73e-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="ce73e-110">Além disso, na maioria dos casos, as matrizes de tipo de valor apresentam muito melhor localidade de referência.</span><span class="sxs-lookup"><span data-stu-id="ce73e-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="ce73e-111">A próxima diferença está relacionada ao uso de memória.</span><span class="sxs-lookup"><span data-stu-id="ce73e-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="ce73e-112">Tipos de valor obterem box quando convertido em um tipo de referência ou uma das interfaces que elas implementam.</span><span class="sxs-lookup"><span data-stu-id="ce73e-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="ce73e-113">Eles obtêm desconvertidos ao converter para o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="ce73e-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="ce73e-114">Como caixas são objetos que são alocados no heap e coleta de lixo, muito com conversão boxing e unboxing pode ter um impacto negativo sobre o heap, o coletor de lixo e, por fim, o desempenho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="ce73e-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="ce73e-115">Por outro lado, não há tal conversão boxing ocorre como tipos de referência são convertidos.</span><span class="sxs-lookup"><span data-stu-id="ce73e-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="ce73e-116">(Para obter mais informações, consulte [conversão Boxing e Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="ce73e-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="ce73e-117">Em seguida, as atribuições de tipo de referência copiar a referência, enquanto as atribuições de tipo de valor copie o valor inteiro.</span><span class="sxs-lookup"><span data-stu-id="ce73e-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="ce73e-118">Portanto, as atribuições de tipos de referência grandes são mais baratas do que as atribuições de tipos de valor grande.</span><span class="sxs-lookup"><span data-stu-id="ce73e-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="ce73e-119">Por fim, os tipos de referência são passados por referência, enquanto que os tipos de valor são passados por valor.</span><span class="sxs-lookup"><span data-stu-id="ce73e-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="ce73e-120">As alterações a uma instância de um tipo de referência afetam todas as referências que apontam para a instância.</span><span class="sxs-lookup"><span data-stu-id="ce73e-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="ce73e-121">Instâncias do tipo de valor são copiadas quando eles são passados por valor.</span><span class="sxs-lookup"><span data-stu-id="ce73e-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="ce73e-122">Quando uma instância de um tipo de valor é alterada, ele certamente não afeta qualquer uma das suas cópias.</span><span class="sxs-lookup"><span data-stu-id="ce73e-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="ce73e-123">Como as cópias não são criadas explicitamente pelo usuário, mas são criadas implicitamente quando os argumentos são passados ou retornam os valores são retornados, tipos de valor que podem ser alterados podem ser confusos para muitos usuários.</span><span class="sxs-lookup"><span data-stu-id="ce73e-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="ce73e-124">Portanto, os tipos de valor devem ser imutáveis.</span><span class="sxs-lookup"><span data-stu-id="ce73e-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="ce73e-125">Como regra geral, a maioria dos tipos em uma estrutura deve ser classes.</span><span class="sxs-lookup"><span data-stu-id="ce73e-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="ce73e-126">No entanto, há algumas situações em que as características de um tipo de valor torná-lo mais apropriado usar structs.</span><span class="sxs-lookup"><span data-stu-id="ce73e-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="ce73e-127">**✓ CONSIDER** definindo um struct, em vez de uma classe, se as instâncias do tipo são pequena e geralmente curta duração ou geralmente são inseridas em outros objetos.</span><span class="sxs-lookup"><span data-stu-id="ce73e-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="ce73e-128">**X AVOID** definindo uma estrutura, a menos que o tipo tem todas as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="ce73e-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
-   <span data-ttu-id="ce73e-129">Logicamente, ele representa um único valor, semelhante aos tipos primitivos (`int`, `double`, etc.).</span><span class="sxs-lookup"><span data-stu-id="ce73e-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
-   <span data-ttu-id="ce73e-130">Ele tem um tamanho de instância em 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="ce73e-130">It has an instance size under 16 bytes.</span></span>  
  
-   <span data-ttu-id="ce73e-131">É imutável.</span><span class="sxs-lookup"><span data-stu-id="ce73e-131">It is immutable.</span></span>  
  
-   <span data-ttu-id="ce73e-132">Ele não terá a ser demarcado com frequência.</span><span class="sxs-lookup"><span data-stu-id="ce73e-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="ce73e-133">Em todos os outros casos, você deve definir seus tipos como classes.</span><span class="sxs-lookup"><span data-stu-id="ce73e-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="ce73e-134">*Portions © 2005, 2009 Microsoft Corporation. Todos os direitos reservados.*</span><span class="sxs-lookup"><span data-stu-id="ce73e-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="ce73e-135">*Reimpresso com permissão da Pearson Education, Inc. de [as diretrizes de Design do Framework: As convenções, linguagens e padrões para bibliotecas do .NET reutilizável, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) por Krzysztof Cwalina e Brad Abrams, publicados 22 de outubro de 2008 pela Addison-Wesley Professional, como parte da série de desenvolvimento do Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="ce73e-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ce73e-136">Consulte também</span><span class="sxs-lookup"><span data-stu-id="ce73e-136">See also</span></span>

- [<span data-ttu-id="ce73e-137">Diretrizes de Design de tipo</span><span class="sxs-lookup"><span data-stu-id="ce73e-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)
- [<span data-ttu-id="ce73e-138">Diretrizes de design do Framework</span><span class="sxs-lookup"><span data-stu-id="ce73e-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
