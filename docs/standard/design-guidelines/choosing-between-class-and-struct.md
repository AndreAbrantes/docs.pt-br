---
title: Escolher entre Classe e Struct
description: Saiba como decidir se deseja criar um tipo como uma classe ou criar um tipo como uma estrutura. Entenda como tipos de referência e tipos de valor diferem no .NET.
ms.date: 10/22/2008
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
ms.openlocfilehash: b1f3d36f4a9b6e44451a8534ca79fb674071a955
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94821470"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="b59c1-104">Escolher entre Classe e Struct</span><span class="sxs-lookup"><span data-stu-id="b59c1-104">Choosing Between Class and Struct</span></span>
<span data-ttu-id="b59c1-105">Uma das decisões básicas de design que cada designer de estrutura enfrenta é se deve criar um tipo como uma classe (um tipo de referência) ou como uma struct (um tipo de valor).</span><span class="sxs-lookup"><span data-stu-id="b59c1-105">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="b59c1-106">Uma boa compreensão das diferenças no comportamento dos tipos de referência e dos tipos de valor é crucial para fazer essa escolha.</span><span class="sxs-lookup"><span data-stu-id="b59c1-106">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>

 <span data-ttu-id="b59c1-107">A primeira diferença entre os tipos de referência e os tipos de valor que consideraremos é que os tipos de referência são alocados no heap e no lixo coletado, enquanto os tipos de valor são alocados na pilha ou embutidos em tipos contendo e desalocados quando a pilha se desenrola ou quando seu tipo recipiente é desalocado.</span><span class="sxs-lookup"><span data-stu-id="b59c1-107">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="b59c1-108">Portanto, alocações e desalocações de tipos de valor são em geral mais baratas do que as alocações e desalocações de tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="b59c1-108">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>

 <span data-ttu-id="b59c1-109">Em seguida, as matrizes dos tipos de referência são alocadas fora de linha, o que significa que os elementos da matriz são apenas referências a instâncias do tipo de referência que residem no heap.</span><span class="sxs-lookup"><span data-stu-id="b59c1-109">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="b59c1-110">Matrizes de tipo de valor são alocadas embutidas, o que significa que os elementos da matriz são as instâncias reais do tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="b59c1-110">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="b59c1-111">Portanto, alocações e desalocações de matrizes de tipo de valor são muito mais baratas do que as alocações e desalocações de matrizes de tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="b59c1-111">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="b59c1-112">Além disso, na maioria das vezes, as matrizes de tipo de valor apresentam uma localidade muito melhor de referência.</span><span class="sxs-lookup"><span data-stu-id="b59c1-112">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>

 <span data-ttu-id="b59c1-113">A próxima diferença está relacionada ao uso de memória.</span><span class="sxs-lookup"><span data-stu-id="b59c1-113">The next difference is related to memory usage.</span></span> <span data-ttu-id="b59c1-114">Os tipos de valor ficam na caixa quando são convertidos em um tipo de referência ou em uma das interfaces que implementam.</span><span class="sxs-lookup"><span data-stu-id="b59c1-114">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="b59c1-115">Eles ficam inativos ao converter de volta para o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="b59c1-115">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="b59c1-116">Como as caixas são objetos alocados no heap e são coletadas com lixo, muitas boxing e unboxing podem ter um impacto negativo sobre o heap, o coletor de lixo e, por fim, o desempenho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b59c1-116">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="b59c1-117">Por outro lado, nenhuma Boxing ocorre conforme os tipos de referência são convertidos.</span><span class="sxs-lookup"><span data-stu-id="b59c1-117">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="b59c1-118">(Para obter mais informações, consulte [boxing e unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="b59c1-118">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>

 <span data-ttu-id="b59c1-119">Em seguida, atribuições de tipo de referência copiam a referência, enquanto atribuições de tipo de valor copiam o valor inteiro.</span><span class="sxs-lookup"><span data-stu-id="b59c1-119">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="b59c1-120">Portanto, as atribuições de tipos de referência grandes são mais baratas do que as atribuições de tipos de valor grande.</span><span class="sxs-lookup"><span data-stu-id="b59c1-120">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>

 <span data-ttu-id="b59c1-121">Por fim, os tipos de referência são passados por referência, enquanto os tipos de valor são passados por valor.</span><span class="sxs-lookup"><span data-stu-id="b59c1-121">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="b59c1-122">As alterações em uma instância de um tipo de referência afetam todas as referências que apontam para a instância.</span><span class="sxs-lookup"><span data-stu-id="b59c1-122">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="b59c1-123">As instâncias de tipo de valor são copiadas quando são passadas por valor.</span><span class="sxs-lookup"><span data-stu-id="b59c1-123">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="b59c1-124">Quando uma instância de um tipo de valor é alterada, é claro que não afeta nenhuma de suas cópias.</span><span class="sxs-lookup"><span data-stu-id="b59c1-124">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="b59c1-125">Como as cópias não são criadas explicitamente pelo usuário, mas são criadas implicitamente quando argumentos são passados ou valores de retorno são retornados, os tipos de valor que podem ser alterados podem ser confusos para muitos usuários.</span><span class="sxs-lookup"><span data-stu-id="b59c1-125">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="b59c1-126">Portanto, os tipos de valor devem ser imutáveis.</span><span class="sxs-lookup"><span data-stu-id="b59c1-126">Therefore, value types should be immutable.</span></span>

 <span data-ttu-id="b59c1-127">Como regra geral, a maioria dos tipos em uma estrutura deve ser classes.</span><span class="sxs-lookup"><span data-stu-id="b59c1-127">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="b59c1-128">No entanto, há algumas situações em que as características de um tipo de valor tornam mais apropriado o uso de structs.</span><span class="sxs-lookup"><span data-stu-id="b59c1-128">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>

 <span data-ttu-id="b59c1-129">✔️ CONSIDERAR a definição de uma struct em vez de uma classe se as instâncias do tipo forem pequenas e geralmente de curta duração ou se forem normalmente inseridas em outros objetos.</span><span class="sxs-lookup"><span data-stu-id="b59c1-129">✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>

 <span data-ttu-id="b59c1-130">❌ Evite definir uma struct, a menos que o tipo tenha todas as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="b59c1-130">❌ AVOID defining a struct unless the type has all of the following characteristics:</span></span>

- <span data-ttu-id="b59c1-131">Ele representa logicamente um único valor, semelhante a tipos primitivos ( `int` , `double` , etc.).</span><span class="sxs-lookup"><span data-stu-id="b59c1-131">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>

- <span data-ttu-id="b59c1-132">Ele tem um tamanho de instância inferior a 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="b59c1-132">It has an instance size under 16 bytes.</span></span>

- <span data-ttu-id="b59c1-133">É imutável.</span><span class="sxs-lookup"><span data-stu-id="b59c1-133">It is immutable.</span></span>

- <span data-ttu-id="b59c1-134">Ele não precisará ser emoldurado com frequência.</span><span class="sxs-lookup"><span data-stu-id="b59c1-134">It will not have to be boxed frequently.</span></span>

 <span data-ttu-id="b59c1-135">Em todos os outros casos, você deve definir seus tipos como classes.</span><span class="sxs-lookup"><span data-stu-id="b59c1-135">In all other cases, you should define your types as classes.</span></span>

 <span data-ttu-id="b59c1-136">*Partes © 2005, 2009 Microsoft Corporation. Todos os direitos reservados.*</span><span class="sxs-lookup"><span data-stu-id="b59c1-136">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="b59c1-137">*Reimpresso com permissão da Pearson Education, Inc. das [Diretrizes de Design do Framework: convenções, linguagens e padrões para bibliotecas do .NET reutilizável, 2ª edição](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) por Krzysztof Cwalina e Brad Abrams, publicado em 22 de outubro de 2008 por Addison-Wesley Professional como parte da série de desenvolvimento do Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="b59c1-137">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="b59c1-138">Confira também</span><span class="sxs-lookup"><span data-stu-id="b59c1-138">See also</span></span>

- [<span data-ttu-id="b59c1-139">Diretrizes de design de tipo</span><span class="sxs-lookup"><span data-stu-id="b59c1-139">Type Design Guidelines</span></span>](type.md)
- [<span data-ttu-id="b59c1-140">Diretrizes de design de estrutura</span><span class="sxs-lookup"><span data-stu-id="b59c1-140">Framework Design Guidelines</span></span>](index.md)
