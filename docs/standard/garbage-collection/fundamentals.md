---
title: Noções básicas da coleta de lixo
description: Saiba como o coletor de lixo funciona e como ele pode ser configurado para ter um desempenho ideal.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: 322e079a1be556efb536b24e216e480c1950bd8c
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/07/2020
ms.locfileid: "87917020"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="b8078-103">Noções básicas da coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="b8078-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="b8078-104">No Common Language Runtime (CLR), o coletor de lixo (GC) serve como um Gerenciador de memória automático.</span><span class="sxs-lookup"><span data-stu-id="b8078-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="b8078-105">O coletor de lixo gerencia a alocação e o lançamento da memória para um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b8078-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="b8078-106">Para os desenvolvedores que trabalham com código gerenciado, isso significa que você não precisa escrever código para executar tarefas de gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="b8078-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="b8078-107">O gerenciamento automático de memória pode eliminar problemas comuns, como esquecer de liberar um objeto e causar um vazamento de memória ou tentar acessar a memória de um objeto que já foi liberado.</span><span class="sxs-lookup"><span data-stu-id="b8078-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="b8078-108">Este artigo descreve os principais conceitos da coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="b8078-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="b8078-109">Vantagens</span><span class="sxs-lookup"><span data-stu-id="b8078-109">Benefits</span></span>

<span data-ttu-id="b8078-110">O coletor de lixo fornece os seguintes benefícios:</span><span class="sxs-lookup"><span data-stu-id="b8078-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="b8078-111">Libera os desenvolvedores de terem que liberar memória manualmente.</span><span class="sxs-lookup"><span data-stu-id="b8078-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="b8078-112">Aloca objetos no heap gerenciado com eficiência.</span><span class="sxs-lookup"><span data-stu-id="b8078-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="b8078-113">Recupera os objetos que não estão sendo usados, limpa a memória e mantém a memória disponível para alocações futuras.</span><span class="sxs-lookup"><span data-stu-id="b8078-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="b8078-114">Os objetos gerenciados obtêm automaticamente conteúdo limpo para começar, de modo que seus construtores não precisam inicializar todos os campos de dados.</span><span class="sxs-lookup"><span data-stu-id="b8078-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="b8078-115">Fornece segurança de memória, assegurando que um objeto não possa usar o conteúdo de outro objeto.</span><span class="sxs-lookup"><span data-stu-id="b8078-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="b8078-116">Conceitos básicos de memória</span><span class="sxs-lookup"><span data-stu-id="b8078-116">Fundamentals of memory</span></span>

<span data-ttu-id="b8078-117">A lista a seguir resume conceitos importantes de memória do CLR.</span><span class="sxs-lookup"><span data-stu-id="b8078-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="b8078-118">Cada processo tem seu próprio espaço de endereço virtual separado.</span><span class="sxs-lookup"><span data-stu-id="b8078-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="b8078-119">Todos os processos no mesmo computador compartilham a mesma memória física e o arquivo de paginação, se houver um.</span><span class="sxs-lookup"><span data-stu-id="b8078-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="b8078-120">Por padrão, em computadores de 32 bits, cada processo tem um espaço de endereço virtual no modo de usuário de 2 GB.</span><span class="sxs-lookup"><span data-stu-id="b8078-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="b8078-121">Como desenvolvedor de aplicativos, você trabalha apenas com o espaço de endereço virtual e nunca manipula a memória física diretamente.</span><span class="sxs-lookup"><span data-stu-id="b8078-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="b8078-122">O coletor de lixo aloca e libera memória virtual para você no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="b8078-123">Se você estiver escrevendo código nativo, use as funções do Windows para trabalhar com o espaço de endereço virtual.</span><span class="sxs-lookup"><span data-stu-id="b8078-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="b8078-124">Essas funções alocam e liberam memória virtual para você em heaps nativos.</span><span class="sxs-lookup"><span data-stu-id="b8078-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="b8078-125">A memória virtual pode estar em três estados:</span><span class="sxs-lookup"><span data-stu-id="b8078-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="b8078-126">Estado</span><span class="sxs-lookup"><span data-stu-id="b8078-126">State</span></span> | <span data-ttu-id="b8078-127">Descrição</span><span class="sxs-lookup"><span data-stu-id="b8078-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="b8078-128">Grátis</span><span class="sxs-lookup"><span data-stu-id="b8078-128">Free</span></span> | <span data-ttu-id="b8078-129">O bloco de memória não tem referências a ele e está disponível para alocação.</span><span class="sxs-lookup"><span data-stu-id="b8078-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="b8078-130">Reservado</span><span class="sxs-lookup"><span data-stu-id="b8078-130">Reserved</span></span> | <span data-ttu-id="b8078-131">O bloco de memória está disponível para seu uso e não pode ser usado para nenhuma outra solicitação de alocação.</span><span class="sxs-lookup"><span data-stu-id="b8078-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="b8078-132">No entanto, você não pode armazenar dados nesse bloco de memória até que ele esteja comprometido.</span><span class="sxs-lookup"><span data-stu-id="b8078-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="b8078-133">Confirmado</span><span class="sxs-lookup"><span data-stu-id="b8078-133">Committed</span></span> | <span data-ttu-id="b8078-134">O bloco de memória é atribuído para armazenamento físico.</span><span class="sxs-lookup"><span data-stu-id="b8078-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="b8078-135">O espaço de endereço virtual pode ficar fragmentado.</span><span class="sxs-lookup"><span data-stu-id="b8078-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="b8078-136">Isso significa que há blocos livres, também conhecido como furos, no espaço de endereço.</span><span class="sxs-lookup"><span data-stu-id="b8078-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="b8078-137">Quando uma alocação de memória virtual é solicitada, o gerenciador de memória virtual precisa localizar um único bloco livre suficientemente grande para atender a essa solicitação de alocação.</span><span class="sxs-lookup"><span data-stu-id="b8078-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="b8078-138">Mesmo que você tenha 2 GB de espaço livre, uma alocação que requer 2 GB não será bem-sucedida, a menos que todo o espaço livre esteja em um único bloco de endereço.</span><span class="sxs-lookup"><span data-stu-id="b8078-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="b8078-139">Você pode ficar sem memória se não houver espaço de endereço virtual suficiente para reservar ou espaço físico para confirmar.</span><span class="sxs-lookup"><span data-stu-id="b8078-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="b8078-140">O arquivo de paginação é usado mesmo se a pressão de memória física (ou seja, a demanda de memória física) estiver baixa.</span><span class="sxs-lookup"><span data-stu-id="b8078-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="b8078-141">Na primeira vez em que a pressão de memória física é alta, o sistema operacional deve liberar espaço na memória física para armazenar dados e faz backup de alguns dos dados que estão na memória física para o arquivo de paginação.</span><span class="sxs-lookup"><span data-stu-id="b8078-141">The first time that physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="b8078-142">Esses dados não são paginados até que seja necessário, portanto, é possível encontrar paginação em situações em que a pressão da memória física está baixa.</span><span class="sxs-lookup"><span data-stu-id="b8078-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="b8078-143">Alocação de memória</span><span class="sxs-lookup"><span data-stu-id="b8078-143">Memory allocation</span></span>

<span data-ttu-id="b8078-144">Quando você inicializa um novo processo, o runtime reserva uma região contígua de espaço de endereço para o processo.</span><span class="sxs-lookup"><span data-stu-id="b8078-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="b8078-145">Esse espaço de endereço reservado é chamado de heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="b8078-146">O heap gerenciado mantém um ponteiro para o endereço no qual o próximo objeto do heap será alocado.</span><span class="sxs-lookup"><span data-stu-id="b8078-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="b8078-147">Inicialmente, esse ponteiro é definido como o endereço básico do heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="b8078-148">Todos os tipos de referência são alocados no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="b8078-149">Quando um aplicativo cria o primeiro tipo de referência, a memória é alocada para o tipo no endereço base do heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="b8078-150">Quando o aplicativo cria o próximo objeto, o coletor de lixo aloca memória para ele no espaço de endereço logo depois do primeiro objeto.</span><span class="sxs-lookup"><span data-stu-id="b8078-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="b8078-151">Desde que exista espaço de endereço disponível, o coletor de lixo continua alocando espaço para novos objetos dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="b8078-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="b8078-152">A alocação memória com base no heap gerenciado é mais rápida do que a alocação de memória não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="b8078-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="b8078-153">Como o tempo de execução aloca memória para um objeto adicionando um valor a um ponteiro, é quase tão rápido quanto alocar memória da pilha.</span><span class="sxs-lookup"><span data-stu-id="b8078-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="b8078-154">Além disso, como novos objetos alocados consecutivamente são armazenados de forma contígua no heap gerenciado, um aplicativo pode acessar os objetos rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8078-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="b8078-155">Liberação de memória</span><span class="sxs-lookup"><span data-stu-id="b8078-155">Memory release</span></span>

<span data-ttu-id="b8078-156">O mecanismo de otimização do coletor de lixo determina o melhor momento para executar uma coleta com base nas alocações que estão sendo feitas.</span><span class="sxs-lookup"><span data-stu-id="b8078-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="b8078-157">Quando o coletor de lixo executa uma coleta, ele libera a memória dos objetos que não estão mais sendo usados pelo aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b8078-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="b8078-158">Ele determina quais objetos não estão mais sendo usados examinando as *raízes*do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b8078-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="b8078-159">As raízes de um aplicativo incluem campos estáticos, variáveis locais e parâmetros na pilha de um thread, além de registros de CPU.</span><span class="sxs-lookup"><span data-stu-id="b8078-159">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="b8078-160">Cada raiz refere-se a um objeto no heap gerenciado ou é definida como nula.</span><span class="sxs-lookup"><span data-stu-id="b8078-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="b8078-161">O coletor de lixo tem acesso à lista de raízes ativas mantidas pelo runtime e pelo compilador JIT (just-in-time).</span><span class="sxs-lookup"><span data-stu-id="b8078-161">The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</span></span> <span data-ttu-id="b8078-162">Usando essa lista, o coletor de lixo cria um grafo que contém todos os objetos que podem ser acessados por meio das raízes.</span><span class="sxs-lookup"><span data-stu-id="b8078-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="b8078-163">Objetos que não estão no gráfico são inacessíveis a partir das raízes do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b8078-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="b8078-164">O coletor de lixo considera o lixo dos objetos inacessíveis e libera a memória alocada para eles.</span><span class="sxs-lookup"><span data-stu-id="b8078-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="b8078-165">Durante uma coleta, o coletor de lixo examina o heap gerenciado, procurando os blocos de espaço de endereço ocupados por objetos inacessíveis.</span><span class="sxs-lookup"><span data-stu-id="b8078-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="b8078-166">Na medida em que descobre cada objeto inacessível, ele usa uma função de cópia de memória para compactar os objetos acessíveis na memória, liberando os blocos de espaços de endereço alocados para objetos inacessíveis.</span><span class="sxs-lookup"><span data-stu-id="b8078-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="b8078-167">Uma vez que a memória dos objetos acessíveis tenha sido compactada, o coletor de lixo faz as correções necessárias no ponteiro de forma que as raízes do aplicativo apontem para os objetos em seus novos locais.</span><span class="sxs-lookup"><span data-stu-id="b8078-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="b8078-168">Ele também posiciona o ponteiro do heap gerenciado após o último objeto acessível.</span><span class="sxs-lookup"><span data-stu-id="b8078-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="b8078-169">A memória é compactada somente se uma coleção descobre um número significativo de objetos inacessíveis.</span><span class="sxs-lookup"><span data-stu-id="b8078-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="b8078-170">Se todos os objetos no heap gerenciado sobrevivem a uma coleta, não há necessidade de compactação de memória.</span><span class="sxs-lookup"><span data-stu-id="b8078-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="b8078-171">Para melhorar o desempenho, o runtime aloca memória para objetos grandes em um heap separado.</span><span class="sxs-lookup"><span data-stu-id="b8078-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="b8078-172">O coletor de lixo automaticamente libera a memória para objetos grandes.</span><span class="sxs-lookup"><span data-stu-id="b8078-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="b8078-173">No entanto, para evitar a movimentação de objetos grandes na memória, essa memória geralmente não é compactada.</span><span class="sxs-lookup"><span data-stu-id="b8078-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="b8078-174">Condições para uma coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="b8078-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="b8078-175">A coleta de lixo ocorre quando uma das seguintes condições é verdadeira:</span><span class="sxs-lookup"><span data-stu-id="b8078-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="b8078-176">O sistema tem pouca memória física.</span><span class="sxs-lookup"><span data-stu-id="b8078-176">The system has low physical memory.</span></span> <span data-ttu-id="b8078-177">Isso é detectado pela notificação de memória insuficiente do sistema operacional ou memória insuficiente, conforme indicado pelo host.</span><span class="sxs-lookup"><span data-stu-id="b8078-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="b8078-178">A memória usada por objetos alocados no heap gerenciado ultrapassa um limite aceitável.</span><span class="sxs-lookup"><span data-stu-id="b8078-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="b8078-179">Esse limite é ajustado continuamente enquanto o processo é executado.</span><span class="sxs-lookup"><span data-stu-id="b8078-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="b8078-180">O método <xref:System.GC.Collect%2A?displayProperty=nameWithType> é chamado.</span><span class="sxs-lookup"><span data-stu-id="b8078-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="b8078-181">Em quase todos os casos, você não precisa chamar esse método, pois o coletor de lixo é executado continuamente.</span><span class="sxs-lookup"><span data-stu-id="b8078-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="b8078-182">Esse método é usado principalmente para situações exclusivas e testes.</span><span class="sxs-lookup"><span data-stu-id="b8078-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="b8078-183">O heap gerenciado</span><span class="sxs-lookup"><span data-stu-id="b8078-183">The managed heap</span></span>

<span data-ttu-id="b8078-184">Depois que o coletor de lixo é inicializado pelo CLR, ele aloca um segmento da memória para armazenar e gerenciar objetos.</span><span class="sxs-lookup"><span data-stu-id="b8078-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="b8078-185">Essa memória é chamada de heap gerenciado, em contraposição a um heap nativo no sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="b8078-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="b8078-186">Há um heap gerenciado para cada processo gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="b8078-187">Todos os threads no processo alocam memória para objetos no mesmo heap.</span><span class="sxs-lookup"><span data-stu-id="b8078-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="b8078-188">Para reservar memória, o coletor de lixo chama a função do Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) e reserva um segmento de memória por vez para aplicativos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="b8078-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="b8078-189">O coletor de lixo também reserva segmentos, conforme necessário, e libera segmentos de volta para o sistema operacional (depois de limpá-los de qualquer objeto) chamando a função [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) do Windows.</span><span class="sxs-lookup"><span data-stu-id="b8078-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b8078-190">O tamanho de segmentos alocados pelo coletor de lixo é específico da implementação e está sujeito a alterações a qualquer momento, incluindo em atualizações periódicas.</span><span class="sxs-lookup"><span data-stu-id="b8078-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="b8078-191">Seu aplicativo nunca deve fazer suposições sobre o tamanho de um segmento em particular nem depender dele, tampouco deve tentar configurar a quantidade de memória disponível para alocações de segmento.</span><span class="sxs-lookup"><span data-stu-id="b8078-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="b8078-192">Quanto menos objetos alocados no heap, menos trabalho o coletor de lixo precisa fazer.</span><span class="sxs-lookup"><span data-stu-id="b8078-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="b8078-193">Quando você aloca objetos, não usa valores arredondados que excedem suas necessidades, como alocar uma matriz de 32 bytes quando você precisa de apenas 15 bytes.</span><span class="sxs-lookup"><span data-stu-id="b8078-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="b8078-194">Quando uma coleta de lixo é disparada, o coletor de lixo recupera a memória ocupada por objetos mortos.</span><span class="sxs-lookup"><span data-stu-id="b8078-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="b8078-195">O processo de recuperação compacta objetos vivos para que eles sejam movidos juntos e o espaço inativo é removido, tornando o heap menor.</span><span class="sxs-lookup"><span data-stu-id="b8078-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="b8078-196">Isso garante que os objetos alocados juntos permaneçam juntos no heap gerenciado para preservar sua localidade.</span><span class="sxs-lookup"><span data-stu-id="b8078-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="b8078-197">O grau de intrusão (frequência e a duração) de coletas de lixo é o resultado do volume de alocações e da quantidade de memória restante no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="b8078-198">O heap pode ser considerado como o acúmulo de dois heaps: o [heap de objetos grandes](large-object-heap.md) e o heap de objetos pequenos.</span><span class="sxs-lookup"><span data-stu-id="b8078-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="b8078-199">A heap de objeto grande contém objetos que são 85.000 bytes e maiores, que geralmente são matrizes.</span><span class="sxs-lookup"><span data-stu-id="b8078-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="b8078-200">É raro que um objeto de instância seja extremamente grande.</span><span class="sxs-lookup"><span data-stu-id="b8078-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="b8078-201">Você pode [Configurar o tamanho do limite](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) para objetos a serem acessados no heap de objeto grande.</span><span class="sxs-lookup"><span data-stu-id="b8078-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="b8078-202">Gerações</span><span class="sxs-lookup"><span data-stu-id="b8078-202">Generations</span></span>

<span data-ttu-id="b8078-203">O algoritmo GC se baseia em várias considerações:</span><span class="sxs-lookup"><span data-stu-id="b8078-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="b8078-204">É mais rápido compactar a memória para uma parte do heap gerenciado do que para todo o heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="b8078-205">Os objetos mais recentes têm tempos de vida menores e objetos mais antigos têm tempos de vida mais longos.</span><span class="sxs-lookup"><span data-stu-id="b8078-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="b8078-206">Os objetos mais recentes tendem a estar relacionados entre si e acessados pelo aplicativo ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="b8078-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="b8078-207">A coleta de lixo ocorre principalmente com a recuperação de objetos de curta duração.</span><span class="sxs-lookup"><span data-stu-id="b8078-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="b8078-208">Para otimizar o desempenho do coletor de lixo, o heap gerenciado é dividido em três gerações, 0, 1 e 2, para que possa manipular objetos de vida longa e de curta duração separadamente.</span><span class="sxs-lookup"><span data-stu-id="b8078-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="b8078-209">O coletor de lixo armazena novos objetos na geração 0.</span><span class="sxs-lookup"><span data-stu-id="b8078-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="b8078-210">Os objetos criados no início no tempo de vida do aplicativo que sobrevivem a coleções são promovidos e armazenados nas gerações 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="b8078-211">Como é mais rápido compactar uma parte do heap gerenciado do que o heap inteiro, esse esquema permite que o coletor de lixo libere a memória em uma geração específica, em vez de liberar a memória para todo o heap gerenciado cada vez que executar uma coleção.</span><span class="sxs-lookup"><span data-stu-id="b8078-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="b8078-212">**Geração 0**.</span><span class="sxs-lookup"><span data-stu-id="b8078-212">**Generation 0**.</span></span> <span data-ttu-id="b8078-213">Essa é a geração mais jovem e contém objetos de vida útil curta.</span><span class="sxs-lookup"><span data-stu-id="b8078-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="b8078-214">Um exemplo de um objeto de vida útil curta é uma variável temporária.</span><span class="sxs-lookup"><span data-stu-id="b8078-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="b8078-215">A coleta de lixo ocorre com mais frequência nessa geração.</span><span class="sxs-lookup"><span data-stu-id="b8078-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="b8078-216">Os objetos alocados recentemente formam uma nova geração de objetos e são coleções de 0 geração implicitamente.</span><span class="sxs-lookup"><span data-stu-id="b8078-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="b8078-217">No entanto, se forem objetos grandes, eles irão para o LOH (heap de objeto grande), que às vezes é chamado de *geração 3*.</span><span class="sxs-lookup"><span data-stu-id="b8078-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="b8078-218">A geração 3 é uma geração física que é coletada logicamente como parte da geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="b8078-219">A maioria dos objetos são recuperados para a coleta de lixo na geração 0 e não sobrevivem à próxima geração.</span><span class="sxs-lookup"><span data-stu-id="b8078-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="b8078-220">Se um aplicativo tentar criar um novo objeto quando a geração 0 estiver cheia, o coletor de lixo executará uma coleção em uma tentativa de liberar espaço de endereço para o objeto.</span><span class="sxs-lookup"><span data-stu-id="b8078-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="b8078-221">O coletor de lixo inicia examinando os objetos na geração 0 em vez de todos os objetos no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b8078-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="b8078-222">Uma coleção da geração 0 geralmente recupera memória suficiente para permitir que o aplicativo continue criando novos objetos.</span><span class="sxs-lookup"><span data-stu-id="b8078-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="b8078-223">**Geração 1**.</span><span class="sxs-lookup"><span data-stu-id="b8078-223">**Generation 1**.</span></span> <span data-ttu-id="b8078-224">Essa geração contém objetos de vida útil curta e serve como um buffer entre objetos de vida útil curta e longa.</span><span class="sxs-lookup"><span data-stu-id="b8078-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="b8078-225">Depois que o coletor de lixo executa uma coleção de geração 0, ele compacta a memória para os objetos acessíveis e promove-os para a geração 1.</span><span class="sxs-lookup"><span data-stu-id="b8078-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="b8078-226">Como os objetos que sobrevivem a coleções tendem a ter tempos de vida mais longos, faz sentido promovê-los a uma geração mais alta.</span><span class="sxs-lookup"><span data-stu-id="b8078-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="b8078-227">O coletor de lixo não precisa examinar novamente os objetos nas gerações 1 e 2 cada vez que executa uma coleção de geração 0.</span><span class="sxs-lookup"><span data-stu-id="b8078-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="b8078-228">Se uma coleção de geração 0 não recuperar memória suficiente para que o aplicativo crie um novo objeto, o coletor de lixo poderá executar uma coleção de geração 1 e, em seguida, a geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="b8078-229">Os objetos na geração 1 que sobrevivem a coleções são promovidos para a geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="b8078-230">**Geração 2**.</span><span class="sxs-lookup"><span data-stu-id="b8078-230">**Generation 2**.</span></span> <span data-ttu-id="b8078-231">Essa geração contém objetos de vida útil longa.</span><span class="sxs-lookup"><span data-stu-id="b8078-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="b8078-232">Um exemplo de um objeto de vida longa é um objeto em um aplicativo de servidor que contém dados estáticos que residem durante o processo.</span><span class="sxs-lookup"><span data-stu-id="b8078-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="b8078-233">Os objetos na geração 2 que sobrevivem a uma coleção permanecem na geração 2 até que sejam determinados como inacessíveis em uma coleção futura.</span><span class="sxs-lookup"><span data-stu-id="b8078-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="b8078-234">Objetos na heap de objeto grande (que às vezes é chamado de *geração 3*) também são coletados na geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-234">Objects on the large object heap (which is sometimes referred to as *generation 3*) are also collected in generation 2.</span></span>

<span data-ttu-id="b8078-235">Coletas de lixo ocorrem em gerações específicas conforme as condições permitirem.</span><span class="sxs-lookup"><span data-stu-id="b8078-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="b8078-236">Coletar uma geração significa coletar objetos nessa geração e todas as suas gerações mais jovens.</span><span class="sxs-lookup"><span data-stu-id="b8078-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="b8078-237">Uma coleta de lixo de geração 2 também é conhecida como uma coleta de lixo completa, porque recupera objetos em todas as gerações (ou seja, todos os objetos no heap gerenciado).</span><span class="sxs-lookup"><span data-stu-id="b8078-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="b8078-238">Sobrevivência e promoções</span><span class="sxs-lookup"><span data-stu-id="b8078-238">Survival and promotions</span></span>

<span data-ttu-id="b8078-239">Os objetos que não são recuperados em uma coleta de lixo são conhecidos como os sobreviventes e são promovidos para a próxima geração:</span><span class="sxs-lookup"><span data-stu-id="b8078-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="b8078-240">Os objetos que sobrevivem a uma coleta de lixo de geração 0 são promovidos para a geração 1.</span><span class="sxs-lookup"><span data-stu-id="b8078-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="b8078-241">Os objetos que sobrevivem a uma coleta de lixo de geração 1 são promovidos para a geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="b8078-242">Os objetos que sobrevivem a uma coleta de lixo de geração 2 permanecem na geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="b8078-243">Quando o coletor de lixo detecta que a taxa de sobrevivência é alta em uma geração, ela aumenta o limite de alocações para essa geração.</span><span class="sxs-lookup"><span data-stu-id="b8078-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="b8078-244">A próxima coleção Obtém um tamanho substancial de memória recuperada.</span><span class="sxs-lookup"><span data-stu-id="b8078-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="b8078-245">O CLR balanceia continuamente duas prioridades: não permitir que o conjunto de trabalho de um aplicativo fique muito grande atrasando a coleta de lixo e não permitindo que a coleta de lixo seja executada com muita frequência.</span><span class="sxs-lookup"><span data-stu-id="b8078-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="b8078-246">Gerações e segmentos efêmeros</span><span class="sxs-lookup"><span data-stu-id="b8078-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="b8078-247">Como os objetos nas gerações 0 e 1 são de curta duração, essas gerações são conhecidas como as *gerações efêmeras*.</span><span class="sxs-lookup"><span data-stu-id="b8078-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="b8078-248">As gerações efêmeras são alocadas no segmento de memória que é conhecido como o segmento efêmero.</span><span class="sxs-lookup"><span data-stu-id="b8078-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="b8078-249">Cada novo segmento adquirido pelo coletor de lixo torna-se o novo segmento efêmero e contém os objetos que sobreviveram a uma coleta de lixo da geração 0.</span><span class="sxs-lookup"><span data-stu-id="b8078-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="b8078-250">O segmento efêmero antigo torna-se o novo segmento da geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="b8078-251">O tamanho do segmento efêmero varia dependendo se um sistema for de 32 bits ou 64 bits e no tipo de coletor de lixo em execução ([estação de trabalho ou servidor GC](workstation-server-gc.md)).</span><span class="sxs-lookup"><span data-stu-id="b8078-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="b8078-252">A tabela a seguir mostra os tamanhos padrão do segmento efêmero.</span><span class="sxs-lookup"><span data-stu-id="b8078-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="b8078-253">Estação de trabalho/servidor GC</span><span class="sxs-lookup"><span data-stu-id="b8078-253">Workstation/server GC</span></span>|<span data-ttu-id="b8078-254">32 bits</span><span class="sxs-lookup"><span data-stu-id="b8078-254">32-bit</span></span>|<span data-ttu-id="b8078-255">64 bits</span><span class="sxs-lookup"><span data-stu-id="b8078-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="b8078-256">GC da estação de trabalho</span><span class="sxs-lookup"><span data-stu-id="b8078-256">Workstation GC</span></span>|<span data-ttu-id="b8078-257">16 MB</span><span class="sxs-lookup"><span data-stu-id="b8078-257">16 MB</span></span>|<span data-ttu-id="b8078-258">256 MB</span><span class="sxs-lookup"><span data-stu-id="b8078-258">256 MB</span></span>|
|<span data-ttu-id="b8078-259">GC do servidor</span><span class="sxs-lookup"><span data-stu-id="b8078-259">Server GC</span></span>|<span data-ttu-id="b8078-260">64 MB</span><span class="sxs-lookup"><span data-stu-id="b8078-260">64 MB</span></span>|<span data-ttu-id="b8078-261">4 GB</span><span class="sxs-lookup"><span data-stu-id="b8078-261">4 GB</span></span>|
|<span data-ttu-id="b8078-262">GC do Servidor com > 4 CPUs lógicas</span><span class="sxs-lookup"><span data-stu-id="b8078-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="b8078-263">32 MB</span><span class="sxs-lookup"><span data-stu-id="b8078-263">32 MB</span></span>|<span data-ttu-id="b8078-264">2 GB</span><span class="sxs-lookup"><span data-stu-id="b8078-264">2 GB</span></span>|
|<span data-ttu-id="b8078-265">GC do Servidor com > 8 CPUs lógicas</span><span class="sxs-lookup"><span data-stu-id="b8078-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="b8078-266">16 MB</span><span class="sxs-lookup"><span data-stu-id="b8078-266">16 MB</span></span>|<span data-ttu-id="b8078-267">1 GB</span><span class="sxs-lookup"><span data-stu-id="b8078-267">1 GB</span></span>|

<span data-ttu-id="b8078-268">O segmento efêmero pode incluir objetos da geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="b8078-269">Objetos da geração 2 podem usar vários segmentos (tantos quanto exigido pelo seu processo e permitido pela memória).</span><span class="sxs-lookup"><span data-stu-id="b8078-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="b8078-270">A quantidade de memória liberada de uma coleta de lixo efêmera é limitada ao tamanho do segmento efêmero.</span><span class="sxs-lookup"><span data-stu-id="b8078-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="b8078-271">A quantidade de memória liberada é proporcional ao espaço que era ocupado pelos objetos inativos.</span><span class="sxs-lookup"><span data-stu-id="b8078-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="b8078-272">O que ocorre durante uma coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="b8078-272">What happens during a garbage collection</span></span>

<span data-ttu-id="b8078-273">Uma coleta de lixo tem as seguintes fases:</span><span class="sxs-lookup"><span data-stu-id="b8078-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="b8078-274">Uma fase de marcação que localiza todos os objetos vivos e cria uma lista desses objetos.</span><span class="sxs-lookup"><span data-stu-id="b8078-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="b8078-275">Uma fase de relocação que atualiza as referências aos objetos que serão compactados.</span><span class="sxs-lookup"><span data-stu-id="b8078-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="b8078-276">Uma fase de compactação que recupera o espaço ocupado por objetos inativos e compacta os objetos sobreviventes.</span><span class="sxs-lookup"><span data-stu-id="b8078-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="b8078-277">A fase de compactação move objetos que sobreviveram a uma coleta de lixo em direção à extremidade mais antiga do segmento.</span><span class="sxs-lookup"><span data-stu-id="b8078-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="b8078-278">Em virtude das coletas da geração 2 poderem ocupar vários segmentos, objetos que são promovidos para a geração 2 podem ser movidos para um segmento mais antigo.</span><span class="sxs-lookup"><span data-stu-id="b8078-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="b8078-279">Tanto os sobreviventes da geração 1 quanto da geração 2 podem ser movidos para um segmento diferente, porque eles são promovidos para a geração 2.</span><span class="sxs-lookup"><span data-stu-id="b8078-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="b8078-280">Normalmente, o LOH (heap de objeto grande) não é compactado, pois copiar objetos grandes impõe uma penalidade de desempenho.</span><span class="sxs-lookup"><span data-stu-id="b8078-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="b8078-281">No entanto, no .NET Core e no .NET Framework 4.5.1 e posterior, você pode usar a <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriedade para compactar o heap de objeto grande sob demanda.</span><span class="sxs-lookup"><span data-stu-id="b8078-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="b8078-282">Além disso, o LOH é compactado automaticamente quando um limite rígido é definido especificando:</span><span class="sxs-lookup"><span data-stu-id="b8078-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="b8078-283">Um limite de memória em um contêiner.</span><span class="sxs-lookup"><span data-stu-id="b8078-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="b8078-284">As opções de configuração de tempo de execução do [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) ou [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent) .</span><span class="sxs-lookup"><span data-stu-id="b8078-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent) run-time configuration options.</span></span>

<span data-ttu-id="b8078-285">O coletor de lixo usa as informações a seguir para determinar se os objetos estão vivos:</span><span class="sxs-lookup"><span data-stu-id="b8078-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="b8078-286">**Raízes da pilha**.</span><span class="sxs-lookup"><span data-stu-id="b8078-286">**Stack roots**.</span></span> <span data-ttu-id="b8078-287">Variáveis de pilha fornecidas pelo compilador JIT (just-in-time) e movimentador de pilhas.</span><span class="sxs-lookup"><span data-stu-id="b8078-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="b8078-288">As otimizações JIT podem aumentar ou diminuir as regiões do código dentro das quais as variáveis de pilha são relatadas ao coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="b8078-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="b8078-289">**Identificadores de coleta de lixo**.</span><span class="sxs-lookup"><span data-stu-id="b8078-289">**Garbage collection handles**.</span></span> <span data-ttu-id="b8078-290">Identificadores que apontam para objetos gerenciados e que podem ser alocados pelo código do usuário ou pelo Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="b8078-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="b8078-291">**Dados estáticos**.</span><span class="sxs-lookup"><span data-stu-id="b8078-291">**Static data**.</span></span> <span data-ttu-id="b8078-292">Objetos estáticos em domínios de aplicativo que podem fazer referência a outros objetos.</span><span class="sxs-lookup"><span data-stu-id="b8078-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="b8078-293">Cada domínio de aplicativo controla seus objetos estáticos.</span><span class="sxs-lookup"><span data-stu-id="b8078-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="b8078-294">Antes de iniciar uma coleta de lixo, todos os threads gerenciados são suspensos, exceto o thread que disparou a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="b8078-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="b8078-295">A ilustração a seguir mostra um thread que dispara uma coleta de lixo e faz com que outros threads sejam suspensos.</span><span class="sxs-lookup"><span data-stu-id="b8078-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Quando um thread dispara uma coleta de lixo](media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="b8078-297">Recursos não gerenciados</span><span class="sxs-lookup"><span data-stu-id="b8078-297">Unmanaged resources</span></span>

<span data-ttu-id="b8078-298">Para a maioria dos objetos que seu aplicativo cria, você pode confiar na coleta de lixo para executar automaticamente as tarefas de gerenciamento de memória necessárias.</span><span class="sxs-lookup"><span data-stu-id="b8078-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="b8078-299">Entretanto, recursos não gerenciados requerem limpeza explícita.</span><span class="sxs-lookup"><span data-stu-id="b8078-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="b8078-300">O tipo mais comum de recursos não gerenciados é um objeto que encapsula um recurso do sistema operacional, como um identificador de arquivo, um identificador de janela ou uma conexão de rede.</span><span class="sxs-lookup"><span data-stu-id="b8078-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="b8078-301">Embora o coletor de lixo possa controlar o tempo de vida de um objeto gerenciado que encapsula um recurso não gerenciado, ele não tem conhecimento específico sobre como limpar o recurso.</span><span class="sxs-lookup"><span data-stu-id="b8078-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="b8078-302">Quando você cria um objeto que encapsula um recurso não gerenciado, é recomendável que você forneça o código necessário para limpar o recurso não gerenciado em um `Dispose` método público.</span><span class="sxs-lookup"><span data-stu-id="b8078-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="b8078-303">Ao fornecer um método `Dispose`, você permite que usuários do seu objeto liberem, explicitamente, sua memória quando terminarem o objeto.</span><span class="sxs-lookup"><span data-stu-id="b8078-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="b8078-304">Ao usar um objeto que encapsula um recurso não gerenciado, certifique-se de chamar `Dispose` conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="b8078-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="b8078-305">Você também deve fornecer uma maneira para que seus recursos não gerenciados sejam liberados caso um consumidor de seu tipo se esqueça de chamar `Dispose` .</span><span class="sxs-lookup"><span data-stu-id="b8078-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="b8078-306">Você pode usar um identificador seguro para encapsular o recurso não gerenciado ou substituir o <xref:System.Object.Finalize?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b8078-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="b8078-307">Para obter mais informações sobre como limpar recursos não gerenciados, consulte [limpar recursos não gerenciados](unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="b8078-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="b8078-308">Consulte também</span><span class="sxs-lookup"><span data-stu-id="b8078-308">See also</span></span>

- [<span data-ttu-id="b8078-309">Coleta de lixo de estação de trabalho ou de servidor</span><span class="sxs-lookup"><span data-stu-id="b8078-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="b8078-310">Coleta de lixo em segundo plano</span><span class="sxs-lookup"><span data-stu-id="b8078-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="b8078-311">Opções de configuração para GC</span><span class="sxs-lookup"><span data-stu-id="b8078-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="b8078-312">Coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="b8078-312">Garbage collection</span></span>](index.md)
