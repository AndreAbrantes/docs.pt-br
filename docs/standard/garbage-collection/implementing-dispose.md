---
title: Como implementar um método Dispose
ms.date: 04/07/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: 0583329ae75fa54cf000212479895ccebdbd30d8
ms.sourcegitcommit: fbb8a593a511ce667992502a3ce6d8f65c594edf
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/16/2019
ms.locfileid: "74142061"
---
# <a name="implementing-a-dispose-method"></a><span data-ttu-id="31ca4-102">Como implementar um método Dispose</span><span class="sxs-lookup"><span data-stu-id="31ca4-102">Implementing a Dispose method</span></span>

<span data-ttu-id="31ca4-103">Você implementa um método <xref:System.IDisposable.Dispose%2A> para liberar recursos não gerenciados usados pelo seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="31ca4-103">You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application.</span></span> <span data-ttu-id="31ca4-104">O coletor de lixo .NET não alocar nem libera memória não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="31ca4-104">The .NET garbage collector does not allocate or release unmanaged memory.</span></span>  
  
<span data-ttu-id="31ca4-105">O padrão para o descarte um objeto, conhecido como [padrão Dispose](implementing-dispose.md), impõe ordem no tempo de vida de um objeto.</span><span class="sxs-lookup"><span data-stu-id="31ca4-105">The pattern for disposing an object, referred to as a [dispose pattern](implementing-dispose.md), imposes order on the lifetime of an object.</span></span> <span data-ttu-id="31ca4-106">O padrão de descarte é usado somente para os objetos que acessam recursos não gerenciados, como identificadores de arquivo e pipe, identificadores de Registro, identificadores de espera ou ponteiros para blocos de memória não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="31ca4-106">The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="31ca4-107">Isso ocorre porque o coletor de lixo é muito eficiente para recuperar objetos gerenciados não usados, mas não é capaz de recuperar objetos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="31ca4-107">This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</span></span>  
  
<span data-ttu-id="31ca4-108">O padrão de descarte tem duas variações:</span><span class="sxs-lookup"><span data-stu-id="31ca4-108">The dispose pattern has two variations:</span></span>  
  
- <span data-ttu-id="31ca4-109">Você envolve cada recurso não gerenciado usado por um tipo em um identificador seguro (ou seja, em uma classe derivada de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="31ca4-109">You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span></span> <span data-ttu-id="31ca4-110">Nesse caso, você implementa a interface <xref:System.IDisposable> e um método `Dispose(Boolean)` adicional.</span><span class="sxs-lookup"><span data-stu-id="31ca4-110">In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method.</span></span> <span data-ttu-id="31ca4-111">Essa é a variação recomendada e não requer a substituição do método <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-111">This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span>  
  
  > [!NOTE]
  > <span data-ttu-id="31ca4-112">O namespace <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> fornece um conjunto de classes derivadas de <xref:System.Runtime.InteropServices.SafeHandle>, que são listadas na seção [Usando identificadores seguros](#SafeHandles).</span><span class="sxs-lookup"><span data-stu-id="31ca4-112">The <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section.</span></span> <span data-ttu-id="31ca4-113">Se não conseguir encontrar uma classe adequada para liberar seu recurso não gerenciado, você poderá implementar sua própria subclasse de <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-113">If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
- <span data-ttu-id="31ca4-114">Você implementa a interface <xref:System.IDisposable> e um método `Dispose(Boolean)` adicional, além de substituir o método <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-114">You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31ca4-115">Você deve substituir <xref:System.Object.Finalize%2A> para garantir que os recursos não gerenciados sejam descartados se sua implementação de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> não for chamada por um consumidor do seu tipo.</span><span class="sxs-lookup"><span data-stu-id="31ca4-115">You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation is not called by a consumer of your type.</span></span> <span data-ttu-id="31ca4-116">Se você usar a técnica recomendada discutida no item anterior, a classe <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> fará isso em seu nome.</span><span class="sxs-lookup"><span data-stu-id="31ca4-116">If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class does this on your behalf.</span></span>  
  
<span data-ttu-id="31ca4-117">Para ajudar a garantir que os recursos sejam sempre limpos corretamente, um método <xref:System.IDisposable.Dispose%2A> deve poder ser chamado várias vezes sem gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="31ca4-117">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.</span></span>  
  
<span data-ttu-id="31ca4-118">O exemplo de código fornecido para o método <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> mostra a agressividade com a qual uma coleta de lixo pode fazer com que um finalizador seja executado enquanto um membro do objeto recuperado ainda está em execução.</span><span class="sxs-lookup"><span data-stu-id="31ca4-118">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</span></span> <span data-ttu-id="31ca4-119">É uma boa ideia chamar o método <xref:System.GC.KeepAlive%2A> no final de um método <xref:System.IDisposable.Dispose%2A> longo.</span><span class="sxs-lookup"><span data-stu-id="31ca4-119">It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="Dispose2"></a>
## <a name="dispose-and-disposeboolean"></a><span data-ttu-id="31ca4-120">Dispose() e Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="31ca4-120">Dispose() and Dispose(Boolean)</span></span>  

<span data-ttu-id="31ca4-121">A interface <xref:System.IDisposable> requer a implementação de um único método sem parâmetros, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-121">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="31ca4-122">No entanto, o padrão de descarte requer que dois métodos `Dispose` sejam implementados:</span><span class="sxs-lookup"><span data-stu-id="31ca4-122">However, the dispose pattern requires two `Dispose` methods to be implemented:</span></span>  
  
- <span data-ttu-id="31ca4-123">Uma implementação pública não virtual (`NonInheritable` no Visual Basic) de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> que não possua parâmetros.</span><span class="sxs-lookup"><span data-stu-id="31ca4-123">A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>  
  
- <span data-ttu-id="31ca4-124">Um método `Overridable` virtual protegido (`Dispose` no Visual Basic) cuja assinatura é:</span><span class="sxs-lookup"><span data-stu-id="31ca4-124">A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>  
  
  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  
  
### <a name="the-dispose-overload"></a><span data-ttu-id="31ca4-125">A sobrecarga Dispose()</span><span class="sxs-lookup"><span data-stu-id="31ca4-125">The Dispose() overload</span></span>

<span data-ttu-id="31ca4-126">Como o método público, não virtual (`NonInheritable` no Visual Basic) e sem parâmetro `Dispose` é chamado por um consumidor do tipo, sua finalidade é liberar recursos não gerenciados e indicar que o finalizador, se houver um, não precisa ser executado.</span><span class="sxs-lookup"><span data-stu-id="31ca4-126">Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="31ca4-127">Por isso, ele tem uma implementação padrão:</span><span class="sxs-lookup"><span data-stu-id="31ca4-127">Because of this, it has a standard implementation:</span></span>  
  
[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  
  
<span data-ttu-id="31ca4-128">O método `Dispose` executa toda a limpeza do objeto, de modo que o coletor de lixo não precisa mais chamar a substituição dos objetos <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-128">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="31ca4-129">Assim, a chamada para o método <xref:System.GC.SuppressFinalize%2A> impede que o coletor de lixo execute o finalizador.</span><span class="sxs-lookup"><span data-stu-id="31ca4-129">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="31ca4-130">Se o tipo não possuir um finalizador, a chamada para <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="31ca4-130">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="31ca4-131">Observe que o trabalho real de liberar recursos não gerenciado é executado pela segunda sobrecarga do método `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="31ca4-131">Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.</span></span>  
  
### <a name="the-disposeboolean-overload"></a><span data-ttu-id="31ca4-132">A sobrecarga Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="31ca4-132">The Dispose(Boolean) overload</span></span>

<span data-ttu-id="31ca4-133">Na segunda sobrecarga, o parâmetro *disposing* é um <xref:System.Boolean> que indica se a chamada do método é proveniente de um método <xref:System.IDisposable.Dispose%2A> (seu valor é `true`) ou de um finalizador (seu valor é `false`).</span><span class="sxs-lookup"><span data-stu-id="31ca4-133">In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>  
  
<span data-ttu-id="31ca4-134">O corpo do método consiste em dois blocos de código:</span><span class="sxs-lookup"><span data-stu-id="31ca4-134">The body of the method consists of two blocks of code:</span></span>  
  
- <span data-ttu-id="31ca4-135">Um bloco que libera recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="31ca4-135">A block that frees unmanaged resources.</span></span> <span data-ttu-id="31ca4-136">Este bloco é executado independentemente do valor do parâmetro `disposing`.</span><span class="sxs-lookup"><span data-stu-id="31ca4-136">This block executes regardless of the value of the `disposing` parameter.</span></span>  
  
- <span data-ttu-id="31ca4-137">Um bloco condicional que libera recursos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="31ca4-137">A conditional block that frees managed resources.</span></span> <span data-ttu-id="31ca4-138">Este bloco será executado se o valor de `disposing` for `true`.</span><span class="sxs-lookup"><span data-stu-id="31ca4-138">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="31ca4-139">Os recursos gerenciados que ele libera podem incluir:</span><span class="sxs-lookup"><span data-stu-id="31ca4-139">The managed resources that it frees can include:</span></span>  
  
  <span data-ttu-id="31ca4-140">**Objetos gerenciados que implementam <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="31ca4-140">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="31ca4-141">O bloco condicional pode ser usado para chamar sua implementação de <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-141">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="31ca4-142">Se você usou um indicador seguro para encapsular o recurso não gerenciado, é necessário chamar a implementação de <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> aqui.</span><span class="sxs-lookup"><span data-stu-id="31ca4-142">If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementation here.</span></span>  
  
  <span data-ttu-id="31ca4-143">**Objetos gerenciados que consomem muita memória ou consomem recursos escassos.**</span><span class="sxs-lookup"><span data-stu-id="31ca4-143">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="31ca4-144">Liberar esses objetos explicitamente no método `Dispose` libera-os mais rápido do que se eles fossem recuperados de forma não determinística pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="31ca4-144">Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</span></span>  
  
<span data-ttu-id="31ca4-145">Se a chamada do método vier de um finalizador (isto é, se *disposing* for `false`), somente o código que libera os recursos não gerenciados é executado.</span><span class="sxs-lookup"><span data-stu-id="31ca4-145">If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes.</span></span> <span data-ttu-id="31ca4-146">Como a ordem em que o coletor de lixo destrói objetos gerenciados durante a finalização não é definida, chamar essa sobrecarga `Dispose` com um valor de `false` impede que o finalizador tente liberar os recursos gerenciados que já podem ter sido recuperados.</span><span class="sxs-lookup"><span data-stu-id="31ca4-146">Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="31ca4-147">Implementando o padrão de descarte para uma classe base</span><span class="sxs-lookup"><span data-stu-id="31ca4-147">Implementing the dispose pattern for a base class</span></span>

<span data-ttu-id="31ca4-148">Se você implementar o padrão de descarte para uma classe base, deverá fornecer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="31ca4-148">If you implement the dispose pattern for a base class, you must provide the following:</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="31ca4-149">É preciso implementar esse padrão para todas as classes de base que implementam <xref:System.IDisposable.Dispose> e não são `sealed` (`NotInheritable` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="31ca4-149">You should implement this pattern for all base classes that implement <xref:System.IDisposable.Dispose> and are not `sealed` (`NotInheritable` in Visual Basic).</span></span>  
  
- <span data-ttu-id="31ca4-150">Uma implementação de <xref:System.IDisposable.Dispose%2A> que chame o método `Dispose(Boolean)`.</span><span class="sxs-lookup"><span data-stu-id="31ca4-150">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.</span></span>  
  
- <span data-ttu-id="31ca4-151">Um método `Dispose(Boolean)` que execute o trabalho real de liberar recursos.</span><span class="sxs-lookup"><span data-stu-id="31ca4-151">A `Dispose(Boolean)` method that performs the actual work of releasing resources.</span></span>  
  
- <span data-ttu-id="31ca4-152">Uma classe derivada de <xref:System.Runtime.InteropServices.SafeHandle> que envolva o recurso não gerenciado (recomendado) ou uma substituição para o método <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-152">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31ca4-153">A classe <xref:System.Runtime.InteropServices.SafeHandle> fornece um finalizador que o libera de ter que codificar um.</span><span class="sxs-lookup"><span data-stu-id="31ca4-153">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span>  
  
<span data-ttu-id="31ca4-154">Aqui está o padrão geral para implementar o padrão de descarte para uma classe base que usa um identificador seguro.</span><span class="sxs-lookup"><span data-stu-id="31ca4-154">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>  
  
[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="31ca4-155">O exemplo anterior usa um objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para ilustrar o padrão; qualquer objeto derivado de <xref:System.Runtime.InteropServices.SafeHandle> poderia ser usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="31ca4-155">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="31ca4-156">Observe que o exemplo não cria corretamente uma instância de seu objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-156">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="31ca4-157">Aqui está o padrão geral para implementar o padrão de descarte para uma classe base que substitui <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-157">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
> [!NOTE]
> <span data-ttu-id="31ca4-158">No C#, você deve substituir <xref:System.Object.Finalize%2A?displayProperty=nameWithType> definindo um [destruidor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="31ca4-158">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="31ca4-159">Implementando o padrão de descarte para uma classe derivada</span><span class="sxs-lookup"><span data-stu-id="31ca4-159">Implementing the dispose pattern for a derived class</span></span>

<span data-ttu-id="31ca4-160">Uma classe derivada de uma classe que implementa a interface <xref:System.IDisposable> não deve implementar <xref:System.IDisposable> porque a implementação da classe base <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> é herdada pelas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="31ca4-160">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="31ca4-161">Em vez disso, para liberar recursos de uma classe derivada, você fornece o seguinte:</span><span class="sxs-lookup"><span data-stu-id="31ca4-161">Instead, to release resources of a derived class, you provide the following:</span></span>  
  
- <span data-ttu-id="31ca4-162">Um método `protected Dispose(Boolean)` que substitua o método da classe base e execute o trabalho real de liberar os recursos da classe derivada.</span><span class="sxs-lookup"><span data-stu-id="31ca4-162">A `protected Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</span></span> <span data-ttu-id="31ca4-163">Esse método também deve chamar o método `Dispose(Boolean)` da classe base e passar seu status de descarte para o argumento.</span><span class="sxs-lookup"><span data-stu-id="31ca4-163">This method should also call the `Dispose(Boolean)` method of the base class and pass its disposing status for the argument.</span></span>  
  
- <span data-ttu-id="31ca4-164">Uma classe derivada de <xref:System.Runtime.InteropServices.SafeHandle> que envolva o recurso não gerenciado (recomendado) ou uma substituição para o método <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-164">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31ca4-165">A classe <xref:System.Runtime.InteropServices.SafeHandle> fornece um finalizador que o libera de ter que codificar um.</span><span class="sxs-lookup"><span data-stu-id="31ca4-165">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="31ca4-166">Se você fornecer um finalizador, ele deverá chamar a sobrecarga de `Dispose(Boolean)` com um argumento *disposing* de `false`.</span><span class="sxs-lookup"><span data-stu-id="31ca4-166">If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.</span></span>  
  
<span data-ttu-id="31ca4-167">Aqui está o padrão geral para implementar o padrão de descarte para uma classe derivada que usa um identificador seguro:</span><span class="sxs-lookup"><span data-stu-id="31ca4-167">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>  
  
[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
> [!NOTE]
> <span data-ttu-id="31ca4-168">O exemplo anterior usa um objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para ilustrar o padrão; qualquer objeto derivado de <xref:System.Runtime.InteropServices.SafeHandle> poderia ser usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="31ca4-168">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="31ca4-169">Observe que o exemplo não cria corretamente uma instância de seu objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-169">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="31ca4-170">Aqui está o padrão geral para implementar o padrão de descarte para uma classe derivada que substitui <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="31ca4-170">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>  
  
[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  
  
> [!NOTE]
> <span data-ttu-id="31ca4-171">No C#, você deve substituir <xref:System.Object.Finalize%2A?displayProperty=nameWithType> definindo um [destruidor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="31ca4-171">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
<a name="SafeHandles"></a>   
## <a name="using-safe-handles"></a><span data-ttu-id="31ca4-172">Usando identificadores seguros</span><span class="sxs-lookup"><span data-stu-id="31ca4-172">Using safe handles</span></span>

<span data-ttu-id="31ca4-173">Escrever código para o finalizador de um objeto é uma tarefa complexa que poderá causar problemas se não for feito corretamente.</span><span class="sxs-lookup"><span data-stu-id="31ca4-173">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="31ca4-174">Assim, recomendamos que você construa objetos <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>, em vez de implementar um finalizador.</span><span class="sxs-lookup"><span data-stu-id="31ca4-174">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>  
  
<span data-ttu-id="31ca4-175">As classes derivadas da classe <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> simplificam problemas de vida útil de objetos ao atribuir e liberar identificadores sem interrupção.</span><span class="sxs-lookup"><span data-stu-id="31ca4-175">Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class simplify object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="31ca4-176">Elas contêm um finalizador crítico que certamente será executado enquanto um domínio de aplicativo estiver descarregando.</span><span class="sxs-lookup"><span data-stu-id="31ca4-176">They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</span></span> <span data-ttu-id="31ca4-177">Para obter mais informações sobre as vantagens de usar um identificador seguro, consulte <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="31ca4-177">For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31ca4-178">As seguintes classes derivadas no namespace <xref:Microsoft.Win32.SafeHandles> fornecem os identificadores seguros:</span><span class="sxs-lookup"><span data-stu-id="31ca4-178">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>  
  
- <span data-ttu-id="31ca4-179">As classes <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> e <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> para arquivos, arquivos mapeados na memória e pipes.</span><span class="sxs-lookup"><span data-stu-id="31ca4-179">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>  
  
- <span data-ttu-id="31ca4-180">A classe <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> para exibições de memória.</span><span class="sxs-lookup"><span data-stu-id="31ca4-180">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>  
  
- <span data-ttu-id="31ca4-181">As classes <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> para construtores de criptografia.</span><span class="sxs-lookup"><span data-stu-id="31ca4-181">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>  
  
- <span data-ttu-id="31ca4-182">A classe <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> para chaves do registro.</span><span class="sxs-lookup"><span data-stu-id="31ca4-182">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>  
  
- <span data-ttu-id="31ca4-183">A classe <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> para identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="31ca4-183">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>  
  
<a name="base"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="31ca4-184">Usando um identificador seguro para implementar o padrão de descarte para uma classe base</span><span class="sxs-lookup"><span data-stu-id="31ca4-184">Using a safe handle to implement the dispose pattern for a base class</span></span>

<span data-ttu-id="31ca4-185">O exemplo a seguir ilustra o padrão de descarte para uma classe base, `DisposableStreamResource`, a qual usa um identificador seguro para encapsular recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="31ca4-185">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="31ca4-186">Define uma classe `DisposableResource` que usa <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para encapsular um objeto <xref:System.IO.Stream> que representa um arquivo aberto.</span><span class="sxs-lookup"><span data-stu-id="31ca4-186">It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="31ca4-187">O método `DisposableResource` também inclui uma única propriedade, `Size`, a qual retorna o número total de bytes no fluxo de arquivos.</span><span class="sxs-lookup"><span data-stu-id="31ca4-187">The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>  
  
[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  
  
<a name="derived"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="31ca4-188">Usando um identificador seguro para implementar o padrão de descarte para uma classe derivada</span><span class="sxs-lookup"><span data-stu-id="31ca4-188">Using a safe handle to implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="31ca4-189">O exemplo a seguir ilustra o padrão de descarte para uma classe derivada, `DisposableStreamResource2`, que herda da classe `DisposableStreamResource` apresentada no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="31ca4-189">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="31ca4-190">A classe acrescenta um método adicional, `WriteFileInfo`, e usa um objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para encapsular o identificador do arquivo gravável.</span><span class="sxs-lookup"><span data-stu-id="31ca4-190">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>  
  
[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  
  
## <a name="see-also"></a><span data-ttu-id="31ca4-191">Consulte também</span><span class="sxs-lookup"><span data-stu-id="31ca4-191">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="31ca4-192">Como definir e consumir classes e structs (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="31ca4-192">How to: Define and Consume Classes and Structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
- [<span data-ttu-id="31ca4-193">Padrão de descarte</span><span class="sxs-lookup"><span data-stu-id="31ca4-193">Dispose Pattern</span></span>](implementing-dispose.md)
