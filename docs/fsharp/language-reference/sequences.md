---
title: Sequências
description: 'Saiba como usar sequências F #, quando você tem uma coleção de dados grande e ordenada, mas não espera necessariamente usar todos os elementos.'
ms.date: 08/13/2020
ms.openlocfilehash: c84e0aebcc79a595c0ae3b9075648fb629bdd65c
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/18/2020
ms.locfileid: "88559031"
---
# <a name="sequences"></a><span data-ttu-id="131af-103">Sequências</span><span class="sxs-lookup"><span data-stu-id="131af-103">Sequences</span></span>

<span data-ttu-id="131af-104">Uma *sequência* é uma série lógica de elementos de um tipo.</span><span class="sxs-lookup"><span data-stu-id="131af-104">A *sequence* is a logical series of elements all of one type.</span></span> <span data-ttu-id="131af-105">As sequências são particularmente úteis quando você tem uma coleção de dados grande e ordenada, mas não espera necessariamente usar todos os elementos.</span><span class="sxs-lookup"><span data-stu-id="131af-105">Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all of the elements.</span></span> <span data-ttu-id="131af-106">Os elementos de sequência individuais são calculados somente conforme necessário, portanto, uma sequência pode fornecer um melhor desempenho do que uma lista em situações nas quais nem todos os elementos são usados.</span><span class="sxs-lookup"><span data-stu-id="131af-106">Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used.</span></span> <span data-ttu-id="131af-107">As sequências são representadas pelo `seq<'T>` tipo, que é um alias para <xref:System.Collections.Generic.IEnumerable%601> .</span><span class="sxs-lookup"><span data-stu-id="131af-107">Sequences are represented by the `seq<'T>` type, which is an alias for <xref:System.Collections.Generic.IEnumerable%601>.</span></span> <span data-ttu-id="131af-108">Portanto, qualquer tipo de .NET que implemente <xref:System.Collections.Generic.IEnumerable%601> a interface pode ser usado como uma sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-108">Therefore, any .NET type that implements <xref:System.Collections.Generic.IEnumerable%601> interface can be used as a sequence.</span></span> <span data-ttu-id="131af-109">O [módulo Seq](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) fornece suporte para manipulações que envolvem sequências.</span><span class="sxs-lookup"><span data-stu-id="131af-109">The [Seq module](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) provides support for manipulations involving sequences.</span></span>

## <a name="sequence-expressions"></a><span data-ttu-id="131af-110">Expressões de sequência</span><span class="sxs-lookup"><span data-stu-id="131af-110">Sequence Expressions</span></span>

<span data-ttu-id="131af-111">Uma *expressão de sequência* é uma expressão que é avaliada como uma sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-111">A *sequence expression* is an expression that evaluates to a sequence.</span></span> <span data-ttu-id="131af-112">Expressões de sequência podem usar vários formulários.</span><span class="sxs-lookup"><span data-stu-id="131af-112">Sequence expressions can take a number of forms.</span></span> <span data-ttu-id="131af-113">A forma mais simples especifica um intervalo.</span><span class="sxs-lookup"><span data-stu-id="131af-113">The simplest form specifies a range.</span></span> <span data-ttu-id="131af-114">Por exemplo, `seq { 1 .. 5 }` cria uma sequência que contém cinco elementos, incluindo os pontos de extremidade 1 e 5.</span><span class="sxs-lookup"><span data-stu-id="131af-114">For example, `seq { 1 .. 5 }` creates a sequence that contains five elements, including the endpoints 1 and 5.</span></span> <span data-ttu-id="131af-115">Você também pode especificar um incremento (ou decrementar) entre dois pontos duplos.</span><span class="sxs-lookup"><span data-stu-id="131af-115">You can also specify an increment (or decrement) between two double periods.</span></span> <span data-ttu-id="131af-116">Por exemplo, o código a seguir cria a sequência de múltiplos de 10.</span><span class="sxs-lookup"><span data-stu-id="131af-116">For example, the following code creates the sequence of multiples of 10.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

<span data-ttu-id="131af-117">Expressões de sequência são constituídas de expressões F # que produzem valores da sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-117">Sequence expressions are made up of F# expressions that produce values of the sequence.</span></span> <span data-ttu-id="131af-118">Você também pode gerar valores programaticamente:</span><span class="sxs-lookup"><span data-stu-id="131af-118">You can also generate values programmatically:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

<span data-ttu-id="131af-119">O exemplo anterior usa o `->` operador, que permite que você especifique uma expressão cujo valor se tornará uma parte da sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-119">The previous sample uses the `->` operator, which allows you to specify an expression whose value will become a part of the sequence.</span></span> <span data-ttu-id="131af-120">Você só poderá usar `->` se todas as partes do código que o segue retornarem um valor.</span><span class="sxs-lookup"><span data-stu-id="131af-120">You can only use `->` if every part of the code that follows it returns a value.</span></span>

<span data-ttu-id="131af-121">Como alternativa, você pode especificar a `do` palavra-chave, com um opcional a `yield` seguir:</span><span class="sxs-lookup"><span data-stu-id="131af-121">Alternatively, you can specify the `do` keyword, with an optional `yield` that follows:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

<span data-ttu-id="131af-122">O código a seguir gera uma lista de pares de coordenadas junto com um índice em uma matriz que representa a grade.</span><span class="sxs-lookup"><span data-stu-id="131af-122">The following code generates a list of coordinate pairs along with an index into an array that represents the grid.</span></span> <span data-ttu-id="131af-123">Observe que a primeira `for` expressão requer que um `do` seja especificado.</span><span class="sxs-lookup"><span data-stu-id="131af-123">Note that the first `for` expression requires a `do` to be specified.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

<span data-ttu-id="131af-124">Uma `if` expressão usada em uma sequência é um filtro.</span><span class="sxs-lookup"><span data-stu-id="131af-124">An `if` expression used in a sequence is a filter.</span></span> <span data-ttu-id="131af-125">Por exemplo, para gerar uma sequência de apenas números primos, supondo que você tenha uma função `isprime` do tipo `int -> bool` , construa a sequência da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="131af-125">For example, to generate a sequence of only prime numbers, assuming that you have a function `isprime` of type `int -> bool`, construct the sequence as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

<span data-ttu-id="131af-126">Conforme mencionado anteriormente, `do` é necessário aqui porque não há `else` ramificação com o `if` .</span><span class="sxs-lookup"><span data-stu-id="131af-126">As mentioned previously, `do` is required here because there is no `else` branch that goes with the `if`.</span></span> <span data-ttu-id="131af-127">Se você tentar usar o `->` , receberá um erro dizendo que nem todas as ramificações retornarão um valor.</span><span class="sxs-lookup"><span data-stu-id="131af-127">If you try to use `->`, you'll get an error saying that not all branches return a value.</span></span>

## <a name="the-yield-keyword"></a><span data-ttu-id="131af-128">A palavra-chave `yield!`</span><span class="sxs-lookup"><span data-stu-id="131af-128">The `yield!` keyword</span></span>

<span data-ttu-id="131af-129">Às vezes, você pode desejar incluir uma sequência de elementos em outra sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-129">Sometimes, you may wish to include a sequence of elements into another sequence.</span></span> <span data-ttu-id="131af-130">Para incluir uma sequência em outra sequência, você precisará usar a `yield!` palavra-chave:</span><span class="sxs-lookup"><span data-stu-id="131af-130">To include a sequence within another sequence, you'll need to use the `yield!` keyword:</span></span>

```fsharp
// Repeats '1 2 3 4 5' ten times
seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5}
}
```

<span data-ttu-id="131af-131">Outra maneira de pensar `yield!` é que ele nivela uma sequência interna e, em seguida, inclui isso na sequência que a contém.</span><span class="sxs-lookup"><span data-stu-id="131af-131">Another way of thinking of `yield!` is that it flattens an inner sequence and then includes that in the containing sequence.</span></span>

<span data-ttu-id="131af-132">Quando `yield!` é usado em uma expressão, todos os outros valores únicos devem usar a `yield` palavra-chave:</span><span class="sxs-lookup"><span data-stu-id="131af-132">When `yield!` is used in an expression, all other single values must use the `yield` keyword:</span></span>

```fsharp
// Combine repeated values with their values
seq {
    for x in 1..10 do
        yield x
        yield! seq { for i in 1..x -> i}
}
```

<span data-ttu-id="131af-133">O exemplo anterior produzirá o valor de, `x` além de todos os valores de `1` para `x` cada `x` .</span><span class="sxs-lookup"><span data-stu-id="131af-133">The previous example will produce the value of `x` in addition to all values from `1` to `x` for each `x`.</span></span>

## <a name="examples"></a><span data-ttu-id="131af-134">Exemplos</span><span class="sxs-lookup"><span data-stu-id="131af-134">Examples</span></span>

<span data-ttu-id="131af-135">O primeiro exemplo usa uma expressão de sequência que contém uma iteração, um filtro e um yield para gerar uma matriz.</span><span class="sxs-lookup"><span data-stu-id="131af-135">The first example uses a sequence expression that contains an iteration, a filter, and a yield to generate an array.</span></span> <span data-ttu-id="131af-136">Esse código imprime uma sequência de números primos entre 1 e 100 no console.</span><span class="sxs-lookup"><span data-stu-id="131af-136">This code prints a sequence of prime numbers between 1 and 100 to the console.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

<span data-ttu-id="131af-137">O exemplo a seguir cria uma tabela de multiplicação que consiste em tuplas de três elementos, cada um consistindo de dois fatores e do produto:</span><span class="sxs-lookup"><span data-stu-id="131af-137">The following example creates a multiplication table that consists of tuples of three elements, each consisting of two factors and the product:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

<span data-ttu-id="131af-138">O exemplo a seguir demonstra o uso de `yield!` para combinar Sequências individuais em uma única sequência final.</span><span class="sxs-lookup"><span data-stu-id="131af-138">The following example demonstrates the use of `yield!` to combine individual sequences into a single final sequence.</span></span> <span data-ttu-id="131af-139">Nesse caso, as sequências para cada subárvore em uma árvore binária são concatenadas em uma função recursiva para produzir a sequência final.</span><span class="sxs-lookup"><span data-stu-id="131af-139">In this case, the sequences for each subtree in a binary tree are concatenated in a recursive function to produce the final sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a><span data-ttu-id="131af-140">Usando sequências</span><span class="sxs-lookup"><span data-stu-id="131af-140">Using Sequences</span></span>

<span data-ttu-id="131af-141">As sequências dão suporte a muitas das mesmas funções que as [listas](lists.md).</span><span class="sxs-lookup"><span data-stu-id="131af-141">Sequences support many of the same functions as [lists](lists.md).</span></span> <span data-ttu-id="131af-142">As sequências também dão suporte a operações como agrupamento e contagem usando funções de geração de chaves.</span><span class="sxs-lookup"><span data-stu-id="131af-142">Sequences also support operations such as grouping and counting by using key-generating functions.</span></span> <span data-ttu-id="131af-143">As sequências também dão suporte a funções mais diversificadas para extração de subsequências.</span><span class="sxs-lookup"><span data-stu-id="131af-143">Sequences also support more diverse functions for extracting subsequences.</span></span>

<span data-ttu-id="131af-144">Muitos tipos de dados, como listas, matrizes, conjuntos e mapas são implicitamente sequências porque são coleções enumeráveis.</span><span class="sxs-lookup"><span data-stu-id="131af-144">Many data types, such as lists, arrays, sets, and maps are implicitly sequences because they are enumerable collections.</span></span> <span data-ttu-id="131af-145">Uma função que usa uma sequência como um argumento funciona com qualquer um dos tipos de dados comuns de F #, além de qualquer tipo de dados .NET que implemente `System.Collections.Generic.IEnumerable<'T>` .</span><span class="sxs-lookup"><span data-stu-id="131af-145">A function that takes a sequence as an argument works with any of the common F# data types, in addition to any .NET data type that implements `System.Collections.Generic.IEnumerable<'T>`.</span></span> <span data-ttu-id="131af-146">Compare isso com uma função que usa uma lista como um argumento, que só pode receber listas.</span><span class="sxs-lookup"><span data-stu-id="131af-146">Contrast this to a function that takes a list as an argument, which can only take lists.</span></span> <span data-ttu-id="131af-147">O tipo `seq<'T>` é uma abreviação de tipo para `IEnumerable<'T>` .</span><span class="sxs-lookup"><span data-stu-id="131af-147">The type `seq<'T>` is a type abbreviation for `IEnumerable<'T>`.</span></span> <span data-ttu-id="131af-148">Isso significa que qualquer tipo que implementa o genérico `System.Collections.Generic.IEnumerable<'T>` , que inclui matrizes, listas, conjuntos e mapas em F #, e também a maioria dos tipos de coleção .net, é compatível com o `seq` tipo e pode ser usado sempre que uma sequência é esperada.</span><span class="sxs-lookup"><span data-stu-id="131af-148">This means that any type that implements the generic `System.Collections.Generic.IEnumerable<'T>`, which includes arrays, lists, sets, and maps in F#, and also most .NET collection types, is compatible with the `seq` type and can be used wherever a sequence is expected.</span></span>

## <a name="module-functions"></a><span data-ttu-id="131af-149">Funções do módulo</span><span class="sxs-lookup"><span data-stu-id="131af-149">Module Functions</span></span>

<span data-ttu-id="131af-150">O [módulo Seq](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) no [namespace FSharp. Collections](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections.html) contém funções para trabalhar com sequências.</span><span class="sxs-lookup"><span data-stu-id="131af-150">The [Seq module](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html) in the [FSharp.Collections namespace](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections.html) contains functions for working with sequences.</span></span> <span data-ttu-id="131af-151">Essas funções funcionam com listas, matrizes, mapas e conjuntos também, porque todos esses tipos são enumeráveis e, portanto, podem ser tratados como sequências.</span><span class="sxs-lookup"><span data-stu-id="131af-151">These functions work with lists, arrays, maps, and sets as well, because all of those types are enumerable, and therefore can be treated as sequences.</span></span>

## <a name="creating-sequences"></a><span data-ttu-id="131af-152">Criando sequências</span><span class="sxs-lookup"><span data-stu-id="131af-152">Creating Sequences</span></span>

<span data-ttu-id="131af-153">Você pode criar sequências usando expressões de sequência, conforme descrito anteriormente, ou usando determinadas funções.</span><span class="sxs-lookup"><span data-stu-id="131af-153">You can create sequences by using sequence expressions, as described previously, or by using certain functions.</span></span>

<span data-ttu-id="131af-154">Você pode criar uma sequência vazia usando [Seq. Empty](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#empty)ou pode criar uma sequência de apenas um elemento especificado usando [Seq. Singleton](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#singleton).</span><span class="sxs-lookup"><span data-stu-id="131af-154">You can create an empty sequence by using [Seq.empty](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#empty), or you can create a sequence of just one specified element by using [Seq.singleton](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#singleton).</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

<span data-ttu-id="131af-155">Você pode usar [Seq.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#init) para criar uma sequência para a qual os elementos são criados usando uma função que você fornece.</span><span class="sxs-lookup"><span data-stu-id="131af-155">You can use [Seq.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#init) to create a sequence for which the elements are created by using a function that you provide.</span></span> <span data-ttu-id="131af-156">Você também fornece um tamanho para a sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-156">You also provide a size for the sequence.</span></span> <span data-ttu-id="131af-157">Essa função é exatamente como [List.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#init), exceto que os elementos não são criados até que você itere pela sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-157">This function is just like [List.init](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#init), except that the elements are not created until you iterate through the sequence.</span></span> <span data-ttu-id="131af-158">O código a seguir ilustra o uso de `Seq.init` .</span><span class="sxs-lookup"><span data-stu-id="131af-158">The following code illustrates the use of `Seq.init`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

<span data-ttu-id="131af-159">A saída é</span><span class="sxs-lookup"><span data-stu-id="131af-159">The output is</span></span>

```console
0 10 20 30 40
```

<span data-ttu-id="131af-160">Usando a função [Seq. ofArray](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofArray) e [seq. ofList&#60;&#62;](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofList), você pode criar sequências de matrizes e listas.</span><span class="sxs-lookup"><span data-stu-id="131af-160">By using [Seq.ofArray](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofArray) and [Seq.ofList&#60;'T&#62; Function](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#ofList), you can create sequences from arrays and lists.</span></span> <span data-ttu-id="131af-161">No entanto, você também pode converter matrizes e listas em sequências usando um operador cast.</span><span class="sxs-lookup"><span data-stu-id="131af-161">However, you can also convert arrays and lists to sequences by using a cast operator.</span></span> <span data-ttu-id="131af-162">As duas técnicas são mostradas no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="131af-162">Both techniques are shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

<span data-ttu-id="131af-163">Usando [Seq. Cast](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cast), você pode criar uma sequência de uma coleção de tipo fraco, como aquelas definidas em `System.Collections` .</span><span class="sxs-lookup"><span data-stu-id="131af-163">By using [Seq.cast](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cast), you can create a sequence from a weakly typed collection, such as those defined in `System.Collections`.</span></span> <span data-ttu-id="131af-164">Essas coleções tipadas de forma fraca têm o tipo de elemento `System.Object` e são enumeradas usando o tipo não genérico `System.Collections.Generic.IEnumerable&#96;1` .</span><span class="sxs-lookup"><span data-stu-id="131af-164">Such weakly typed collections have the element type `System.Object` and are enumerated by using the non-generic `System.Collections.Generic.IEnumerable&#96;1` type.</span></span> <span data-ttu-id="131af-165">O código a seguir ilustra o uso de `Seq.cast` para converter um `System.Collections.ArrayList` em uma sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-165">The following code illustrates the use of `Seq.cast` to convert an `System.Collections.ArrayList` into a sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

<span data-ttu-id="131af-166">Você pode definir sequências infinitas usando a função [Seq.initInfinite](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#initInfinite) .</span><span class="sxs-lookup"><span data-stu-id="131af-166">You can define infinite sequences by using the [Seq.initInfinite](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#initInfinite) function.</span></span> <span data-ttu-id="131af-167">Para tal sequência, você fornece uma função que gera cada elemento do índice do elemento.</span><span class="sxs-lookup"><span data-stu-id="131af-167">For such a sequence, you provide a function that generates each element from the index of the element.</span></span> <span data-ttu-id="131af-168">Sequências infinitas são possíveis devido à avaliação lenta; os elementos são criados conforme necessário chamando a função que você especificar.</span><span class="sxs-lookup"><span data-stu-id="131af-168">Infinite sequences are possible because of lazy evaluation; elements are created as needed by calling the function that you specify.</span></span> <span data-ttu-id="131af-169">O exemplo de código a seguir produz uma sequência infinita de números de ponto flutuante, neste caso, a série alternada de recíprocos de quadrados de inteiros sucessivos.</span><span class="sxs-lookup"><span data-stu-id="131af-169">The following code example produces an infinite sequence of floating point numbers, in this case the alternating series of reciprocals of squares of successive integers.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

<span data-ttu-id="131af-170">[Seq. desdobrar](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#unfold) gera uma sequência de uma função de computação que usa um estado e a transforma para produzir cada elemento subsequente na sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-170">[Seq.unfold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#unfold) generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</span></span> <span data-ttu-id="131af-171">O estado é apenas um valor que é usado para computar cada elemento e pode ser alterado conforme cada elemento é computado.</span><span class="sxs-lookup"><span data-stu-id="131af-171">The state is just a value that is used to compute each element, and can change as each element is computed.</span></span> <span data-ttu-id="131af-172">O segundo argumento para `Seq.unfold` é o valor inicial usado para iniciar a sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-172">The second argument to `Seq.unfold` is the initial value that is used to start the sequence.</span></span> <span data-ttu-id="131af-173">`Seq.unfold` usa um tipo de opção para o estado, que permite que você finalize a sequência retornando o `None` valor.</span><span class="sxs-lookup"><span data-stu-id="131af-173">`Seq.unfold` uses an option type for the state, which enables you to terminate the sequence by returning the `None` value.</span></span> <span data-ttu-id="131af-174">O código a seguir mostra dois exemplos de sequências `seq1` e `fib` , que são gerados por uma `unfold` operação.</span><span class="sxs-lookup"><span data-stu-id="131af-174">The following code shows two examples of sequences, `seq1` and `fib`, that are generated by an `unfold` operation.</span></span> <span data-ttu-id="131af-175">A primeira, `seq1` , é apenas uma sequência simples com números de até 20.</span><span class="sxs-lookup"><span data-stu-id="131af-175">The first, `seq1`, is just a simple sequence with numbers up to 20.</span></span> <span data-ttu-id="131af-176">O segundo, `fib` ,, usa `unfold` para calcular a sequência Fibonacci.</span><span class="sxs-lookup"><span data-stu-id="131af-176">The second, `fib`, uses `unfold` to compute the Fibonacci sequence.</span></span> <span data-ttu-id="131af-177">Como cada elemento na sequência Fibonacci é a soma dos dois números de Fibonacci anteriores, o valor de estado é uma tupla que consiste nos dois números anteriores na sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-177">Because each element in the Fibonacci sequence is the sum of the previous two Fibonacci numbers, the state value is a tuple that consists of the previous two numbers in the sequence.</span></span> <span data-ttu-id="131af-178">O valor inicial é `(1,1)` , os dois primeiros números na sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-178">The initial value is `(1,1)`, the first two numbers in the sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

<span data-ttu-id="131af-179">A saída é da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="131af-179">The output is as follows:</span></span>

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

<span data-ttu-id="131af-180">O código a seguir é um exemplo que usa muitas das funções de módulo de sequência descritas aqui para gerar e calcular os valores de sequências infinitas.</span><span class="sxs-lookup"><span data-stu-id="131af-180">The following code is an example that uses many of the sequence module functions described here to generate and compute the values of infinite sequences.</span></span> <span data-ttu-id="131af-181">O código pode levar alguns minutos para ser executado.</span><span class="sxs-lookup"><span data-stu-id="131af-181">The code might take a few minutes to run.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a><span data-ttu-id="131af-182">Pesquisando e Localizando elementos</span><span class="sxs-lookup"><span data-stu-id="131af-182">Searching and Finding Elements</span></span>

<span data-ttu-id="131af-183">As sequências dão suporte à funcionalidade disponível com listas: [Seq. Exists](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [Seq. exists2](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [Seq. Find](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#find), [Seq. FindIndex](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#findIndex), [Seq. escolha](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pick), [Seq. tryFind](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFind)e [Seq. tryFindIndex](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFindIndex).</span><span class="sxs-lookup"><span data-stu-id="131af-183">Sequences support functionality available with lists: [Seq.exists](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [Seq.exists2](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#exists), [Seq.find](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#find), [Seq.findIndex](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#findIndex), [Seq.pick](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pick), [Seq.tryFind](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFind), and [Seq.tryFindIndex](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#tryFindIndex).</span></span> <span data-ttu-id="131af-184">As versões dessas funções que estão disponíveis para sequências avaliam a sequência somente até o elemento que está sendo pesquisado.</span><span class="sxs-lookup"><span data-stu-id="131af-184">The versions of these functions that are available for sequences evaluate the sequence only up to the element that is being searched for.</span></span> <span data-ttu-id="131af-185">Para obter exemplos, consulte [listas](lists.md).</span><span class="sxs-lookup"><span data-stu-id="131af-185">For examples, see [Lists](lists.md).</span></span>

## <a name="obtaining-subsequences"></a><span data-ttu-id="131af-186">Obtendo subsequências</span><span class="sxs-lookup"><span data-stu-id="131af-186">Obtaining Subsequences</span></span>

<span data-ttu-id="131af-187">[Seq. Filter](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#filter) e [Seq. Choose](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#choose) são como as funções correspondentes que estão disponíveis para listas, exceto que a filtragem e a escolha não ocorrem até que os elementos de sequência sejam avaliados.</span><span class="sxs-lookup"><span data-stu-id="131af-187">[Seq.filter](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#filter) and [Seq.choose](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#choose) are like the corresponding functions that are available for lists, except that the filtering and choosing does not occur until the sequence elements are evaluated.</span></span>

<span data-ttu-id="131af-188">[Seq. Truncate](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#truncate) cria uma sequência de outra sequência, mas limita a sequência a um número especificado de elementos.</span><span class="sxs-lookup"><span data-stu-id="131af-188">[Seq.truncate](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#truncate) creates a sequence from another sequence, but limits the sequence to a specified number of elements.</span></span> <span data-ttu-id="131af-189">[Seq. Take](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#take) cria uma nova sequência que contém apenas um número especificado de elementos desde o início de uma sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-189">[Seq.take](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#take) creates a new sequence that contains only a specified number of elements from the start of a sequence.</span></span> <span data-ttu-id="131af-190">Se houver menos elementos na sequência do que você especificar para executar, `Seq.take` o lançará um `System.InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="131af-190">If there are fewer elements in the sequence than you specify to take, `Seq.take` throws a `System.InvalidOperationException`.</span></span> <span data-ttu-id="131af-191">A diferença entre `Seq.take` e `Seq.truncate` é que o não `Seq.truncate` produzirá um erro se o número de elementos for menor que o número especificado.</span><span class="sxs-lookup"><span data-stu-id="131af-191">The difference between `Seq.take` and `Seq.truncate` is that `Seq.truncate` does not produce an error if the number of elements is fewer than the number you specify.</span></span>

<span data-ttu-id="131af-192">O código a seguir mostra o comportamento e as diferenças entre `Seq.truncate` e `Seq.take` .</span><span class="sxs-lookup"><span data-stu-id="131af-192">The following code shows the behavior of and differences between `Seq.truncate` and `Seq.take`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

<span data-ttu-id="131af-193">A saída, antes da ocorrência do erro, é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="131af-193">The output, before the error occurs, is as follows.</span></span>

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

<span data-ttu-id="131af-194">Usando [Seq. TakeWhile](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#takeWhile), você pode especificar uma função de predicado (uma função booliana) e criar uma sequência de outra sequência composta desses elementos da sequência original para a qual o predicado é `true` , mas parar antes do primeiro elemento para o qual o predicado retorna `false` .</span><span class="sxs-lookup"><span data-stu-id="131af-194">By using [Seq.takeWhile](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#takeWhile), you can specify a predicate function (a Boolean function) and create a sequence from another sequence made up of those elements of the original sequence for which the predicate is `true`, but stop before the first element for which the predicate returns `false`.</span></span> <span data-ttu-id="131af-195">[Seq. Skip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skip) retorna uma sequência que ignora um número especificado dos primeiros elementos de outra sequência e retorna os elementos restantes.</span><span class="sxs-lookup"><span data-stu-id="131af-195">[Seq.skip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skip) returns a sequence that skips a specified number of the first elements of another sequence and returns the remaining elements.</span></span> <span data-ttu-id="131af-196">[Seq. SkipWhile](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skipWhile) retorna uma sequência que ignora os primeiros elementos de outra sequência, desde que o predicado retorne `true` e, em seguida, retorne os elementos restantes, começando com o primeiro elemento para o qual o predicado retorna `false` .</span><span class="sxs-lookup"><span data-stu-id="131af-196">[Seq.skipWhile](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#skipWhile) returns a sequence that skips the first elements of another sequence as long as the predicate returns `true`, and then returns the remaining elements, starting with the first element for which the predicate returns `false`.</span></span>

<span data-ttu-id="131af-197">O exemplo de código a seguir ilustra o comportamento e as diferenças entre `Seq.takeWhile` , `Seq.skip` e `Seq.skipWhile` .</span><span class="sxs-lookup"><span data-stu-id="131af-197">The following code example illustrates the behavior of and differences between `Seq.takeWhile`, `Seq.skip`, and `Seq.skipWhile`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

<span data-ttu-id="131af-198">A saída é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="131af-198">The output is as follows.</span></span>

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a><span data-ttu-id="131af-199">Transformando sequências</span><span class="sxs-lookup"><span data-stu-id="131af-199">Transforming Sequences</span></span>

<span data-ttu-id="131af-200">[Seq. emparelha](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pairwise) cria uma nova sequência na qual os elementos sucessivos da sequência de entrada são agrupados em tuplas.</span><span class="sxs-lookup"><span data-stu-id="131af-200">[Seq.pairwise](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#pairwise) creates a new sequence in which successive elements of the input sequence are grouped into tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

<span data-ttu-id="131af-201">O [Seq. Window](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#windowed) é como `Seq.pairwise` , exceto que, em vez de produzir uma sequência de tuplas, ele produz uma sequência de matrizes que contêm cópias de elementos adjacentes (uma *janela*) da sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-201">[Seq.windowed](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#windowed) is like `Seq.pairwise`, except that instead of producing a sequence of tuples, it produces a sequence of arrays that contain copies of adjacent elements (a *window*) from the sequence.</span></span> <span data-ttu-id="131af-202">Você especifica o número de elementos adjacentes que deseja em cada matriz.</span><span class="sxs-lookup"><span data-stu-id="131af-202">You specify the number of adjacent elements you want in each array.</span></span>

<span data-ttu-id="131af-203">O exemplo de código a seguir demonstra o uso de `Seq.windowed`.</span><span class="sxs-lookup"><span data-stu-id="131af-203">The following code example demonstrates the use of `Seq.windowed`.</span></span> <span data-ttu-id="131af-204">Nesse caso, o número de elementos na janela é 3.</span><span class="sxs-lookup"><span data-stu-id="131af-204">In this case the number of elements in the window is 3.</span></span> <span data-ttu-id="131af-205">O exemplo usa `printSeq` , que é definido no exemplo de código anterior.</span><span class="sxs-lookup"><span data-stu-id="131af-205">The example uses `printSeq`, which is defined in the previous code example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

<span data-ttu-id="131af-206">A saída é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="131af-206">The output is as follows.</span></span>

<span data-ttu-id="131af-207">Sequência inicial:</span><span class="sxs-lookup"><span data-stu-id="131af-207">Initial sequence:</span></span>

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a><span data-ttu-id="131af-208">Operações com várias sequências</span><span class="sxs-lookup"><span data-stu-id="131af-208">Operations with Multiple Sequences</span></span>

<span data-ttu-id="131af-209">[Seq.zip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip) e [Seq.zip3](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip3) demoram duas ou três sequências e produzem uma sequência de tuplas.</span><span class="sxs-lookup"><span data-stu-id="131af-209">[Seq.zip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip) and [Seq.zip3](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#zip3) take two or three sequences and produce a sequence of tuples.</span></span> <span data-ttu-id="131af-210">Essas funções são como as funções correspondentes disponíveis para [listas](lists.md).</span><span class="sxs-lookup"><span data-stu-id="131af-210">These functions are like the corresponding functions available for [lists](lists.md).</span></span> <span data-ttu-id="131af-211">Não há nenhuma funcionalidade correspondente para separar uma sequência em duas ou mais sequências.</span><span class="sxs-lookup"><span data-stu-id="131af-211">There is no corresponding functionality to separate one sequence into two or more sequences.</span></span> <span data-ttu-id="131af-212">Se você precisar dessa funcionalidade para uma sequência, converta a sequência em uma lista e use [list. Unzip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#unzip).</span><span class="sxs-lookup"><span data-stu-id="131af-212">If you need this functionality for a sequence, convert the sequence to a list and use [List.unzip](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#unzip).</span></span>

## <a name="sorting-comparing-and-grouping"></a><span data-ttu-id="131af-213">Classificando, comparando e agrupando</span><span class="sxs-lookup"><span data-stu-id="131af-213">Sorting, Comparing, and Grouping</span></span>

<span data-ttu-id="131af-214">As funções de classificação com suporte para listas também funcionam com sequências.</span><span class="sxs-lookup"><span data-stu-id="131af-214">The sorting functions supported for lists also work with sequences.</span></span> <span data-ttu-id="131af-215">Isso inclui [Seq. Sort](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sort) e [Seq. sortBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sortBy).</span><span class="sxs-lookup"><span data-stu-id="131af-215">This includes [Seq.sort](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sort) and [Seq.sortBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sortBy).</span></span> <span data-ttu-id="131af-216">Essas funções iteram por toda a sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-216">These functions iterate through the whole sequence.</span></span>

<span data-ttu-id="131af-217">Você compara duas sequências usando a função [Seq. compareWith](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#compareWith) .</span><span class="sxs-lookup"><span data-stu-id="131af-217">You compare two sequences by using the [Seq.compareWith](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#compareWith) function.</span></span> <span data-ttu-id="131af-218">A função compara os elementos sucessivos por vez e para quando encontra o primeiro par desigual.</span><span class="sxs-lookup"><span data-stu-id="131af-218">The function compares successive elements in turn, and stops when it encounters the first unequal pair.</span></span> <span data-ttu-id="131af-219">Quaisquer elementos adicionais não contribuem para a comparação.</span><span class="sxs-lookup"><span data-stu-id="131af-219">Any additional elements do not contribute to the comparison.</span></span>

<span data-ttu-id="131af-220">O código a seguir demonstra o uso de `Seq.compareWith`.</span><span class="sxs-lookup"><span data-stu-id="131af-220">The following code shows the use of `Seq.compareWith`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

<span data-ttu-id="131af-221">No código anterior, apenas o primeiro elemento é computado e examinado, e o resultado é-1.</span><span class="sxs-lookup"><span data-stu-id="131af-221">In the previous code, only the first element is computed and examined, and the result is -1.</span></span>

<span data-ttu-id="131af-222">[Seq. countBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#countBy) usa uma função que gera um valor chamado *chave* para cada elemento.</span><span class="sxs-lookup"><span data-stu-id="131af-222">[Seq.countBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#countBy) takes a function that generates a value called a *key* for each element.</span></span> <span data-ttu-id="131af-223">Uma chave é gerada para cada elemento chamando essa função em cada elemento.</span><span class="sxs-lookup"><span data-stu-id="131af-223">A key is generated for each element by calling this function on each element.</span></span> <span data-ttu-id="131af-224">`Seq.countBy` em seguida, retorna uma sequência que contém os valores de chave e uma contagem do número de elementos que geraram cada valor da chave.</span><span class="sxs-lookup"><span data-stu-id="131af-224">`Seq.countBy` then returns a sequence that contains the key values, and a count of the number of elements that generated each value of the key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

<span data-ttu-id="131af-225">A saída é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="131af-225">The output is as follows.</span></span>

```console
(1, 34) (2, 33) (0, 33)
```

<span data-ttu-id="131af-226">A saída anterior mostra que havia 34 elementos da sequência original que produziram os valores de chave 1, 33 que produziram a chave 2 e 33 valores que produziram a chave 0.</span><span class="sxs-lookup"><span data-stu-id="131af-226">The previous output shows that there were 34 elements of the original sequence that produced the key 1, 33 values that produced the key 2, and 33 values that produced the key 0.</span></span>

<span data-ttu-id="131af-227">Você pode agrupar elementos de uma sequência chamando [Seq. GroupBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#groupBy).</span><span class="sxs-lookup"><span data-stu-id="131af-227">You can group elements of a sequence by calling [Seq.groupBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#groupBy).</span></span> <span data-ttu-id="131af-228">`Seq.groupBy` usa uma sequência e uma função que gera uma chave de um elemento.</span><span class="sxs-lookup"><span data-stu-id="131af-228">`Seq.groupBy` takes a sequence and a function that generates a key from an element.</span></span> <span data-ttu-id="131af-229">A função é executada em cada elemento da sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-229">The function is executed on each element of the sequence.</span></span> <span data-ttu-id="131af-230">`Seq.groupBy` Retorna uma sequência de tuplas, em que o primeiro elemento de cada tupla é a chave e a segunda é uma sequência de elementos que produzem essa chave.</span><span class="sxs-lookup"><span data-stu-id="131af-230">`Seq.groupBy` returns a sequence of tuples, where the first element of each tuple is the key and the second is a sequence of elements that produce that key.</span></span>

<span data-ttu-id="131af-231">O exemplo de código a seguir mostra o uso de `Seq.groupBy` para particionar a sequência de números de 1 a 100 em três grupos que têm os valores de chave distintos 0, 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="131af-231">The following code example shows the use of `Seq.groupBy` to partition the sequence of numbers from 1 to 100 into three groups that have the distinct key values 0, 1, and 2.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

<span data-ttu-id="131af-232">A saída é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="131af-232">The output is as follows.</span></span>

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

<span data-ttu-id="131af-233">Você pode criar uma sequência que elimina elementos duplicados chamando [Seq. Distinct](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinct).</span><span class="sxs-lookup"><span data-stu-id="131af-233">You can create a sequence that eliminates duplicate elements by calling [Seq.distinct](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinct).</span></span> <span data-ttu-id="131af-234">Ou você pode usar [Seq. distinctBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinctBy), que usa uma função de geração de chaves a ser chamada em cada elemento.</span><span class="sxs-lookup"><span data-stu-id="131af-234">Or you can use [Seq.distinctBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#distinctBy), which takes a key-generating function to be called on each element.</span></span> <span data-ttu-id="131af-235">A sequência resultante contém elementos da sequência original que têm chaves exclusivas; os elementos posteriores que produzem uma chave duplicada para um elemento anterior são descartados.</span><span class="sxs-lookup"><span data-stu-id="131af-235">The resulting sequence contains elements of the original sequence that have unique keys; later elements that produce a duplicate key to an earlier element are discarded.</span></span>

<span data-ttu-id="131af-236">O exemplo de código a seguir ilustra o uso do objeto `Seq.distinct`.</span><span class="sxs-lookup"><span data-stu-id="131af-236">The following code example illustrates the use of `Seq.distinct`.</span></span> <span data-ttu-id="131af-237">`Seq.distinct` é demonstrado pela geração de sequências que representam números binários e, em seguida, mostrando que os únicos elementos distintos são 0 e 1.</span><span class="sxs-lookup"><span data-stu-id="131af-237">`Seq.distinct` is demonstrated by generating sequences that represent binary numbers, and then showing that the only distinct elements are 0 and 1.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

<span data-ttu-id="131af-238">O código a seguir demonstra `Seq.distinctBy` iniciando com uma sequência que contém números negativos e positivos e usando a função de valor absoluto como a função de geração de chaves.</span><span class="sxs-lookup"><span data-stu-id="131af-238">The following code demonstrates `Seq.distinctBy` by starting with a sequence that contains negative and positive numbers and using the absolute value function as the key-generating function.</span></span> <span data-ttu-id="131af-239">A sequência resultante não tem todos os números positivos que correspondem aos números negativos na sequência, pois os números negativos aparecem anteriormente na sequência e, portanto, são selecionados em vez dos números positivos que têm o mesmo valor absoluto ou chave.</span><span class="sxs-lookup"><span data-stu-id="131af-239">The resulting sequence is missing all the positive numbers that correspond to the negative numbers in the sequence, because the negative numbers appear earlier in the sequence and therefore are selected instead of the positive numbers that have the same absolute value, or key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a><span data-ttu-id="131af-240">Sequências ReadOnly e armazenadas em cache</span><span class="sxs-lookup"><span data-stu-id="131af-240">Readonly and Cached Sequences</span></span>

<span data-ttu-id="131af-241">[Seq. ReadOnly](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#readonly) cria uma cópia somente leitura de uma sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-241">[Seq.readonly](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#readonly) creates a read-only copy of a sequence.</span></span> <span data-ttu-id="131af-242">`Seq.readonly` é útil quando você tem uma coleção de leitura/gravação, como uma matriz, e não deseja modificar a coleção original.</span><span class="sxs-lookup"><span data-stu-id="131af-242">`Seq.readonly` is useful when you have a read-write collection, such as an array, and you do not want to modify the original collection.</span></span> <span data-ttu-id="131af-243">Essa função pode ser usada para preservar o encapsulamento de dados.</span><span class="sxs-lookup"><span data-stu-id="131af-243">This function can be used to preserve data encapsulation.</span></span> <span data-ttu-id="131af-244">No exemplo de código a seguir, um tipo que contém uma matriz é criado.</span><span class="sxs-lookup"><span data-stu-id="131af-244">In the following code example, a type that contains an array is created.</span></span> <span data-ttu-id="131af-245">Uma propriedade expõe a matriz, mas em vez de retornar uma matriz, ela retorna uma sequência que é criada a partir da matriz usando `Seq.readonly` .</span><span class="sxs-lookup"><span data-stu-id="131af-245">A property exposes the array, but instead of returning an array, it returns a sequence that is created from the array by using `Seq.readonly`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

<span data-ttu-id="131af-246">[Seq. cache](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cache) cria uma versão armazenada de uma sequência.</span><span class="sxs-lookup"><span data-stu-id="131af-246">[Seq.cache](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#cache) creates a stored version of a sequence.</span></span> <span data-ttu-id="131af-247">Use `Seq.cache` para evitar a reavaliação de uma sequência, ou quando você tiver vários threads que usam uma sequência, mas você deve certificar-se de que cada elemento seja acionado apenas uma vez.</span><span class="sxs-lookup"><span data-stu-id="131af-247">Use `Seq.cache` to avoid reevaluation of a sequence, or when you have multiple threads that use a sequence, but you must make sure that each element is acted upon only one time.</span></span> <span data-ttu-id="131af-248">Quando você tem uma sequência que está sendo usada por vários threads, você pode ter um thread que enumera e computa os valores para a sequência original, e os threads restantes podem usar a sequência armazenada em cache.</span><span class="sxs-lookup"><span data-stu-id="131af-248">When you have a sequence that is being used by multiple threads, you can have one thread that enumerates and computes the values for the original sequence, and remaining threads can use the cached sequence.</span></span>

## <a name="performing-computations-on-sequences"></a><span data-ttu-id="131af-249">Executando cálculos em sequências</span><span class="sxs-lookup"><span data-stu-id="131af-249">Performing Computations on Sequences</span></span>

<span data-ttu-id="131af-250">Operações aritméticas simples são como as de listas, como [Seq. Average](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#average), [Seq. Sum](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sum), [Seq. averageBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#averageBy), [Seq. sumBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sumBy)e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="131af-250">Simple arithmetic operations are like those of lists, such as [Seq.average](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#average), [Seq.sum](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sum), [Seq.averageBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#averageBy), [Seq.sumBy](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#sumBy), and so on.</span></span>

<span data-ttu-id="131af-251">[Seq. fold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#fold), [Seq. reduz](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#reduce)e [Seq. scan](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#scan) são como as funções correspondentes que estão disponíveis para listas.</span><span class="sxs-lookup"><span data-stu-id="131af-251">[Seq.fold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#fold), [Seq.reduce](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#reduce), and [Seq.scan](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#scan) are like the corresponding functions that are available for lists.</span></span> <span data-ttu-id="131af-252">As sequências dão suporte a um subconjunto das variações completas dessas funções que listam o suporte.</span><span class="sxs-lookup"><span data-stu-id="131af-252">Sequences support a subset of the full variations of these functions that lists support.</span></span> <span data-ttu-id="131af-253">Para obter mais informações e exemplos, consulte [listas](lists.md).</span><span class="sxs-lookup"><span data-stu-id="131af-253">For more information and examples, see [Lists](lists.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="131af-254">Confira também</span><span class="sxs-lookup"><span data-stu-id="131af-254">See also</span></span>

- [<span data-ttu-id="131af-255">Referência de linguagem F #</span><span class="sxs-lookup"><span data-stu-id="131af-255">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="131af-256">Tipos F#</span><span class="sxs-lookup"><span data-stu-id="131af-256">F# Types</span></span>](fsharp-types.md)
