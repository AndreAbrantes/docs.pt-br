---
title: Genéricos (F#)
description: 'Saiba como usar as funções genéricas do F # e tipos que permitem que você escreva código que funciona com uma variedade de tipos sem repetir o código.'
ms.date: 05/16/2016
ms.openlocfilehash: fc061f19c6c7fa737f7ca05aae83fd42c0010b37
ms.sourcegitcommit: 3c1c3ba79895335ff3737934e39372555ca7d6d0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/05/2018
ms.locfileid: "43749230"
---
# <a name="generics"></a><span data-ttu-id="55cd5-103">Genéricos</span><span class="sxs-lookup"><span data-stu-id="55cd5-103">Generics</span></span>

<span data-ttu-id="55cd5-104">Os valores, os métodos, as propriedades e os tipos de agregação, como classes, registros e uniões discriminadas, da função em F# podem ser *genéricos*.</span><span class="sxs-lookup"><span data-stu-id="55cd5-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="55cd5-105">As construções genéricas contêm pelo menos um parâmetro de tipo, que é geralmente fornecido pelo usuário da construção genérica.</span><span class="sxs-lookup"><span data-stu-id="55cd5-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="55cd5-106">Os tipos e as funções genéricas permitem que você escreva códigos que funcionam com diversos tipos sem repetir o código de cada tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="55cd5-107">Tornar seu código genérico pode ser algo simples em F#, pois normalmente seu código é implicitamente inferido como genérico pelos mecanismos de generalização automática e de inferência de tipos do compilador.</span><span class="sxs-lookup"><span data-stu-id="55cd5-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="55cd5-108">Sintaxe</span><span class="sxs-lookup"><span data-stu-id="55cd5-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="55cd5-109">Comentários</span><span class="sxs-lookup"><span data-stu-id="55cd5-109">Remarks</span></span>

<span data-ttu-id="55cd5-110">A declaração de um tipo ou de uma função explicitamente genérica é muito semelhante a de um tipo ou função não genérica, exceto com relação à especificação (e uso) dos parâmetros de tipo, entre colchetes após o nome da função ou do tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="55cd5-111">Geralmente, as declarações são implicitamente genéricas.</span><span class="sxs-lookup"><span data-stu-id="55cd5-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="55cd5-112">Se você não especificar completamente o tipo de cada parâmetro usado para compor uma função ou tipo, o compilador tentará inferir o tipo de cada parâmetro, o valor e a variável de código que você escreve.</span><span class="sxs-lookup"><span data-stu-id="55cd5-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="55cd5-113">Para saber mais, veja [Inferência de tipo](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="55cd5-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="55cd5-114">Se o código do tipo ou função não restringir de outro modo os tipos de parâmetros, a função ou o tipo será implicitamente genérico.</span><span class="sxs-lookup"><span data-stu-id="55cd5-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="55cd5-115">Esse processo é chamado de *generalização automática*.</span><span class="sxs-lookup"><span data-stu-id="55cd5-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="55cd5-116">Há alguns limites para a generalização automática.</span><span class="sxs-lookup"><span data-stu-id="55cd5-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="55cd5-117">Por exemplo, se o compilador em F# não puder inferir os tipos de uma construção genérica, o compilador relatará um erro que faz referência a uma restrição chamada de *restrição de valor*.</span><span class="sxs-lookup"><span data-stu-id="55cd5-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="55cd5-118">Nesse caso, talvez seja necessário adicionar algumas anotações de tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="55cd5-119">Para saber mais sobre generalização automática e restrição de valor e como alterar seu código para resolver esse problema, veja [Generalização automática](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="55cd5-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="55cd5-120">Na sintaxe anterior, *type-parameters* é uma lista separada por vírgulas de parâmetros que representam tipos desconhecidos, cada um deles começa com uma aspa simples e, opcionalmente, com uma cláusula de restrição que limita ainda mais os tipos que podem ser usados para esse parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="55cd5-121">Para obter a sintaxe das cláusulas de restrição de vários tipos e outras informações sobre restrições, veja [Restrições](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="55cd5-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="55cd5-122">Na sintaxe, *type-definition* é igual à definição de tipo para um tipo não genérico.</span><span class="sxs-lookup"><span data-stu-id="55cd5-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="55cd5-123">Ele inclui os parâmetros do construtor para um tipo de classe, uma cláusula `as` opcional, o símbolo de igual, os campos de registro, a cláusula `inherit`, as opções de uma união discriminada, associações `let` e `do`, definições de membro e qualquer outra coisa permitida em uma definição de tipo não genérico.</span><span class="sxs-lookup"><span data-stu-id="55cd5-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="55cd5-124">Os outros elementos de sintaxe são os mesmos para tipos e funções não genéricos.</span><span class="sxs-lookup"><span data-stu-id="55cd5-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="55cd5-125">Por exemplo, *object-identifier* é um identificador que representa o objeto contido em si.</span><span class="sxs-lookup"><span data-stu-id="55cd5-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="55cd5-126">Os construtores, os campos e as propriedades não podem ser mais genéricos do que o tipo delimitador.</span><span class="sxs-lookup"><span data-stu-id="55cd5-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="55cd5-127">Além disso, os valores em um módulo não podem ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="55cd5-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="55cd5-128">Construções implicitamente genéricas</span><span class="sxs-lookup"><span data-stu-id="55cd5-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="55cd5-129">Quando o compilador de F# infere os tipos em seu código, ele trata automaticamente qualquer função que possa ser genérica como genérica.</span><span class="sxs-lookup"><span data-stu-id="55cd5-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="55cd5-130">Se você especificar um tipo explicitamente, como um tipo de parâmetro, você evita a generalização automática.</span><span class="sxs-lookup"><span data-stu-id="55cd5-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="55cd5-131">No exemplo de código a seguir, `makeList` é genérico, mesmo que ele ou seus parâmetros não sejam explicitamente declarados como genéricos.</span><span class="sxs-lookup"><span data-stu-id="55cd5-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="55cd5-132">A assinatura da função é inferida como `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="55cd5-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="55cd5-133">Observe que, neste exemplo, `a` e `b` são inferidos com tendo o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="55cd5-134">Isso ocorre porque eles são incluídos em uma lista juntos, e todos os elementos de uma lista devem ser do mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="55cd5-135">Você também pode tornar uma função genérica usando a sintaxe de aspas simples em uma anotação de tipo para indicar que um tipo de parâmetro é um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="55cd5-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="55cd5-136">No código a seguir, `function1` é genérico porque os parâmetros são declarados dessa maneira, como parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="55cd5-137">Construções explicitamente genéricas</span><span class="sxs-lookup"><span data-stu-id="55cd5-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="55cd5-138">Você também pode tornar uma função genérica declarando explicitamente seus parâmetros de tipo entre colchetes angulares (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="55cd5-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="55cd5-139">O código a seguir ilustra isso.</span><span class="sxs-lookup"><span data-stu-id="55cd5-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="55cd5-140">Como usar construções genéricas</span><span class="sxs-lookup"><span data-stu-id="55cd5-140">Using Generic Constructs</span></span>

<span data-ttu-id="55cd5-141">Quando você usa métodos ou funções genéricas, talvez não seja necessário especificar os argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="55cd5-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="55cd5-142">O compilador usa a inferência de tipo para inferir os argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="55cd5-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="55cd5-143">Se ainda houver ambiguidade, forneça argumentos de tipo entre colchetes angulares, separando vários argumentos de tipo por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="55cd5-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="55cd5-144">O código a seguir mostra o uso das funções definidas nas seções anteriores.</span><span class="sxs-lookup"><span data-stu-id="55cd5-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

>[!NOTE]
<span data-ttu-id="55cd5-145">Há duas maneiras de se referir a um tipo genérico por nome.</span><span class="sxs-lookup"><span data-stu-id="55cd5-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="55cd5-146">Por exemplo, `list<int>` e `int list` são duas maneiras de se referir a um tipo genérico `list` que tem um único argumento de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="55cd5-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="55cd5-147">A segunda forma é usada apenas com tipos internos de F#, como `list` e `option`.</span><span class="sxs-lookup"><span data-stu-id="55cd5-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="55cd5-148">Se houver vários argumentos de tipo, você normalmente usará a sintaxe `Dictionary<int, string>`, mas também é possível usar a sintaxe `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="55cd5-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="55cd5-149">Caracteres curinga como argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="55cd5-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="55cd5-150">Para especificar se um argumento de tipo deve ser deduzido pelo compilador, você pode usar o sublinhado, ou um símbolo de caractere curinga (`_`), em vez de um argumento de tipo nomeado.</span><span class="sxs-lookup"><span data-stu-id="55cd5-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="55cd5-151">Isso será mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="55cd5-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="55cd5-152">Restrições em funções e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="55cd5-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="55cd5-153">Em uma definição de função ou tipo genérico, você pode usar somente as construções sabidamente disponíveis no parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="55cd5-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="55cd5-154">Isso é necessário para habilitar a verificação de chamadas de função e de método no tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="55cd5-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="55cd5-155">Se você declarar explicitamente os parâmetros de tipo, aplique uma restrição explícita a um parâmetro de tipo genérico a fim de notificar o compilador de que certos métodos e funções estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="55cd5-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="55cd5-156">No entanto, se você permitir que o compilador de F# deduza seus tipos de parâmetros genéricos, ele determinará as restrições apropriadas a você.</span><span class="sxs-lookup"><span data-stu-id="55cd5-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="55cd5-157">Para saber mais, veja [Restrições](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="55cd5-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="55cd5-158">Parâmetros de tipo resolvidos estaticamente</span><span class="sxs-lookup"><span data-stu-id="55cd5-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="55cd5-159">Há dois tipos de parâmetros de tipo que podem ser usados em programas em F#.</span><span class="sxs-lookup"><span data-stu-id="55cd5-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="55cd5-160">O primeiro são os parâmetros de tipo genérico do tipo descrito nas seções anteriores.</span><span class="sxs-lookup"><span data-stu-id="55cd5-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="55cd5-161">Esse primeiro tipo de parâmetro de tipo é equivalente a parâmetros de tipo genérico usados em linguagens como Visual Basic e C#.</span><span class="sxs-lookup"><span data-stu-id="55cd5-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="55cd5-162">Outro tipo de parâmetro de tipo é específico do F# e é conhecido como um *parâmetro de tipo resolvido estaticamente*.</span><span class="sxs-lookup"><span data-stu-id="55cd5-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="55cd5-163">Para saber mais sobre essas construções, veja [Parâmetros de tipo resolvidos estaticamente](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="55cd5-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="55cd5-164">Exemplos</span><span class="sxs-lookup"><span data-stu-id="55cd5-164">Examples</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="55cd5-165">Consulte também</span><span class="sxs-lookup"><span data-stu-id="55cd5-165">See also</span></span>

- [<span data-ttu-id="55cd5-166">Referência de Linguagem</span><span class="sxs-lookup"><span data-stu-id="55cd5-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="55cd5-167">Tipos</span><span class="sxs-lookup"><span data-stu-id="55cd5-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="55cd5-168">Parâmetros de tipo resolvidos estaticamente</span><span class="sxs-lookup"><span data-stu-id="55cd5-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="55cd5-169">Genéricos no .NET Framework</span><span class="sxs-lookup"><span data-stu-id="55cd5-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="55cd5-170">Generalização Automática</span><span class="sxs-lookup"><span data-stu-id="55cd5-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="55cd5-171">Restrições</span><span class="sxs-lookup"><span data-stu-id="55cd5-171">Constraints</span></span>](constraints.md)
