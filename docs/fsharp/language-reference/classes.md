---
title: Classes (F#)
description: 'Saiba como o F # Classes são tipos que representam os objetos que podem ter propriedades, métodos e eventos.'
ms.date: 05/16/2016
ms.openlocfilehash: 71cd713d192d28565e879b79b2fc9e0530e5f841
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/07/2018
ms.locfileid: "44060577"
---
# <a name="classes"></a><span data-ttu-id="ecc8e-103">Classes</span><span class="sxs-lookup"><span data-stu-id="ecc8e-103">Classes</span></span>

<span data-ttu-id="ecc8e-104">*Classes* são tipos que representam os objetos que podem ter propriedades, métodos e eventos.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="ecc8e-105">Sintaxe</span><span class="sxs-lookup"><span data-stu-id="ecc8e-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="ecc8e-106">Comentários</span><span class="sxs-lookup"><span data-stu-id="ecc8e-106">Remarks</span></span>

<span data-ttu-id="ecc8e-107">As classes representam a descrição fundamental dos tipos de objeto do .NET; a classe é o conceito de tipo primário que dá suporte à programação orientada a objeto em F #.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="ecc8e-108">Na sintaxe anterior, o `type-name` é qualquer identificador válido.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="ecc8e-109">O `type-params` descreve parâmetros de tipo genérico opcional.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="ecc8e-110">Ele consiste em nomes de parâmetro de tipo e restrições entre colchetes angulares (`<` e `>`).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="ecc8e-111">Para obter mais informações, consulte [genéricos](generics/index.md) e [restrições](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-111">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="ecc8e-112">O `parameter-list` descreve os parâmetros do construtor.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="ecc8e-113">O modificador de acesso de primeira pertence ao tipo; a segunda diz respeito ao construtor primário.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="ecc8e-114">Em ambos os casos, o padrão é `public`.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="ecc8e-115">Especificar a classe base para uma classe usando o `inherit` palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="ecc8e-116">Você deve fornecer argumentos, entre parênteses, o construtor de classe base.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="ecc8e-117">Declarar campos ou valores que são locais para a classe por meio de função `let` associações e você deve seguir as regras gerais para `let` associações.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="ecc8e-118">O `do-bindings` seção inclui o código a ser executado no momento da construção do objeto.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="ecc8e-119">O `member-list` consiste em construtores adicionais, instância e declarações de método estático, declarações de interface, associações abstratas e declarações de propriedade e evento.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="ecc8e-120">Elas são descritas em [membros](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-120">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="ecc8e-121">O `identifier` que é usado com opcional `as` palavra-chave fornece um nome para a variável de instância, ou identificador self, que pode ser usado na definição de tipo para fazer referência à instância do tipo.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="ecc8e-122">Para obter mais informações, consulte a seção Self identificadores neste tópico.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="ecc8e-123">As palavras-chave `class` e `end` que marcam o início e final da definição do são opcionais.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="ecc8e-124">Mutuamente recursivas tipos, que são tipos que fazem referência uns aos outros, são Unidos junto com o `and` exatamente como mutuamente funções recursivas são de palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="ecc8e-125">Para obter um exemplo, consulte a seção mutuamente recursivas tipos.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="ecc8e-126">Construtores</span><span class="sxs-lookup"><span data-stu-id="ecc8e-126">Constructors</span></span>

<span data-ttu-id="ecc8e-127">O construtor é o código que cria uma instância do tipo de classe.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="ecc8e-128">Construtores para classes funcionam de forma um pouco diferente no F # do que em outras linguagens .NET.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="ecc8e-129">Em uma classe de F #, sempre há um construtor primário cujos argumentos são descritos na `parameter-list` que segue o nome do tipo e cujo corpo consiste o `let` (e `let rec`) associações no início da declaração de classe e o `do`associações que seguem.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="ecc8e-130">Os argumentos do construtor primário estão no escopo em toda a declaração de classe.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="ecc8e-131">Você pode adicionar os construtores adicionais usando o `new` palavra-chave para adicionar um membro, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="ecc8e-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="ecc8e-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="ecc8e-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="ecc8e-133">O corpo do novo construtor deve invocar o construtor primário que é especificado no topo da declaração de classe.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="ecc8e-134">O exemplo a seguir ilustra esse conceito.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-134">The following example illustrates this concept.</span></span> <span data-ttu-id="ecc8e-135">No código a seguir, `MyClass` possui dois construtores, um construtor primário que usa dois argumentos e outro construtor que não usa nenhum argumento.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="ecc8e-136">Let e associações</span><span class="sxs-lookup"><span data-stu-id="ecc8e-136">let and do Bindings</span></span>

<span data-ttu-id="ecc8e-137">O `let` e `do` ligações em uma definição de classe formam o corpo do construtor de classe primária e, portanto, são executados sempre que uma instância da classe é criada.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="ecc8e-138">Se um `let` associação é uma função e, em seguida, ele é compilado em um membro.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="ecc8e-139">Se o `let` associação é um valor que não é usado em qualquer função ou um membro, em seguida, ele é compilado em uma variável que é local para o construtor.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="ecc8e-140">Caso contrário, ele é compilado em um campo da classe.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="ecc8e-141">O `do` expressões que seguem são compiladas para o construtor primário e executar o código de inicialização para cada instância.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="ecc8e-142">Porque os construtores adicionais sempre chamem o construtor primário, o `let` associações e `do` associações sempre executado, independentemente de qual construtor é chamado.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="ecc8e-143">Campos que são criados por `let` associações podem ser acessadas em todo os métodos e propriedades da classe; no entanto, eles não podem ser acessados de métodos estáticos, mesmo se os métodos estáticos usam uma variável de instância como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="ecc8e-144">Não pode ser acessados usando o identificador de autoatendimento, se houver.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="ecc8e-145">Autoidentificadores</span><span class="sxs-lookup"><span data-stu-id="ecc8e-145">Self Identifiers</span></span>

<span data-ttu-id="ecc8e-146">Um *identificador self* é um nome que representa a instância atual.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="ecc8e-147">Autoidentificadores se parecer com o `this` palavra-chave em c# ou C++ ou `Me` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="ecc8e-148">Você pode definir um identificador de autoatendimento de duas maneiras diferentes, dependendo se você deseja que o identificador de autoatendimento do escopo para a definição de classe inteira ou apenas para um método individual.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="ecc8e-149">Para definir um identificador de autoatendimento para a classe inteira, use o `as` palavra-chave depois dos parênteses de fechamento do parâmetro de construtor de lista e especifique o nome do identificador.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="ecc8e-150">Para definir um identificador individual para apenas um método, forneça o identificador de auto na declaração de membro, logo antes do nome do método e um ponto (.) como separador.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="ecc8e-151">O exemplo de código a seguir ilustra as duas maneiras de criar um identificador de self.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="ecc8e-152">Na primeira linha, o `as` palavra-chave é usada para definir o identificador de self.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="ecc8e-153">Na quinta linha, o identificador `this` é usado para definir um identificador de autoatendimento cujo escopo é restrito para o método `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="ecc8e-154">Ao contrário em outras linguagens .NET, você pode nomear o identificador self desejar; Você não está restrito a nomes, como `self`, `Me`, ou `this`.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="ecc8e-155">O identificador de autoatendimento que é declarado com o `as` palavra-chave não foi inicializado até depois que o `let` associações são executadas.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="ecc8e-156">Portanto, ele não pode ser usado no `let` associações.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="ecc8e-157">Você pode usar o identificador de autoatendimento no `do` seção de associações.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="ecc8e-158">Parâmetros de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="ecc8e-158">Generic Type Parameters</span></span>

<span data-ttu-id="ecc8e-159">Parâmetros de tipo genérico são especificados entre colchetes angulares (`<` e `>`), na forma de uma marca de aspas simples seguida por um identificador.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="ecc8e-160">Vários parâmetros de tipo genérico são separados por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="ecc8e-161">O parâmetro de tipo genérico está no escopo em toda a declaração.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="ecc8e-162">O exemplo de código a seguir mostra como especificar parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="ecc8e-163">Argumentos de tipo são inferidos quando o tipo é usado.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="ecc8e-164">No código a seguir, o tipo inferido é uma sequência de tuplas.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="ecc8e-165">Especificação de herança</span><span class="sxs-lookup"><span data-stu-id="ecc8e-165">Specifying Inheritance</span></span>

<span data-ttu-id="ecc8e-166">O `inherit` cláusula identifica a classe base direta, se houver um.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="ecc8e-167">No F #, apenas uma classe base direta é permitida.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="ecc8e-168">Interfaces que implementa uma classe não são consideradas classes base.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="ecc8e-169">Interfaces são discutidos os [Interfaces](Interfaces.md) tópico.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="ecc8e-170">Você pode acessar os métodos e propriedades da classe base da classe derivada usando a palavra-chave de linguagem `base` como um identificador, seguido por um ponto (.) e o nome do membro.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="ecc8e-171">Para obter mais informações, consulte [Herança](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="ecc8e-172">Seção de membros</span><span class="sxs-lookup"><span data-stu-id="ecc8e-172">Members Section</span></span>

<span data-ttu-id="ecc8e-173">Você pode definir estático ou instância métodos, propriedades, implementações de interface, membros abstratos, declarações de evento e construtores adicionais nesta seção.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="ecc8e-174">Let e fazem ligações não pode aparecer nesta seção.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="ecc8e-175">Porque os membros podem ser adicionados a uma variedade de tipos F #, além de classes, eles serão discutidos em um tópico separado, [membros](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="ecc8e-176">Mutuamente recursivas tipos</span><span class="sxs-lookup"><span data-stu-id="ecc8e-176">Mutually Recursive Types</span></span>

<span data-ttu-id="ecc8e-177">Quando você define tipos que fazem referência entre si de uma forma circular, é enfileirar as definições de tipo usando o `and` palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="ecc8e-178">O `and` palavra-chave substitui o `type` palavra-chave em todos, exceto a primeira definição, da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="ecc8e-179">A saída é uma lista de todos os arquivos no diretório atual.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="ecc8e-180">Quando usar Classes e estruturas, registros e uniões</span><span class="sxs-lookup"><span data-stu-id="ecc8e-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="ecc8e-181">Considerando a variedade de tipos para escolher, você precisa ter uma boa compreensão de como o que cada tipo é projetado para selecionar o tipo apropriado para uma determinada situação.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="ecc8e-182">As classes são projetadas para uso em contextos de programação orientada a objeto.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="ecc8e-183">Programação orientada a objeto é o paradigma dominante usado em aplicativos que são escritos para o .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="ecc8e-184">Se seu código F # tem trabalhem em conjunto com o .NET Framework ou outra biblioteca orientada a objeto e, especialmente se você tiver que estendem a partir de um sistema de tipos orientado a objeto, como uma biblioteca de interface do usuário, as classes são provavelmente apropriadas.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="ecc8e-185">Se você não está interoperando intimamente com o código orientado a objeto, ou se você estiver escrevendo código que é independente e, portanto, protegido contra interações frequentes com o código orientado a objeto, você deve considerar o uso de registros e uniões discriminadas.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="ecc8e-186">Uma única e bem pensamento – out união discriminada, junto com correspondência apropriada de código, geralmente pode ser usado como uma alternativa mais simples para uma hierarquia de objetos.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="ecc8e-187">Para obter mais informações sobre as uniões discriminadas, consulte [uniões discriminadas](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="ecc8e-188">Registros têm a vantagem de ser mais simples do que as classes, mas os registros não são apropriados quando as demandas de um tipo excedem o que pode ser feito com a sua simplicidade.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="ecc8e-189">Os registros são basicamente simples agregações de valores, sem construtores separados que podem executar ações personalizadas, sem campos ocultos e sem as implementações de herança ou interface.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="ecc8e-190">Embora membros como métodos e propriedades podem ser adicionados aos registros para tornar seu comportamento mais complexo, os campos armazenados em um registro ainda são uma agregação simples de valores.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="ecc8e-191">Para obter mais informações sobre os registros, consulte [registros](records.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="ecc8e-192">Estruturas também são úteis para pequenos agregados de dados, mas elas diferem das classes e registros são tipos de valor do .NET.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="ecc8e-193">Registros e classes são tipos de referência do .NET.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="ecc8e-194">A semântica de tipos de valor e tipos de referência é diferente tipos de valor são passados por valor.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="ecc8e-195">Isso significa que eles são copiados bit por bit quando são passados como um parâmetro ou retornados de uma função.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="ecc8e-196">Eles também são armazenados na pilha ou, se eles forem usados como um campo, inserido dentro do objeto pai, em vez de armazenados em seu próprio local separado no heap.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="ecc8e-197">Portanto, as estruturas são apropriadas para dados acessados com frequência quando a sobrecarga de acessar o heap é um problema.</span><span class="sxs-lookup"><span data-stu-id="ecc8e-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="ecc8e-198">Para obter mais informações sobre estruturas, consulte [estruturas](structures.md).</span><span class="sxs-lookup"><span data-stu-id="ecc8e-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="ecc8e-199">Consulte também</span><span class="sxs-lookup"><span data-stu-id="ecc8e-199">See also</span></span>

- [<span data-ttu-id="ecc8e-200">Referência da Linguagem F#</span><span class="sxs-lookup"><span data-stu-id="ecc8e-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="ecc8e-201">Membros</span><span class="sxs-lookup"><span data-stu-id="ecc8e-201">Members</span></span>](members/index.md)
- [<span data-ttu-id="ecc8e-202">Herança</span><span class="sxs-lookup"><span data-stu-id="ecc8e-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="ecc8e-203">Interfaces</span><span class="sxs-lookup"><span data-stu-id="ecc8e-203">Interfaces</span></span>](interfaces.md)
