---
title: Valores (F#)
description: 'Saiba como os valores em F # são quantidades que têm um tipo específico.'
ms.date: 05/16/2016
ms.openlocfilehash: f645481ce8395c11ae920aee06cbf07955aeb684
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2018
ms.locfileid: "45677819"
---
# <a name="values"></a><span data-ttu-id="c1456-103">Valores</span><span class="sxs-lookup"><span data-stu-id="c1456-103">Values</span></span>

<span data-ttu-id="c1456-104">Os valores em F# podem ser números inteiros ou de ponto flutuante, caracteres ou texto, listas, sequências, matrizes, tuplas, uniões discriminadas, registros, tipos de classe ou valores de função.</span><span class="sxs-lookup"><span data-stu-id="c1456-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="c1456-105">Associação de valor</span><span class="sxs-lookup"><span data-stu-id="c1456-105">Binding a Value</span></span>

<span data-ttu-id="c1456-106">O termo *associação* significa associar um nome a uma definição.</span><span class="sxs-lookup"><span data-stu-id="c1456-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="c1456-107">A palavra-chave `let` associa um valor, como nos exemplos a seguir:</span><span class="sxs-lookup"><span data-stu-id="c1456-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="c1456-108">O tipo de um valor é inferido da definição.</span><span class="sxs-lookup"><span data-stu-id="c1456-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="c1456-109">Para um tipo primitivo, como um número de ponto flutuante ou integral, o tipo é determinado pelo tipo do literal.</span><span class="sxs-lookup"><span data-stu-id="c1456-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="c1456-110">Portanto, no exemplo anterior, o compilador infere o tipo de `b` como `unsigned int`, enquanto o compilador infere o tipo de `a` como `int`.</span><span class="sxs-lookup"><span data-stu-id="c1456-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="c1456-111">O tipo de valor de uma função é determinado pelo valor de retorno no corpo da função.</span><span class="sxs-lookup"><span data-stu-id="c1456-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="c1456-112">Para saber mais sobre tipos de valor de função, veja [Funções](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="c1456-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="c1456-113">Para saber mais sobre tipos de literal, veja [Literais](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="c1456-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="c1456-114">O compilador não emite diagnóstico sobre associações não utilizados por padrão.</span><span class="sxs-lookup"><span data-stu-id="c1456-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="c1456-115">Para receber essas mensagens, habilitar o aviso 1182 no arquivo de projeto ou ao invocar o compilador (consulte `--warnon` sob [opções do compilador](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="c1456-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="c1456-116">Por que imutável?</span><span class="sxs-lookup"><span data-stu-id="c1456-116">Why Immutable?</span></span>

<span data-ttu-id="c1456-117">Valores imutáveis são valores que não podem ser alterados durante a execução de um programa.</span><span class="sxs-lookup"><span data-stu-id="c1456-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="c1456-118">Se você estiver acostumado com linguagens como C++, Visual Basic ou X#, talvez se surpreenda por F# dar prioridade para valores imutáveis em vez de variáveis que podem receber novos valores durante a execução de um programa.</span><span class="sxs-lookup"><span data-stu-id="c1456-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="c1456-119">Dados imutáveis são um elemento importante da programação funcional.</span><span class="sxs-lookup"><span data-stu-id="c1456-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="c1456-120">Em um ambiente multithread, é difícil gerenciar variáveis mutáveis compartilhadas que podem ser alteradas por muitos threads diferentes.</span><span class="sxs-lookup"><span data-stu-id="c1456-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="c1456-121">Além disso, com as variáveis mutáveis, às vezes pode ser difícil dizer se uma variável pode ser alterada quando ela é passada para outra função.</span><span class="sxs-lookup"><span data-stu-id="c1456-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="c1456-122">Em linguagens funcionais puras, não há variáveis, e as funções se comportam estritamente como funções matemáticas.</span><span class="sxs-lookup"><span data-stu-id="c1456-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="c1456-123">Quando um código em uma linguagem de procedimento usa uma atribuição de variável para alterar um valor, o código equivalente em uma linguagem funcional tem um valor imutável, que é a entrada, uma função imutável e valores imutáveis diferentes como saída.</span><span class="sxs-lookup"><span data-stu-id="c1456-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="c1456-124">Essa limitação matemática permite uma raciocínio mais firme sobre o comportamento do programa.</span><span class="sxs-lookup"><span data-stu-id="c1456-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="c1456-125">Esse raciocínio mais firme é o que permite aos compiladores verificar o código de forma mais rigorosa e otimizar com mais efetividade, além de ajudar os desenvolvedores a entender e a escrever o código corretamente.</span><span class="sxs-lookup"><span data-stu-id="c1456-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="c1456-126">Portanto, provavelmente o código funcional é mais fácil de depurar do que o código de procedimento comum.</span><span class="sxs-lookup"><span data-stu-id="c1456-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="c1456-127">F# não é uma linguagem funcional pura, ainda assim é totalmente compatível com a programação funcional.</span><span class="sxs-lookup"><span data-stu-id="c1456-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="c1456-128">O uso de valores imutáveis é uma prática recomendada, pois isso permite que seu código se beneficie de um aspecto importante da programação funcional.</span><span class="sxs-lookup"><span data-stu-id="c1456-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="c1456-129">Variáveis mutáveis</span><span class="sxs-lookup"><span data-stu-id="c1456-129">Mutable Variables</span></span>

<span data-ttu-id="c1456-130">Você pode usar a palavra-chave `mutable` para especificar uma variável que pode ser alterada.</span><span class="sxs-lookup"><span data-stu-id="c1456-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="c1456-131">As variáveis mutáveis em F# geralmente devem ter um escopo limitado, como um campo de um tipo ou um valor local.</span><span class="sxs-lookup"><span data-stu-id="c1456-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="c1456-132">Variáveis mutáveis com um escopo limitado são mais fáceis de controlar e têm uma probabilidade menor de serem modificadas de maneira incorreta.</span><span class="sxs-lookup"><span data-stu-id="c1456-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="c1456-133">Você pode atribuir um valor inicial para uma variável mutável usando a palavra-chave `let` da mesma maneira que você definira um valor.</span><span class="sxs-lookup"><span data-stu-id="c1456-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="c1456-134">No entanto, a diferença é que você pode atribuir posteriormente novos valores a variáveis mutáveis usando o operador `<-`, como no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="c1456-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="c1456-135">Os valores marcados `mutable` pode ser elevada automaticamente a `'a ref` se capturadas por um fechamento, incluindo formulários que criar fechamentos, tais como `seq` construtores.</span><span class="sxs-lookup"><span data-stu-id="c1456-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="c1456-136">Se você quiser ser notificado quando isso ocorre, habilitar o aviso 3180 no arquivo de projeto ou ao invocar o compilador.</span><span class="sxs-lookup"><span data-stu-id="c1456-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="c1456-137">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="c1456-137">Related Topics</span></span>

|<span data-ttu-id="c1456-138">Título</span><span class="sxs-lookup"><span data-stu-id="c1456-138">Title</span></span>|<span data-ttu-id="c1456-139">Descrição</span><span class="sxs-lookup"><span data-stu-id="c1456-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="c1456-140">Associações let</span><span class="sxs-lookup"><span data-stu-id="c1456-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="c1456-141">Fornece informações sobre como usar o `let` palavra-chave para associar nomes a valores e funções.</span><span class="sxs-lookup"><span data-stu-id="c1456-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="c1456-142">Funções</span><span class="sxs-lookup"><span data-stu-id="c1456-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="c1456-143">Fornece uma visão geral das funções em F#.</span><span class="sxs-lookup"><span data-stu-id="c1456-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="c1456-144">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c1456-144">See also</span></span>

- [<span data-ttu-id="c1456-145">Valores Nulos</span><span class="sxs-lookup"><span data-stu-id="c1456-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="c1456-146">Referência da Linguagem F#</span><span class="sxs-lookup"><span data-stu-id="c1456-146">F# Language Reference</span></span>](../index.md)
