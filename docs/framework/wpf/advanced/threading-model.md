---
title: Modelo de threading
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 87dcfa22bcce730c5a9b61721c3a846a08146475
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/09/2020
ms.locfileid: "77094495"
---
# <a name="threading-model"></a><span data-ttu-id="1108c-102">Modelo de threading</span><span class="sxs-lookup"><span data-stu-id="1108c-102">Threading Model</span></span>
<span data-ttu-id="1108c-103">O [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] foi projetado para livrar os desenvolvedores das dificuldades de threading.</span><span class="sxs-lookup"><span data-stu-id="1108c-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="1108c-104">Como resultado, a maioria dos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] desenvolvedores não precisará escrever uma interface que use mais de um thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="1108c-105">Como os programas multi-threaded são complexos e difíceis de serem depurados, deve-se evitá-los quando existem soluções single-threaded.</span><span class="sxs-lookup"><span data-stu-id="1108c-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="1108c-106">No entanto, não importa quão bem projetado, nenhuma estrutura de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] será capaz de fornecer uma solução de thread único para cada tipo de problema.</span><span class="sxs-lookup"><span data-stu-id="1108c-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1108c-107">vem perto, mas ainda há situações em que vários threads melhoram [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] a capacidade de resposta ou o desempenho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="1108c-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="1108c-108">Depois de abordar alguns documentos de suporte, este artigo explora algumas dessas situações e, em seguida, termina com uma discussão de alguns detalhes de nível mais baixo.</span><span class="sxs-lookup"><span data-stu-id="1108c-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="1108c-109">Este tópico discute o threading usando o método <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> para chamadas assíncronas.</span><span class="sxs-lookup"><span data-stu-id="1108c-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="1108c-110">Você também pode fazer chamadas assíncronas chamando o método <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, que pega um <xref:System.Action> ou <xref:System.Func%601> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="1108c-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="1108c-111">O método <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> retorna um <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601>, que tem uma propriedade <xref:System.Windows.Threading.DispatcherOperation.Task%2A>.</span><span class="sxs-lookup"><span data-stu-id="1108c-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="1108c-112">Você pode usar a palavra-chave `await` com o <xref:System.Windows.Threading.DispatcherOperation> ou o <xref:System.Threading.Tasks.Task>associado.</span><span class="sxs-lookup"><span data-stu-id="1108c-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="1108c-113">Se você precisar esperar de forma síncrona o <xref:System.Threading.Tasks.Task> retornado por um <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601>, chame o método de extensão <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="1108c-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="1108c-114">Chamar <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> resultará em um deadlock.</span><span class="sxs-lookup"><span data-stu-id="1108c-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="1108c-115">Para obter mais informações sobre como usar um <xref:System.Threading.Tasks.Task> para executar operações assíncronas, consulte paralelismo de tarefas.</span><span class="sxs-lookup"><span data-stu-id="1108c-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="1108c-116">O método <xref:System.Windows.Threading.Dispatcher.Invoke%2A> também tem sobrecargas que usam um <xref:System.Action> ou <xref:System.Func%601> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="1108c-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="1108c-117">Você pode usar o método <xref:System.Windows.Threading.Dispatcher.Invoke%2A> para fazer chamadas síncronas passando um delegado, <xref:System.Action> ou <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="1108c-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="1108c-118">Visão geral e o dispatcher</span><span class="sxs-lookup"><span data-stu-id="1108c-118">Overview and the Dispatcher</span></span>
 <span data-ttu-id="1108c-119">Normalmente, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicativos começam com dois threads: um para lidar com a renderização e outro para gerenciar o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1108c-120">O thread de renderização é executado de forma efetiva em segundo plano enquanto o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] recebe entrada, manipula eventos, pinta a tela e executa o código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="1108c-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="1108c-121">A maioria dos aplicativos usa um único thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], embora em algumas situações seja melhor usar vários.</span><span class="sxs-lookup"><span data-stu-id="1108c-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="1108c-122">Abordaremos isso com um exemplo posteriormente.</span><span class="sxs-lookup"><span data-stu-id="1108c-122">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="1108c-123">O [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] de filas de threads de itens de trabalho dentro de um objeto chamado de <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1108c-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1108c-124">O <xref:System.Windows.Threading.Dispatcher> seleciona itens de trabalho de acordo com a prioridade e executa cada um deles para conclusão.</span><span class="sxs-lookup"><span data-stu-id="1108c-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="1108c-125">Cada thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] deve ter pelo menos um <xref:System.Windows.Threading.Dispatcher>, e cada <xref:System.Windows.Threading.Dispatcher> pode executar itens de trabalho em exatamente um thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="1108c-126">O truque para a criação de aplicativos responsivos e amigáveis é maximizar a taxa de transferência de <xref:System.Windows.Threading.Dispatcher> mantendo os itens de trabalho pequenos.</span><span class="sxs-lookup"><span data-stu-id="1108c-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="1108c-127">Dessa forma, os itens nunca ficam obsoletos na fila de <xref:System.Windows.Threading.Dispatcher> aguardando o processamento.</span><span class="sxs-lookup"><span data-stu-id="1108c-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="1108c-128">Qualquer atraso perceptível entre a entrada e a resposta pode frustrar um usuário.</span><span class="sxs-lookup"><span data-stu-id="1108c-128">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="1108c-129">Como [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicativos devem lidar com operações grandes?</span><span class="sxs-lookup"><span data-stu-id="1108c-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="1108c-130">E se o código envolver um cálculo grande ou precisar consultar um banco de dados em algum servidor remoto?</span><span class="sxs-lookup"><span data-stu-id="1108c-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="1108c-131">Normalmente, a resposta é manipular a operação grande em um thread separado, deixando o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread livre para tendem a itens na fila de <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1108c-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1108c-132">Quando a operação grande for concluída, ela poderá relatar seu resultado para o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] para exibição.</span><span class="sxs-lookup"><span data-stu-id="1108c-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="1108c-133">Historicamente, o Windows permite que [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementos sejam acessados somente pelo thread que os criou.</span><span class="sxs-lookup"><span data-stu-id="1108c-133">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="1108c-134">Isso significa que um thread de segundo plano responsável por uma tarefa de execução longa não pode atualizar uma caixa de texto quando ele é concluído.</span><span class="sxs-lookup"><span data-stu-id="1108c-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="1108c-135">O Windows faz isso para garantir a integridade dos componentes de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-135">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="1108c-136">Uma caixa de listagem poderá ter uma aparência estranha se seu conteúdo for atualizado por um thread de segundo plano durante a pintura.</span><span class="sxs-lookup"><span data-stu-id="1108c-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 <span data-ttu-id="1108c-137">O [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tem um mecanismo de exclusão mútua interno que garante essa coordenação.</span><span class="sxs-lookup"><span data-stu-id="1108c-137">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="1108c-138">A maioria das classes no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] deriva de <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="1108c-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="1108c-139">Na construção, um <xref:System.Windows.Threading.DispatcherObject> armazena uma referência ao <xref:System.Windows.Threading.Dispatcher> vinculado ao thread em execução no momento.</span><span class="sxs-lookup"><span data-stu-id="1108c-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="1108c-140">Na verdade, o <xref:System.Windows.Threading.DispatcherObject> associa o thread que o cria.</span><span class="sxs-lookup"><span data-stu-id="1108c-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="1108c-141">Durante a execução do programa, um <xref:System.Windows.Threading.DispatcherObject> pode chamar seu método público <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>.</span><span class="sxs-lookup"><span data-stu-id="1108c-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="1108c-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examina a <xref:System.Windows.Threading.Dispatcher> associada ao thread atual e a compara com a referência <xref:System.Windows.Threading.Dispatcher> armazenada durante a construção.</span><span class="sxs-lookup"><span data-stu-id="1108c-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="1108c-143">Se eles não corresponderem, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> lançará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="1108c-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="1108c-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> deve ser chamado no início de cada método que pertence a um <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="1108c-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="1108c-145">Se apenas um thread puder modificar o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], como threads em segundo plano interagem com o usuário?</span><span class="sxs-lookup"><span data-stu-id="1108c-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="1108c-146">Um thread em segundo plano pode pedir ao thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] para executar uma operação em seu nome.</span><span class="sxs-lookup"><span data-stu-id="1108c-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="1108c-147">Ele faz isso registrando um item de trabalho com a <xref:System.Windows.Threading.Dispatcher> do thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-148">A classe <xref:System.Windows.Threading.Dispatcher> fornece dois métodos para registrar itens de trabalho: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="1108c-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="1108c-149">Ambos os métodos agendam um delegado para execução.</span><span class="sxs-lookup"><span data-stu-id="1108c-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="1108c-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> é uma chamada síncrona – ou seja, não retorna até que o thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] realmente termine de executar o delegado.</span><span class="sxs-lookup"><span data-stu-id="1108c-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="1108c-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> é assíncrona e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="1108c-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="1108c-152">O <xref:System.Windows.Threading.Dispatcher> ordena os elementos em sua fila por prioridade.</span><span class="sxs-lookup"><span data-stu-id="1108c-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="1108c-153">Há dez níveis que podem ser especificados ao adicionar um elemento à fila de <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1108c-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1108c-154">Essas prioridades são mantidas na enumeração de <xref:System.Windows.Threading.DispatcherPriority>.</span><span class="sxs-lookup"><span data-stu-id="1108c-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="1108c-155">Informações detalhadas sobre os níveis de <xref:System.Windows.Threading.DispatcherPriority> podem ser encontradas na documentação do SDK do Windows.</span><span class="sxs-lookup"><span data-stu-id="1108c-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="1108c-156">Threads em ação: as amostras</span><span class="sxs-lookup"><span data-stu-id="1108c-156">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="1108c-157">Um aplicativo single-threaded com um cálculo de execução longa</span><span class="sxs-lookup"><span data-stu-id="1108c-157">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="1108c-158">A maioria das GUIs (interfaces gráficas do usuário) passam uma grande parte do tempo ocioso enquanto aguarda eventos gerados em resposta às interações do usuário.</span><span class="sxs-lookup"><span data-stu-id="1108c-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="1108c-159">Com a programação cuidadosa, esse tempo ocioso pode ser usado crítica, sem afetar a capacidade de resposta do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1108c-160">O modelo de Threading [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] não permite que a entrada interrompa uma operação que ocorre no thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-161">Isso significa que você deve se certificar de retornar ao <xref:System.Windows.Threading.Dispatcher> periodicamente para processar eventos de entrada pendentes antes que eles fiquem obsoletos.</span><span class="sxs-lookup"><span data-stu-id="1108c-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="1108c-162">Considere o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="1108c-162">Consider the following example:</span></span>

 ![Captura de tela que mostra o encadeamento de números primos.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="1108c-164">Este aplicativo simples faz uma contagem ascendente a partir do três, pesquisando os números primos.</span><span class="sxs-lookup"><span data-stu-id="1108c-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="1108c-165">Quando o usuário clica no botão **Iniciar** , a pesquisa começa.</span><span class="sxs-lookup"><span data-stu-id="1108c-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="1108c-166">Quando o programa encontra um primo, ele atualiza a interface do usuário com sua descoberta.</span><span class="sxs-lookup"><span data-stu-id="1108c-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="1108c-167">A qualquer momento, o usuário pode parar a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="1108c-167">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="1108c-168">Embora seja simples o suficiente, a pesquisa de números primos poderá continuar para sempre, o que apresenta algumas dificuldades.</span><span class="sxs-lookup"><span data-stu-id="1108c-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="1108c-169">Se tratarmos toda a pesquisa dentro do manipulador de eventos de clique do botão, nunca daremos à [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a oportunidade de lidar com outros eventos.</span><span class="sxs-lookup"><span data-stu-id="1108c-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="1108c-170">O [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] não seria capaz de responder a entradas ou processar mensagens.</span><span class="sxs-lookup"><span data-stu-id="1108c-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="1108c-171">Ele nunca redesenhará e nunca responderá aos cliques do botão.</span><span class="sxs-lookup"><span data-stu-id="1108c-171">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="1108c-172">Poderíamos realizar a pesquisa de números primos em um thread separado, mas precisaríamos lidar com problemas de sincronização.</span><span class="sxs-lookup"><span data-stu-id="1108c-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="1108c-173">Com uma abordagem single-threaded, podemos atualizar diretamente o rótulo que lista o maior primo encontrado.</span><span class="sxs-lookup"><span data-stu-id="1108c-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="1108c-174">Se dividirmos a tarefa de cálculo em partes gerenciáveis, poderemos retornar periodicamente ao <xref:System.Windows.Threading.Dispatcher> e processar eventos.</span><span class="sxs-lookup"><span data-stu-id="1108c-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="1108c-175">Podemos dar [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uma oportunidade de redesenhar e processar a entrada.</span><span class="sxs-lookup"><span data-stu-id="1108c-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="1108c-176">A melhor maneira de dividir o tempo de processamento entre o cálculo e a manipulação de eventos é gerenciar o cálculo do <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1108c-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1108c-177">Usando o método <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>, podemos agendar verificações de números primos na mesma fila da qual [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] eventos são extraídos.</span><span class="sxs-lookup"><span data-stu-id="1108c-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="1108c-178">Em nosso exemplo, agendamos somente uma única verificação de números primos por vez.</span><span class="sxs-lookup"><span data-stu-id="1108c-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="1108c-179">Depois que a verificação de números primos for concluída, agendaremos a próxima verificação imediatamente.</span><span class="sxs-lookup"><span data-stu-id="1108c-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="1108c-180">Essa verificação prossegue somente após os eventos de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] pendentes terem sido tratados.</span><span class="sxs-lookup"><span data-stu-id="1108c-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Captura de tela que mostra a fila do Dispatcher.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="1108c-182">O Microsoft Word realiza a verificação ortográfica usando esse mecanismo.</span><span class="sxs-lookup"><span data-stu-id="1108c-182">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="1108c-183">A verificação ortográfica é feita em segundo plano usando o tempo ocioso do thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-184">Vamos dar uma olhada no código.</span><span class="sxs-lookup"><span data-stu-id="1108c-184">Let's take a look at the code.</span></span>

 <span data-ttu-id="1108c-185">O exemplo a seguir mostra o XAML que cria a interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="1108c-185">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="1108c-186">O exemplo a seguir mostra o code-behind.</span><span class="sxs-lookup"><span data-stu-id="1108c-186">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="1108c-187">O exemplo a seguir mostra o manipulador de eventos para o <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="1108c-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="1108c-188">Além de atualizar o texto na <xref:System.Windows.Controls.Button>, esse manipulador é responsável por agendar a primeira verificação de número primo adicionando um delegado à fila de <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1108c-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1108c-189">Um pouco depois que esse manipulador de eventos concluiu seu trabalho, o <xref:System.Windows.Threading.Dispatcher> selecionará esse delegado para execução.</span><span class="sxs-lookup"><span data-stu-id="1108c-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="1108c-190">Como mencionamos anteriormente, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> é o membro <xref:System.Windows.Threading.Dispatcher> usado para agendar um delegado para execução.</span><span class="sxs-lookup"><span data-stu-id="1108c-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="1108c-191">Nesse caso, escolhemos a prioridade de <xref:System.Windows.Threading.DispatcherPriority.SystemIdle>.</span><span class="sxs-lookup"><span data-stu-id="1108c-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="1108c-192">O <xref:System.Windows.Threading.Dispatcher> executará esse delegado somente quando não houver eventos importantes a serem processados.</span><span class="sxs-lookup"><span data-stu-id="1108c-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="1108c-193">A capacidade de resposta da [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] é mais importante do que a verificação de números.</span><span class="sxs-lookup"><span data-stu-id="1108c-193">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="1108c-194">Também passamos um novo delegado que representa a rotina de verificação de números.</span><span class="sxs-lookup"><span data-stu-id="1108c-194">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="1108c-195">Esse método verifica se o próximo número ímpar é um primo.</span><span class="sxs-lookup"><span data-stu-id="1108c-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="1108c-196">Se for primo, o método atualizará diretamente o `bigPrime`<xref:System.Windows.Controls.TextBlock> para refletir sua descoberta.</span><span class="sxs-lookup"><span data-stu-id="1108c-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="1108c-197">Podemos fazer isso porque o cálculo é feito no mesmo thread que foi usado para criar o componente.</span><span class="sxs-lookup"><span data-stu-id="1108c-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="1108c-198">Optamos por usar um thread separado para o cálculo, teríamos que usar um mecanismo de sincronização mais complicado e executar a atualização no thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-199">Demonstraremos essa situação a seguir.</span><span class="sxs-lookup"><span data-stu-id="1108c-199">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="1108c-200">Para obter o código-fonte completo deste exemplo, consulte o [aplicativo de thread único com exemplo de cálculo de longa execução](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span><span class="sxs-lookup"><span data-stu-id="1108c-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="1108c-201">Manipulando uma operação de bloqueio com um thread de segundo plano</span><span class="sxs-lookup"><span data-stu-id="1108c-201">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="1108c-202">A manipulação de operações de bloqueio em um aplicativo gráfico pode ser difícil.</span><span class="sxs-lookup"><span data-stu-id="1108c-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="1108c-203">Não desejamos chamar métodos de bloqueio por meio de manipuladores de eventos, pois o aplicativo parecerá congelado.</span><span class="sxs-lookup"><span data-stu-id="1108c-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="1108c-204">Podemos usar um thread separado para lidar com essas operações, mas quando terminarmos, temos que sincronizar com o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] porque não podemos modificar diretamente a GUI de nosso thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="1108c-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="1108c-205">Podemos usar <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> para inserir delegados no <xref:System.Windows.Threading.Dispatcher> do thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-206">Eventualmente, esses delegados serão executados com permissão para modificar elementos de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="1108c-207">Neste exemplo, simulamos uma chamada de procedimento remoto que recupera uma previsão do tempo.</span><span class="sxs-lookup"><span data-stu-id="1108c-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="1108c-208">Usamos um thread de trabalho separado para executar essa chamada e agendamos um método Update na <xref:System.Windows.Threading.Dispatcher> do thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] quando terminarmos.</span><span class="sxs-lookup"><span data-stu-id="1108c-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Captura de tela que mostra a interface do usuário do clima.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="1108c-210">Veja a seguir alguns dos detalhes a serem observados.</span><span class="sxs-lookup"><span data-stu-id="1108c-210">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="1108c-211">Criando o manipulador de botões</span><span class="sxs-lookup"><span data-stu-id="1108c-211">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="1108c-212">Quando o botão recebe um clique, exibimos o desenho do relógio e iniciamos sua animação.</span><span class="sxs-lookup"><span data-stu-id="1108c-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="1108c-213">Desabilitamos o botão.</span><span class="sxs-lookup"><span data-stu-id="1108c-213">We disable the button.</span></span> <span data-ttu-id="1108c-214">Invocamos o método `FetchWeatherFromServer` em um novo thread e, em seguida, retornamos, permitindo que o <xref:System.Windows.Threading.Dispatcher> processe eventos enquanto aguardamos para coletar a previsão do tempo.</span><span class="sxs-lookup"><span data-stu-id="1108c-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="1108c-215">Buscando o clima</span><span class="sxs-lookup"><span data-stu-id="1108c-215">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="1108c-216">Para manter as coisas simples, na verdade, não apresentamos nenhum código de rede neste exemplo.</span><span class="sxs-lookup"><span data-stu-id="1108c-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="1108c-217">Em vez disso, simulamos o atraso do acesso à rede colocando nosso novo thread em suspensão por quatro segundos.</span><span class="sxs-lookup"><span data-stu-id="1108c-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="1108c-218">Neste momento, o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] original ainda está em execução e respondendo a eventos.</span><span class="sxs-lookup"><span data-stu-id="1108c-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="1108c-219">Para mostrar isso, deixamos uma animação em execução e os botões Minimizar e Maximizar também continuam funcionando.</span><span class="sxs-lookup"><span data-stu-id="1108c-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="1108c-220">Quando o atraso é concluído e selecionamos aleatoriamente nossa previsão do tempo, é hora de relatar de volta para o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-221">Fazemos isso agendando uma chamada para `UpdateUserInterface` no thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] usando a <xref:System.Windows.Threading.Dispatcher>desse thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1108c-222">Passamos uma cadeia de caracteres que descreve o clima para essa chamada de método agendada.</span><span class="sxs-lookup"><span data-stu-id="1108c-222">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="1108c-223">Atualizando o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1108c-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="1108c-224">Quando o <xref:System.Windows.Threading.Dispatcher> no thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] tem tempo, ele executa a chamada agendada para `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="1108c-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="1108c-225">Esse método para a animação do relógio e escolhe uma imagem para descrever o clima.</span><span class="sxs-lookup"><span data-stu-id="1108c-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="1108c-226">Ele exibe essa imagem e restaura o botão “Buscar Previsão”.</span><span class="sxs-lookup"><span data-stu-id="1108c-226">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="1108c-227">Várias janelas, vários threads</span><span class="sxs-lookup"><span data-stu-id="1108c-227">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="1108c-228">Alguns aplicativos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] exigem várias janelas de nível superior.</span><span class="sxs-lookup"><span data-stu-id="1108c-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="1108c-229">É perfeitamente aceitável que uma combinação de thread/<xref:System.Windows.Threading.Dispatcher> gerencie várias janelas, mas às vezes vários threads realizam um trabalho melhor.</span><span class="sxs-lookup"><span data-stu-id="1108c-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="1108c-230">Isso será especialmente verdadeiro se houver uma possibilidade de que uma das janelas monopolize o thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="1108c-231">O Windows Explorer funciona dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="1108c-231">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="1108c-232">Cada nova janela do Explorer pertence ao processo original, mas é criada sob o controle de um thread independente.</span><span class="sxs-lookup"><span data-stu-id="1108c-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="1108c-233">Usando um controle de <xref:System.Windows.Controls.Frame> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], podemos exibir páginas da Web.</span><span class="sxs-lookup"><span data-stu-id="1108c-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="1108c-234">Podemos criar facilmente um substituto simples do Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="1108c-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="1108c-235">Começamos com um recurso importante: a capacidade de abrir uma nova janela do Explorer.</span><span class="sxs-lookup"><span data-stu-id="1108c-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="1108c-236">Quando o usuário clica no botão “Nova Janela”, iniciamos uma cópia de nossa janela em um thread separado.</span><span class="sxs-lookup"><span data-stu-id="1108c-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="1108c-237">Dessa forma, operações de execução longa ou de bloqueio em uma das janelas não bloquearão todas as outras janelas.</span><span class="sxs-lookup"><span data-stu-id="1108c-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="1108c-238">Na realidade, o modelo de navegador da Web tem seu próprio modelo de threading complicado.</span><span class="sxs-lookup"><span data-stu-id="1108c-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="1108c-239">Nós o escolhemos porque deve ser conhecido pela maioria dos leitores.</span><span class="sxs-lookup"><span data-stu-id="1108c-239">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="1108c-240">O exemplo a seguir mostra o código.</span><span class="sxs-lookup"><span data-stu-id="1108c-240">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="1108c-241">Os seguintes segmentos de threading desse código são os mais interessantes para nós neste contexto:</span><span class="sxs-lookup"><span data-stu-id="1108c-241">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="1108c-242">Esse método é chamado quando o botão “Nova Janela” recebe um clique.</span><span class="sxs-lookup"><span data-stu-id="1108c-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="1108c-243">Ele cria um novo thread e o inicia de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="1108c-243">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="1108c-244">Esse método é o ponto de partida para o novo thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="1108c-245">Criamos uma nova janela sob o controle desse thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1108c-246">cria automaticamente uma nova <xref:System.Windows.Threading.Dispatcher> para gerenciar o novo thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="1108c-247">Tudo o que temos a fazer para tornar a janela funcional é iniciar o <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1108c-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="1108c-248">Detalhes técnicos e obstáculos</span><span class="sxs-lookup"><span data-stu-id="1108c-248">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="1108c-249">Escrevendo componentes usando o threading</span><span class="sxs-lookup"><span data-stu-id="1108c-249">Writing Components Using Threading</span></span>
 <span data-ttu-id="1108c-250">O guia do desenvolvedor do Microsoft .NET Framework descreve um padrão de como um componente pode expor o comportamento assíncrono para seus clientes (consulte [visão geral do padrão assíncrono baseado em evento](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="1108c-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="1108c-251">Por exemplo, suponha que queríamos empacotar o método `FetchWeatherFromServer` em um componente reutilizável e não-gráfico.</span><span class="sxs-lookup"><span data-stu-id="1108c-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="1108c-252">Seguindo o padrão do Standard Microsoft .NET Framework, isso seria semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="1108c-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="1108c-253">O `GetWeatherAsync` usaria uma das técnicas descritas anteriormente, como a criação de um thread de segundo plano, para fazer o trabalho de forma assíncrona, não bloqueando o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="1108c-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="1108c-254">Uma das partes mais importantes desse padrão é chamar o método *methodname*`Completed` no mesmo thread que chamou o método *MethodName*`Async` para começar.</span><span class="sxs-lookup"><span data-stu-id="1108c-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="1108c-255">Você pode fazer isso usando [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] razoavelmente fácil, armazenando <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>— mas o componente não-gráfico só poderia ser usado em aplicativos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], não em Windows Forms ou em programas ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="1108c-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="1108c-256">A classe <xref:System.Windows.Threading.DispatcherSynchronizationContext> lida com essa necessidade — imagine-a como uma versão simplificada do <xref:System.Windows.Threading.Dispatcher> que funciona com outras estruturas de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] também.</span><span class="sxs-lookup"><span data-stu-id="1108c-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="1108c-257">Bombeamento aninhado</span><span class="sxs-lookup"><span data-stu-id="1108c-257">Nested Pumping</span></span>
 <span data-ttu-id="1108c-258">Às vezes, não é viável bloquear completamente o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-259">Vamos considerar o método <xref:System.Windows.MessageBox.Show%2A> da classe <xref:System.Windows.MessageBox>.</span><span class="sxs-lookup"><span data-stu-id="1108c-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="1108c-260"><xref:System.Windows.MessageBox.Show%2A> não retorna até que o usuário clique no botão OK.</span><span class="sxs-lookup"><span data-stu-id="1108c-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="1108c-261">No entanto, ele cria uma janela que deve ter um loop de mensagens para ser interativa.</span><span class="sxs-lookup"><span data-stu-id="1108c-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="1108c-262">Enquanto aguardamos até que o usuário clique em OK, a janela do aplicativo original não responde à entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="1108c-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="1108c-263">No entanto, ele continua processando mensagens de pintura.</span><span class="sxs-lookup"><span data-stu-id="1108c-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="1108c-264">A janela original se redesenha quando é coberta e revelada.</span><span class="sxs-lookup"><span data-stu-id="1108c-264">The original window redraws itself when covered and revealed.</span></span>

 ![Captura de tela que mostra uma MessageBox com um botão OK](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="1108c-266">Algum thread deve ser responsável pela janela da caixa de mensagem.</span><span class="sxs-lookup"><span data-stu-id="1108c-266">Some thread must be in charge of the message box window.</span></span> <span data-ttu-id="1108c-267">O [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] poderá criar um novo thread apenas para a janela da caixa de mensagem, mas esse thread não poderá pintar os elementos desabilitados na janela original (lembre-se da discussão anterior sobre exclusão mútua).</span><span class="sxs-lookup"><span data-stu-id="1108c-267">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="1108c-268">Em vez disso, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] usa um sistema de processamento de mensagens aninhado.</span><span class="sxs-lookup"><span data-stu-id="1108c-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="1108c-269">A classe <xref:System.Windows.Threading.Dispatcher> inclui um método especial chamado <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, que armazena o ponto de execução atual de um aplicativo e, em seguida, inicia um novo loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="1108c-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="1108c-270">Quando o loop de mensagem aninhado é concluído, a execução é retomada após a chamada de <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> original.</span><span class="sxs-lookup"><span data-stu-id="1108c-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="1108c-271">Nesse caso, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> mantém o contexto do programa na chamada para <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>e inicia um novo loop de mensagem para redesenhar a janela de plano de fundo e manipular a entrada para a janela da caixa de mensagem.</span><span class="sxs-lookup"><span data-stu-id="1108c-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="1108c-272">Quando o usuário clica em OK e limpa a janela pop-up, o loop aninhado é encerrado e o controle é retomado após a chamada para <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="1108c-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="1108c-273">Eventos roteados obsoletos</span><span class="sxs-lookup"><span data-stu-id="1108c-273">Stale Routed Events</span></span>
 <span data-ttu-id="1108c-274">O sistema de eventos roteados no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifica árvores inteiras quando os eventos são gerados.</span><span class="sxs-lookup"><span data-stu-id="1108c-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="1108c-275">Quando o botão esquerdo do mouse é pressionado sobre a elipse, `handler2` é executado.</span><span class="sxs-lookup"><span data-stu-id="1108c-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="1108c-276">Após a conclusão do `handler2`, o evento é passado ao objeto <xref:System.Windows.Controls.Canvas>, que usa `handler1` para processá-lo.</span><span class="sxs-lookup"><span data-stu-id="1108c-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="1108c-277">Isso ocorrerá somente se `handler2` não marcar explicitamente o objeto de evento como manipulado.</span><span class="sxs-lookup"><span data-stu-id="1108c-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="1108c-278">É possível que `handler2` levará muito tempo processando esse evento.</span><span class="sxs-lookup"><span data-stu-id="1108c-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="1108c-279">`handler2` pode usar <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> para iniciar um loop de mensagem aninhado que não retorna por horas.</span><span class="sxs-lookup"><span data-stu-id="1108c-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="1108c-280">Se `handler2` não marcar o evento como manipulado quando esse loop de mensagem for concluído, o evento será passado para a árvore, embora seja muito antigo.</span><span class="sxs-lookup"><span data-stu-id="1108c-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="1108c-281">Reentrada e bloqueio</span><span class="sxs-lookup"><span data-stu-id="1108c-281">Reentrancy and Locking</span></span>
 <span data-ttu-id="1108c-282">O mecanismo de bloqueio do Common Language Runtime (CLR) não se comporta exatamente como alguém pode imaginar; uma delas pode esperar que um thread interrompa completamente a operação ao solicitar um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="1108c-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="1108c-283">Na realidade, o thread continua recebendo e processando mensagens de alta prioridade.</span><span class="sxs-lookup"><span data-stu-id="1108c-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="1108c-284">Isso ajuda a impedir bloqueios e torna a interface minimamente dinâmica, mas introduz a possibilidade de bugs sutis.</span><span class="sxs-lookup"><span data-stu-id="1108c-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="1108c-285">A grande maioria do tempo que você não precisa saber nada sobre isso, mas em circunstâncias raras (geralmente envolvendo mensagens de janela do Win32 ou componentes COM STA), vale a pena saber.</span><span class="sxs-lookup"><span data-stu-id="1108c-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="1108c-286">A maioria das interfaces não é criada com a segurança de thread em mente porque os desenvolvedores trabalham sob a suposição de que um [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nunca é acessado por mais de um thread.</span><span class="sxs-lookup"><span data-stu-id="1108c-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="1108c-287">Nesse caso, esse único thread pode fazer alterações ambientais em tempos inesperados, causando os efeitos indesejados que o <xref:System.Windows.Threading.DispatcherObject> mecanismo de exclusão mútua deve resolver.</span><span class="sxs-lookup"><span data-stu-id="1108c-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="1108c-288">Considere o seguinte pseudocódigo:</span><span class="sxs-lookup"><span data-stu-id="1108c-288">Consider the following pseudocode:</span></span>

 <span data-ttu-id="1108c-289">![Diagrama que mostra a reentrância de Threading.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="1108c-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="1108c-290">Na maioria das vezes, essa é a coisa certa, mas há ocasiões em [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] em que essa reentrância inesperada pode realmente causar problemas.</span><span class="sxs-lookup"><span data-stu-id="1108c-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="1108c-291">Portanto, em determinados momentos chave, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] chama <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, que altera a instrução de bloqueio desse thread para usar o bloqueio de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] livre de reentrada, em vez do bloqueio CLR comum.</span><span class="sxs-lookup"><span data-stu-id="1108c-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="1108c-292">Então, por que a equipe do CLR escolheu esse comportamento?</span><span class="sxs-lookup"><span data-stu-id="1108c-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="1108c-293">Isso tinha a ver com objetos COM STA e com o thread de finalização.</span><span class="sxs-lookup"><span data-stu-id="1108c-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="1108c-294">Quando um objeto é coletado pelo lixo, seu método de `Finalize` é executado no thread do finalizador dedicado, não no thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-295">E aí está o problema, porque um objeto COM STA criado no thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] só pode ser descartado no thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1108c-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1108c-296">O CLR faz o equivalente de um <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (nesse caso, usando Win32's `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="1108c-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="1108c-297">Mas se o thread de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] estiver ocupado, o thread do finalizador será interrompido e o objeto COM STA não poderá ser descartado, o que criará um sério vazamento de memória.</span><span class="sxs-lookup"><span data-stu-id="1108c-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="1108c-298">Portanto, a equipe do CLR fez a chamada difícil para que os bloqueios funcionem da maneira que fazem.</span><span class="sxs-lookup"><span data-stu-id="1108c-298">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="1108c-299">A tarefa para [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] é evitar a reentrância inesperada sem reintroduzir o vazamento de memória, motivo pelo qual não bloqueamos a reentrância em todos os lugares.</span><span class="sxs-lookup"><span data-stu-id="1108c-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="1108c-300">Confira também</span><span class="sxs-lookup"><span data-stu-id="1108c-300">See also</span></span>

- [<span data-ttu-id="1108c-301">Amostra de aplicativo single-threaded com um cálculo de execução longa</span><span class="sxs-lookup"><span data-stu-id="1108c-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
