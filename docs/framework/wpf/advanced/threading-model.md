---
title: Modelo de threading
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 0bcb0e7369345aaae39d99a005a07304aaad7043
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59200344"
---
# <a name="threading-model"></a><span data-ttu-id="cffc1-102">Modelo de threading</span><span class="sxs-lookup"><span data-stu-id="cffc1-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="cffc1-103">foi projetado para livrar os desenvolvedores das dificuldades de threading.</span><span class="sxs-lookup"><span data-stu-id="cffc1-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="cffc1-104">Como resultado, a maioria dos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] os desenvolvedores não terão que escrever uma interface que usa mais de um thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="cffc1-105">Como os programas multi-threaded são complexos e difíceis de serem depurados, deve-se evitá-los quando existem soluções single-threaded.</span><span class="sxs-lookup"><span data-stu-id="cffc1-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="cffc1-106">Não importa quão bem projetada, no entanto, não [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] estrutura nunca será capaz de fornecer uma solução single-threaded para todos os tipos de problema.</span><span class="sxs-lookup"><span data-stu-id="cffc1-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="cffc1-107">chega perto, mas ainda existem situações em que vários threads melhora [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] desempenho e capacidade de resposta dos aplicativos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="cffc1-108">Depois de abordar alguns documentos de suporte, este artigo explora algumas dessas situações e, em seguida, termina com uma discussão de alguns detalhes de nível mais baixo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  

> [!NOTE]
>  <span data-ttu-id="cffc1-109">Este tópico discute o threading usando o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> método para chamadas assíncronas.</span><span class="sxs-lookup"><span data-stu-id="cffc1-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="cffc1-110">Você também pode fazer chamadas assíncronas chamando o <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> método, que recebem um <xref:System.Action> ou <xref:System.Func%601> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="cffc1-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="cffc1-111">O <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> método retorna um <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601>, que tem um <xref:System.Windows.Threading.DispatcherOperation.Task%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="cffc1-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="cffc1-112">Você pode usar o `await` palavra-chave com qualquer um de <xref:System.Windows.Threading.DispatcherOperation> ou associado <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="cffc1-113">Se você precisar aguardar de forma síncrona a <xref:System.Threading.Tasks.Task> que é retornado por um <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601>, chame o <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> método de extensão.</span><span class="sxs-lookup"><span data-stu-id="cffc1-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="cffc1-114">Chamar <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> resultará em um deadlock.</span><span class="sxs-lookup"><span data-stu-id="cffc1-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="cffc1-115">Para obter mais informações sobre como usar um <xref:System.Threading.Tasks.Task> para executar operações assíncronas, consulte paralelismo de tarefas.</span><span class="sxs-lookup"><span data-stu-id="cffc1-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="cffc1-116">O <xref:System.Windows.Threading.Dispatcher.Invoke%2A> método também tem sobrecargas que usam uma <xref:System.Action> ou <xref:System.Func%601> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="cffc1-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="cffc1-117">Você pode usar o <xref:System.Windows.Threading.Dispatcher.Invoke%2A> chamadas de método para tornar síncrono, passando um delegado <xref:System.Action> ou <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="cffc1-118">Visão geral e o dispatcher</span><span class="sxs-lookup"><span data-stu-id="cffc1-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="cffc1-119">Normalmente, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicativos iniciam com dois threads: um para manipulação de renderização e outra para gerenciar o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cffc1-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="cffc1-120">O thread de renderização é executado oculto em segundo plano enquanto efetivamente o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread recebe entrada, trata os eventos, pinta a tela e executa o código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="cffc1-121">A maioria dos aplicativos usa um único [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] de thread, embora em algumas situações, é melhor usar várias.</span><span class="sxs-lookup"><span data-stu-id="cffc1-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="cffc1-122">Abordaremos isso com um exemplo posteriormente.</span><span class="sxs-lookup"><span data-stu-id="cffc1-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="cffc1-123">O [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] itens dentro de um objeto chamado de trabalho de filas de thread um <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="cffc1-124">O <xref:System.Windows.Threading.Dispatcher> seleciona itens de trabalho em uma base de prioridade e executa cada um deles até a conclusão.</span><span class="sxs-lookup"><span data-stu-id="cffc1-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="cffc1-125">Cada [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread deve ter pelo menos um <xref:System.Windows.Threading.Dispatcher>e cada <xref:System.Windows.Threading.Dispatcher> pode executar itens de trabalho em exatamente um thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="cffc1-126">O truque para a criação de aplicativos dinâmicos e amigáveis é maximizar a <xref:System.Windows.Threading.Dispatcher> taxa de transferência, mantendo os itens de trabalho pequenos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="cffc1-127">Essa forma os itens nunca ficam obsoletos sentados <xref:System.Windows.Threading.Dispatcher> fila aguardando processamento.</span><span class="sxs-lookup"><span data-stu-id="cffc1-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="cffc1-128">Qualquer atraso perceptível entre a entrada e a resposta pode frustrar um usuário.</span><span class="sxs-lookup"><span data-stu-id="cffc1-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="cffc1-129">Portanto, como os [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicativos devem para manipular operações grandes?</span><span class="sxs-lookup"><span data-stu-id="cffc1-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="cffc1-130">E se o código envolver um cálculo grande ou precisar consultar um banco de dados em algum servidor remoto?</span><span class="sxs-lookup"><span data-stu-id="cffc1-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="cffc1-131">Normalmente, a resposta é tratar a operação grande em um thread separado, deixando os [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread livre para atender aos itens no <xref:System.Windows.Threading.Dispatcher> fila.</span><span class="sxs-lookup"><span data-stu-id="cffc1-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="cffc1-132">Quando a operação grande for concluída, ela pode relatar seu resultado para o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread para exibição.</span><span class="sxs-lookup"><span data-stu-id="cffc1-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="cffc1-133">Historicamente, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] permite [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementos sejam acessados somente pelo thread que os criou.</span><span class="sxs-lookup"><span data-stu-id="cffc1-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="cffc1-134">Isso significa que um thread de segundo plano responsável por uma tarefa de execução longa não pode atualizar uma caixa de texto quando ele é concluído.</span><span class="sxs-lookup"><span data-stu-id="cffc1-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] <span data-ttu-id="cffc1-135">faz isso para garantir a integridade do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] componentes.</span><span class="sxs-lookup"><span data-stu-id="cffc1-135">does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="cffc1-136">Uma caixa de listagem poderá ter uma aparência estranha se seu conteúdo for atualizado por um thread de segundo plano durante a pintura.</span><span class="sxs-lookup"><span data-stu-id="cffc1-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="cffc1-137">tem um mecanismo de exclusão mútua interno que garante essa coordenação.</span><span class="sxs-lookup"><span data-stu-id="cffc1-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="cffc1-138">A maioria das classes no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derivam <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="cffc1-139">Na construção, um <xref:System.Windows.Threading.DispatcherObject> armazena uma referência para o <xref:System.Windows.Threading.Dispatcher> vinculado ao thread em execução no momento.</span><span class="sxs-lookup"><span data-stu-id="cffc1-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="cffc1-140">Na verdade, o <xref:System.Windows.Threading.DispatcherObject> associado ao thread que o cria.</span><span class="sxs-lookup"><span data-stu-id="cffc1-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="cffc1-141">Durante a execução do programa, uma <xref:System.Windows.Threading.DispatcherObject> pode chamar seu público <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cffc1-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> <span data-ttu-id="cffc1-142">examina o <xref:System.Windows.Threading.Dispatcher> associada ao thread atual e o compara a <xref:System.Windows.Threading.Dispatcher> referência armazenada durante a construção.</span><span class="sxs-lookup"><span data-stu-id="cffc1-142">examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="cffc1-143">Se elas não corresponderem, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="cffc1-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> <span data-ttu-id="cffc1-144">se destina a ser chamado no início de cada método pertencente a um <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-144">is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="cffc1-145">Se apenas um thread pode modificar o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], como threads em segundo plano interagem com o usuário?</span><span class="sxs-lookup"><span data-stu-id="cffc1-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="cffc1-146">Um thread em segundo plano pode solicitar o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread para executar uma operação em seu nome.</span><span class="sxs-lookup"><span data-stu-id="cffc1-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="cffc1-147">Isso é feito registrando um item de trabalho com o <xref:System.Windows.Threading.Dispatcher> do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-148">O <xref:System.Windows.Threading.Dispatcher> classe fornece dois métodos para registrar itens de trabalho: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="cffc1-149">Ambos os métodos agendam um delegado para execução.</span><span class="sxs-lookup"><span data-stu-id="cffc1-149">Both methods schedule a delegate for execution.</span></span> <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <span data-ttu-id="cffc1-150">é uma chamada síncrona – ou seja, ele não retorna até que o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread termina, na verdade, executar o delegado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-150">is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> <span data-ttu-id="cffc1-151">é assíncrona e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cffc1-151">is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="cffc1-152">O <xref:System.Windows.Threading.Dispatcher> ordena os elementos em sua fila por prioridade.</span><span class="sxs-lookup"><span data-stu-id="cffc1-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="cffc1-153">Existem dez níveis que podem ser especificados ao adicionar um elemento para o <xref:System.Windows.Threading.Dispatcher> fila.</span><span class="sxs-lookup"><span data-stu-id="cffc1-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="cffc1-154">Essas prioridades são mantidas no <xref:System.Windows.Threading.DispatcherPriority> enumeração.</span><span class="sxs-lookup"><span data-stu-id="cffc1-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="cffc1-155">Informações detalhadas sobre <xref:System.Windows.Threading.DispatcherPriority> níveis podem ser encontrados no [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentação.</span><span class="sxs-lookup"><span data-stu-id="cffc1-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="cffc1-156">Threads em ação: Os exemplos</span><span class="sxs-lookup"><span data-stu-id="cffc1-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="cffc1-157">Um aplicativo single-threaded com um cálculo de execução longa</span><span class="sxs-lookup"><span data-stu-id="cffc1-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="cffc1-158">A maioria dos [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] gasta uma grande parte de seu tempo ociosa enquanto aguarda eventos que são gerados em resposta às interações do usuário.</span><span class="sxs-lookup"><span data-stu-id="cffc1-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="cffc1-159">Com uma programação cuidadosa esse tempo ocioso pode ser usado de forma construtiva, sem afetar a capacidade de resposta da [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cffc1-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="cffc1-160">O [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] modelo de threading não permite que a entrada interrompa uma operação que ocorre no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-161">Isso significa que você deve garantir que retornará para o <xref:System.Windows.Threading.Dispatcher> periodicamente para processar eventos de entrada antes que eles se tornem obsoletos pendentes.</span><span class="sxs-lookup"><span data-stu-id="cffc1-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="cffc1-162">Considere o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="cffc1-162">Consider the following example:</span></span>  
  
 ![Captura de tela que mostra o threading de números primos.](./media/threading-model/threading-prime-numbers.png)  
  
 <span data-ttu-id="cffc1-164">Este aplicativo simples faz uma contagem ascendente a partir do três, pesquisando os números primos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="cffc1-165">Quando o usuário clica o **iniciar** botão, a pesquisa começa.</span><span class="sxs-lookup"><span data-stu-id="cffc1-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="cffc1-166">Quando o programa encontra um primo, ele atualiza a interface do usuário com sua descoberta.</span><span class="sxs-lookup"><span data-stu-id="cffc1-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="cffc1-167">A qualquer momento, o usuário pode parar a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="cffc1-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="cffc1-168">Embora seja simples o suficiente, a pesquisa de números primos poderá continuar para sempre, o que apresenta algumas dificuldades.</span><span class="sxs-lookup"><span data-stu-id="cffc1-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="cffc1-169">Se manipularmos toda a pesquisa no manipulador de eventos de clique do botão, nunca daremos a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] a oportunidade de manipular outros eventos de thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="cffc1-170">O [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] não poderá responder à entrada nem processar mensagens.</span><span class="sxs-lookup"><span data-stu-id="cffc1-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="cffc1-171">Ele nunca redesenhará e nunca responderá aos cliques do botão.</span><span class="sxs-lookup"><span data-stu-id="cffc1-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="cffc1-172">Poderíamos realizar a pesquisa de números primos em um thread separado, mas precisaríamos lidar com problemas de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cffc1-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="cffc1-173">Com uma abordagem single-threaded, podemos atualizar diretamente o rótulo que lista o maior primo encontrado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="cffc1-174">Se dividirmos a tarefa de cálculo em partes gerenciáveis, podemos periodicamente retornar para o <xref:System.Windows.Threading.Dispatcher> e processar eventos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="cffc1-175">Podemos dar [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uma oportunidade de redesenhar e processar a entrada.</span><span class="sxs-lookup"><span data-stu-id="cffc1-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="cffc1-176">A melhor maneira de dividir o tempo de processamento entre cálculo e manipulação de eventos é gerenciar o cálculo do <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="cffc1-177">Usando o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> método, podemos agendar verificações de números primos na mesma fila da qual [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] eventos são extraídos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="cffc1-178">Em nosso exemplo, agendamos somente uma única verificação de números primos por vez.</span><span class="sxs-lookup"><span data-stu-id="cffc1-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="cffc1-179">Depois que a verificação de números primos for concluída, agendaremos a próxima verificação imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cffc1-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="cffc1-180">Essa verificação continua somente após pendentes [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] eventos foram tratados.</span><span class="sxs-lookup"><span data-stu-id="cffc1-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 ![Captura de tela que mostra a fila do dispatcher.](./media/threading-model/threading-dispatcher-queue.png)  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)] <span data-ttu-id="cffc1-182">realiza a verificação ortográfica usando esse mecanismo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-182">accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="cffc1-183">Verificação ortográfica é feita em segundo plano usando o tempo ocioso do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-184">Vamos dar uma olhada no código.</span><span class="sxs-lookup"><span data-stu-id="cffc1-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="cffc1-185">O exemplo a seguir mostra o XAML que cria a interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="cffc1-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="cffc1-186">O exemplo a seguir mostra o code-behind.</span><span class="sxs-lookup"><span data-stu-id="cffc1-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="cffc1-187">O exemplo a seguir mostra o manipulador de eventos para o <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="cffc1-188">Além de atualizar o texto sobre o <xref:System.Windows.Controls.Button>, esse manipulador é responsável por agendar a primeira verificação de números primos adicionando um delegado para o <xref:System.Windows.Threading.Dispatcher> fila.</span><span class="sxs-lookup"><span data-stu-id="cffc1-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="cffc1-189">Algum tempo depois que esse manipulador de eventos tiver concluído seu trabalho, o <xref:System.Windows.Threading.Dispatcher> selecionará esse delegado para execução.</span><span class="sxs-lookup"><span data-stu-id="cffc1-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="cffc1-190">Como mencionado anteriormente, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> é o <xref:System.Windows.Threading.Dispatcher> membro usado para agendar um delegado para execução.</span><span class="sxs-lookup"><span data-stu-id="cffc1-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="cffc1-191">Nesse caso, escolhemos o <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> prioridade.</span><span class="sxs-lookup"><span data-stu-id="cffc1-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="cffc1-192">O <xref:System.Windows.Threading.Dispatcher> executará esse delegado somente quando não há nenhum processamento de eventos importantes.</span><span class="sxs-lookup"><span data-stu-id="cffc1-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="cffc1-193">capacidade de resposta é mais importante do que a verificação de números.</span><span class="sxs-lookup"><span data-stu-id="cffc1-193">responsiveness is more important than number checking.</span></span> <span data-ttu-id="cffc1-194">Também passamos um novo delegado que representa a rotina de verificação de números.</span><span class="sxs-lookup"><span data-stu-id="cffc1-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="cffc1-195">Esse método verifica se o próximo número ímpar é um primo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="cffc1-196">Se for primo, o método atualizará diretamente o `bigPrime`<xref:System.Windows.Controls.TextBlock> para refletir sua descoberta.</span><span class="sxs-lookup"><span data-stu-id="cffc1-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="cffc1-197">Podemos fazer isso porque o cálculo é feito no mesmo thread que foi usado para criar o componente.</span><span class="sxs-lookup"><span data-stu-id="cffc1-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="cffc1-198">Se tivéssemos escolhido usar um thread separado para o cálculo, teríamos que usar um mecanismo de sincronização mais complicado e executar a atualização no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-199">Demonstraremos essa situação a seguir.</span><span class="sxs-lookup"><span data-stu-id="cffc1-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="cffc1-200">Para o código-fonte completo para este exemplo, consulte o [aplicativo single-threaded com exemplo de cálculo de execução longa](https://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="cffc1-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="cffc1-201">Manipulando uma operação de bloqueio com um thread de segundo plano</span><span class="sxs-lookup"><span data-stu-id="cffc1-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="cffc1-202">A manipulação de operações de bloqueio em um aplicativo gráfico pode ser difícil.</span><span class="sxs-lookup"><span data-stu-id="cffc1-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="cffc1-203">Não desejamos chamar métodos de bloqueio por meio de manipuladores de eventos, pois o aplicativo parecerá congelado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="cffc1-204">Podemos usar um thread separado para lidar com essas operações, mas quando terminamos, é necessário sincronizar com o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread porque não podemos modificar diretamente o [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] de nosso thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="cffc1-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="cffc1-205">Podemos usar <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Inserir delegados na <xref:System.Windows.Threading.Dispatcher> da [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-206">Eventualmente, esses representantes serão executados com permissão para modificar [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="cffc1-207">Neste exemplo, simulamos uma chamada de procedimento remoto que recupera uma previsão do tempo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="cffc1-208">Usamos um thread de trabalho separada para executar essa chamada e agendamos um método de atualização no <xref:System.Windows.Threading.Dispatcher> do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] quando terminamos de thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 ![Captura de tela que mostra informações sobre o clima da interface do usuário.](./media/threading-model/threading-weather-ui.png)  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="cffc1-210">Veja a seguir alguns dos detalhes a serem observados.</span><span class="sxs-lookup"><span data-stu-id="cffc1-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="cffc1-211">Criando o manipulador de botões</span><span class="sxs-lookup"><span data-stu-id="cffc1-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="cffc1-212">Quando o botão recebe um clique, exibimos o desenho do relógio e iniciamos sua animação.</span><span class="sxs-lookup"><span data-stu-id="cffc1-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="cffc1-213">Desabilitamos o botão.</span><span class="sxs-lookup"><span data-stu-id="cffc1-213">We disable the button.</span></span> <span data-ttu-id="cffc1-214">Invocamos o `FetchWeatherFromServer` método em um novo thread e, em seguida, podemos retornar, permitindo que o <xref:System.Windows.Threading.Dispatcher> processe eventos enquanto aguardamos a coleta da previsão do tempo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="cffc1-215">Buscando o clima</span><span class="sxs-lookup"><span data-stu-id="cffc1-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="cffc1-216">Para manter as coisas simples, na verdade, não apresentamos nenhum código de rede neste exemplo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="cffc1-217">Em vez disso, simulamos o atraso do acesso à rede colocando nosso novo thread em suspensão por quatro segundos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="cffc1-218">Nesse momento, o original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] segmento ainda está em execução e respondendo a eventos.</span><span class="sxs-lookup"><span data-stu-id="cffc1-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="cffc1-219">Para mostrar isso, deixamos uma animação em execução e os botões Minimizar e Maximizar também continuam funcionando.</span><span class="sxs-lookup"><span data-stu-id="cffc1-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="cffc1-220">Quando o atraso é concluído e aleatoriamente, selecionamos nossa previsão do tempo, é hora de relatar para o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-221">Fazemos isso com o agendamento de uma chamada para `UpdateUserInterface` no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread usando esse thread <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="cffc1-222">Passamos uma cadeia de caracteres que descreve o clima para essa chamada de método agendada.</span><span class="sxs-lookup"><span data-stu-id="cffc1-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="cffc1-223">Atualizando o</span><span class="sxs-lookup"><span data-stu-id="cffc1-223">Updating the</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="cffc1-224">Quando o <xref:System.Windows.Threading.Dispatcher> no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread tem tempo, ele executa a chamada agendada para `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="cffc1-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="cffc1-225">Esse método para a animação do relógio e escolhe uma imagem para descrever o clima.</span><span class="sxs-lookup"><span data-stu-id="cffc1-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="cffc1-226">Ele exibe essa imagem e restaura o botão “Buscar Previsão”.</span><span class="sxs-lookup"><span data-stu-id="cffc1-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="cffc1-227">Várias janelas, vários threads</span><span class="sxs-lookup"><span data-stu-id="cffc1-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="cffc1-228">Alguns [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicativos exigem várias janelas de nível superior.</span><span class="sxs-lookup"><span data-stu-id="cffc1-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="cffc1-229">É perfeitamente aceitável para um Thread /<xref:System.Windows.Threading.Dispatcher> combinação para gerenciar várias janelas, mas às vezes, vários threads fazem um trabalho melhor.</span><span class="sxs-lookup"><span data-stu-id="cffc1-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="cffc1-230">Isso será especialmente verdadeiro se houver uma possibilidade de que uma das janelas monopolize o thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] <span data-ttu-id="cffc1-231">Explorer funciona desta maneira.</span><span class="sxs-lookup"><span data-stu-id="cffc1-231">Explorer works in this fashion.</span></span> <span data-ttu-id="cffc1-232">Cada nova janela do Explorer pertence ao processo original, mas é criada sob o controle de um thread independente.</span><span class="sxs-lookup"><span data-stu-id="cffc1-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="cffc1-233">Usando um [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> controle, podemos exibir páginas da Web.</span><span class="sxs-lookup"><span data-stu-id="cffc1-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="cffc1-234">Podemos criar facilmente um simples [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substituir.</span><span class="sxs-lookup"><span data-stu-id="cffc1-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="cffc1-235">Começamos com um recurso importante: a capacidade de abrir uma nova janela do Explorer.</span><span class="sxs-lookup"><span data-stu-id="cffc1-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="cffc1-236">Quando o usuário clica no botão “Nova Janela”, iniciamos uma cópia de nossa janela em um thread separado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="cffc1-237">Dessa forma, operações de execução longa ou de bloqueio em uma das janelas não bloquearão todas as outras janelas.</span><span class="sxs-lookup"><span data-stu-id="cffc1-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="cffc1-238">Na realidade, o modelo de navegador da Web tem seu próprio modelo de threading complicado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="cffc1-239">Nós o escolhemos porque deve ser conhecido pela maioria dos leitores.</span><span class="sxs-lookup"><span data-stu-id="cffc1-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="cffc1-240">O exemplo a seguir mostra o código.</span><span class="sxs-lookup"><span data-stu-id="cffc1-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="cffc1-241">Os seguintes segmentos de threading desse código são os mais interessantes para nós neste contexto:</span><span class="sxs-lookup"><span data-stu-id="cffc1-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="cffc1-242">Esse método é chamado quando o botão “Nova Janela” recebe um clique.</span><span class="sxs-lookup"><span data-stu-id="cffc1-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="cffc1-243">Ele cria um novo thread e o inicia de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="cffc1-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="cffc1-244">Esse método é o ponto de partida para o novo thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="cffc1-245">Criamos uma nova janela sob o controle desse thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="cffc1-246">automaticamente cria um novo <xref:System.Windows.Threading.Dispatcher> para gerenciar o novo thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="cffc1-247">Tudo o que precisamos fazer para tornar a janela funcional é iniciar o <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="cffc1-248">Detalhes técnicos e obstáculos</span><span class="sxs-lookup"><span data-stu-id="cffc1-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="cffc1-249">Escrevendo componentes usando o threading</span><span class="sxs-lookup"><span data-stu-id="cffc1-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="cffc1-250">Guia do desenvolvedor do Microsoft .NET Framework descreve um padrão de como um componente pode expor o comportamento assíncrono para seus clientes (consulte [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="cffc1-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="cffc1-251">Por exemplo, suponha que desejamos empacotar o `FetchWeatherFromServer` método em um componente reutilizável não gráfico.</span><span class="sxs-lookup"><span data-stu-id="cffc1-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="cffc1-252">Seguindo o padrão do Microsoft .NET Framework, isso seria algo semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="cffc1-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 `GetWeatherAsync` <span data-ttu-id="cffc1-253">usaria uma das técnicas descritas anteriormente, como a criação de um thread em segundo plano, para fazer o trabalho de forma assíncrona, não bloqueando o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="cffc1-253">would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="cffc1-254">Uma das partes mais importantes desse padrão é chamar o *MethodName* `Completed` método no mesmo thread que chamou o *MethodName* `Async` método começar.</span><span class="sxs-lookup"><span data-stu-id="cffc1-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="cffc1-255">Você pode fazer isso usando [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bastante fácil, armazenando <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>— mas, em seguida, o componente não gráfico só podia ser usado na [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicativos, não no [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] ou [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programas.</span><span class="sxs-lookup"><span data-stu-id="cffc1-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="cffc1-256">O <xref:System.Windows.Threading.DispatcherSynchronizationContext> classe atende a essa necessidade – pense nela como uma versão simplificada do <xref:System.Windows.Threading.Dispatcher> que funciona com outros [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] estruturas também.</span><span class="sxs-lookup"><span data-stu-id="cffc1-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="cffc1-257">Bombeamento aninhado</span><span class="sxs-lookup"><span data-stu-id="cffc1-257">Nested Pumping</span></span>  
 <span data-ttu-id="cffc1-258">Às vezes, não é viável completamente travar o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-259">Vamos considerar o <xref:System.Windows.MessageBox.Show%2A> método da <xref:System.Windows.MessageBox> classe.</span><span class="sxs-lookup"><span data-stu-id="cffc1-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <xref:System.Windows.MessageBox.Show%2A> <span data-ttu-id="cffc1-260">não retorna até que o usuário clica no botão Okey.</span><span class="sxs-lookup"><span data-stu-id="cffc1-260">doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="cffc1-261">No entanto, ele cria uma janela que deve ter um loop de mensagens para ser interativa.</span><span class="sxs-lookup"><span data-stu-id="cffc1-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="cffc1-262">Enquanto aguardamos até que o usuário clique em OK, a janela do aplicativo original não responde à entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="cffc1-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="cffc1-263">No entanto, ele continua processando mensagens de pintura.</span><span class="sxs-lookup"><span data-stu-id="cffc1-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="cffc1-264">A janela original se redesenha quando é coberta e revelada.</span><span class="sxs-lookup"><span data-stu-id="cffc1-264">The original window redraws itself when covered and revealed.</span></span>  
  
 ![Captura de tela que mostra uma MessageBox com um botão Okey](./media/threading-model/threading-message-loop.png)  
  
 <span data-ttu-id="cffc1-266">Algum thread deve ser responsável pela janela da caixa de mensagem.</span><span class="sxs-lookup"><span data-stu-id="cffc1-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="cffc1-267">foi possível criar um novo thread apenas para a janela da caixa de mensagem, mas esse thread seria impossível pintar os elementos desabilitados na janela original (Lembre-se da discussão anterior sobre exclusão mútua).</span><span class="sxs-lookup"><span data-stu-id="cffc1-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="cffc1-268">Em vez disso, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] usa uma sistema de processamento de mensagens aninhado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="cffc1-269">O <xref:System.Windows.Threading.Dispatcher> classe inclui um método chamado <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, que armazena o ponto de execução atual do aplicativo, em seguida, começa um novo loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="cffc1-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="cffc1-270">Quando termina o loop de mensagens aninhado, a execução continua após original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> chamar.</span><span class="sxs-lookup"><span data-stu-id="cffc1-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="cffc1-271">Nesse caso, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> mantém o contexto do programa na chamada para <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, e inicia um novo loop de mensagens para redesenhar a janela do plano de fundo e manipular a entrada para a janela da caixa de mensagem.</span><span class="sxs-lookup"><span data-stu-id="cffc1-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="cffc1-272">Quando o usuário clica Okey e limpa a janela pop-up, o loop aninhado é encerrado e o controle continua após a chamada para <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="cffc1-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="cffc1-273">Eventos roteados obsoletos</span><span class="sxs-lookup"><span data-stu-id="cffc1-273">Stale Routed Events</span></span>  
 <span data-ttu-id="cffc1-274">O sistema de eventos roteados em [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifica árvores inteiras quando os eventos são gerados.</span><span class="sxs-lookup"><span data-stu-id="cffc1-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="cffc1-275">Quando o botão esquerdo do mouse é pressionado sobre a elipse, `handler2` é executado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="cffc1-276">Após `handler2` for concluída, o evento é passado para o <xref:System.Windows.Controls.Canvas> objeto, que usa `handler1` para processá-lo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="cffc1-277">Isso ocorre apenas se `handler2` faz não explicitamente marca o objeto de evento como manipulado.</span><span class="sxs-lookup"><span data-stu-id="cffc1-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="cffc1-278">É possível que `handler2` levará a uma grande quantidade de tempo de processamento esse evento.</span><span class="sxs-lookup"><span data-stu-id="cffc1-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> `handler2` <span data-ttu-id="cffc1-279">pode usar <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> para iniciar um loop de mensagens aninhado que não retorna por horas.</span><span class="sxs-lookup"><span data-stu-id="cffc1-279">might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="cffc1-280">Se `handler2` não marca o evento como manipulado quando esse loop de mensagem for concluído, o evento é passado a árvore mesmo que ele seja muito antigo.</span><span class="sxs-lookup"><span data-stu-id="cffc1-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="cffc1-281">Reentrada e bloqueio</span><span class="sxs-lookup"><span data-stu-id="cffc1-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="cffc1-282">O mecanismo de bloqueio de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] não se comporta exatamente como alguém poderia imaginar; podemos esperar que um thread pare a operação completamente ao solicitar um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="cffc1-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="cffc1-283">Na realidade, o thread continua recebendo e processando mensagens de alta prioridade.</span><span class="sxs-lookup"><span data-stu-id="cffc1-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="cffc1-284">Isso ajuda a impedir bloqueios e torna a interface minimamente dinâmica, mas introduz a possibilidade de bugs sutis.</span><span class="sxs-lookup"><span data-stu-id="cffc1-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="cffc1-285">A grande maioria das vezes você não precisa saber nada sobre isso, mas em raras circunstâncias (geralmente envolvendo [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] mensagens de janela ou componentes COM STA) isso pode valer a pena saber.</span><span class="sxs-lookup"><span data-stu-id="cffc1-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="cffc1-286">A maioria das interfaces não são criadas com o acesso thread-safe em mente porque os desenvolvedores trabalham sob a suposição de que um [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nunca é acessada por mais de um thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="cffc1-287">Nesse caso, o que o único thread pode fazer alterações ambientais em momentos inesperados, causando aqueles efeitos indesejados que o <xref:System.Windows.Threading.DispatcherObject> mecanismo de exclusão mútua deverá para resolver.</span><span class="sxs-lookup"><span data-stu-id="cffc1-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="cffc1-288">Considere o seguinte pseudocódigo:</span><span class="sxs-lookup"><span data-stu-id="cffc1-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="cffc1-289">![Diagrama que mostra reentrância de threading. ](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="cffc1-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="cffc1-290">Na maioria das vezes, que é a coisa certa, mas há momentos no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] em que essa reentrada inesperada pode realmente causar problemas.</span><span class="sxs-lookup"><span data-stu-id="cffc1-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="cffc1-291">Portanto, em determinados momentos cruciais, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] chamadas <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, que altera a instrução de bloqueio para esse thread usar o [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bloqueio livre de reentrância, em vez do habitual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] bloqueio.</span><span class="sxs-lookup"><span data-stu-id="cffc1-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="cffc1-292">Então, por que fez a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] equipe escolheu esse comportamento?</span><span class="sxs-lookup"><span data-stu-id="cffc1-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="cffc1-293">Isso tinha a ver com objetos COM STA e com o thread de finalização.</span><span class="sxs-lookup"><span data-stu-id="cffc1-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="cffc1-294">Quando um objeto é coletado como lixo, seus `Finalize` método é executado no thread finalizador dedicado, não o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-295">E aí está o problema, porque um objeto COM STA que foi criado a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread somente pode ser descartado no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="cffc1-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="cffc1-296">O [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] faz o equivalente a um <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (nesse caso, usando do Win32 `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="cffc1-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="cffc1-297">Porém, se o [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread está ocupado, o thread do finalizador será interrompido e o objeto COM STA não pode ser descartado, o que cria um vazamento de memória grave.</span><span class="sxs-lookup"><span data-stu-id="cffc1-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="cffc1-298">Portanto, o [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] equipe tomou a difícil decisão para fazer com que os bloqueios funcionem da maneira que eles fazem.</span><span class="sxs-lookup"><span data-stu-id="cffc1-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="cffc1-299">A tarefa para [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] é evitar a reentrância inesperada sem reintroduzir a perda de memória, por isso, não bloqueamos a reentrada em todos os lugares.</span><span class="sxs-lookup"><span data-stu-id="cffc1-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cffc1-300">Consulte também</span><span class="sxs-lookup"><span data-stu-id="cffc1-300">See also</span></span>

- [<span data-ttu-id="cffc1-301">Aplicativo Single-Threaded com exemplo de cálculo de execução longa</span><span class="sxs-lookup"><span data-stu-id="cffc1-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
