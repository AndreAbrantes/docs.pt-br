---
title: Árvores
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 696772da1ebee405493f2ff0e1481daf93d08ec7
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187029"
---
# <a name="trees-in-wpf"></a>Árvores no WPF
Em muitas tecnologias, elementos e componentes são organizados em uma estrutura de árvore em que os desenvolvedores manipulam diretamente os nós de objeto na árvore para afetar a renderização ou o comportamento de um aplicativo. O [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] também usa várias metáforas de estrutura de árvore para definir relações entre elementos do programa. Em geral, os desenvolvedores de WPF conseguem criar um aplicativo em código ou definir partes do aplicativo em XAML enquanto pensam conceitualmente sobre a metáfora da árvore de objeto, mas chamarão uma API específica ou usarão marcação específica para fazer isso em vez de alguma API geral de manipulação de árvore de objeto, como a que poderia ser usada em XML DOM. O WPF expõe duas classes auxiliares que <xref:System.Windows.LogicalTreeHelper> <xref:System.Windows.Media.VisualTreeHelper>fornecem uma visão de metáfora de árvore, e . Os termos “árvore visual” e “árvore lógica” também são utilizados na documentação do WPF porque essas mesmas árvores são úteis para entender o comportamento de alguns recursos principais do WPF. Este tópico define o que a árvore visual e a árvore lógica representam, discute <xref:System.Windows.LogicalTreeHelper> como <xref:System.Windows.Media.VisualTreeHelper>essas árvores se relacionam com um conceito geral de árvore de objetos, e introduz e s.  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a>Árvores no WPF  
 A estrutura de árvore mais completa no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] é a árvore de objetos. Se você definir uma página de aplicativo no [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e, em seguida, carregar o [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], a estrutura de árvore será criada com base nas relações de aninhamento dos elementos na marcação. Se você definir um aplicativo ou uma parte do aplicativo em código, a estrutura de árvore será criada com base em como os valores de propriedade são designados para propriedades que implementam o modelo de conteúdo de um determinado objeto. No [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], a árvore de objetos completa é conceitualizada e pode ser reportada à API pública de duas maneiras: como árvore lógica e como árvore visual. As distinções entre a árvore lógica e a árvore visual não são sempre necessariamente importantes, mas, ocasionalmente, podem causar problemas com alguns subsistemas do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] e afetar opções feitas na marcação ou código.  
  
 Apesar de a árvore lógica ou a árvore visual não serem sempre manipuladas diretamente, entender os conceitos de como elas interagem é útil para entender o WPF como uma tecnologia. Ver o WPF como uma metáfora de árvore de algum tipo também é crucial para entender como a herança de propriedades e roteamento de evento funcionam no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
> Como a árvore de objetos é mais um conceito de uma API real, outra maneira de pensar o conceito é como um grafo de objeto. Na prática, existem relações entre objetos em tempo de execução em que a metáfora de árvore travará. No entanto, especialmente com a interface do usuário definida em XAML, a metáfora da árvore é relevante o suficiente para a maior parte da documentação do WPF usar o termo “árvore de objetos” ao fazer referência a esse conceito geral.  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a>A árvore lógica  
 No [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], conteúdo é adicionado aos elementos da interface do usuário mediante a configuração dos objetos que apoiam esses elementos. Por exemplo, você adiciona itens <xref:System.Windows.Controls.ListBox> a um <xref:System.Windows.Controls.ItemsControl.Items%2A> controle manipulando sua propriedade. Ao fazer isso, você está colocando <xref:System.Windows.Controls.ItemCollection> itens <xref:System.Windows.Controls.ItemsControl.Items%2A> no que é o valor da propriedade. Da mesma forma, para <xref:System.Windows.Controls.DockPanel>adicionar objetos a a , você manipula seu <xref:System.Windows.Controls.Panel.Children%2A> valor de propriedade. Aqui, você está adicionando objetos ao <xref:System.Windows.Controls.UIElementCollection>. Para um exemplo de código, [consulte Como: Adicionar um elemento dinamicamente](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 Em [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], quando você coloca itens <xref:System.Windows.Controls.ListBox> de lista em um ou <xref:System.Windows.Controls.DockPanel>controles ou <xref:System.Windows.Controls.ItemsControl.Items%2A> outros <xref:System.Windows.Controls.Panel.Children%2A> elementos de IU em um , você também usa as propriedades, explícita ou implicitamente, como no exemplo a seguir.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Se você fosse processar esse XAML como XML em um Modelo de Objeto do Documento e se tivesse incluído as marcas de comentário como implícitas (o que seria legal), a árvore DOM XML resultante incluiria elementos para o `<ListBox.Items>` e os outros itens implícitos. Contudo, o XAML não processa dessa forma quando você lê a marcação e grava em objetos; o grafo do objeto resultante não inclui, literalmente, o `ListBox.Items`. No entanto, <xref:System.Windows.Controls.ListBox> ele `Items` tem <xref:System.Windows.Controls.ItemCollection>uma propriedade <xref:System.Windows.Controls.ItemCollection> chamada que contém <xref:System.Windows.Controls.ListBox> um , e que é inicializado, mas vazio quando o XAML é processado. Em seguida, cada elemento de objeto <xref:System.Windows.Controls.ListBox> filho que <xref:System.Windows.Controls.ItemCollection> existe como `ItemCollection.Add`conteúdo para o é adicionado às chamadas por analisador para . Esse exemplo de processamento de XAML em uma árvore de objetos é, até o momento, aparentemente um exemplo em que a árvore de objetos criada é, basicamente, a árvore lógica.  
  
 No entanto, a árvore lógica não é o gráfico de objeto inteiro que existe para a interface do motorista da sua aplicação em tempo de execução, mesmo com os itens de sintaxe implícita XAML fatorados. A principal razão para isso são visuais e modelos. Por exemplo, <xref:System.Windows.Controls.Button>considere o . A árvore lógica <xref:System.Windows.Controls.Button> relata o `Content`objeto e também sua corda . Porém, esse botão contém mais recursos na árvore de objetos de tempo de execução. Em particular, o botão só aparece na tela <xref:System.Windows.Controls.Button> do jeito que aparece porque um modelo de controle específico foi aplicado. Os visuais que vêm de um modelo aplicado (como o modelo definido <xref:System.Windows.Controls.Border> de cinza escuro ao redor do botão visual) não são relatados na árvore lógica, mesmo se você estiver olhando para a árvore lógica durante o tempo de execução (como manusear um evento de entrada da ui visível e, em seguida, ler a árvore lógica). Para encontrar os visuais do modelo, seria necessário examinar a árvore visual.  
  
 Para obter mais informações a respeito de como a sintaxe do [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] é mapeada para o grafo de objeto criado, bem como sobre a sintaxe implícita em XAML, consulte [Sintaxe XAML em detalhes](xaml-syntax-in-detail.md) ou [Visão geral de XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a>A finalidade da árvore lógica  
 A árvore lógica existe para que os modelos de conteúdo possam ser iterados imediatamente sobre os possíveis objetos filho e para que os modelos de conteúdo possam ser extensíveis. Além disso, a árvore lógica fornece uma estrutura para determinadas notificações, como nos casos em que todos os objetos na árvore lógica são carregados. Basicamente, a árvore lógica é uma aproximação de um grafo de objeto de tempo de execução no nível da estrutura, que exclui visuais, mas é adequada para várias operações de consulta em relação à composição do seu próprio aplicativo de tempo de execução.  
  
 Além disso, tanto as referências estáticas quanto as dinâmicas dos recursos são resolvidas olhando para cima através da <xref:System.Windows.FrameworkElement> árvore <xref:System.Windows.FrameworkContentElement>lógica `Resources` para <xref:System.Windows.FrameworkElement.Resources%2A> coletas <xref:System.Windows.ResourceDictionary>no objeto solicitante inicial e, em seguida, continuando até a árvore lógica e verificando cada um (ou ) para outro valor que contenha um , possivelmente contendo essa chave. A árvore lógica é usada para pesquisa de recursos quando a árvore lógica e a árvore visual estão presentes. Para obter mais informações sobre dicionários de recursos e pesquisa, consulte [Recursos de XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a>Composição da árvore lógica  
 A árvore lógica é definida no nível de estrutura do WPF, o que significa que <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>o elemento base wpf mais relevante para operações de árvores lógicas é ou . No entanto, como você pode <xref:System.Windows.LogicalTreeHelper> ver se você realmente usa a API, a árvore lógica às vezes contém nós que não são ou <xref:System.Windows.FrameworkElement> . <xref:System.Windows.FrameworkContentElement> Por exemplo, a árvore <xref:System.Windows.Controls.TextBlock.Text%2A> lógica <xref:System.Windows.Controls.TextBlock>relata o valor de a , que é uma string.  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a>Substituindo a árvore lógica  
 Autores de controle avançado podem substituir a árvore lógica substituindo várias APIs que definem como um objeto geral ou modelo de conteúdo adiciona ou remove objetos dentro da árvore lógica. Para ver um exemplo de como substituir a árvore lógica, consulte [Substituir a árvore lógica](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a>Herança do valor de propriedade  
 A herança do valor da propriedade opera por meio de uma árvore híbrida. Os metadados reais <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> que contêm a propriedade que permite <xref:System.Windows.FrameworkPropertyMetadata> a herança de propriedade são a classe de nível de quadro WPF. Portanto, tanto o pai que detém o valor original quanto o <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>objeto infantil que herda esse valor devem ser ou , e ambos devem fazer parte de alguma árvore lógica. No entanto, para propriedades existentes do WPF que dão suporte à herança de propriedade, a herança de valor da propriedade pode ser perpetuada por meio de um objeto intermediário que não está na árvore lógica. Principalmente, isso é relevante para fazer com que elementos de modelo usem valores da propriedade herdados definidos na instância que é modelada ou em níveis ainda mais altos de composição de nível de página e, portanto, mais altos na árvore lógica. Para a herança de valor da propriedade funcionar consistentemente em tal limite, a propriedade que herda deve ser registrada como uma propriedade anexada. Você deve seguir esse padrão caso pretenda definir uma propriedade de dependência personalizada com comportamento de herança de propriedade. A árvore exata usada para a herança de propriedade não pode ser totalmente prevista por um método de utilitário de classe auxiliar, mesmo em tempo de execução. Para obter mais informações, consulte [Herança do valor da propriedade](property-value-inheritance.md).  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a>A árvore visual  
 Além do conceito de árvore lógica, há também o conceito de árvore visual no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. A árvore visual descreve a estrutura dos objetos visuais, representada pela <xref:System.Windows.Media.Visual> classe base. Quando você grava um modelo para um controle, define ou redefine a árvore visual que se aplica a ele. A árvore visual também interessa aos desenvolvedores que desejam controle de baixo nível sobre o desenho por motivos de desempenho e otimização. Uma exposição da árvore visual como parte da programação convencional do aplicativo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] é que as rotas de eventos para um evento roteado viajam principalmente junto à árvore visual, não à árvore lógica. Essa sutileza do comportamento do evento roteado pode não ser imediatamente aparente, a menos que você seja um autor de controle. O roteamento de eventos através da árvore visual habilita controles que implementam composição no nível visual para manipular eventos ou criar setters de eventos.  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a>Árvores, elementos de conteúdo e hosts de conteúdo  
 Os elementos de <xref:System.Windows.ContentElement>conteúdo (classes derivadas) não fazem parte da árvore visual; eles não herdam <xref:System.Windows.Media.Visual> e não têm uma representação visual. Para aparecer em uma ui em <xref:System.Windows.ContentElement> tudo, um deve ser hospedado <xref:System.Windows.Media.Visual> em um host de conteúdo que é tanto um participante de árvore lógica. Normalmente tal objeto <xref:System.Windows.FrameworkElement>é um . É possível conceitualizar que o host de conteúdo se assemelha a um “navegador” para o conteúdo e escolhe como exibir esse conteúdo dentro da região da tela controlada pelo host. Quando o conteúdo é hospedado, pode se tornar um participante em determinados processos de árvore que, normalmente, estão associados à árvore visual. Geralmente, a <xref:System.Windows.FrameworkElement> classe host inclui código de <xref:System.Windows.ContentElement> implementação que adiciona qualquer hospedeiro à rota do evento através de subnomes da árvore lógica de conteúdo, mesmo que o conteúdo hospedado não faça parte da árvore visual verdadeira. Isso é necessário para <xref:System.Windows.ContentElement> que se possa obter um evento roteado que encaminha para qualquer elemento que não seja ele mesmo.  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a>Passagem da árvore  
 A <xref:System.Windows.LogicalTreeHelper> classe <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>fornece <xref:System.Windows.LogicalTreeHelper.GetParent%2A>os <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> métodos e métodos para a travessia lógica das árvores. Na maioria dos casos, não deve ser necessário atravessar a árvore lógica de controles existentes, porque esses controles quase sempre expõem seus elementos filho lógicos como uma propriedade de coleção dedicada que dá suporte ao acesso de coleção, como `Add`, um indexador etc. A travessia de árvores é principalmente um cenário que é usado por autores <xref:System.Windows.Controls.ItemsControl> <xref:System.Windows.Controls.Panel> de controle que optam por não derivar de padrões de controle pretendidos, como ou onde as propriedades de coleta já estão definidas, e que pretendem fornecer suporte próprio de propriedade de coleção.  
  
 A árvore visual também suporta uma classe auxiliar <xref:System.Windows.Media.VisualTreeHelper>para a travessia visual da árvore, . A árvore visual não é exposta como convenientemente através <xref:System.Windows.Media.VisualTreeHelper> de propriedades específicas de controle, por isso a classe é a maneira recomendada de atravessar a árvore visual se isso for necessário para o seu cenário de programação. Para obter mais informações, consulte [Visão geral de renderização de gráficos do WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Às vezes, é necessário examinar a árvore visual de um modelo aplicado. Você deve ter cuidado ao usar essa técnica. Mesmo que você esteja atravessando uma árvore visual para um controle onde você define o <xref:System.Windows.Controls.Control.Template%2A> modelo, os consumidores do seu controle podem sempre alterar o modelo definindo a propriedade em instâncias, e até mesmo o usuário final pode influenciar o modelo aplicado alterando o tema do sistema.  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a>Rotas para eventos roteados como “árvore”  
 Como mencionado antes, a rota de qualquer evento roteado percorre um caminho único e predeterminado de uma árvore que é um híbrido das representações de árvore visual e lógica. A rota do evento pode percorrer as direções para cima ou para baixo dentro da árvore, dependendo de ser um evento roteado por túnel ou propagação. O conceito de rota de evento não tem uma classe auxiliar diretamente de suporte que possa ser usada para “conduzir” a rota do evento independentemente de gerar um evento que seja realmente roteado. Há uma classe que representa <xref:System.Windows.EventRoute>a rota, mas os métodos dessa classe são geralmente apenas para uso interno.  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a>Dicionários de recursos e árvores  
 A pesquisa de dicionário de recursos para todos os `Resources` definidos em uma página basicamente atravessa a árvore lógica. Os objetos que não estão na árvore lógica podem fazer referência a recursos com chave, mas a sequência de pesquisa de recursos começa no ponto em que o objeto está conectado à árvore lógica. No WPF, apenas os nódulos `Resources` lógicos das <xref:System.Windows.ResourceDictionary>árvores podem ter uma propriedade que contenha um , <xref:System.Windows.ResourceDictionary>portanto, não há nenhum benefício em atravessar a árvore visual à procura de recursos chaveados a partir de um .  
  
 No entanto, a pesquisa de recursos também pode se estender além da árvore lógica imediata. Para marcação de aplicativo, a pesquisa de recurso pode seguir adiante até dicionários de recursos no nível do aplicativo e, a seguir, até valores de suporte e sistema de tema que são referenciados como propriedades estáticas ou chaves. Os próprios temas também poderão fazer referência a valores do sistema fora da árvore lógica de tema se as referências de recurso forem dinâmicas. Para obter mais informações sobre dicionários de recursos e lógica de pesquisa, consulte [Recursos de XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Confira também

- [Visão geral da entrada](input-overview.md)
- [Visão geral de renderização de gráficos do WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Visão geral de eventos roteados](routed-events-overview.md)
- [Inicialização de elementos de objeto que não estão em uma árvore de objetos](initialization-for-object-elements-not-in-an-object-tree.md)
- [Arquitetura do WPF](wpf-architecture.md)
