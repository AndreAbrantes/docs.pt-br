---
title: XAML e classes personalizadas para WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 8b47c43e897004a6c7eb3d2f8b2a2b9bb625e158
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/23/2019
ms.locfileid: "68400826"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="f7e13-102">XAML e classes personalizadas para WPF</span><span class="sxs-lookup"><span data-stu-id="f7e13-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="f7e13-103">O XAML conforme implementado nas estruturas Common Language Runtime (CLR) dá suporte à capacidade de definir uma classe ou estrutura personalizada em qualquer linguagem de Common Language Runtime (CLR) e, em seguida, acessar essa classe usando a marcação XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="f7e13-104">É possível usar uma mistura de tipos definidos do [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] e tipos personalizados dentro do mesmo arquivo de marcação, normalmente mapeando os tipos personalizados até um prefixo de namespace de XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="f7e13-105">Este tópico aborda as exigências que uma classe personalizada deve cumprir para que possa ser usada como um elemento XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="f7e13-106">Classes personalizadas em aplicativos ou assemblies</span><span class="sxs-lookup"><span data-stu-id="f7e13-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="f7e13-107">As classes personalizadas que são usadas em XAML podem ser definidas de duas maneiras distintas: dentro do code-behind ou outro código que produz o aplicativo primário do [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] ou como uma classe em um assembly separado, como um executável ou DLL usados como biblioteca de classes.</span><span class="sxs-lookup"><span data-stu-id="f7e13-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="f7e13-108">Cada uma dessas abordagens apresenta vantagens e desvantagens.</span><span class="sxs-lookup"><span data-stu-id="f7e13-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="f7e13-109">A vantagem de criar uma biblioteca de classes é que qualquer uma dessas classes personalizadas pode ser compartilhada entre vários aplicativos possíveis diferentes.</span><span class="sxs-lookup"><span data-stu-id="f7e13-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="f7e13-110">Uma biblioteca separada também facilita o controle de problemas de versão dos aplicativos e simplifica uma classe em que o uso pretendido da classe é como um elemento raiz em uma página XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="f7e13-111">A vantagem de definir as classes personalizadas no aplicativo é que essa técnica é relativamente simples e minimiza os problemas de implantação e testes encontrados quando assemblies separados são introduzidos além do executável principal do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="f7e13-112">Se definidas no mesmo assembly ou em um assembly diferente, as classes personalizadas precisam ser mapeadas entre o namespace de CLR e o namespace de XML para que possam ser usadas no XAML como elementos.</span><span class="sxs-lookup"><span data-stu-id="f7e13-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="f7e13-113">Consulte [Namespaces de XAML e mapeamento de namespace para XAML do WPF](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f7e13-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="f7e13-114">Exigências para uma classe personalizada como um elemento XAML</span><span class="sxs-lookup"><span data-stu-id="f7e13-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="f7e13-115">Para que possa ser instanciada como um elemento de objeto, sua classe deve cumprir as exigências abaixo:</span><span class="sxs-lookup"><span data-stu-id="f7e13-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="f7e13-116">A classe personalizada deve ser pública e dar suporte a um construtor público padrão (sem parâmetros).</span><span class="sxs-lookup"><span data-stu-id="f7e13-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="f7e13-117">(Consulte a seção a seguir para ver as observações sobre estruturas.)</span><span class="sxs-lookup"><span data-stu-id="f7e13-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="f7e13-118">A classe personalizada não deve ser uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="f7e13-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="f7e13-119">As classes aninhadas e o “ponto” na sintaxe de uso do CLR geral interferem com outros recursos do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] e/ou do XAML, como propriedades anexadas.</span><span class="sxs-lookup"><span data-stu-id="f7e13-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="f7e13-120">Além de habilitar a sintaxe de elemento de objeto, sua definição de objeto também habilita a sintaxe de elemento de propriedade para outras propriedades públicas que assumem o objeto como o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="f7e13-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="f7e13-121">Isso ocorre porque, agora, o objeto pode ser instanciado como um elemento de objeto e pode preencher o valor do elemento da propriedade de tal propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7e13-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="f7e13-122">Estruturas</span><span class="sxs-lookup"><span data-stu-id="f7e13-122">Structures</span></span>  
 <span data-ttu-id="f7e13-123">As estruturas que você define como tipos personalizados são sempre capazes de serem construídas em [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML no. Isso ocorre porque os compiladores CLR criam implicitamente um construtor sem parâmetros para uma estrutura que inicializa todos os valores de propriedade para seus padrões.</span><span class="sxs-lookup"><span data-stu-id="f7e13-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="f7e13-124">Em alguns casos, o comportamento de construção padrão e/ou o uso do elemento de objeto para uma estrutura não é desejável.</span><span class="sxs-lookup"><span data-stu-id="f7e13-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="f7e13-125">Isso pode ocorrer porque a estrutura se destina a preencher valores e a funcionar conceitualmente como uma união, em que os valores contidos poderão ter interpretações mutuamente exclusivas e, consequentemente, nenhuma das propriedades será configurável.</span><span class="sxs-lookup"><span data-stu-id="f7e13-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="f7e13-126">Um [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] exemplo dessa estrutura é <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="f7e13-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="f7e13-127">Em geral, tais estruturas devem implementar um conversor de tipo de modo que os valores possam ser expressos na forma de atributo, usando as convenções de cadeia de caracteres que criam a interpretações ou modos diferentes de valores da estrutura.</span><span class="sxs-lookup"><span data-stu-id="f7e13-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="f7e13-128">A estrutura também deve expor comportamento semelhante para a construção de código por meio de um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f7e13-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="f7e13-129">Exigências para as propriedades de uma classe personalizada como atributos XAML</span><span class="sxs-lookup"><span data-stu-id="f7e13-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="f7e13-130">As propriedades devem referenciar um tipo por valor (como um primitivo) ou usar uma classe para o tipo que tem um construtor sem parâmetros ou um conversor de tipo dedicado que um processador XAML pode acessar.</span><span class="sxs-lookup"><span data-stu-id="f7e13-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="f7e13-131">Na implementação CLR XAML, os processadores XAML encontram tais conversores por meio de suporte nativo para primitivos de linguagem ou por meio <xref:System.ComponentModel.TypeConverterAttribute> da aplicação de um tipo ou membro em definições de tipo de backup</span><span class="sxs-lookup"><span data-stu-id="f7e13-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="f7e13-132">Como alternativa, a propriedade poderá fazer referência a um tipo de classe abstrata ou a uma interface.</span><span class="sxs-lookup"><span data-stu-id="f7e13-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="f7e13-133">Para classes abstratas ou interfaces, a expectativa de análise de XAML é que o valor da propriedade deve ser preenchido com instâncias de classe práticas que implementam a interface ou instâncias dos tipos que derivam da classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="f7e13-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="f7e13-134">As propriedades podem ser declaradas em uma classe abstrata, mas podem ser definidas somente em classes práticas que derivam da classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="f7e13-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="f7e13-135">Isso ocorre porque a criação do elemento Object para a classe requer um construtor público sem parâmetros na classe.</span><span class="sxs-lookup"><span data-stu-id="f7e13-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="f7e13-136">Sintaxe de atributo habilitada para TypeConverter</span><span class="sxs-lookup"><span data-stu-id="f7e13-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="f7e13-137">Se você fornecer um conversor de tipos atribuído e dedicado no nível de classe, a conversão de tipos aplicada habilita a sintaxe de atributo para qualquer propriedade que precise instanciar esse tipo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="f7e13-138">Um conversor de tipo não habilita o uso do elemento de objeto do tipo; somente a presença de um construtor sem parâmetros para esse tipo habilita o uso do elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f7e13-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="f7e13-139">Portanto, propriedades que são habilitadas por conversor de tipos geralmente não são utilizáveis em sintaxe de propriedade, a menos que o próprio tipo também dê suporte à sintaxe de elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f7e13-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="f7e13-140">A exceção é que é possível especificar uma sintaxe de elemento de propriedade, mas o elemento de propriedade contêm uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="f7e13-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="f7e13-141">Esse uso é basicamente equivalente a um uso de sintaxe de atributo, e esse uso não é comum, a menos que haja uma necessidade de tratamento de espaço em branco mais robusto do valor do atributo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="f7e13-142">O exemplo a seguir é um uso de elemento de propriedade que usa uma cadeia de caracteres e o equivalente do uso de atributo:</span><span class="sxs-lookup"><span data-stu-id="f7e13-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="f7e13-143">Exemplos de propriedades em que a sintaxe de atributo é permitida, mas a sintaxe do elemento de propriedade que contém um elemento Object não é permitido por meio <xref:System.Windows.Input.Cursor> de XAML são várias propriedades que usam o tipo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="f7e13-144">A <xref:System.Windows.Input.Cursor> classe tem um conversor <xref:System.Windows.Input.CursorConverter>de tipo dedicado, mas não expõe um construtor sem parâmetros, portanto, <xref:System.Windows.FrameworkElement.Cursor%2A> a propriedade só pode ser definida por meio da sintaxe de atributo <xref:System.Windows.Input.Cursor> , embora o tipo real seja um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="f7e13-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="f7e13-145">Conversores de tipo por propriedade</span><span class="sxs-lookup"><span data-stu-id="f7e13-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="f7e13-146">Como alternativa, a própria propriedade poderá declarar um conversor de tipos no nível de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7e13-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="f7e13-147">Isso permite uma "mini linguagem" que instancia objetos do tipo da propriedade embutida, processando os valores de cadeia de caracteres de entrada do atributo como entrada <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> para uma operação com base no tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="f7e13-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="f7e13-148">Normalmente, isso é feito para fornecer um acessador de conveniência, mas não como meio exclusivo para configurar uma propriedade em XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="f7e13-149">No entanto, também é possível usar conversores de tipo para atributos em que você deseja usar tipos CLR existentes que não fornecem um construtor sem parâmetros ou um conversor de tipo atribuído.</span><span class="sxs-lookup"><span data-stu-id="f7e13-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="f7e13-150">Exemplos da [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API são determinadas propriedades que assumem o <xref:System.Globalization.CultureInfo> tipo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="f7e13-151">Nesse caso, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] o usou o tipo de estrutura <xref:System.Globalization.CultureInfo> de Microsoft .net existente para solucionar melhor os cenários de compatibilidade e migração que foram usados em versões anteriores do <xref:System.Globalization.CultureInfo> Framework, mas o tipo não oferecia suporte ao os construtores ou a conversão de tipo de nível de tipo podem ser usados diretamente como um valor de propriedade XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="f7e13-152">Sempre que você expõe uma propriedade que tem uma utilização de XAML, especialmente se for um autor de controle, considere a possibilidade de dar suporte a essa propriedade com uma propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="f7e13-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="f7e13-153">Isso é particularmente verdadeiro se você usar a implementação [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] existente do processador XAML, pois você pode melhorar o desempenho usando <xref:System.Windows.DependencyProperty> o backup.</span><span class="sxs-lookup"><span data-stu-id="f7e13-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="f7e13-154">Uma propriedade de dependência vai expor recursos do sistema de propriedades para a propriedade que os usuários virão a esperar de uma propriedade acessível do XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="f7e13-155">Isso inclui recursos como animação, vinculação de dados e suporte de estilo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="f7e13-156">Para obter mais informações, consulte [Propriedades de dependência personalizada](custom-dependency-properties.md) e [Carregamento de XAML e propriedades de dependência](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="f7e13-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="f7e13-157">Gravando e atribuindo um conversor de tipos</span><span class="sxs-lookup"><span data-stu-id="f7e13-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="f7e13-158">Ocasionalmente, você precisará escrever uma classe <xref:System.ComponentModel.TypeConverter> derivada personalizada para fornecer conversão de tipo para seu tipo de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7e13-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="f7e13-159">Para obter instruções sobre como derivar e criar um conversor de tipo que pode dar suporte a usos de XAML e como aplicar <xref:System.ComponentModel.TypeConverterAttribute>o, consulte [TypeConverters e XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f7e13-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="f7e13-160">Exigências de sintaxe de atributo do manipulador de eventos XAML em eventos de uma classe personalizada</span><span class="sxs-lookup"><span data-stu-id="f7e13-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="f7e13-161">Para ser utilizável como um evento CLR, o evento deve ser exposto como um evento público em uma classe que dá suporte a um construtor sem parâmetros ou em uma classe abstrata na qual o evento pode ser acessado em classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f7e13-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="f7e13-162">Para ser usado convenientemente como um evento roteado, seu evento CLR deve implementar `add` Explicit e `remove` métodos, que adicionam e removem manipuladores para a assinatura de evento do CLR e encaminham esses <xref:System.Windows.UIElement.AddHandler%2A> manipuladores para o e <xref:System.Windows.UIElement.RemoveHandler%2A> maneiras.</span><span class="sxs-lookup"><span data-stu-id="f7e13-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="f7e13-163">Esses métodos adicionam ou removem os manipuladores para o armazenamento do manipulador de eventos roteados na instância à qual o evento está anexado.</span><span class="sxs-lookup"><span data-stu-id="f7e13-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7e13-164">É possível registrar manipuladores diretamente para eventos roteados usando <xref:System.Windows.UIElement.AddHandler%2A>, e para não definir deliberadamente um evento CLR que expõe o evento roteado.</span><span class="sxs-lookup"><span data-stu-id="f7e13-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="f7e13-165">Em geral, isso não é recomendado, porque o evento não permitirá sintaxe de atributo XAML para anexar manipuladores; a classe resultante oferecerá um modo de exibição de XAML menos transparente dos recursos do tipo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="f7e13-166">Gravando propriedades de coleção</span><span class="sxs-lookup"><span data-stu-id="f7e13-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="f7e13-167">As propriedades que usam um tipo de coleção têm uma sintaxe XAML que permite especificar os objetos que são adicionados à coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="f7e13-168">Essa sintaxe possui dois recursos notáveis.</span><span class="sxs-lookup"><span data-stu-id="f7e13-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="f7e13-169">O objeto que é o objeto de coleção não precisa ser especificado na sintaxe de elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f7e13-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="f7e13-170">A presença desse tipo de coleção é implícita sempre que você especifica uma propriedade em XAML que utiliza um tipo de coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="f7e13-171">Os elementos filho da propriedade de coleção na marcação são processados para se tornarem membros da coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="f7e13-172">Normalmente, o acesso ao código para os membros de uma coleção é realizado por meio de métodos de lista/dicionário, como `Add`, ou por meio de um indexador.</span><span class="sxs-lookup"><span data-stu-id="f7e13-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="f7e13-173">Mas a sintaxe XAML não oferece suporte a métodos ou indexadores (exceção: O XAML 2009 pode dar suporte a métodos, mas o uso de XAML 2009 restringe os possíveis usos do WPF; consulte [recursos de linguagem XAML 2009](../../xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="f7e13-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="f7e13-174">As coleções obviamente são uma exigência muito comum para a criação de uma árvore de elementos; você precisa de alguma forma para preencher essas coleções em XAML declarativo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="f7e13-175">Portanto, os elementos filho de uma propriedade de coleção são processados ao serem adicionados à coleção que é o valor de tipo de propriedade da coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="f7e13-176">A implementação de serviços de XAML do .NET Framework e, consequentemente, o processador XAML do WPF usam a seguinte definição para o que constitui uma propriedade de coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="f7e13-177">O tipo de propriedade da propriedade deve implementar um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="f7e13-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="f7e13-178">Implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="f7e13-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="f7e13-179">Implementa <xref:System.Collections.IDictionary> ou o equivalente genérico (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="f7e13-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="f7e13-180">Deriva de <xref:System.Array> (para obter mais informações sobre matrizes em XAML, consulte [extensão de marcação x:array](../../xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="f7e13-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="f7e13-181">Implementa <xref:System.Windows.Markup.IAddChild> (uma interface definida por [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="f7e13-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="f7e13-182">Cada um desses tipos de CLR tem um método do `Add`, que é usado pelo processador de XAML para adicionar itens à coleção subjacente ao criar o grafo do objeto.</span><span class="sxs-lookup"><span data-stu-id="f7e13-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7e13-183">As interfaces `List` genéricas `Dictionary` e (<xref:System.Collections.Generic.IList%601> e <xref:System.Collections.Generic.IDictionary%602>) não têm suporte para detecção de coleção pelo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processador XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="f7e13-184">No entanto, você pode <xref:System.Collections.Generic.List%601> usar a classe como uma classe base, porque <xref:System.Collections.IList> ela implementa diretamente <xref:System.Collections.Generic.Dictionary%602> ou como uma classe base, porque ela <xref:System.Collections.IDictionary> implementa diretamente.</span><span class="sxs-lookup"><span data-stu-id="f7e13-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="f7e13-185">Quando declarar uma propriedade que utiliza uma coleção, tenha cuidado com a maneira como o valor da propriedade é inicializado em novas instâncias do tipo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="f7e13-186">Se você não estiver implementando a propriedade como uma propriedade de dependência, é adequado que ela use um campo de suporte que chame o construtor do tipo de coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="f7e13-187">Se a propriedade for uma propriedade de dependência, talvez seja necessário inicializar a propriedade de coleção como parte do construtor de tipo padrão.</span><span class="sxs-lookup"><span data-stu-id="f7e13-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="f7e13-188">Isso ocorre porque uma propriedade de dependência extrai o valor padrão de metadados e, normalmente, você não quer que o valor inicial de uma propriedade de coleção seja uma coleção estática e compartilhada.</span><span class="sxs-lookup"><span data-stu-id="f7e13-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="f7e13-189">Deve haver uma instância de coleção por cada instância de tipo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="f7e13-190">Para obter mais informações, consulte [Propriedades de dependência personalizada](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="f7e13-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="f7e13-191">É possível implementar um tipo de coleção personalizada para sua propriedade da coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="f7e13-192">Devido ao tratamento implícito da propriedade de coleção, o tipo de coleção personalizada não precisa fornecer um construtor sem parâmetros para ser usado em XAML implicitamente.</span><span class="sxs-lookup"><span data-stu-id="f7e13-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="f7e13-193">No entanto, opcionalmente, você pode fornecer um construtor sem parâmetros para o tipo de coleção.</span><span class="sxs-lookup"><span data-stu-id="f7e13-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="f7e13-194">Pode ser uma prática que vale a pena.</span><span class="sxs-lookup"><span data-stu-id="f7e13-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="f7e13-195">A menos que você forneça um construtor sem parâmetros, você não pode declarar explicitamente a coleção como um elemento Object.</span><span class="sxs-lookup"><span data-stu-id="f7e13-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="f7e13-196">Alguns autores de marcação podem preferir ver a coleção explícita como uma questão de estilo de marcação.</span><span class="sxs-lookup"><span data-stu-id="f7e13-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="f7e13-197">Além disso, um construtor sem parâmetros pode simplificar os requisitos de inicialização quando você cria novos objetos que usam o tipo de coleção como um valor de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7e13-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="f7e13-198">Declarando propriedades de conteúdo XAML</span><span class="sxs-lookup"><span data-stu-id="f7e13-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="f7e13-199">A linguagem XAML define o conceito de uma propriedade de conteúdo do [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="f7e13-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="f7e13-200">Cada classe que é útil na sintaxe de objetos pode ter exatamente uma propriedade de conteúdo XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="f7e13-201">Para declarar uma propriedade para ser a propriedade de conteúdo XAML para sua classe, aplique <xref:System.Windows.Markup.ContentPropertyAttribute> o como parte da definição de classe.</span><span class="sxs-lookup"><span data-stu-id="f7e13-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="f7e13-202">Especifique o nome da propriedade de conteúdo XAML pretendida como <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> o no atributo.</span><span class="sxs-lookup"><span data-stu-id="f7e13-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="f7e13-203">A propriedade é especificada como uma cadeia de caracteres por nome, não como uma construção <xref:System.Reflection.PropertyInfo>de reflexão, como.</span><span class="sxs-lookup"><span data-stu-id="f7e13-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="f7e13-204">Você pode especificar uma propriedade de coleção para ser a propriedade de conteúdo XAML.</span><span class="sxs-lookup"><span data-stu-id="f7e13-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="f7e13-205">Isso resulta em um uso para a propriedade em que o elemento de objeto pode ter um ou mais elementos filho, sem nenhum elemento de objeto de coleção interveniente ou marcas de elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7e13-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="f7e13-206">Em seguida, esses elementos são tratados como o valor da propriedade de conteúdo XAML e adicionados à instância de coleção de suporte.</span><span class="sxs-lookup"><span data-stu-id="f7e13-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="f7e13-207">Algumas propriedades de conteúdo XAML existentes usam o tipo de propriedade de `Object`.</span><span class="sxs-lookup"><span data-stu-id="f7e13-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="f7e13-208">Isso permite que uma propriedade de conteúdo XAML possa obter valores primitivos, <xref:System.String> como um, bem como pegar um único valor de objeto de referência.</span><span class="sxs-lookup"><span data-stu-id="f7e13-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="f7e13-209">Se você seguir esse modelo, seu tipo será responsável pela determinação de tipo, bem como pela manipulação de tipos possíveis.</span><span class="sxs-lookup"><span data-stu-id="f7e13-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="f7e13-210">O motivo típico para um <xref:System.Object> tipo de conteúdo é dar suporte a um meio simples de adicionar conteúdo de objeto como uma cadeia de caracteres (que recebe um tratamento de apresentação padrão) ou um meio avançado de adicionar conteúdo de objeto que especifica uma apresentação não padrão ou dados adicionais.</span><span class="sxs-lookup"><span data-stu-id="f7e13-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="f7e13-211">Serialização de XAML</span><span class="sxs-lookup"><span data-stu-id="f7e13-211">Serializing XAML</span></span>  
 <span data-ttu-id="f7e13-212">Para alguns cenários, como se você fosse um autor de controle, você poderia querer garantir que qualquer representação de objeto que possa ser instanciada em XAML também possa ser serializada para marcação XAML equivalente.</span><span class="sxs-lookup"><span data-stu-id="f7e13-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="f7e13-213">As exigências de serialização não são descritas neste tópico.</span><span class="sxs-lookup"><span data-stu-id="f7e13-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="f7e13-214">Consulte [Visão geral da criação de controle](../controls/control-authoring-overview.md) e [Árvore de elementos e serialização](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="f7e13-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f7e13-215">Consulte também</span><span class="sxs-lookup"><span data-stu-id="f7e13-215">See also</span></span>

- [<span data-ttu-id="f7e13-216">Visão geral de XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="f7e13-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="f7e13-217">Propriedades de dependência personalizada</span><span class="sxs-lookup"><span data-stu-id="f7e13-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="f7e13-218">Visão geral da criação de controle</span><span class="sxs-lookup"><span data-stu-id="f7e13-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="f7e13-219">Visão geral de elementos base</span><span class="sxs-lookup"><span data-stu-id="f7e13-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="f7e13-220">Carregamento de XAML e propriedades da dependência</span><span class="sxs-lookup"><span data-stu-id="f7e13-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
