---
title: Visão geral das propriedades anexadas
description: Saiba mais sobre propriedades anexadas em Windows Presentation Foundation, que são propriedades globais configurável em qualquer objeto.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: 993f65024fcfc4f39a408c81af43b798360e6cf6
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168379"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="1998f-103">Visão geral das propriedades anexadas</span><span class="sxs-lookup"><span data-stu-id="1998f-103">Attached Properties Overview</span></span>

<span data-ttu-id="1998f-104">Uma propriedade anexada é um conceito definido por XAML.</span><span class="sxs-lookup"><span data-stu-id="1998f-104">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="1998f-105">Uma propriedade anexada deve ser utilizada como um tipo de propriedade global configurável em qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="1998f-105">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="1998f-106">No [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], as propriedades anexadas normalmente são definidas como uma forma especializada de propriedade de dependência que não tem a propriedade “wrapper” convencional.</span><span class="sxs-lookup"><span data-stu-id="1998f-106">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <a name="prerequisites"></a><span data-ttu-id="1998f-107">Pré-requisitos<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-107">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="1998f-108">Este artigo pressupõe que você entende as propriedades de dependência da perspectiva de um consumidor de propriedades de dependência existentes em [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes e leu a [visão geral das propriedades de dependência](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1998f-108">This article assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="1998f-109">Para seguir os exemplos neste artigo, você também deve compreender o XAML e saber como escrever aplicativos WPF.</span><span class="sxs-lookup"><span data-stu-id="1998f-109">To follow the examples in this article, you should also understand XAML and know how to write WPF applications.</span></span>

## <a name="why-use-attached-properties"></a><span data-ttu-id="1998f-110">Por que usar propriedades anexadas<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-110">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="1998f-111">Uma finalidade de uma propriedade anexada é permitir que elementos filho diferentes especifiquem valores exclusivos para uma propriedade definida em um elemento pai.</span><span class="sxs-lookup"><span data-stu-id="1998f-111">One purpose of an attached property is to allow different child elements to specify unique values for a property that's defined in a parent element.</span></span> <span data-ttu-id="1998f-112">Um aplicativo específico desse cenário é quando elementos filho informam ao elemento pai como devem ser apresentados no [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1998f-112">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="1998f-113">Um exemplo é a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="1998f-113">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1998f-114">A <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> propriedade é criada como uma propriedade anexada porque foi projetada para ser definida em elementos que estão contidos em um em <xref:System.Windows.Controls.DockPanel> vez de em <xref:System.Windows.Controls.DockPanel> si.</span><span class="sxs-lookup"><span data-stu-id="1998f-114">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel> rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="1998f-115">A <xref:System.Windows.Controls.DockPanel> classe define o <xref:System.Windows.DependencyProperty> campo estático chamado <xref:System.Windows.Controls.DockPanel.DockProperty> e, em seguida, fornece os <xref:System.Windows.Controls.DockPanel.GetDock%2A> <xref:System.Windows.Controls.DockPanel.SetDock%2A> métodos e como acessadores públicos para a propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-115">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <a name="attached-properties-in-xaml"></a><span data-ttu-id="1998f-116">Propriedades anexadas em XAML<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-116">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="1998f-117">Em XAML, as propriedades anexadas são definidas por meio do uso da sintaxe *AttachedPropertyProvider*.*PropertyName*</span><span class="sxs-lookup"><span data-stu-id="1998f-117">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="1998f-118">Veja a seguir um exemplo de como você pode definir <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> em XAML:</span><span class="sxs-lookup"><span data-stu-id="1998f-118">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="1998f-119">O uso é um pouco semelhante a uma propriedade estática; Você sempre referencia o tipo <xref:System.Windows.Controls.DockPanel> que possui e registra a propriedade anexada, em vez de se referir a qualquer instância especificada por nome.</span><span class="sxs-lookup"><span data-stu-id="1998f-119">The usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="1998f-120">Além disso, como uma propriedade anexada em XAML é um atributo definido na marcação, somente a operação de conjuntos tem alguma relevância.</span><span class="sxs-lookup"><span data-stu-id="1998f-120">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="1998f-121">Não é possível obter uma propriedade diretamente em XAML, apesar de existirem alguns mecanismos indiretos para comparar valores, como gatilhos em estilos (para mais detalhes, consulte [Estilo e modelagem](../../../desktop-wpf/fundamentals/styles-templates-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="1998f-121">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="1998f-122">Implementação de propriedades anexadas no WPF</span><span class="sxs-lookup"><span data-stu-id="1998f-122">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="1998f-123">No [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] , a maioria das propriedades anexadas relacionadas à interface do usuário em tipos WPF são implementadas como propriedades de dependência.</span><span class="sxs-lookup"><span data-stu-id="1998f-123">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the UI-related attached properties on WPF types are implemented as dependency properties.</span></span> <span data-ttu-id="1998f-124">As propriedades anexadas são um conceito XAML, enquanto as propriedades de dependência são um conceito do WPF.</span><span class="sxs-lookup"><span data-stu-id="1998f-124">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="1998f-125">Como as propriedades anexadas do WPF são propriedades de dependência, elas dão suporte a conceitos de propriedade de dependência, como metadados de propriedade, e valores padrão dos metadados de propriedade.</span><span class="sxs-lookup"><span data-stu-id="1998f-125">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <a name="how-attached-properties-are-used-by-the-owning-type"></a><span data-ttu-id="1998f-126">Como as propriedades anexadas são usadas pelo tipo proprietário<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-126">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="1998f-127">Embora as propriedades anexadas possam ser definidas em qualquer objeto, isso não significa, automaticamente, que a definição da propriedade produzirá um resultado tangível ou que o valor será usado por outro objeto.</span><span class="sxs-lookup"><span data-stu-id="1998f-127">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="1998f-128">Em geral, as propriedades anexadas são criadas para que os objetos provenientes de uma grande variedade de hierarquias de classe possíveis ou relações lógicas possam reportar informações comuns para o tipo que define a propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-128">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="1998f-129">O tipo que define a propriedade anexada normalmente segue um destes modelos:</span><span class="sxs-lookup"><span data-stu-id="1998f-129">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="1998f-130">O tipo que define a propriedade anexada é concebido para que possa ser o elemento pai dos elementos que definirão valores para a propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-130">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="1998f-131">Em seguida, o tipo itera os objetos filho por meio de lógica interna com relação a algumas estruturas de árvore de objeto, obtém os valores e age sobre eles de alguma maneira.</span><span class="sxs-lookup"><span data-stu-id="1998f-131">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="1998f-132">O tipo que define a propriedade anexada será usado como elemento filho para vários elementos pai e modelos de conteúdo possíveis.</span><span class="sxs-lookup"><span data-stu-id="1998f-132">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="1998f-133">O tipo que define a propriedade anexada representa um serviço.</span><span class="sxs-lookup"><span data-stu-id="1998f-133">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="1998f-134">Outros tipos definem valores para a propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-134">Other types set values for the attached property.</span></span> <span data-ttu-id="1998f-135">A seguir, quando o elemento que define a propriedade é avaliado no contexto do serviço, os valores da propriedade anexada são obtidos por meio da lógica interna da classe de serviço.</span><span class="sxs-lookup"><span data-stu-id="1998f-135">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="1998f-136">Um exemplo de propriedade anexada definida pelo pai</span><span class="sxs-lookup"><span data-stu-id="1998f-136">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="1998f-137">O cenário mais comum em que o WPF define uma propriedade anexada é quando um elemento pai dá suporte a uma coleção de elementos filho e também implementa um comportamento em que as especificidades do comportamento são relatadas individualmente para cada elemento filho.</span><span class="sxs-lookup"><span data-stu-id="1998f-137">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="1998f-138"><xref:System.Windows.Controls.DockPanel>define a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Propriedade anexada e <xref:System.Windows.Controls.DockPanel> tem código de nível de classe como parte de sua lógica de renderização (especificamente, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> e <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A> ).</span><span class="sxs-lookup"><span data-stu-id="1998f-138"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="1998f-139">Uma <xref:System.Windows.Controls.DockPanel> instância sempre verificará se algum de seus elementos filho imediatos definiu um valor para <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1998f-139">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1998f-140">Nesse caso, tais valores se tornam uma entrada para a lógica de renderização aplicada ao elemento filho em questão.</span><span class="sxs-lookup"><span data-stu-id="1998f-140">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="1998f-141"><xref:System.Windows.Controls.DockPanel>As instâncias aninhadas tratam suas próprias coleções de elementos filho imediatos, mas esse comportamento é específico da implementação para o modo como <xref:System.Windows.Controls.DockPanel> os valores de processos são processados <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1998f-141">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="1998f-142">Teoricamente, é possível ter propriedades anexadas que influenciam elementos além do pai imediato.</span><span class="sxs-lookup"><span data-stu-id="1998f-142">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="1998f-143">Se a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Propriedade anexada estiver definida em um elemento que não tem nenhum <xref:System.Windows.Controls.DockPanel> elemento pai para agir sobre ela, nenhum erro ou exceção será gerado.</span><span class="sxs-lookup"><span data-stu-id="1998f-143">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="1998f-144">Isso simplesmente significa que um valor de propriedade global foi definido, mas ele não tem um <xref:System.Windows.Controls.DockPanel> pai atual que possa consumir as informações.</span><span class="sxs-lookup"><span data-stu-id="1998f-144">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <a name="attached-properties-in-code"></a><span data-ttu-id="1998f-145">Propriedades anexadas no código<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-145">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="1998f-146">As propriedades anexadas no WPF não têm os métodos "wrapper" do CLR típicos para acesso de Get/Set fácil.</span><span class="sxs-lookup"><span data-stu-id="1998f-146">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="1998f-147">Isso ocorre porque a propriedade anexada não é necessariamente parte do namespace CLR para instâncias em que a propriedade está definida.</span><span class="sxs-lookup"><span data-stu-id="1998f-147">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="1998f-148">No entanto, um processador XAML deve ser capaz de definir esses valores quando o XAML for analisado.</span><span class="sxs-lookup"><span data-stu-id="1998f-148">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="1998f-149">Para dar suporte a um uso de Propriedade anexado efetivo, o tipo de proprietário da propriedade anexada deve implementar métodos de acessadores dedicados no formato **Get_PropertyName_** e **Set_PropertyName_**.</span><span class="sxs-lookup"><span data-stu-id="1998f-149">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="1998f-150">Esses métodos de acesso dedicados também são úteis para obter ou definir a propriedade anexada em código.</span><span class="sxs-lookup"><span data-stu-id="1998f-150">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="1998f-151">De uma perspectiva de código, uma propriedade anexada é semelhante a um campo de suporte que tem métodos de acesso em vez de acessadores de propriedade; além disso, o campo de suporte pode existir em qualquer objeto, sem precisar ser definido especificamente.</span><span class="sxs-lookup"><span data-stu-id="1998f-151">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="1998f-152">O exemplo a seguir mostra como você pode definir uma propriedade anexada em código.</span><span class="sxs-lookup"><span data-stu-id="1998f-152">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="1998f-153">Neste exemplo, `myCheckBox` é uma instância da <xref:System.Windows.Controls.CheckBox> classe.</span><span class="sxs-lookup"><span data-stu-id="1998f-153">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="1998f-154">Semelhante ao caso XAML, se `myCheckBox` ainda não havia sido adicionado como um elemento filho de `myDockPanel` pela quarta linha de código, a quinta linha de código não geraria uma exceção, mas o valor da propriedade não interagiria com um <xref:System.Windows.Controls.DockPanel> pai e, portanto, não faria nada.</span><span class="sxs-lookup"><span data-stu-id="1998f-154">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the fourth line of code, the fifth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="1998f-155">Somente um <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> valor definido em um elemento filho combinado com a presença de um <xref:System.Windows.Controls.DockPanel> elemento pai causará um comportamento efetivo no aplicativo renderizado.</span><span class="sxs-lookup"><span data-stu-id="1998f-155">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="1998f-156">(Nesse caso, você poderia definir a propriedade anexada e anexar à árvore.</span><span class="sxs-lookup"><span data-stu-id="1998f-156">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="1998f-157">Uma alternativa é anexar à árvore e, em seguida, definir a propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-157">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="1998f-158">A ordem das ações gera o mesmo resultado.)</span><span class="sxs-lookup"><span data-stu-id="1998f-158">Either action order provides the same result.)</span></span>

## <a name="attached-property-metadata"></a><span data-ttu-id="1998f-159">Metadados de Propriedade anexado<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-159">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="1998f-160">Ao registrar a propriedade, <xref:System.Windows.FrameworkPropertyMetadata> é definido para especificar as características da propriedade, como se a propriedade afeta a renderização, a medida e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="1998f-160">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="1998f-161">Em geral, os metadados de uma propriedade anexada não diferem dos metadados de uma propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="1998f-161">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="1998f-162">Se você especificar um valor padrão em uma substituição para metadados da propriedade anexada, esse valor vai se tornar o valor padrão da propriedade anexada implícita em instâncias da classe de substituição.</span><span class="sxs-lookup"><span data-stu-id="1998f-162">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="1998f-163">Especificamente, o valor padrão será relatado se algum processo consultar o valor de uma propriedade anexada por meio do acessador do método `Get` para essa propriedade, especificando uma instância da classe em que os metadados foram especificados, e caso o valor dessa propriedade anexada não tenha sido definido de outra maneira.</span><span class="sxs-lookup"><span data-stu-id="1998f-163">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="1998f-164">Se você desejar habilitar a herança de valor da propriedade em uma propriedade, deverá usar propriedades anexadas em vez de propriedades de dependência não anexadas.</span><span class="sxs-lookup"><span data-stu-id="1998f-164">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="1998f-165">Para obter detalhes, consulte [Herança do valor da propriedade](property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="1998f-165">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <a name="custom-attached-properties"></a><span data-ttu-id="1998f-166">Propriedades anexadas personalizadas<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-166">Custom Attached Properties <a name="custom"></a></span></span>

### <a name="when-to-create-an-attached-property"></a><span data-ttu-id="1998f-167">Quando criar uma propriedade anexada<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-167">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="1998f-168">É possível criar uma propriedade anexada quando há um motivo para ter um mecanismo de configuração de propriedade disponível para classes diferentes da classe de definição.</span><span class="sxs-lookup"><span data-stu-id="1998f-168">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="1998f-169">O cenário mais comum para isso é o layout.</span><span class="sxs-lookup"><span data-stu-id="1998f-169">The most common scenario for this is layout.</span></span> <span data-ttu-id="1998f-170">Exemplos de propriedades de layout existentes são <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> , <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType> e <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1998f-170">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1998f-171">O cenário habilitado aqui é que os elementos que existem como elementos filho para elementos de controle do layout conseguem expressar os requisitos de layout para os elementos pai de layout individualmente, sendo que cada um configura um valor da propriedade que o pai definiu como propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-171">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="1998f-172">Outro cenário para usar uma propriedade anexada é quando a classe representa um serviço, e você deseja que classes possam integrar o serviço de forma mais transparente.</span><span class="sxs-lookup"><span data-stu-id="1998f-172">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="1998f-173">Outro cenário é receber suporte ao designer do WPF do Visual Studio, como a edição da janela **Propriedades** .</span><span class="sxs-lookup"><span data-stu-id="1998f-173">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="1998f-174">Para obter mais informações, consulte [Visão geral da criação de controle](../controls/control-authoring-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1998f-174">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="1998f-175">Como mencionado anteriormente, será necessário registrar como propriedade anexada se você quiser usar a herança de valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="1998f-175">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <a name="how-to-create-an-attached-property"></a><span data-ttu-id="1998f-176">Como criar uma propriedade anexada<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-176">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="1998f-177">Se sua classe estiver definindo a propriedade anexada estritamente para uso em outros tipos, a classe não precisará derivar de <xref:System.Windows.DependencyObject> .</span><span class="sxs-lookup"><span data-stu-id="1998f-177">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="1998f-178">Mas você precisa derivar de <xref:System.Windows.DependencyObject> se você seguir o modelo do WPF geral de ter sua propriedade anexada também é uma propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="1998f-178">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="1998f-179">Defina a propriedade anexada como uma propriedade de dependência declarando um `public static readonly` campo do tipo <xref:System.Windows.DependencyProperty> .</span><span class="sxs-lookup"><span data-stu-id="1998f-179">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="1998f-180">Você define esse campo usando o valor de retorno do <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método.</span><span class="sxs-lookup"><span data-stu-id="1998f-180">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="1998f-181">O nome do campo deve corresponder ao nome da propriedade anexada, acrescentado com a cadeia de caracteres `Property` , para seguir o padrão WPF estabelecido de nomear os campos de identificação versus as propriedades que eles representam.</span><span class="sxs-lookup"><span data-stu-id="1998f-181">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="1998f-182">O provedor de propriedades anexada também deve fornecer os métodos estáticos de **Get_PropertyName_** e **Set_PropertyName_** como acessadores para a propriedade anexada; a falha em fazer isso resulta no sistema de propriedades não poder usar sua propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="1998f-182">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this results in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="1998f-183">Se você omitir o acessador get da propriedade anexada, a vinculação de dados na propriedade não funcionará em ferramentas de design, como o Visual Studio e o Blend para Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="1998f-183">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="1998f-184">O acessador get</span><span class="sxs-lookup"><span data-stu-id="1998f-184">The Get Accessor</span></span>

<span data-ttu-id="1998f-185">A assinatura para o acessador de **Get_PropertyName_** deve ser:</span><span class="sxs-lookup"><span data-stu-id="1998f-185">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="1998f-186">O objeto `target` pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="1998f-186">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1998f-187">Por exemplo, o <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> método digita o parâmetro como <xref:System.Windows.UIElement> , porque a propriedade anexada destina-se apenas a ser definida em <xref:System.Windows.UIElement> instâncias.</span><span class="sxs-lookup"><span data-stu-id="1998f-187">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="1998f-188">O valor retornado pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="1998f-188">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1998f-189">Por exemplo, o <xref:System.Windows.Controls.DockPanel.GetDock%2A> método o digita como <xref:System.Windows.Controls.Dock> , porque o valor só pode ser definido como essa enumeração.</span><span class="sxs-lookup"><span data-stu-id="1998f-189">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="1998f-190">O acessador set</span><span class="sxs-lookup"><span data-stu-id="1998f-190">The Set Accessor</span></span>

<span data-ttu-id="1998f-191">A assinatura para o acessador de **Set_PropertyName_** deve ser:</span><span class="sxs-lookup"><span data-stu-id="1998f-191">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="1998f-192">O objeto `target` pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="1998f-192">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1998f-193">Por exemplo, o <xref:System.Windows.Controls.DockPanel.SetDock%2A> método o digita como <xref:System.Windows.UIElement> , porque a propriedade anexada destina-se apenas a ser definida em <xref:System.Windows.UIElement> instâncias.</span><span class="sxs-lookup"><span data-stu-id="1998f-193">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="1998f-194">O objeto `value` pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="1998f-194">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1998f-195">Por exemplo, o <xref:System.Windows.Controls.DockPanel.SetDock%2A> método o digita como <xref:System.Windows.Controls.Dock> , porque o valor só pode ser definido como essa enumeração.</span><span class="sxs-lookup"><span data-stu-id="1998f-195">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="1998f-196">Lembre-se de que o valor para esse método é a entrada proveniente do carregador de XAML, quando ele encontra a propriedade anexada em um uso da propriedade anexada na marcação.</span><span class="sxs-lookup"><span data-stu-id="1998f-196">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="1998f-197">Essa entrada é o valor especificado como um valor de atributo XAML na marcação.</span><span class="sxs-lookup"><span data-stu-id="1998f-197">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="1998f-198">Portanto, deve haver conversão de tipo, serializador de valores ou suporte à extensão de marcação para o tipo que usar, de modo que o tipo adequado possa ser criado por meio do valor do atributo (que é, basicamente, apenas uma cadeia de caracteres).</span><span class="sxs-lookup"><span data-stu-id="1998f-198">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="1998f-199">O exemplo a seguir mostra o registro de propriedade de dependência (usando o <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método), bem como os acessadores **Get_PropertyName_** e **Set_PropertyName_** .</span><span class="sxs-lookup"><span data-stu-id="1998f-199">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="1998f-200">No exemplo, o nome da propriedade anexada é `IsBubbleSource`.</span><span class="sxs-lookup"><span data-stu-id="1998f-200">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="1998f-201">Portanto, os acessadores devem ser nomeados como `GetIsBubbleSource` e `SetIsBubbleSource`.</span><span class="sxs-lookup"><span data-stu-id="1998f-201">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="1998f-202">Atributos de propriedade anexada</span><span class="sxs-lookup"><span data-stu-id="1998f-202">Attached Property Attributes</span></span>

<span data-ttu-id="1998f-203">O WPF define vários atributos .NET que se destinam a fornecer informações sobre propriedades anexadas a processos de reflexão e a usuários típicos de informações de reflexão e propriedade, como designers.</span><span class="sxs-lookup"><span data-stu-id="1998f-203">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="1998f-204">Como as propriedades anexadas têm um tipo de escopo ilimitado, os designers precisam de uma maneira de evitar sobrecarregar os usuários com uma lista global de todas as propriedades anexadas que são definidas em uma implementação de tecnologia específica que usa XAML.</span><span class="sxs-lookup"><span data-stu-id="1998f-204">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="1998f-205">Os atributos do .NET que o WPF define para propriedades anexadas podem ser usados para definir o escopo das situações em que uma determinada propriedade anexada deve ser mostrada em uma janela de propriedades.</span><span class="sxs-lookup"><span data-stu-id="1998f-205">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="1998f-206">Você também pode considerar a possibilidade de aplicar esses atributos para suas próprias propriedades anexadas personalizadas.</span><span class="sxs-lookup"><span data-stu-id="1998f-206">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="1998f-207">A finalidade e a sintaxe dos atributos do .NET são descritas nas páginas de referência apropriadas:</span><span class="sxs-lookup"><span data-stu-id="1998f-207">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <a name="learning-more-about-attached-properties"></a><span data-ttu-id="1998f-208">Aprendendo mais sobre propriedades anexadas<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="1998f-208">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="1998f-209">Para obter mais informações sobre como criar uma propriedade anexada, consulte [Registrar uma propriedade anexada](how-to-register-an-attached-property.md).</span><span class="sxs-lookup"><span data-stu-id="1998f-209">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="1998f-210">Para ver mais cenários de uso avançados para as propriedades de dependência e as propriedades anexadas, consulte [Propriedades de dependência personalizada](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="1998f-210">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="1998f-211">Também é possível registrar uma propriedade como propriedade anexada e como propriedade de dependência, mas ainda expor implementações de “wrapper”.</span><span class="sxs-lookup"><span data-stu-id="1998f-211">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="1998f-212">Nesse caso, a propriedade pode ser definida nesse elemento ou em qualquer elemento por meio da sintaxe de propriedade anexada XAML.</span><span class="sxs-lookup"><span data-stu-id="1998f-212">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="1998f-213">Um exemplo de uma propriedade com um cenário apropriado para os usos padrão e anexado é <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="1998f-213">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="1998f-214">Confira também</span><span class="sxs-lookup"><span data-stu-id="1998f-214">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="1998f-215">Visão geral das propriedades de dependência</span><span class="sxs-lookup"><span data-stu-id="1998f-215">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="1998f-216">Propriedades de dependência personalizadas</span><span class="sxs-lookup"><span data-stu-id="1998f-216">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="1998f-217">Visão geral de XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="1998f-217">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="1998f-218">Registrar uma propriedade anexada</span><span class="sxs-lookup"><span data-stu-id="1998f-218">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
