---
title: Marcando eventos roteados como manipulados e tratamento de classes
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401636"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Marcando eventos roteados como manipulados e tratamento de classes
Os manipuladores de um evento roteado podem marcar o evento manipulado nos dados do evento. Efetivamente, a manipulação do evento reduzirá a rota. A manipulação de classes é um conceito de programação com suporte nos eventos roteados. Um manipulador de classes tem a oportunidade de manipular um evento roteado específico no nível de uma classe com um manipulador que é invocado antes de qualquer manipulador de instâncias em uma instância da classe.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Pré-requisitos  
 Este tópico fornece mais detalhes sobre os conceitos introduzidos na [Visão geral dos eventos roteados](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Quando marcar eventos como manipulados  
 Quando você define o valor da <xref:System.Windows.RoutedEventArgs.Handled%2A> Propriedade como `true` nos dados do evento para um evento roteado, isso é conhecido como "marcando o evento manipulado". Não há nenhuma regra absoluta para quando você deve marcar eventos roteados como manipulados, seja como autor de um aplicativo ou de um controle que responde aos eventos roteados existentes ou implementa novos eventos roteados. Na maioria das vezes, o conceito de "manipulado", conforme transportado nos dados do evento do evento roteado, deve ser usado como um protocolo limitado para as respostas de seu próprio aplicativo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] para os vários eventos roteados expostos em APIs, bem como para qualquer evento roteado personalizado. Outra maneira de considerar a questão de “manipulado” é que você geralmente deve marcar um evento roteado como manipulado se o código respondeu ao evento roteado de forma significativa e relativamente completa. Normalmente, não deve haver mais de uma resposta significativa que exige implementações de manipulador separadas para uma única ocorrência de evento roteado. Se mais respostas forem necessárias, o código necessário deverá ser implementado por meio da lógica do aplicativo que é encadeada em um único manipulador, em vez de usar o sistema de eventos roteados para o encaminhamento. O conceito do que é “significativo” também é subjetivo e depende do aplicativo ou do código. Como diretriz geral, alguns exemplos de “resposta significativa” incluem: configuração do foco, modificação do estado público, configuração de propriedades que afetam a representação visual e acionamento de outros novos eventos. Exemplos de respostas não significativas incluem: modificação do estado particular (sem impacto visual nem representação programática), log de eventos ou inspeção de argumentos de um evento e opção de não responder a ele.  
  
 O comportamento do sistema de eventos roteados reforça esse modelo de "resposta significativa" para usar o estado manipulado de um evento roteado [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] , pois os manipuladores <xref:System.Windows.UIElement.AddHandler%2A> adicionados ou a assinatura comum do não são invocados em resposta a um evento roteado em que o evento os dados já estão marcados como manipulados. Você deve passar pelo esforço extra de adicionar um manipulador com a versão `handledEventsToo` do parâmetro (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) para manipular eventos roteados que são marcados como manipulados por participantes anteriores na rota de eventos.  
  
 Em algumas circunstâncias, os próprios controles marcam alguns eventos roteados como manipulados. Um evento roteado manipulado representa uma decisão dos autores do controle do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de que as ações do controle em resposta ao evento roteado são significativas ou completas como parte da implementação do controle e de que o evento não precisa de manipulação adicional. Geralmente, isso é feito com a adição de um manipulador de classes para um evento ou a substituição de um dos virtuais do manipulador de classes existentes em uma classe base. Você ainda pode resolver essa manipulação de eventos se necessário; consulte [Resolvendo a supressão de eventos por controles](#WorkingAroundEventSuppressionByControls) mais adiante neste tópico.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Eventos de “visualização” (túnel) vs. eventos de propagação e manipulação de eventos  
 Os eventos roteados de visualização são eventos que seguem uma rota de túnel pela árvore de elementos. A “Visualização” expressa na convenção de nomenclatura indica o princípio geral para eventos de entrada de que os eventos roteados de visualização (túnel) são acionados antes do evento roteado de propagação equivalente. Além disso, os eventos roteados de entrada que têm um par de túnel e de propagação têm uma lógica de manipulação distinta. Se o evento roteado de túnel/visualização for marcado como manipulado por um ouvinte de eventos, o evento roteado de propagação será marcado como manipulado mesmo antes de os ouvintes do evento roteado de propagação o receberem. Os eventos roteados de túnel e de propagação são tecnicamente eventos separados, mas, deliberadamente, compartilham a mesma instância de dados do evento para permitir esse comportamento.  
  
 A conexão entre os eventos roteados de túnel e de propagação é feita pela implementação interna de como uma classe do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] específica aciona seus próprios eventos roteados declarados e isso é verdadeiro para os eventos roteados de entrada emparelhados. Porém, a menos que essa implementação em nível de classe exista, não haverá nenhuma conexão entre um evento roteado de túnel e um evento roteado de propagação que compartilham o esquema de nomenclatura: sem essa implementação, eles serão dois eventos roteados completamente separados e não serão acionados em sequência nem compartilharão dados do evento.  
  
 Para obter mais informações sobre como implementar pares de eventos roteados de entrada de túnel/propagação em uma classe personalizada, consulte [Criar um evento roteado personalizado](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Manipuladores de classe e de instância  
 Os eventos roteados consideram dois tipos diferentes de ouvintes para o evento: ouvintes de classes e ouvintes de instâncias. Ouvintes de classe existem porque os tipos chamaram <xref:System.Windows.EventManager> uma<xref:System.Windows.EventManager.RegisterClassHandler%2A>API específica,, em seu construtor estático, ou substituíram um método virtual de manipulador de classe de uma classe base de elemento. Ouvintes de instância são instâncias/elementos de classe específicos em que um ou mais manipuladores foram anexados a esse evento roteado <xref:System.Windows.UIElement.AddHandler%2A>por uma chamada para. Os [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] eventos roteados existentes fazem <xref:System.Windows.UIElement.AddHandler%2A> chamadas como parte do wrapper de evento Common Language Runtime (CLR){} adicionam{} e removem implementações do evento, que também é [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] como o mecanismo simples de a anexação de manipuladores de eventos por meio de uma sintaxe de atributo está habilitada. Portanto, mesmo o [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] uso simples, por fim, <xref:System.Windows.UIElement.AddHandler%2A> equivale a uma chamada.  
  
 Elementos na árvore visual são verificados quanto a implementações de manipuladores registrados. Os manipuladores são potencialmente invocados em toda a rota, na ordem que é inerente ao tipo da estratégia de roteamento para esse evento roteado. Por exemplo, os eventos roteados de propagação primeiro invocarão os manipuladores anexados ao mesmo elemento que acionou o evento roteado. Em seguida, o evento roteado é “propagado” para o próximo elemento pai e assim por diante até chegar ao elemento raiz do aplicativo.  
  
 Da perspectiva do elemento raiz em uma rota de propagação, se a manipulação de classe ou qualquer elemento mais próximo à origem do evento roteado invocar manipuladores que marcam os argumentos do evento como tendo sido manipulados, os manipuladores nos elementos raiz não serão invocados e a rota de evento será reduzida efetivamente antes de chegar ao elemento raiz. No entanto, a rota não é completamente interrompida, porque os manipuladores podem ser adicionados com um condicional especial indicando que eles ainda devem ser invocados, mesmo se um manipulador de classes ou de instâncias marcou o evento roteado como manipulado. Isso é explicado em [Adicionando manipuladores de instância que são acionados mesmo quando os eventos são marcados como manipulados](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), mais adiante neste tópico.  
  
 Em um nível mais profundo que a rota de evento, potencialmente, também há vários manipuladores de classe atuando em determinada instância de uma classe. Isso ocorre porque o modelo de manipulação de classe para eventos roteados permite que todas as classes possíveis em uma hierarquia de classe registrem, individualmente, seu próprio manipulador de classes para cada evento roteado. Cada manipulador de classes é adicionado a um repositório interno e quando a rota de evento de um aplicativo é construída, os manipuladores de classe são todos adicionados à rota de evento. Os manipuladores de classe são adicionados à rota de forma que o manipulador da classe derivada é invocado primeiro e os manipuladores de cada classe base sucessiva são invocados em seguida. Em geral, os manipuladores de classe não são registrados, para que também respondam aos eventos roteados que já foram marcados como manipulados. Portanto, esse mecanismo de manipulação de classe possibilita uma das duas opções:  
  
- As classes derivadas podem suplementar a manipulação de classe herdada da classe base adicionando um manipulador que não marca o evento roteado como manipulado, pois o manipulador da classe base será invocado algum tempo após o manipulador da classe derivada.  
  
- As classes derivadas podem substituir a manipulação de classe da classe base adicionando um manipulador de classes que marca o evento roteado como manipulado. Você deve ter cuidado com essa abordagem, pois ela potencialmente altera o design de controle base pretendido em áreas como aparência visual, lógica de estado, manipulação de entrada e manipulação de comandos.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Manipulação de classe de eventos roteados por classes base de controle  
 Em cada nó de elemento específico em uma rota de evento, os ouvintes de classes têm a oportunidade de responder ao evento roteado antes de qualquer ouvinte de instâncias do elemento. Por esse motivo, às vezes, os manipuladores de classe são usados para suprimir eventos roteados que uma implementação de classe de controle específica não pretende propagar adiante ou para fornecer uma manipulação especial desse evento roteado que é um recurso da classe. Por exemplo, uma classe pode acionar seu próprio evento específico à classe que contém mais especificações sobre o que uma condição de entrada do usuário significa no contexto dessa classe específica. A implementação de classe pode então marcar o evento roteado mais geral como manipulado. Manipuladores de classe normalmente são adicionados de modo que não sejam invocados para eventos roteados em que os dados de eventos compartilhados já foram marcados como manipulados, <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mas, para casos atípicos, também há uma assinatura que registra manipuladores de classe para invocar mesmo quando eventos roteados são Marcado como manipulado.  
  
### <a name="class-handler-virtuals"></a>Virtuais de manipulador de classes  
 Alguns elementos, especialmente os elementos <xref:System.Windows.UIElement>base, como, expõem os métodos virtuais "On * Event" e "OnPreview\*Event" vazios que correspondem à sua lista de eventos roteados públicos. Esses métodos virtuais podem ser substituídos para implementar um manipulador de classes para esse evento roteado. As classes de elemento base registram esses métodos virtuais como seu manipulador de classes para cada evento <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> roteado usando conforme descrito anteriormente. Os métodos virtuais On\*Event facilitam grande parte da implementação de manipulação de classe para os eventos roteados relevantes, sem a necessidade de inicialização especial em construtores estáticos para cada tipo. Por exemplo, você pode adicionar manipulação de classe para <xref:System.Windows.UIElement.DragEnter> o evento em <xref:System.Windows.UIElement> qualquer classe derivada, substituindo o <xref:System.Windows.UIElement.OnDragEnter%2A> método virtual. Na substituição, é possível manipular o evento roteado, acionar outros eventos, iniciar uma lógica específica à classe que pode alterar propriedades de elementos em instâncias ou qualquer combinação dessas ações. Em geral, você deverá chamar a implementação base nessas substituições, mesmo se marcar o evento como manipulado. É altamente recomendável chamar a implementação base, pois o método virtual está na classe base. Basicamente, o padrão virtual protegido de chamada das implementações base de cada virtual substitui e é análogo a um mecanismo semelhante nativo da manipulação de classe de evento roteado, pelo qual os manipuladores de classe de todas as classes em uma hierarquia de classe são chamados em determinada instância, começando com o manipulador da classe mais derivada e continuando para o manipulador da classe base. Você só deverá omitir a chamada da implementação base se a classe tiver um requisito intencional de alteração da lógica de manipulação da classe base. A decisão de chamar a implementação base antes ou após a substituição do código dependerá da natureza da implementação.  
  
#### <a name="input-event-class-handling"></a>Manipulação de classe de evento de entrada  
 Os métodos virtuais de manipulador de classes são todos registrados para que só sejam invocados em casos em que os dados do evento compartilhados ainda não tenham sido marcados como manipulados. Além disso, exclusivamente para eventos de entrada, as versões de túnel e de propagação normalmente são acionadas em sequência e compartilham dados do evento. Isso indica que, para determinado par de manipuladores de classe de eventos de entrada em que um é a versão de túnel e o outro a versão de propagação, talvez você não deseje marcar o evento como manipulado imediatamente. Se você implementar o método virtual de manipulação de classe de túnel para marcar o evento como manipulado, isso impedirá que o manipulador de classes de propagação seja invocado (além de impedir que os manipuladores de instância normalmente registrados para o evento de túnel ou de propagação sejam invocados).  
  
 Após a conclusão da manipulação de classe em um nó, os ouvintes de instâncias são considerados.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Adicionando manipuladores de instância que são acionados mesmo quando os eventos são marcados como manipulados  
 O <xref:System.Windows.UIElement.AddHandler%2A> método fornece uma sobrecarga específica que permite que você adicione manipuladores que serão invocados pelo sistema de eventos sempre que um evento alcançar o elemento de manipulação na rota, mesmo que algum outro manipulador já tenha ajustado os dados de evento para marcá-lo evento como manipulado. Normalmente, isso não é feito. Em geral, os manipuladores podem ser escritos para ajustar todas as áreas do código do aplicativo que podem ser influenciadas por um evento, independentemente da localização em que foi manipulado em uma árvore de elementos, mesmo se vários resultados finais forem desejados. Além disso, por via de regra, há realmente apenas um elemento que precisa responder a esse evento e a lógica do aplicativo apropriada já ocorreu. No entanto, a sobrecarga `handledEventsToo` está disponível para os casos excepcionais em que algum outro elemento em uma árvore de elementos ou composição de controle já marcou um evento como manipulado, mas outros elementos acima ou abaixo da árvore de elementos (dependendo da rota) ainda desejam invocar seus próprios manipuladores.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Quando marcar eventos manipulados como não manipulados  
 Em geral, eventos roteados marcados como manipulados não devem ser marcados como sem<xref:System.Windows.RoutedEventArgs.Handled%2A> tratamento (redefinidos como `false`) mesmo por `handledEventsToo`manipuladores que agem. No entanto, alguns eventos de entrada têm representações de evento de alto nível e de baixo nível que podem se sobrepor quando o evento de alto nível é visto em uma posição na árvore e o evento de baixo nível em outra posição. Por exemplo, considere o caso em que um elemento filho escuta um evento de chave de alto nível, <xref:System.Windows.UIElement.TextInput> como enquanto um elemento pai escuta um evento de baixo nível <xref:System.Windows.UIElement.KeyDown>, como. Se o elemento pai manipular o evento de baixo nível, o evento de nível mais alto poderá ser suprimido mesmo no elemento filho, que intuitivamente deveria ter a primeira oportunidade de manipular o evento.  
  
 Nessas situações, pode ser necessário adicionar manipuladores aos elementos pai e filho no evento de baixo nível. A implementação do manipulador de elemento filho pode marcar o evento de baixo nível como manipulado, mas a implementação do manipulador de elemento pai o definirá como não manipulado novamente, para que os outros elementos acima na árvore (bem como o evento de alto nível) possam ter a oportunidade de responder. Essa situação deve ser bastante rara.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Suprimindo eventos de entrada propositalmente para composição de controle  
 O principal cenário em que a manipulação de classe de eventos roteados é usada é para eventos de entrada e controles compostos. Por definição, um controle composto consiste em vários controles práticos ou classes base de controle. Geralmente, o autor do controle deseja combinar todos os eventos de entrada possíveis que cada um dos subcomponentes pode acionar, para relatar o controle inteiro como uma única origem do evento. Em alguns casos, o autor do controle pode desejar suprimir por completo os eventos dos componentes ou substituir um evento definido por componente que carrega mais informações ou implica um comportamento mais específico. O exemplo canônico que é imediatamente visível para qualquer autor de componente é como [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] um manipulador de <xref:System.Windows.Controls.Button> qualquer evento do mouse que, eventualmente, será resolvido para o evento intuitivo que <xref:System.Windows.Controls.Primitives.ButtonBase.Click> todos os botões têm: um evento.  
  
 A <xref:System.Windows.Controls.Button> classe base (<xref:System.Windows.Controls.Primitives.ButtonBase>) deriva de <xref:System.Windows.Controls.Control> que, por sua vez, deriva <xref:System.Windows.FrameworkElement> de <xref:System.Windows.UIElement>e, e grande parte da infraestrutura de eventos necessária para o <xref:System.Windows.UIElement> processamento de entrada de controle está disponível no nível. Em particular, <xref:System.Windows.UIElement> o processa <xref:System.Windows.Input.Mouse> eventos gerais que manipulam o teste de cliques para o cursor do mouse dentro de seus limites e fornece eventos distintos para as ações de <xref:System.Windows.UIElement.MouseLeftButtonDown>botão mais comuns, como. <xref:System.Windows.UIElement>também fornece um virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> vazio como o manipulador de classe preregistered para <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.UIElement.MouseLeftButtonDown>e o substitui. Da mesma <xref:System.Windows.Controls.Primitives.ButtonBase> forma, o usa manipuladores de classe para. <xref:System.Windows.UIElement.MouseLeftButtonUp> Nas substituições, que são passadas pelos dados do evento, as implementações marcam essa <xref:System.Windows.RoutedEventArgs> instância como manipulada definindo <xref:System.Windows.RoutedEventArgs.Handled%2A> como `true`e os mesmos dados de evento são o que continua no restante da rota para outros manipuladores de classe e também para manipuladores de instância ou setters de eventos. Além disso, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> a substituição irá disparar o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. O resultado final para a maioria dos ouvintes será que <xref:System.Windows.UIElement.MouseLeftButtonDown> o <xref:System.Windows.UIElement.MouseLeftButtonUp> e os eventos "desaparecem" e <xref:System.Windows.Controls.Primitives.ButtonBase.Click>são substituídos por, um evento que contém mais significado porque é conhecido que esse evento originou-se de um botão verdadeiro e não de alguns parte composta do botão ou de algum outro elemento inteiramente.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Resolvendo a supressão de eventos por controles  
 Às vezes, esse comportamento de supressão de eventos em controles individuais pode interferir em intenções mais gerais da lógica de manipulação de eventos do aplicativo. Por exemplo, se, por algum motivo, seu aplicativo tivesse um <xref:System.Windows.UIElement.MouseLeftButtonDown> manipulador para localizado no elemento raiz do aplicativo, você observaria que qualquer clique do mouse em um botão <xref:System.Windows.UIElement.MouseLeftButtonDown> não <xref:System.Windows.UIElement.MouseLeftButtonUp> invocaria nem manipuladores no nível raiz. Na verdade, o próprio evento foi propagado (novamente, as rotas de evento não são realmente encerradas, mas o sistema de eventos roteados altera seu comportamento de invocação de manipulador depois de ser marcado como manipulado). Quando o evento roteado chegou ao botão, <xref:System.Windows.Controls.Primitives.ButtonBase> a classe Handling marcou <xref:System.Windows.UIElement.MouseLeftButtonDown> o Handled porque queria substituir o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento por mais significado. Portanto, qualquer manipulador <xref:System.Windows.UIElement.MouseLeftButtonDown> padrão além da rota não seria invocado. Há duas técnicas que podem ser usadas para garantir que os manipuladores serão invocados nessa circunstância.  
  
 A primeira técnica é adicionar deliberadamente o manipulador usando `handledEventsToo` a assinatura <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>de. Uma limitação dessa abordagem é que essa técnica de anexar um manipulador de eventos só é possível por meio do código, não da marcação. A sintaxe simples de especificar o nome do manipulador de eventos como um valor de atributo de evento por meio de [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] não permite esse comportamento.  
  
 A segunda técnica funciona somente para eventos de entrada, nos quais as versões de túnel e de propagação do evento roteado são emparelhadas. Para esses eventos roteados, é possível adicionar manipuladores ao evento roteado de visualização/túnel equivalente. Esse evento roteado será encapsulado por meio da rota, começando na raiz, para que o código de manipulação de classes do botão não o intercepte, pressupondo que você anexou o manipulador de Visualização no nível de elemento de algum ancestral na árvore de elementos do aplicativo. Se você usar essa abordagem, tome cuidado ao marcar qualquer evento de Visualização como manipulado. Para o exemplo fornecido com <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> ser manipulado no elemento raiz, se você marcou o evento como <xref:System.Windows.RoutedEventArgs.Handled%2A> na implementação do manipulador, você realmente suprimiria o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Geralmente, esse não é um comportamento desejável.  
  
## <a name="see-also"></a>Consulte também

- <xref:System.Windows.EventManager>
- [Eventos de visualização](preview-events.md)
- [Criar um evento roteado personalizado](how-to-create-a-custom-routed-event.md)
- [Visão geral de eventos roteados](routed-events-overview.md)
