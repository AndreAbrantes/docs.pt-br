---
title: Marcando eventos roteados como manipulados e tratamento de classes
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401636"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="46865-102">Marcando eventos roteados como manipulados e tratamento de classes</span><span class="sxs-lookup"><span data-stu-id="46865-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="46865-103">Os manipuladores de um evento roteado podem marcar o evento manipulado nos dados do evento.</span><span class="sxs-lookup"><span data-stu-id="46865-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="46865-104">Efetivamente, a manipulação do evento reduzirá a rota.</span><span class="sxs-lookup"><span data-stu-id="46865-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="46865-105">A manipulação de classes é um conceito de programação com suporte nos eventos roteados.</span><span class="sxs-lookup"><span data-stu-id="46865-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="46865-106">Um manipulador de classes tem a oportunidade de manipular um evento roteado específico no nível de uma classe com um manipulador que é invocado antes de qualquer manipulador de instâncias em uma instância da classe.</span><span class="sxs-lookup"><span data-stu-id="46865-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="46865-107">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="46865-107">Prerequisites</span></span>  
 <span data-ttu-id="46865-108">Este tópico fornece mais detalhes sobre os conceitos introduzidos na [Visão geral dos eventos roteados](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="46865-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="46865-109">Quando marcar eventos como manipulados</span><span class="sxs-lookup"><span data-stu-id="46865-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="46865-110">Quando você define o valor da <xref:System.Windows.RoutedEventArgs.Handled%2A> Propriedade como `true` nos dados do evento para um evento roteado, isso é conhecido como "marcando o evento manipulado".</span><span class="sxs-lookup"><span data-stu-id="46865-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="46865-111">Não há nenhuma regra absoluta para quando você deve marcar eventos roteados como manipulados, seja como autor de um aplicativo ou de um controle que responde aos eventos roteados existentes ou implementa novos eventos roteados.</span><span class="sxs-lookup"><span data-stu-id="46865-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="46865-112">Na maioria das vezes, o conceito de "manipulado", conforme transportado nos dados do evento do evento roteado, deve ser usado como um protocolo limitado para as respostas de seu próprio aplicativo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] para os vários eventos roteados expostos em APIs, bem como para qualquer evento roteado personalizado.</span><span class="sxs-lookup"><span data-stu-id="46865-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="46865-113">Outra maneira de considerar a questão de “manipulado” é que você geralmente deve marcar um evento roteado como manipulado se o código respondeu ao evento roteado de forma significativa e relativamente completa.</span><span class="sxs-lookup"><span data-stu-id="46865-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="46865-114">Normalmente, não deve haver mais de uma resposta significativa que exige implementações de manipulador separadas para uma única ocorrência de evento roteado.</span><span class="sxs-lookup"><span data-stu-id="46865-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="46865-115">Se mais respostas forem necessárias, o código necessário deverá ser implementado por meio da lógica do aplicativo que é encadeada em um único manipulador, em vez de usar o sistema de eventos roteados para o encaminhamento.</span><span class="sxs-lookup"><span data-stu-id="46865-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="46865-116">O conceito do que é “significativo” também é subjetivo e depende do aplicativo ou do código.</span><span class="sxs-lookup"><span data-stu-id="46865-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="46865-117">Como diretriz geral, alguns exemplos de “resposta significativa” incluem: configuração do foco, modificação do estado público, configuração de propriedades que afetam a representação visual e acionamento de outros novos eventos.</span><span class="sxs-lookup"><span data-stu-id="46865-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="46865-118">Exemplos de respostas não significativas incluem: modificação do estado particular (sem impacto visual nem representação programática), log de eventos ou inspeção de argumentos de um evento e opção de não responder a ele.</span><span class="sxs-lookup"><span data-stu-id="46865-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="46865-119">O comportamento do sistema de eventos roteados reforça esse modelo de "resposta significativa" para usar o estado manipulado de um evento roteado [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] , pois os manipuladores <xref:System.Windows.UIElement.AddHandler%2A> adicionados ou a assinatura comum do não são invocados em resposta a um evento roteado em que o evento os dados já estão marcados como manipulados.</span><span class="sxs-lookup"><span data-stu-id="46865-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="46865-120">Você deve passar pelo esforço extra de adicionar um manipulador com a versão `handledEventsToo` do parâmetro (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) para manipular eventos roteados que são marcados como manipulados por participantes anteriores na rota de eventos.</span><span class="sxs-lookup"><span data-stu-id="46865-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="46865-121">Em algumas circunstâncias, os próprios controles marcam alguns eventos roteados como manipulados.</span><span class="sxs-lookup"><span data-stu-id="46865-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="46865-122">Um evento roteado manipulado representa uma decisão dos autores do controle do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de que as ações do controle em resposta ao evento roteado são significativas ou completas como parte da implementação do controle e de que o evento não precisa de manipulação adicional.</span><span class="sxs-lookup"><span data-stu-id="46865-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="46865-123">Geralmente, isso é feito com a adição de um manipulador de classes para um evento ou a substituição de um dos virtuais do manipulador de classes existentes em uma classe base.</span><span class="sxs-lookup"><span data-stu-id="46865-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="46865-124">Você ainda pode resolver essa manipulação de eventos se necessário; consulte [Resolvendo a supressão de eventos por controles](#WorkingAroundEventSuppressionByControls) mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="46865-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="46865-125">Eventos de “visualização” (túnel) vs. eventos de propagação e manipulação de eventos</span><span class="sxs-lookup"><span data-stu-id="46865-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="46865-126">Os eventos roteados de visualização são eventos que seguem uma rota de túnel pela árvore de elementos.</span><span class="sxs-lookup"><span data-stu-id="46865-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="46865-127">A “Visualização” expressa na convenção de nomenclatura indica o princípio geral para eventos de entrada de que os eventos roteados de visualização (túnel) são acionados antes do evento roteado de propagação equivalente.</span><span class="sxs-lookup"><span data-stu-id="46865-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="46865-128">Além disso, os eventos roteados de entrada que têm um par de túnel e de propagação têm uma lógica de manipulação distinta.</span><span class="sxs-lookup"><span data-stu-id="46865-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="46865-129">Se o evento roteado de túnel/visualização for marcado como manipulado por um ouvinte de eventos, o evento roteado de propagação será marcado como manipulado mesmo antes de os ouvintes do evento roteado de propagação o receberem.</span><span class="sxs-lookup"><span data-stu-id="46865-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="46865-130">Os eventos roteados de túnel e de propagação são tecnicamente eventos separados, mas, deliberadamente, compartilham a mesma instância de dados do evento para permitir esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="46865-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="46865-131">A conexão entre os eventos roteados de túnel e de propagação é feita pela implementação interna de como uma classe do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] específica aciona seus próprios eventos roteados declarados e isso é verdadeiro para os eventos roteados de entrada emparelhados.</span><span class="sxs-lookup"><span data-stu-id="46865-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="46865-132">Porém, a menos que essa implementação em nível de classe exista, não haverá nenhuma conexão entre um evento roteado de túnel e um evento roteado de propagação que compartilham o esquema de nomenclatura: sem essa implementação, eles serão dois eventos roteados completamente separados e não serão acionados em sequência nem compartilharão dados do evento.</span><span class="sxs-lookup"><span data-stu-id="46865-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="46865-133">Para obter mais informações sobre como implementar pares de eventos roteados de entrada de túnel/propagação em uma classe personalizada, consulte [Criar um evento roteado personalizado](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="46865-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="46865-134">Manipuladores de classe e de instância</span><span class="sxs-lookup"><span data-stu-id="46865-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="46865-135">Os eventos roteados consideram dois tipos diferentes de ouvintes para o evento: ouvintes de classes e ouvintes de instâncias.</span><span class="sxs-lookup"><span data-stu-id="46865-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="46865-136">Ouvintes de classe existem porque os tipos chamaram <xref:System.Windows.EventManager> uma<xref:System.Windows.EventManager.RegisterClassHandler%2A>API específica,, em seu construtor estático, ou substituíram um método virtual de manipulador de classe de uma classe base de elemento.</span><span class="sxs-lookup"><span data-stu-id="46865-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="46865-137">Ouvintes de instância são instâncias/elementos de classe específicos em que um ou mais manipuladores foram anexados a esse evento roteado <xref:System.Windows.UIElement.AddHandler%2A>por uma chamada para.</span><span class="sxs-lookup"><span data-stu-id="46865-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="46865-138">Os [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] eventos roteados existentes fazem <xref:System.Windows.UIElement.AddHandler%2A> chamadas como parte do wrapper de evento Common Language Runtime (CLR){} adicionam{} e removem implementações do evento, que também é [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] como o mecanismo simples de a anexação de manipuladores de eventos por meio de uma sintaxe de atributo está habilitada.</span><span class="sxs-lookup"><span data-stu-id="46865-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="46865-139">Portanto, mesmo o [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] uso simples, por fim, <xref:System.Windows.UIElement.AddHandler%2A> equivale a uma chamada.</span><span class="sxs-lookup"><span data-stu-id="46865-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="46865-140">Elementos na árvore visual são verificados quanto a implementações de manipuladores registrados.</span><span class="sxs-lookup"><span data-stu-id="46865-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="46865-141">Os manipuladores são potencialmente invocados em toda a rota, na ordem que é inerente ao tipo da estratégia de roteamento para esse evento roteado.</span><span class="sxs-lookup"><span data-stu-id="46865-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="46865-142">Por exemplo, os eventos roteados de propagação primeiro invocarão os manipuladores anexados ao mesmo elemento que acionou o evento roteado.</span><span class="sxs-lookup"><span data-stu-id="46865-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="46865-143">Em seguida, o evento roteado é “propagado” para o próximo elemento pai e assim por diante até chegar ao elemento raiz do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="46865-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="46865-144">Da perspectiva do elemento raiz em uma rota de propagação, se a manipulação de classe ou qualquer elemento mais próximo à origem do evento roteado invocar manipuladores que marcam os argumentos do evento como tendo sido manipulados, os manipuladores nos elementos raiz não serão invocados e a rota de evento será reduzida efetivamente antes de chegar ao elemento raiz.</span><span class="sxs-lookup"><span data-stu-id="46865-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="46865-145">No entanto, a rota não é completamente interrompida, porque os manipuladores podem ser adicionados com um condicional especial indicando que eles ainda devem ser invocados, mesmo se um manipulador de classes ou de instâncias marcou o evento roteado como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="46865-146">Isso é explicado em [Adicionando manipuladores de instância que são acionados mesmo quando os eventos são marcados como manipulados](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="46865-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="46865-147">Em um nível mais profundo que a rota de evento, potencialmente, também há vários manipuladores de classe atuando em determinada instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="46865-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="46865-148">Isso ocorre porque o modelo de manipulação de classe para eventos roteados permite que todas as classes possíveis em uma hierarquia de classe registrem, individualmente, seu próprio manipulador de classes para cada evento roteado.</span><span class="sxs-lookup"><span data-stu-id="46865-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="46865-149">Cada manipulador de classes é adicionado a um repositório interno e quando a rota de evento de um aplicativo é construída, os manipuladores de classe são todos adicionados à rota de evento.</span><span class="sxs-lookup"><span data-stu-id="46865-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="46865-150">Os manipuladores de classe são adicionados à rota de forma que o manipulador da classe derivada é invocado primeiro e os manipuladores de cada classe base sucessiva são invocados em seguida.</span><span class="sxs-lookup"><span data-stu-id="46865-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="46865-151">Em geral, os manipuladores de classe não são registrados, para que também respondam aos eventos roteados que já foram marcados como manipulados.</span><span class="sxs-lookup"><span data-stu-id="46865-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="46865-152">Portanto, esse mecanismo de manipulação de classe possibilita uma das duas opções:</span><span class="sxs-lookup"><span data-stu-id="46865-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="46865-153">As classes derivadas podem suplementar a manipulação de classe herdada da classe base adicionando um manipulador que não marca o evento roteado como manipulado, pois o manipulador da classe base será invocado algum tempo após o manipulador da classe derivada.</span><span class="sxs-lookup"><span data-stu-id="46865-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="46865-154">As classes derivadas podem substituir a manipulação de classe da classe base adicionando um manipulador de classes que marca o evento roteado como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="46865-155">Você deve ter cuidado com essa abordagem, pois ela potencialmente altera o design de controle base pretendido em áreas como aparência visual, lógica de estado, manipulação de entrada e manipulação de comandos.</span><span class="sxs-lookup"><span data-stu-id="46865-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="46865-156">Manipulação de classe de eventos roteados por classes base de controle</span><span class="sxs-lookup"><span data-stu-id="46865-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="46865-157">Em cada nó de elemento específico em uma rota de evento, os ouvintes de classes têm a oportunidade de responder ao evento roteado antes de qualquer ouvinte de instâncias do elemento.</span><span class="sxs-lookup"><span data-stu-id="46865-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="46865-158">Por esse motivo, às vezes, os manipuladores de classe são usados para suprimir eventos roteados que uma implementação de classe de controle específica não pretende propagar adiante ou para fornecer uma manipulação especial desse evento roteado que é um recurso da classe.</span><span class="sxs-lookup"><span data-stu-id="46865-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="46865-159">Por exemplo, uma classe pode acionar seu próprio evento específico à classe que contém mais especificações sobre o que uma condição de entrada do usuário significa no contexto dessa classe específica.</span><span class="sxs-lookup"><span data-stu-id="46865-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="46865-160">A implementação de classe pode então marcar o evento roteado mais geral como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="46865-161">Manipuladores de classe normalmente são adicionados de modo que não sejam invocados para eventos roteados em que os dados de eventos compartilhados já foram marcados como manipulados, <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mas, para casos atípicos, também há uma assinatura que registra manipuladores de classe para invocar mesmo quando eventos roteados são Marcado como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="46865-162">Virtuais de manipulador de classes</span><span class="sxs-lookup"><span data-stu-id="46865-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="46865-163">Alguns elementos, especialmente os elementos <xref:System.Windows.UIElement>base, como, expõem os métodos virtuais "On \* Event" e "OnPreview\*Event" vazios que correspondem à sua lista de eventos roteados públicos.</span><span class="sxs-lookup"><span data-stu-id="46865-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="46865-164">Esses métodos virtuais podem ser substituídos para implementar um manipulador de classes para esse evento roteado.</span><span class="sxs-lookup"><span data-stu-id="46865-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="46865-165">As classes de elemento base registram esses métodos virtuais como seu manipulador de classes para cada evento <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> roteado usando conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="46865-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="46865-166">Os métodos virtuais On\*Event facilitam grande parte da implementação de manipulação de classe para os eventos roteados relevantes, sem a necessidade de inicialização especial em construtores estáticos para cada tipo.</span><span class="sxs-lookup"><span data-stu-id="46865-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="46865-167">Por exemplo, você pode adicionar manipulação de classe para <xref:System.Windows.UIElement.DragEnter> o evento em <xref:System.Windows.UIElement> qualquer classe derivada, substituindo o <xref:System.Windows.UIElement.OnDragEnter%2A> método virtual.</span><span class="sxs-lookup"><span data-stu-id="46865-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="46865-168">Na substituição, é possível manipular o evento roteado, acionar outros eventos, iniciar uma lógica específica à classe que pode alterar propriedades de elementos em instâncias ou qualquer combinação dessas ações.</span><span class="sxs-lookup"><span data-stu-id="46865-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="46865-169">Em geral, você deverá chamar a implementação base nessas substituições, mesmo se marcar o evento como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="46865-170">É altamente recomendável chamar a implementação base, pois o método virtual está na classe base.</span><span class="sxs-lookup"><span data-stu-id="46865-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="46865-171">Basicamente, o padrão virtual protegido de chamada das implementações base de cada virtual substitui e é análogo a um mecanismo semelhante nativo da manipulação de classe de evento roteado, pelo qual os manipuladores de classe de todas as classes em uma hierarquia de classe são chamados em determinada instância, começando com o manipulador da classe mais derivada e continuando para o manipulador da classe base.</span><span class="sxs-lookup"><span data-stu-id="46865-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="46865-172">Você só deverá omitir a chamada da implementação base se a classe tiver um requisito intencional de alteração da lógica de manipulação da classe base.</span><span class="sxs-lookup"><span data-stu-id="46865-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="46865-173">A decisão de chamar a implementação base antes ou após a substituição do código dependerá da natureza da implementação.</span><span class="sxs-lookup"><span data-stu-id="46865-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="46865-174">Manipulação de classe de evento de entrada</span><span class="sxs-lookup"><span data-stu-id="46865-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="46865-175">Os métodos virtuais de manipulador de classes são todos registrados para que só sejam invocados em casos em que os dados do evento compartilhados ainda não tenham sido marcados como manipulados.</span><span class="sxs-lookup"><span data-stu-id="46865-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="46865-176">Além disso, exclusivamente para eventos de entrada, as versões de túnel e de propagação normalmente são acionadas em sequência e compartilham dados do evento.</span><span class="sxs-lookup"><span data-stu-id="46865-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="46865-177">Isso indica que, para determinado par de manipuladores de classe de eventos de entrada em que um é a versão de túnel e o outro a versão de propagação, talvez você não deseje marcar o evento como manipulado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="46865-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="46865-178">Se você implementar o método virtual de manipulação de classe de túnel para marcar o evento como manipulado, isso impedirá que o manipulador de classes de propagação seja invocado (além de impedir que os manipuladores de instância normalmente registrados para o evento de túnel ou de propagação sejam invocados).</span><span class="sxs-lookup"><span data-stu-id="46865-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="46865-179">Após a conclusão da manipulação de classe em um nó, os ouvintes de instâncias são considerados.</span><span class="sxs-lookup"><span data-stu-id="46865-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="46865-180">Adicionando manipuladores de instância que são acionados mesmo quando os eventos são marcados como manipulados</span><span class="sxs-lookup"><span data-stu-id="46865-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="46865-181">O <xref:System.Windows.UIElement.AddHandler%2A> método fornece uma sobrecarga específica que permite que você adicione manipuladores que serão invocados pelo sistema de eventos sempre que um evento alcançar o elemento de manipulação na rota, mesmo que algum outro manipulador já tenha ajustado os dados de evento para marcá-lo evento como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="46865-182">Normalmente, isso não é feito.</span><span class="sxs-lookup"><span data-stu-id="46865-182">This is not typically done.</span></span> <span data-ttu-id="46865-183">Em geral, os manipuladores podem ser escritos para ajustar todas as áreas do código do aplicativo que podem ser influenciadas por um evento, independentemente da localização em que foi manipulado em uma árvore de elementos, mesmo se vários resultados finais forem desejados.</span><span class="sxs-lookup"><span data-stu-id="46865-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="46865-184">Além disso, por via de regra, há realmente apenas um elemento que precisa responder a esse evento e a lógica do aplicativo apropriada já ocorreu.</span><span class="sxs-lookup"><span data-stu-id="46865-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="46865-185">No entanto, a sobrecarga `handledEventsToo` está disponível para os casos excepcionais em que algum outro elemento em uma árvore de elementos ou composição de controle já marcou um evento como manipulado, mas outros elementos acima ou abaixo da árvore de elementos (dependendo da rota) ainda desejam invocar seus próprios manipuladores.</span><span class="sxs-lookup"><span data-stu-id="46865-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="46865-186">Quando marcar eventos manipulados como não manipulados</span><span class="sxs-lookup"><span data-stu-id="46865-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="46865-187">Em geral, eventos roteados marcados como manipulados não devem ser marcados como sem<xref:System.Windows.RoutedEventArgs.Handled%2A> tratamento (redefinidos como `false`) mesmo por `handledEventsToo`manipuladores que agem.</span><span class="sxs-lookup"><span data-stu-id="46865-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="46865-188">No entanto, alguns eventos de entrada têm representações de evento de alto nível e de baixo nível que podem se sobrepor quando o evento de alto nível é visto em uma posição na árvore e o evento de baixo nível em outra posição.</span><span class="sxs-lookup"><span data-stu-id="46865-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="46865-189">Por exemplo, considere o caso em que um elemento filho escuta um evento de chave de alto nível, <xref:System.Windows.UIElement.TextInput> como enquanto um elemento pai escuta um evento de baixo nível <xref:System.Windows.UIElement.KeyDown>, como.</span><span class="sxs-lookup"><span data-stu-id="46865-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="46865-190">Se o elemento pai manipular o evento de baixo nível, o evento de nível mais alto poderá ser suprimido mesmo no elemento filho, que intuitivamente deveria ter a primeira oportunidade de manipular o evento.</span><span class="sxs-lookup"><span data-stu-id="46865-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="46865-191">Nessas situações, pode ser necessário adicionar manipuladores aos elementos pai e filho no evento de baixo nível.</span><span class="sxs-lookup"><span data-stu-id="46865-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="46865-192">A implementação do manipulador de elemento filho pode marcar o evento de baixo nível como manipulado, mas a implementação do manipulador de elemento pai o definirá como não manipulado novamente, para que os outros elementos acima na árvore (bem como o evento de alto nível) possam ter a oportunidade de responder.</span><span class="sxs-lookup"><span data-stu-id="46865-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="46865-193">Essa situação deve ser bastante rara.</span><span class="sxs-lookup"><span data-stu-id="46865-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="46865-194">Suprimindo eventos de entrada propositalmente para composição de controle</span><span class="sxs-lookup"><span data-stu-id="46865-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="46865-195">O principal cenário em que a manipulação de classe de eventos roteados é usada é para eventos de entrada e controles compostos.</span><span class="sxs-lookup"><span data-stu-id="46865-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="46865-196">Por definição, um controle composto consiste em vários controles práticos ou classes base de controle.</span><span class="sxs-lookup"><span data-stu-id="46865-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="46865-197">Geralmente, o autor do controle deseja combinar todos os eventos de entrada possíveis que cada um dos subcomponentes pode acionar, para relatar o controle inteiro como uma única origem do evento.</span><span class="sxs-lookup"><span data-stu-id="46865-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="46865-198">Em alguns casos, o autor do controle pode desejar suprimir por completo os eventos dos componentes ou substituir um evento definido por componente que carrega mais informações ou implica um comportamento mais específico.</span><span class="sxs-lookup"><span data-stu-id="46865-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="46865-199">O exemplo canônico que é imediatamente visível para qualquer autor de componente é como [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] um manipulador de <xref:System.Windows.Controls.Button> qualquer evento do mouse que, eventualmente, será resolvido para o evento intuitivo que <xref:System.Windows.Controls.Primitives.ButtonBase.Click> todos os botões têm: um evento.</span><span class="sxs-lookup"><span data-stu-id="46865-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="46865-200">A <xref:System.Windows.Controls.Button> classe base (<xref:System.Windows.Controls.Primitives.ButtonBase>) deriva de <xref:System.Windows.Controls.Control> que, por sua vez, deriva <xref:System.Windows.FrameworkElement> de <xref:System.Windows.UIElement>e, e grande parte da infraestrutura de eventos necessária para o <xref:System.Windows.UIElement> processamento de entrada de controle está disponível no nível.</span><span class="sxs-lookup"><span data-stu-id="46865-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="46865-201">Em particular, <xref:System.Windows.UIElement> o processa <xref:System.Windows.Input.Mouse> eventos gerais que manipulam o teste de cliques para o cursor do mouse dentro de seus limites e fornece eventos distintos para as ações de <xref:System.Windows.UIElement.MouseLeftButtonDown>botão mais comuns, como.</span><span class="sxs-lookup"><span data-stu-id="46865-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="46865-202"><xref:System.Windows.UIElement>também fornece um virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> vazio como o manipulador de classe preregistered para <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.UIElement.MouseLeftButtonDown>e o substitui.</span><span class="sxs-lookup"><span data-stu-id="46865-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="46865-203">Da mesma <xref:System.Windows.Controls.Primitives.ButtonBase> forma, o usa manipuladores de classe para. <xref:System.Windows.UIElement.MouseLeftButtonUp></span><span class="sxs-lookup"><span data-stu-id="46865-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="46865-204">Nas substituições, que são passadas pelos dados do evento, as implementações marcam essa <xref:System.Windows.RoutedEventArgs> instância como manipulada definindo <xref:System.Windows.RoutedEventArgs.Handled%2A> como `true`e os mesmos dados de evento são o que continua no restante da rota para outros manipuladores de classe e também para manipuladores de instância ou setters de eventos.</span><span class="sxs-lookup"><span data-stu-id="46865-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="46865-205">Além disso, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> a substituição irá disparar o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.</span><span class="sxs-lookup"><span data-stu-id="46865-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="46865-206">O resultado final para a maioria dos ouvintes será que <xref:System.Windows.UIElement.MouseLeftButtonDown> o <xref:System.Windows.UIElement.MouseLeftButtonUp> e os eventos "desaparecem" e <xref:System.Windows.Controls.Primitives.ButtonBase.Click>são substituídos por, um evento que contém mais significado porque é conhecido que esse evento originou-se de um botão verdadeiro e não de alguns parte composta do botão ou de algum outro elemento inteiramente.</span><span class="sxs-lookup"><span data-stu-id="46865-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="46865-207">Resolvendo a supressão de eventos por controles</span><span class="sxs-lookup"><span data-stu-id="46865-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="46865-208">Às vezes, esse comportamento de supressão de eventos em controles individuais pode interferir em intenções mais gerais da lógica de manipulação de eventos do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="46865-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="46865-209">Por exemplo, se, por algum motivo, seu aplicativo tivesse um <xref:System.Windows.UIElement.MouseLeftButtonDown> manipulador para localizado no elemento raiz do aplicativo, você observaria que qualquer clique do mouse em um botão <xref:System.Windows.UIElement.MouseLeftButtonDown> não <xref:System.Windows.UIElement.MouseLeftButtonUp> invocaria nem manipuladores no nível raiz.</span><span class="sxs-lookup"><span data-stu-id="46865-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="46865-210">Na verdade, o próprio evento foi propagado (novamente, as rotas de evento não são realmente encerradas, mas o sistema de eventos roteados altera seu comportamento de invocação de manipulador depois de ser marcado como manipulado).</span><span class="sxs-lookup"><span data-stu-id="46865-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="46865-211">Quando o evento roteado chegou ao botão, <xref:System.Windows.Controls.Primitives.ButtonBase> a classe Handling marcou <xref:System.Windows.UIElement.MouseLeftButtonDown> o Handled porque queria substituir o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento por mais significado.</span><span class="sxs-lookup"><span data-stu-id="46865-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="46865-212">Portanto, qualquer manipulador <xref:System.Windows.UIElement.MouseLeftButtonDown> padrão além da rota não seria invocado.</span><span class="sxs-lookup"><span data-stu-id="46865-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="46865-213">Há duas técnicas que podem ser usadas para garantir que os manipuladores serão invocados nessa circunstância.</span><span class="sxs-lookup"><span data-stu-id="46865-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="46865-214">A primeira técnica é adicionar deliberadamente o manipulador usando `handledEventsToo` a assinatura <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>de.</span><span class="sxs-lookup"><span data-stu-id="46865-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="46865-215">Uma limitação dessa abordagem é que essa técnica de anexar um manipulador de eventos só é possível por meio do código, não da marcação.</span><span class="sxs-lookup"><span data-stu-id="46865-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="46865-216">A sintaxe simples de especificar o nome do manipulador de eventos como um valor de atributo de evento por meio de [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] não permite esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="46865-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="46865-217">A segunda técnica funciona somente para eventos de entrada, nos quais as versões de túnel e de propagação do evento roteado são emparelhadas.</span><span class="sxs-lookup"><span data-stu-id="46865-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="46865-218">Para esses eventos roteados, é possível adicionar manipuladores ao evento roteado de visualização/túnel equivalente.</span><span class="sxs-lookup"><span data-stu-id="46865-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="46865-219">Esse evento roteado será encapsulado por meio da rota, começando na raiz, para que o código de manipulação de classes do botão não o intercepte, pressupondo que você anexou o manipulador de Visualização no nível de elemento de algum ancestral na árvore de elementos do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="46865-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="46865-220">Se você usar essa abordagem, tome cuidado ao marcar qualquer evento de Visualização como manipulado.</span><span class="sxs-lookup"><span data-stu-id="46865-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="46865-221">Para o exemplo fornecido com <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> ser manipulado no elemento raiz, se você marcou o evento como <xref:System.Windows.RoutedEventArgs.Handled%2A> na implementação do manipulador, você realmente suprimiria o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.</span><span class="sxs-lookup"><span data-stu-id="46865-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="46865-222">Geralmente, esse não é um comportamento desejável.</span><span class="sxs-lookup"><span data-stu-id="46865-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="46865-223">Consulte também</span><span class="sxs-lookup"><span data-stu-id="46865-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="46865-224">Eventos de visualização</span><span class="sxs-lookup"><span data-stu-id="46865-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="46865-225">Criar um evento roteado personalizado</span><span class="sxs-lookup"><span data-stu-id="46865-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="46865-226">Visão geral de eventos roteados</span><span class="sxs-lookup"><span data-stu-id="46865-226">Routed Events Overview</span></span>](routed-events-overview.md)
