---
title: Marcando eventos roteados como manipulados e tratamento de classes
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: b2c9a550e1423acb37da9645d09cdb4ccefcea66
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/22/2017
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Marcando eventos roteados como manipulados e tratamento de classes
Os manipuladores de um evento roteado podem marcar o evento manipulado nos dados do evento. Efetivamente, a manipulação do evento reduzirá a rota. A manipulação de classes é um conceito de programação com suporte nos eventos roteados. Um manipulador de classes tem a oportunidade de manipular um evento roteado específico no nível de uma classe com um manipulador que é invocado antes de qualquer manipulador de instâncias em uma instância da classe.  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Pré-requisitos  
 Este tópico fornece mais detalhes sobre os conceitos introduzidos na [Visão geral dos eventos roteados](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Quando marcar eventos como manipulados  
 Quando você define o valor da <xref:System.Windows.RoutedEventArgs.Handled%2A> propriedade `true` no evento dados para um evento roteado, isso é chamado como "marcar o evento manipulado". Não há nenhuma regra absoluta para quando você deve marcar eventos roteados como manipulados, seja como autor de um aplicativo ou de um controle que responde aos eventos roteados existentes ou implementa novos eventos roteados. Geralmente, o conceito de “manipulado” como realizado nos dados do evento roteado deve ser usado como um protocolo limitado para as respostas de seu próprio aplicativo aos vários eventos roteados expostos nas [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], bem como em eventos roteados personalizados. Outra maneira de considerar a questão de “manipulado” é que você geralmente deve marcar um evento roteado como manipulado se o código respondeu ao evento roteado de forma significativa e relativamente completa. Normalmente, não deve haver mais de uma resposta significativa que exige implementações de manipulador separadas para uma única ocorrência de evento roteado. Se mais respostas forem necessárias, o código necessário deverá ser implementado por meio da lógica do aplicativo que é encadeada em um único manipulador, em vez de usar o sistema de eventos roteados para o encaminhamento. O conceito do que é “significativo” também é subjetivo e depende do aplicativo ou do código. Como diretriz geral, alguns exemplos de “resposta significativa” incluem: configuração do foco, modificação do estado público, configuração de propriedades que afetam a representação visual e acionamento de outros novos eventos. Exemplos de respostas não significativas incluem: modificação do estado particular (sem impacto visual nem representação programática), log de eventos ou inspeção de argumentos de um evento e opção de não responder a ele.  
  
 O comportamento do evento roteado reforça esse modelo de "resposta significativa" para utilizar o estado manipulado de um evento roteado, porque manipuladores acrescentados em [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ou a assinatura comum de <xref:System.Windows.UIElement.AddHandler%2A> não são invocados em resposta a um evento roteado onde o evento dados já estiver marcado como tratados. Você deve percorrer o esforço extra de adicionar um manipulador com o `handledEventsToo` versão de parâmetro (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) para manipular eventos roteados marcados como manipulados por participantes anteriores na rota do evento.  
  
 Em algumas circunstâncias, os próprios controles marcam alguns eventos roteados como manipulados. Um evento roteado manipulado representa uma decisão dos autores do controle do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de que as ações do controle em resposta ao evento roteado são significativas ou completas como parte da implementação do controle e de que o evento não precisa de manipulação adicional. Geralmente, isso é feito com a adição de um manipulador de classes para um evento ou a substituição de um dos virtuais do manipulador de classes existentes em uma classe base. Você ainda pode resolver essa manipulação de eventos se necessário; consulte [Resolvendo a supressão de eventos por controles](#WorkingAroundEventSuppressionByControls) mais adiante neste tópico.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Eventos de “visualização” (túnel) vs. eventos de propagação e manipulação de eventos  
 Os eventos roteados de visualização são eventos que seguem uma rota de túnel pela árvore de elementos. A “Visualização” expressa na convenção de nomenclatura indica o princípio geral para eventos de entrada de que os eventos roteados de visualização (túnel) são acionados antes do evento roteado de propagação equivalente. Além disso, os eventos roteados de entrada que têm um par de túnel e de propagação têm uma lógica de manipulação distinta. Se o evento roteado de túnel/visualização for marcado como manipulado por um ouvinte de eventos, o evento roteado de propagação será marcado como manipulado mesmo antes de os ouvintes do evento roteado de propagação o receberem. Os eventos roteados de túnel e de propagação são tecnicamente eventos separados, mas, deliberadamente, compartilham a mesma instância de dados do evento para permitir esse comportamento.  
  
 A conexão entre os eventos roteados de túnel e de propagação é feita pela implementação interna de como uma classe do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] específica aciona seus próprios eventos roteados declarados e isso é verdadeiro para os eventos roteados de entrada emparelhados. Porém, a menos que essa implementação em nível de classe exista, não haverá nenhuma conexão entre um evento roteado de túnel e um evento roteado de propagação que compartilham o esquema de nomenclatura: sem essa implementação, eles serão dois eventos roteados completamente separados e não serão acionados em sequência nem compartilharão dados do evento.  
  
 Para obter mais informações sobre como implementar pares de eventos roteados de entrada de túnel/propagação em uma classe personalizada, consulte [Criar um evento roteado personalizado](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Manipuladores de classe e de instância  
 Os eventos roteados consideram dois tipos diferentes de ouvintes para o evento: ouvintes de classes e ouvintes de instâncias. Ouvintes de classe existem porque tipos chamou um determinado <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, no seu construtor estático, ou sobrepuseram um método virtual de manipulador de classe de uma classe base do elemento. Ouvintes de instância são instâncias de determinada classe/elementos onde um ou mais manipuladores foram anexados para o evento roteado por uma chamada para <xref:System.Windows.UIElement.AddHandler%2A>. Existente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] eventos roteados fazer chamadas para <xref:System.Windows.UIElement.AddHandler%2A> como parte do [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] wrapper de evento add {} e remover {} implementações do evento, que também é como simples [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mecanismo de anexação de manipuladores de eventos por meio de um atributo sintaxe está habilitada. Assim, mesmo simples [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] uso equivale a um <xref:System.Windows.UIElement.AddHandler%2A> chamar.  
  
 Elementos na árvore visual são verificados quanto a implementações de manipuladores registrados. Os manipuladores são potencialmente invocados em toda a rota, na ordem que é inerente ao tipo da estratégia de roteamento para esse evento roteado. Por exemplo, os eventos roteados de propagação primeiro invocarão os manipuladores anexados ao mesmo elemento que acionou o evento roteado. Em seguida, o evento roteado é “propagado” para o próximo elemento pai e assim por diante até chegar ao elemento raiz do aplicativo.  
  
 Da perspectiva do elemento raiz em uma rota de propagação, se a manipulação de classe ou qualquer elemento mais próximo à origem do evento roteado invocar manipuladores que marcam os argumentos do evento como tendo sido manipulados, os manipuladores nos elementos raiz não serão invocados e a rota de evento será reduzida efetivamente antes de chegar ao elemento raiz. No entanto, a rota não é completamente interrompida, porque os manipuladores podem ser adicionados com um condicional especial indicando que eles ainda devem ser invocados, mesmo se um manipulador de classes ou de instâncias marcou o evento roteado como manipulado. Isso é explicado em [Adicionando manipuladores de instância que são acionados mesmo quando os eventos são marcados como manipulados](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), mais adiante neste tópico.  
  
 Em um nível mais profundo que a rota de evento, potencialmente, também há vários manipuladores de classe atuando em determinada instância de uma classe. Isso ocorre porque o modelo de manipulação de classe para eventos roteados permite que todas as classes possíveis em uma hierarquia de classe registrem, individualmente, seu próprio manipulador de classes para cada evento roteado. Cada manipulador de classes é adicionado a um repositório interno e quando a rota de evento de um aplicativo é construída, os manipuladores de classe são todos adicionados à rota de evento. Os manipuladores de classe são adicionados à rota de forma que o manipulador da classe derivada é invocado primeiro e os manipuladores de cada classe base sucessiva são invocados em seguida. Em geral, os manipuladores de classe não são registrados, para que também respondam aos eventos roteados que já foram marcados como manipulados. Portanto, esse mecanismo de manipulação de classe possibilita uma das duas opções:  
  
-   As classes derivadas podem suplementar a manipulação de classe herdada da classe base adicionando um manipulador que não marca o evento roteado como manipulado, pois o manipulador da classe base será invocado algum tempo após o manipulador da classe derivada.  
  
-   As classes derivadas podem substituir a manipulação de classe da classe base adicionando um manipulador de classes que marca o evento roteado como manipulado. Você deve ter cuidado com essa abordagem, pois ela potencialmente altera o design de controle base pretendido em áreas como aparência visual, lógica de estado, manipulação de entrada e manipulação de comandos.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Manipulação de classe de eventos roteados por classes base de controle  
 Em cada nó de elemento específico em uma rota de evento, os ouvintes de classes têm a oportunidade de responder ao evento roteado antes de qualquer ouvinte de instâncias do elemento. Por esse motivo, às vezes, os manipuladores de classe são usados para suprimir eventos roteados que uma implementação de classe de controle específica não pretende propagar adiante ou para fornecer uma manipulação especial desse evento roteado que é um recurso da classe. Por exemplo, uma classe pode acionar seu próprio evento específico à classe que contém mais especificações sobre o que uma condição de entrada do usuário significa no contexto dessa classe específica. A implementação de classe pode então marcar o evento roteado mais geral como manipulado. Manipuladores de classe são adicionados normalmente, de modo que não sejam invocados para roteadas eventos em que os dados de evento compartilhados já foi marcados manipulados, mas para casos atípicos também há um <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> assinatura que registra manipuladores de classe para invocar mesmo quando os eventos roteados são marcado como manipulado.  
  
### <a name="class-handler-virtuals"></a>Virtuais de manipulador de classes  
 Alguns elementos, particularmente os elementos base como <xref:System.Windows.UIElement>, expor vazio "em * evento" e "OnPreview\*evento" métodos virtuais que correspondem à sua lista de eventos roteados públicos. Esses métodos virtuais podem ser substituídos para implementar um manipulador de classes para esse evento roteado. As classes de elemento base registram esses métodos virtuais como seu manipulador de classe para cada evento roteado utilizando <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> conforme descrito anteriormente. Os métodos virtuais On\*Event facilitam grande parte da implementação de manipulação de classe para os eventos roteados relevantes, sem a necessidade de inicialização especial em construtores estáticos para cada tipo. Por exemplo, você pode adicionar manipulação de classe para o <xref:System.Windows.UIElement.DragEnter> eventos em qualquer <xref:System.Windows.UIElement> classe derivada, substituindo o <xref:System.Windows.UIElement.OnDragEnter%2A> método virtual. Na substituição, é possível manipular o evento roteado, acionar outros eventos, iniciar uma lógica específica à classe que pode alterar propriedades de elementos em instâncias ou qualquer combinação dessas ações. Em geral, você deverá chamar a implementação base nessas substituições, mesmo se marcar o evento como manipulado. É altamente recomendável chamar a implementação base, pois o método virtual está na classe base. Basicamente, o padrão virtual protegido de chamada das implementações base de cada virtual substitui e é análogo a um mecanismo semelhante nativo da manipulação de classe de evento roteado, pelo qual os manipuladores de classe de todas as classes em uma hierarquia de classe são chamados em determinada instância, começando com o manipulador da classe mais derivada e continuando para o manipulador da classe base. Você só deverá omitir a chamada da implementação base se a classe tiver um requisito intencional de alteração da lógica de manipulação da classe base. A decisão de chamar a implementação base antes ou após a substituição do código dependerá da natureza da implementação.  
  
#### <a name="input-event-class-handling"></a>Manipulação de classe de evento de entrada  
 Os métodos virtuais de manipulador de classes são todos registrados para que só sejam invocados em casos em que os dados do evento compartilhados ainda não tenham sido marcados como manipulados. Além disso, exclusivamente para eventos de entrada, as versões de túnel e de propagação normalmente são acionadas em sequência e compartilham dados do evento. Isso indica que, para determinado par de manipuladores de classe de eventos de entrada em que um é a versão de túnel e o outro a versão de propagação, talvez você não deseje marcar o evento como manipulado imediatamente. Se você implementar o método virtual de manipulação de classe de túnel para marcar o evento como manipulado, isso impedirá que o manipulador de classes de propagação seja invocado (além de impedir que os manipuladores de instância normalmente registrados para o evento de túnel ou de propagação sejam invocados).  
  
 Após a conclusão da manipulação de classe em um nó, os ouvintes de instâncias são considerados.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Adicionando manipuladores de instância que são acionados mesmo quando os eventos são marcados como manipulados  
 O <xref:System.Windows.UIElement.AddHandler%2A> método fornece uma sobrecarga específica que permite que você adicione manipuladores que serão invocados pelo sistema de eventos sempre que um evento alcançar o elemento manipulador na rota, mesmo que outro manipulador já tenha ajustado os dados de evento para marcar que evento como manipulado. Normalmente, isso não é feito. Em geral, os manipuladores podem ser escritos para ajustar todas as áreas do código do aplicativo que podem ser influenciadas por um evento, independentemente da localização em que foi manipulado em uma árvore de elementos, mesmo se vários resultados finais forem desejados. Além disso, por via de regra, há realmente apenas um elemento que precisa responder a esse evento e a lógica do aplicativo apropriada já ocorreu. No entanto, a sobrecarga `handledEventsToo` está disponível para os casos excepcionais em que algum outro elemento em uma árvore de elementos ou composição de controle já marcou um evento como manipulado, mas outros elementos acima ou abaixo da árvore de elementos (dependendo da rota) ainda desejam invocar seus próprios manipuladores.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Quando marcar eventos manipulados como não manipulados  
 Em geral, eventos roteados são marcados como manipulados não devem ser marcados como sem tratamento (<xref:System.Windows.RoutedEventArgs.Handled%2A> definida como `false`) mesmo por manipuladores que atuem em `handledEventsToo`. No entanto, alguns eventos de entrada têm representações de evento de alto nível e de baixo nível que podem se sobrepor quando o evento de alto nível é visto em uma posição na árvore e o evento de baixo nível em outra posição. Por exemplo, considere o caso em que um elemento filho ouve um alto nível, como <xref:System.Windows.UIElement.TextInput> enquanto um elemento pai ouve um evento de baixo nível, como <xref:System.Windows.UIElement.KeyDown>. Se o elemento pai manipular o evento de baixo nível, o evento de nível mais alto poderá ser suprimido mesmo no elemento filho, que intuitivamente deveria ter a primeira oportunidade de manipular o evento.  
  
 Nessas situações, pode ser necessário adicionar manipuladores aos elementos pai e filho no evento de baixo nível. A implementação do manipulador de elemento filho pode marcar o evento de baixo nível como manipulado, mas a implementação do manipulador de elemento pai o definirá como não manipulado novamente, para que os outros elementos acima na árvore (bem como o evento de alto nível) possam ter a oportunidade de responder. Essa situação deve ser bastante rara.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Suprimindo eventos de entrada propositalmente para composição de controle  
 O principal cenário em que a manipulação de classe de eventos roteados é usada é para eventos de entrada e controles compostos. Por definição, um controle composto consiste em vários controles práticos ou classes base de controle. Geralmente, o autor do controle deseja combinar todos os eventos de entrada possíveis que cada um dos subcomponentes pode acionar, para relatar o controle inteiro como uma única origem do evento. Em alguns casos, o autor do controle pode desejar suprimir por completo os eventos dos componentes ou substituir um evento definido por componente que carrega mais informações ou implica um comportamento mais específico. O exemplo canônico fica imediatamente visível para qualquer autor de componente é como uma [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> manipula qualquer evento de mouse que eventualmente resolverá no evento intuitivo que todos os botões têm: um <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 O <xref:System.Windows.Controls.Button> classe base (<xref:System.Windows.Controls.Primitives.ButtonBase>) deriva <xref:System.Windows.Controls.Control> que por sua vez é derivada de <xref:System.Windows.FrameworkElement> e <xref:System.Windows.UIElement>e grande parte da infraestrutura de evento necessária para o processamento da entrada está disponível na <xref:System.Windows.UIElement> nível. Em particular, <xref:System.Windows.UIElement> processa geral <xref:System.Windows.Input.Mouse> eventos que manipulam teste de hit para o cursor do mouse dentro de seus limites e oferece eventos distintos para os mais comuns botão ações, como <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement>também oferece um virtual vazio <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> como o manipulador de classe pré-registrado para <xref:System.Windows.UIElement.MouseLeftButtonDown>, e <xref:System.Windows.Controls.Primitives.ButtonBase> substitui-lo. Da mesma forma, <xref:System.Windows.Controls.Primitives.ButtonBase> utiliza manipuladores de classe para <xref:System.Windows.UIElement.MouseLeftButtonUp>. Na sobreposição, que é passadas os dados de evento, as implementações marcam <xref:System.Windows.RoutedEventArgs> instância como manipulada, definindo <xref:System.Windows.RoutedEventArgs.Handled%2A> para `true`, e que os mesmos dados de evento são continuam ao longo do restante da rota para outros manipuladores de classe e manipuladores de instância ou setters de evento. Além disso, o <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> substituição lado gerará o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. O resultado final para a maioria dos ouvintes será o <xref:System.Windows.UIElement.MouseLeftButtonDown> e <xref:System.Windows.UIElement.MouseLeftButtonUp> eventos "desaparecem" e são substituídos por <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, um evento que traz mais significado porque é conhecido que esse evento originou de um botão verdadeiro e não alguns composição pedaços do botão ou algum outro elemento inteiramente.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Resolvendo a supressão de eventos por controles  
 Às vezes, esse comportamento de supressão de eventos em controles individuais pode interferir em intenções mais gerais da lógica de manipulação de eventos do aplicativo. Por exemplo, se por algum motivo sua aplicação tinha um manipulador para <xref:System.Windows.UIElement.MouseLeftButtonDown> localizado no elemento raiz do aplicativo, você perceberá que qualquer clique do mouse em um botão não invocaria <xref:System.Windows.UIElement.MouseLeftButtonDown> ou <xref:System.Windows.UIElement.MouseLeftButtonUp> manipuladores no nível raiz. Na verdade, o próprio evento foi propagado (novamente, as rotas de evento não são realmente encerradas, mas o sistema de eventos roteados altera seu comportamento de invocação de manipulador depois de ser marcado como manipulado). Quando o evento roteado alcança o botão, o <xref:System.Windows.Controls.Primitives.ButtonBase> tratamento de classe marcado como o <xref:System.Windows.UIElement.MouseLeftButtonDown> manipulado porque queria substituir o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos com mais significado. Portanto, qualquer padrão <xref:System.Windows.UIElement.MouseLeftButtonDown> manipulador ainda mais a rota não seria invocado. Há duas técnicas que podem ser usadas para garantir que os manipuladores serão invocados nessa circunstância.  
  
 A primeira técnica é deliberadamente acrescentar o manipulador usando o `handledEventsToo` assinatura de <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Uma limitação dessa abordagem é que essa técnica de anexar um manipulador de eventos só é possível por meio do código, não da marcação. A sintaxe simples de especificar o nome do manipulador de eventos como um valor de atributo de evento por meio de [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] não permite esse comportamento.  
  
 A segunda técnica funciona somente para eventos de entrada, nos quais as versões de túnel e de propagação do evento roteado são emparelhadas. Para esses eventos roteados, é possível adicionar manipuladores ao evento roteado de visualização/túnel equivalente. Esse evento roteado será encapsulado por meio da rota, começando na raiz, para que o código de manipulação de classes do botão não o intercepte, pressupondo que você anexou o manipulador de Visualização no nível de elemento de algum ancestral na árvore de elementos do aplicativo. Se você usar essa abordagem, tome cuidado ao marcar qualquer evento de Visualização como manipulado. Para o exemplo fornecido com <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> sendo manipulado no elemento raiz, se você marcou o evento como <xref:System.Windows.RoutedEventArgs.Handled%2A> na implementação do manipulador, você realmente deve suprimir o <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Geralmente, esse não é um comportamento desejável.  
  
## <a name="see-also"></a>Consulte também  
 <xref:System.Windows.EventManager>  
 [Eventos de visualização](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [Criar um evento roteado personalizado](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [Visão geral de eventos roteados](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
