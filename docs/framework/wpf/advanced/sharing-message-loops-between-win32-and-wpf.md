---
title: Compartilhando loops de mensagem entre Win32 e WPF
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 31efc6e514682502e91487565869285dad22cab0
ms.sourcegitcommit: 83ecdf731dc1920bca31f017b1556c917aafd7a0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/12/2019
ms.locfileid: "67860016"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="4e9a5-102">Compartilhando loops de mensagem entre Win32 e WPF</span><span class="sxs-lookup"><span data-stu-id="4e9a5-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="4e9a5-103">Este tópico descreve como implementar um loop de mensagem para interoperação com [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], usando existente de exposição de loop em mensagem <xref:System.Windows.Threading.Dispatcher> ou criando um loop de mensagem separado no [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] lado de seu código de interoperação.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="4e9a5-104">ComponentDispatcher e o loop de mensagem</span><span class="sxs-lookup"><span data-stu-id="4e9a5-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="4e9a5-105">Um cenário comum para suporte de eventos de teclado e interoperação é implementar <xref:System.Windows.Interop.IKeyboardInputSink>, ou subclasses de classes que já implementam <xref:System.Windows.Interop.IKeyboardInputSink>, como <xref:System.Windows.Interop.HwndSource> ou <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="4e9a5-106">No entanto, o suporte ao coletor de teclado não trata de todas as necessidades de loop de mensagem possíveis que você pode ter ao enviar e receber mensagens entre os limites de interoperação.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="4e9a5-107">Para ajudar a formalizar uma arquitetura de loop de mensagem do aplicativo, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] fornece o <xref:System.Windows.Interop.ComponentDispatcher> classe, que define um protocolo simples para um loop de mensagem a seguir.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="4e9a5-108"><xref:System.Windows.Interop.ComponentDispatcher> é uma classe estática que expõe diversos membros.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="4e9a5-109">O escopo de cada método é unido implicitamente ao thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="4e9a5-110">Um loop de mensagem precisa chamar algumas dessas APIs em momentos críticos (conforme definido na próxima seção).</span><span class="sxs-lookup"><span data-stu-id="4e9a5-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="4e9a5-111"><xref:System.Windows.Interop.ComponentDispatcher> Fornece eventos que outros componentes (como o coletor de teclado) podem aguardar.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="4e9a5-112">O <xref:System.Windows.Threading.Dispatcher> classe chama todos os <xref:System.Windows.Interop.ComponentDispatcher> métodos em uma sequência apropriada.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="4e9a5-113">Se você estiver implementando seu próprio loop de mensagem, seu código é responsável por chamar <xref:System.Windows.Interop.ComponentDispatcher> métodos de maneira semelhante.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="4e9a5-114">Chamar <xref:System.Windows.Interop.ComponentDispatcher> métodos em um thread invocará somente manipuladores de eventos que foram registrados naquele thread.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="4e9a5-115">Escrevendo loops de mensagem</span><span class="sxs-lookup"><span data-stu-id="4e9a5-115">Writing Message Loops</span></span>  
 <span data-ttu-id="4e9a5-116">A seguir está uma lista de verificação de <xref:System.Windows.Interop.ComponentDispatcher> membros que você usará se escrever seu próprio loop de mensagem:</span><span class="sxs-lookup"><span data-stu-id="4e9a5-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="4e9a5-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: seu loop de mensagem deve chamá-lo para indicar que o thread é modal.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="4e9a5-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: seu loop de mensagem deve chamá-lo para indicar que o thread foi revertido para não modal.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="4e9a5-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: seu loop de mensagem deve chamá-lo para indicar que <xref:System.Windows.Interop.ComponentDispatcher> deve gerar o <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> eventos.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="4e9a5-120"><xref:System.Windows.Interop.ComponentDispatcher> não gerará <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> se <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> é `true`, mas loops de mensagem poderão optar por chamar <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> mesmo se <xref:System.Windows.Interop.ComponentDispatcher> não possa responder enquanto no estado modal.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="4e9a5-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: seu loop de mensagem deve chamá-lo para indicar que uma nova mensagem está disponível.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="4e9a5-122">O valor retornado indica se um ouvinte para um <xref:System.Windows.Interop.ComponentDispatcher> evento manipulado a mensagem.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="4e9a5-123">Se <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> retorna `true` (tratado), o dispatcher deve fazer nada com a mensagem.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="4e9a5-124">Se o valor retornado for `false`, o despachante deverá chamar a função [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] de `TranslateMessage` e, em seguida, chamar `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="4e9a5-125">Usando ComponentDispatcher e manipulando mensagens existentes</span><span class="sxs-lookup"><span data-stu-id="4e9a5-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="4e9a5-126">A seguir está uma lista de verificação <xref:System.Windows.Interop.ComponentDispatcher> membros que você usará se você depender inerente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="4e9a5-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: Retorna se o aplicativo se tornou modal (por exemplo, um loop de mensagem modal foi introduzido).</span><span class="sxs-lookup"><span data-stu-id="4e9a5-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="4e9a5-128"><xref:System.Windows.Interop.ComponentDispatcher> pode controlar este estado porque a classe mantém uma contagem dos <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> e <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> chamadas a partir do loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="4e9a5-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> e <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> eventos seguem as regras padrão para invocações de delegados.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="4e9a5-130">Representantes são invocados em ordem não especificada e todos os representantes são invocados, mesmo que o primeiro marca a mensagem como tratada.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="4e9a5-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indica um momento apropriado e eficiente para fazer o processamento ocioso (não há nenhuma mensagem pendente para o thread).</span><span class="sxs-lookup"><span data-stu-id="4e9a5-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="4e9a5-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> não será gerado se o thread é modal.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="4e9a5-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: gerado para todas as mensagens que processa a bomba de mensagens.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="4e9a5-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: gerado para todas as mensagens que não foram tratadas durante <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="4e9a5-135">Uma mensagem é considerada tratada se depois de <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> evento ou <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> evento, o `handled` parâmetro passado por referência nos dados de evento é `true`.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="4e9a5-136">Manipuladores de evento devem ignorar a mensagem se `handled` for `true`, pois isso significa que o manipulador diferente a tratou primeiro.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="4e9a5-137">Manipuladores de eventos dos dois eventos podem modificar a mensagem.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="4e9a5-138">O despachante deve despachar a mensagem modificada e não a mensagem original inalterada.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="4e9a5-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> é entregue a todos os ouvintes, mas a intenção arquitetural é que somente a janela de nível superior que contém o HWND no qual as mensagens direcionadas devem invocar código em resposta à mensagem.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="4e9a5-140">Como HwndSource trata eventos de ComponentDispatcher</span><span class="sxs-lookup"><span data-stu-id="4e9a5-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="4e9a5-141">Se o <xref:System.Windows.Interop.HwndSource> é uma janela de nível superior (sem um HWND pai), ele registrará com <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="4e9a5-142">Se <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> é gerado, e se a mensagem destina-se para o <xref:System.Windows.Interop.HwndSource> ou janelas filho, <xref:System.Windows.Interop.HwndSource> chamadas seu <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> sequência de coletor de teclado.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="4e9a5-143">Se o <xref:System.Windows.Interop.HwndSource> não é uma janela de nível superior (tiver um HWND pai), não haverá nenhum tratamento.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="4e9a5-144">Somente a janela de nível superior deve realizar o tratamento e espera-se que haja uma janela de nível superior com suporte para coletor de teclado como parte de qualquer cenário de interoperação.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="4e9a5-145">Se <xref:System.Windows.Interop.HwndHost.WndProc%2A> em um <xref:System.Windows.Interop.HwndSource> é chamado sem um método de coletor de teclado apropriado seja chamado primeiro, seu aplicativo receberá os eventos de teclado de nível superiores, como <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="4e9a5-146">No entanto, nenhum método de coletor de teclado será chamado, o que contorna recursos de modelo de entrada do teclado desejáveis, como suporte para chave de acesso.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="4e9a5-147">Isso pode acontecer porque o loop de mensagem não notificou adequadamente o thread relevante no <xref:System.Windows.Interop.ComponentDispatcher>, ou porque o HWND pai não invocou as respostas de coletor de teclado apropriadas.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="4e9a5-148">Uma mensagem que vai para o coletor de teclado não pode ser enviada ao HWND se você tiver adicionado ganchos para aquela mensagem usando o <xref:System.Windows.Interop.HwndSource.AddHook%2A> método.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="4e9a5-149">A mensagem pode ser sido tratada no nível de bomba de mensagens diretamente e não enviada para a função `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="4e9a5-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4e9a5-150">Consulte também</span><span class="sxs-lookup"><span data-stu-id="4e9a5-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="4e9a5-151">Interoperação do WPF e do Win32</span><span class="sxs-lookup"><span data-stu-id="4e9a5-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="4e9a5-152">Modelo de threading</span><span class="sxs-lookup"><span data-stu-id="4e9a5-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="4e9a5-153">Visão geral da entrada</span><span class="sxs-lookup"><span data-stu-id="4e9a5-153">Input Overview</span></span>](input-overview.md)
