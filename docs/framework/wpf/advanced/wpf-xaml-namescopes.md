---
title: Namescopes XAML WPF
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: c13dba48d21235c57be64d90b6547902e0428a6e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/04/2018
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="31e7b-102">Namescopes XAML WPF</span><span class="sxs-lookup"><span data-stu-id="31e7b-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="31e7b-103">Os namescopes de XAML são um conceito que identifica objetos que são definidos em XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="31e7b-104">Os nomes em um namescope de XAML podem ser usados para estabelecer relações entre os nomes de objetos definidos por XAML e seus equivalentes de instância em uma árvore de objetos.</span><span class="sxs-lookup"><span data-stu-id="31e7b-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="31e7b-105">Normalmente, os namescopes de XAML no código gerenciado do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] são criados ao carregar as raízes da página XAML individual de um aplicativo XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="31e7b-106">XAML namescopes como o objeto de programação são definidos pelo <xref:System.Windows.Markup.INameScope> interface e também são implementados pela classe prática <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="31e7b-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  
  
  
  
<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="31e7b-107">Namescopes em aplicativos de XAML carregados</span><span class="sxs-lookup"><span data-stu-id="31e7b-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="31e7b-108">Em um contexto mais amplo de programação ou de ciência da computação, os conceitos de programação geralmente incluem o princípio de um identificador exclusivo ou de um nome que pode ser usado para acessar um objeto.</span><span class="sxs-lookup"><span data-stu-id="31e7b-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="31e7b-109">Para sistemas que usam identificadores ou nomes, o namescope define os limites dentro dos quais um processo ou uma técnica pesquisará, se um objeto com esse nome for solicitado ou os limites em que a exclusividade de nomes de identificação é imposta.</span><span class="sxs-lookup"><span data-stu-id="31e7b-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="31e7b-110">Esses princípios gerais são verdadeiros para namescopes XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="31e7b-111">No WPF, os namescopes de XAML são criados no elemento raiz de uma página XAML quando a página é carregada.</span><span class="sxs-lookup"><span data-stu-id="31e7b-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="31e7b-112">Cada nome especificado na página XAML, começando na raiz da página, é adicionado a um namescopes de XAML pertinente.</span><span class="sxs-lookup"><span data-stu-id="31e7b-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="31e7b-113">Em WPF XAML, os elementos que são elementos de raiz comuns (como <xref:System.Windows.Controls.Page>, e <xref:System.Windows.Window>) sempre controlam um namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="31e7b-114">Se um elemento como <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement> é o elemento raiz da página na marcação, um [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processador adiciona um <xref:System.Windows.Controls.Page> raiz implicitamente para que o <xref:System.Windows.Controls.Page> possa fornecer um namescope XAML de trabalho.</span><span class="sxs-lookup"><span data-stu-id="31e7b-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31e7b-115">As ações de build do WPF criam um namescope de XAML para uma produção de XAML mesmo se os atributos `Name` ou `x:Name` não estiverem definidos em nenhum elemento na marcação de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="31e7b-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="31e7b-116">Se você tentar usar o mesmo nome duas vezes em qualquer namescope de XAML, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="31e7b-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="31e7b-117">Para o XAML do WPF que tem code-behind e faz parte de um aplicativo compilado, a exceção é gerada em tempo de compilação por ações de compilação do WPF, ao criar a classe gerada para a página durante a compilação de marcação inicial.</span><span class="sxs-lookup"><span data-stu-id="31e7b-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="31e7b-118">Para o XAML que não é compilado por marcação por qualquer ação de build, as exceções relacionadas a problemas de namescopes de XAML podem ser geradas quando o XAML é carregado.</span><span class="sxs-lookup"><span data-stu-id="31e7b-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="31e7b-119">Os designers de XAML também podem prever problemas de namescope de XAML em tempo de design.</span><span class="sxs-lookup"><span data-stu-id="31e7b-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="31e7b-120">Adicionando objetos a árvores de objetos de tempo de execução</span><span class="sxs-lookup"><span data-stu-id="31e7b-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="31e7b-121">O momento em que o XAML é analisado representa o momento em que um namescope de XAML do WPF é criado e definido.</span><span class="sxs-lookup"><span data-stu-id="31e7b-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="31e7b-122">Se você adicionar um objeto a uma árvore de objetos em um ponto no tempo após o momento em que o XAML que produziu a árvore foi analisado, um valor `Name` ou `x:Name` no novo objeto não atualizará automaticamente as informações em um namescope de XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="31e7b-123">Para adicionar um nome de um objeto em um namescope WPF XAML depois XAML é carregado, você deve chamar a implementação apropriada de <xref:System.Windows.Markup.INameScope.RegisterName%2A> no objeto que define o namescope XAML, que normalmente é a raiz da página XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="31e7b-124">Se o nome não estiver registrado, o objeto adicionado não pode ser referenciado pelo nome através de métodos como <xref:System.Windows.FrameworkElement.FindName%2A>, e você não pode usar esse nome para o direcionamento de animação.</span><span class="sxs-lookup"><span data-stu-id="31e7b-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="31e7b-125">O cenário mais comum para desenvolvedores de aplicativos é que você usará <xref:System.Windows.FrameworkElement.RegisterName%2A> para registrar nomes para o namescope XAML na raiz da página atual.</span><span class="sxs-lookup"><span data-stu-id="31e7b-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="31e7b-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> é parte de um cenário importante para storyboards que objetos de destino para animações.</span><span class="sxs-lookup"><span data-stu-id="31e7b-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="31e7b-127">Para obter mais informações, consulte [Visão geral de storyboards](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="31e7b-127">For more information, see [Storyboards Overview](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="31e7b-128">Se você chamar <xref:System.Windows.FrameworkElement.RegisterName%2A> em um objeto que não seja o objeto que define o namescope XAML, o nome ainda está registrado para o namescope XAML que o objeto de chamada é mantido em, como se você tivesse chamado <xref:System.Windows.FrameworkElement.RegisterName%2A> no namescope XAML definindo o objeto.</span><span class="sxs-lookup"><span data-stu-id="31e7b-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="31e7b-129">Namescopes de XAML no código</span><span class="sxs-lookup"><span data-stu-id="31e7b-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="31e7b-130">Você pode criar e usar namescopes de XAML no código.</span><span class="sxs-lookup"><span data-stu-id="31e7b-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="31e7b-131">As APIs e os conceitos envolvidos na criação de namescopes de XAML são os mesmos, mesmo para um uso de código puro, porque o processador de XAML para o [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] usa essas APIs e conceitos quando processa o próprio XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="31e7b-132">Os conceitos e a API existem principalmente para que seja possível encontrar objetos por nome em uma árvore de objeto que é normalmente definida, parcialmente ou totalmente, em XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="31e7b-133">Para aplicativos que são criados por meio de programação e não de XAML carregado, o objeto que define um namescope XAML deve implementar <xref:System.Windows.Markup.INameScope>, ou ser um <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement> a classe derivada, para dar suporte à criação de um namescope XAML em seu instâncias.</span><span class="sxs-lookup"><span data-stu-id="31e7b-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="31e7b-134">Além disso, para qualquer elemento que não é carregado e processado por um processador de XAML, o namescope de XAML do objeto não é criado ou inicializado por padrão.</span><span class="sxs-lookup"><span data-stu-id="31e7b-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="31e7b-135">Você deve criar explicitamente um novo namescope de XAML para qualquer objeto no qual você pretende registrar nomes posteriormente.</span><span class="sxs-lookup"><span data-stu-id="31e7b-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="31e7b-136">Para criar um namescope XAML, chame estático <xref:System.Windows.NameScope.SetNameScope%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e7b-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="31e7b-137">Especifique o objeto que terá a propriedade como o `dependencyObject` parâmetro e um novo <xref:System.Windows.NameScope.%23ctor%2A> chamada de construtor como o `value` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="31e7b-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="31e7b-138">Se o objeto fornecido como `dependencyObject` para <xref:System.Windows.NameScope.SetNameScope%2A> não é um <xref:System.Windows.Markup.INameScope> implementação, <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>, chamar <xref:System.Windows.FrameworkElement.RegisterName%2A> em qualquer filho elementos não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="31e7b-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="31e7b-139">Se você não conseguir criar o novo namescope XAML explicitamente, em seguida, chama a <xref:System.Windows.FrameworkElement.RegisterName%2A> gerará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="31e7b-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="31e7b-140">Para obter um exemplo de uso de APIs de namescope de XAML no código, consulte [Definir um escopo de nome](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="31e7b-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="31e7b-141">Namescopes de XAML em estilos e modelos</span><span class="sxs-lookup"><span data-stu-id="31e7b-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="31e7b-142">Os estilos e modelos no [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fornecem a capacidade para reutilizar e reaplicar conteúdo de uma maneira simples.</span><span class="sxs-lookup"><span data-stu-id="31e7b-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="31e7b-143">No entanto, os estilos e modelos também podem incluir elementos com nomes XAML definidos no nível do modelo.</span><span class="sxs-lookup"><span data-stu-id="31e7b-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="31e7b-144">Esse mesmo modelo pode ser usado várias vezes em uma página.</span><span class="sxs-lookup"><span data-stu-id="31e7b-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="31e7b-145">Por esse motivo, os estilos e modelos definem seus próprios namescopes de XAML, independente do local, em uma árvore de objetos, em que o estilo ou o modelo é aplicado.</span><span class="sxs-lookup"><span data-stu-id="31e7b-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="31e7b-146">Considere o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="31e7b-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="31e7b-147">Aqui, o mesmo modelo é aplicado a dois botões diferentes.</span><span class="sxs-lookup"><span data-stu-id="31e7b-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="31e7b-148">Se os modelos não tivessem namescopes de XAML distintos, o nome `TheBorder` usado no modelo causaria uma colisão de nomes no namescope de XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="31e7b-149">Cada instanciação do modelo tem seu próprio namescope de XAML, portanto, neste exemplo, cada namescope de XAML de modelo instanciado conteria exatamente um nome.</span><span class="sxs-lookup"><span data-stu-id="31e7b-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="31e7b-150">Os estilos também definem seus próprios namescopes de XAML, principalmente para que as partes de storyboards possam ter nomes específicos atribuídos.</span><span class="sxs-lookup"><span data-stu-id="31e7b-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="31e7b-151">Esses nomes habilitam comportamentos específicos de controle que se destinarão a elementos desse nome, mesmo que o modelo tenha sido redefinido como parte da personalização do controle.</span><span class="sxs-lookup"><span data-stu-id="31e7b-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="31e7b-152">Devido aos namescopes de XAML separados, encontrar elementos nomeados em um modelo é mais desafiador que localizar um elemento nomeado que não faz parte do modelo em uma página.</span><span class="sxs-lookup"><span data-stu-id="31e7b-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="31e7b-153">Primeiro, você precisa determinar o modelo aplicado, fazendo com que o <xref:System.Windows.Controls.Control.Template%2A> valor da propriedade do controle onde o modelo é aplicado.</span><span class="sxs-lookup"><span data-stu-id="31e7b-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="31e7b-154">Em seguida, você pode chamar a versão do modelo de <xref:System.Windows.FrameworkTemplate.FindName%2A>, passando o controle onde o modelo foi aplicado como o segundo parâmetro.</span><span class="sxs-lookup"><span data-stu-id="31e7b-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="31e7b-155">Se você for um autor de controle e estiver gerando uma convenção em que um determinado elemento nomeado em um modelo aplicado é o destino para um comportamento que é definido pelo próprio controle, você pode usar o <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> método do seu código de implementação de controle.</span><span class="sxs-lookup"><span data-stu-id="31e7b-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="31e7b-156">O <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> método estiver protegido, somente o autor do controle tem acesso a ele.</span><span class="sxs-lookup"><span data-stu-id="31e7b-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="31e7b-157">Se você estiver trabalhando de dentro de um modelo e da necessidade de obter o XAML namescope onde o modelo é aplicado, obter o valor de <xref:System.Windows.FrameworkElement.TemplatedParent%2A>e, em seguida, chame <xref:System.Windows.FrameworkElement.FindName%2A> existe.</span><span class="sxs-lookup"><span data-stu-id="31e7b-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="31e7b-158">Um exemplo de trabalho dentro do modelo seria se você estivesse escrevendo a implementação do manipulador de eventos em que o evento será acionado de um elemento em um modelo aplicado.</span><span class="sxs-lookup"><span data-stu-id="31e7b-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="31e7b-159">Namescopes de XAML e APIs relacionadas a nomes</span><span class="sxs-lookup"><span data-stu-id="31e7b-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="31e7b-160"><xref:System.Windows.FrameworkElement> tem <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> e <xref:System.Windows.FrameworkElement.UnregisterName%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="31e7b-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="31e7b-161">Se o objeto em que você chama esses métodos é proprietário de um namescope de XAML, os métodos chamam nos métodos do namescope de XAML relevante.</span><span class="sxs-lookup"><span data-stu-id="31e7b-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="31e7b-162">Caso contrário, o elemento pai é verificado para ver se ele é proprietário de um namescope de XAML e esse processo continua recursivamente até que seja encontrado um namescope de XAML (devido ao comportamento do processador de XAML, é garantido que haverá um namescope de XAML na raiz).</span><span class="sxs-lookup"><span data-stu-id="31e7b-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="31e7b-163"><xref:System.Windows.FrameworkContentElement> possui comportamentos análogos, com exceção de que nenhum <xref:System.Windows.FrameworkContentElement> jamais possuirá um namescope XAML.</span><span class="sxs-lookup"><span data-stu-id="31e7b-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="31e7b-164">Os métodos existem no <xref:System.Windows.FrameworkContentElement> para que as chamadas podem ser encaminhadas eventualmente para um <xref:System.Windows.FrameworkElement> elemento pai.</span><span class="sxs-lookup"><span data-stu-id="31e7b-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="31e7b-165"><xref:System.Windows.NameScope.SetNameScope%2A> é usado para mapear um novo namescope XAML para um objeto existente.</span><span class="sxs-lookup"><span data-stu-id="31e7b-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="31e7b-166">Você pode chamar <xref:System.Windows.NameScope.SetNameScope%2A> mais de uma vez para redefinir ou limpar o XAML namescope, mas que não é um uso comum.</span><span class="sxs-lookup"><span data-stu-id="31e7b-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="31e7b-167">Além disso, <xref:System.Windows.NameScope.GetNameScope%2A> geralmente não é usado em código.</span><span class="sxs-lookup"><span data-stu-id="31e7b-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="31e7b-168">Implementações de namescope de XAML</span><span class="sxs-lookup"><span data-stu-id="31e7b-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="31e7b-169">As classes a seguir implementam <xref:System.Windows.Markup.INameScope> diretamente:</span><span class="sxs-lookup"><span data-stu-id="31e7b-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
-   <xref:System.Windows.NameScope>  
  
-   <xref:System.Windows.Style>  
  
-   <xref:System.Windows.ResourceDictionary>  
  
-   <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="31e7b-170"><xref:System.Windows.ResourceDictionary> Não use nomes XAML ou namescopes; Ele usa chaves em vez disso, porque é uma implementação de dicionário.</span><span class="sxs-lookup"><span data-stu-id="31e7b-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="31e7b-171">A única razão <xref:System.Windows.ResourceDictionary> implementa <xref:System.Windows.Markup.INameScope> é para que ele pode lançar exceções para o código do usuário que ajudam a esclarecer a distinção entre um namescope XAML verdadeiro e como um <xref:System.Windows.ResourceDictionary> trata as chaves e também para garantir que namescopes XAML não são aplicadas a um <xref:System.Windows.ResourceDictionary> pelos elementos pai.</span><span class="sxs-lookup"><span data-stu-id="31e7b-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="31e7b-172"><xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style> implementar <xref:System.Windows.Markup.INameScope> através de definições de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="31e7b-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="31e7b-173">As implementações explícitas permitem que esses namescopes XAML se comportam convencionalmente quando eles são acessados por meio de <xref:System.Windows.Markup.INameScope> interface, que é como namescopes XAML são expressos por [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processos internos.</span><span class="sxs-lookup"><span data-stu-id="31e7b-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="31e7b-174">Mas as definições de interface explícita não fazem parte da superfície de API convencional de <xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style>, porque raramente você precisa chamar o <xref:System.Windows.Markup.INameScope> métodos em <xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style> diretamente e, em vez disso, use outra API como <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="31e7b-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="31e7b-175">As seguintes classes de definem seu próprios namescope XAML, usando o <xref:System.Windows.NameScope?displayProperty=nameWithType> classe auxiliar e conectar-se à sua implementação de namescope XAML por meio de <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> propriedade anexada:</span><span class="sxs-lookup"><span data-stu-id="31e7b-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
-   <xref:System.Windows.FrameworkElement>  
  
-   <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="31e7b-176">Consulte também</span><span class="sxs-lookup"><span data-stu-id="31e7b-176">See Also</span></span>  
 [<span data-ttu-id="31e7b-177">Namespaces XAML e mapeamento de namespace para XAML WPF</span><span class="sxs-lookup"><span data-stu-id="31e7b-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)  
 [<span data-ttu-id="31e7b-178">Diretiva x:Name</span><span class="sxs-lookup"><span data-stu-id="31e7b-178">x:Name Directive</span></span>](../../../../docs/framework/xaml-services/x-name-directive.md)
