---
title: Sintaxe XAML em detalhes
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 38c77086075e79c0ec5b4b1564ed753eded23b34
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124488"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="f8831-102">Sintaxe XAML em detalhes</span><span class="sxs-lookup"><span data-stu-id="f8831-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="f8831-103">Este tópico define os termos que são usados para descrever os elementos da sintaxe XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="f8831-104">Esses termos são usados com frequência durante o restante desta documentação, tanto especificamente para a documentação do WPF quanto para as outras estruturas que usam XAML ou os conceitos básicos do XAML habilitados pelo suporte à linguagem XAML no nível de System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="f8831-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="f8831-105">Este tópico trata mais a fundo da terminologia básica introduzida no tópico [Visão geral de XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="f8831-106">Especificação da Linguagem XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="f8831-107">A terminologia de sintaxe XAML definida aqui também é definida ou referenciada dentro da especificação da linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="f8831-108">XAML é uma linguagem baseada em XML e segue ou expande regras estruturais do XML.</span><span class="sxs-lookup"><span data-stu-id="f8831-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="f8831-109">Parte da terminologia é compartilhada com ou se baseia na terminologia usada com frequência ao descrever a linguagem XML ou o modelo de objeto do documento XML.</span><span class="sxs-lookup"><span data-stu-id="f8831-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="f8831-110">Para obter mais informações sobre a especificação da linguagem XAML, baixe [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) do Centro de Download da Microsoft.</span><span class="sxs-lookup"><span data-stu-id="f8831-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="f8831-111">XAML e CLR</span><span class="sxs-lookup"><span data-stu-id="f8831-111">XAML and CLR</span></span>  
 <span data-ttu-id="f8831-112">XAML é uma linguagem de marcação.</span><span class="sxs-lookup"><span data-stu-id="f8831-112">XAML is a markup language.</span></span> <span data-ttu-id="f8831-113">O Common Language Runtime (CLR), como implícito pelo nome, permite a execução em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f8831-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="f8831-114">XAML por si só não é uma das linguagens comuns diretamente consumidas pelo runtime de CLR.</span><span class="sxs-lookup"><span data-stu-id="f8831-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="f8831-115">Em vez disso, você pode pensar em XAML como dando suporte a seu próprio sistema de tipos.</span><span class="sxs-lookup"><span data-stu-id="f8831-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="f8831-116">O sistema de análise de XAML específico que é usado pelo WPF se baseia no CLR e o sistema de tipos do CLR.</span><span class="sxs-lookup"><span data-stu-id="f8831-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="f8831-117">Tipos XAML são mapeados para tipos do CLR para instanciar uma representação de tempo de execução quando o XAML para WPF é analisado.</span><span class="sxs-lookup"><span data-stu-id="f8831-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="f8831-118">Por esse motivo, o restante da discussão de sintaxe neste documento incluirá referências ao sistema de tipos do CLR, embora as discussões de sintaxe equivalentes na especificação da linguagem XAML não o façam.</span><span class="sxs-lookup"><span data-stu-id="f8831-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="f8831-119">(Segundo o nível de especificação da linguagem XAML, tipos de XAML podem ser mapeados para qualquer outro sistema de tipos, o que significa que esse sistema não precisa ser o CLR; no entanto, isso exigiria a criação e uso de um analisador XAML diferente.)</span><span class="sxs-lookup"><span data-stu-id="f8831-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="f8831-120">Membros de tipos e herança de classe</span><span class="sxs-lookup"><span data-stu-id="f8831-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="f8831-121">Propriedades e eventos, tal como aparecem como membros XAML de um tipo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], muitas vezes são herdados de tipos base.</span><span class="sxs-lookup"><span data-stu-id="f8831-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="f8831-122">Considere este exemplo: `<Button Background="Blue" .../>`.</span><span class="sxs-lookup"><span data-stu-id="f8831-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="f8831-123">A propriedade <xref:System.Windows.Controls.Control.Background%2A> não é uma propriedade imediatamente declarada na classe <xref:System.Windows.Controls.Button>, se você examinar a definição de classe, os resultados de reflexo ou a documentação.</span><span class="sxs-lookup"><span data-stu-id="f8831-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="f8831-124">Em vez disso, <xref:System.Windows.Controls.Control.Background%2A> é herdado da classe base <xref:System.Windows.Controls.Control>.</span><span class="sxs-lookup"><span data-stu-id="f8831-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="f8831-125">O comportamento de herança de classe de elementos XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] é uma mudança significativa de uma interpretação de marcação XML imposta pelo esquema.</span><span class="sxs-lookup"><span data-stu-id="f8831-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="f8831-126">A herança de classe pode se tornar complexa, especialmente quando classes base intermediárias são abstratas ou interfaces estão envolvidas.</span><span class="sxs-lookup"><span data-stu-id="f8831-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="f8831-127">Essa é uma razão pela qual o conjunto de elementos XAML e seus atributos permitidos é difícil de representar de forma precisa e completa usando os tipos de esquema que normalmente são usados para a programação XML, como o formato DTD ou XSD.</span><span class="sxs-lookup"><span data-stu-id="f8831-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="f8831-128">Outro motivo é que os recursos de extensibilidade e mapeamento de tipo da própria linguagem XAML impedem a integridade de qualquer representação fixa dos tipos e membros permitidos.</span><span class="sxs-lookup"><span data-stu-id="f8831-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="f8831-129">Sintaxe de elemento de objeto</span><span class="sxs-lookup"><span data-stu-id="f8831-129">Object Element Syntax</span></span>  
 <span data-ttu-id="f8831-130">*Sintaxe de elemento de objeto* é a sintaxe de marcação XAML que instancia uma estrutura ou classe CLR pela declaração de um elemento XML.</span><span class="sxs-lookup"><span data-stu-id="f8831-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="f8831-131">Essa sintaxe é semelhante à sintaxe de outras linguagens de marcação como HTML.</span><span class="sxs-lookup"><span data-stu-id="f8831-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="f8831-132">A sintaxe de elemento de objeto começa com um colchete angular esquerdo (\<), seguido imediatamente do nome do tipo da classe ou estrutura sendo instanciada.</span><span class="sxs-lookup"><span data-stu-id="f8831-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="f8831-133">Zero ou mais espaços podem seguir o nome do tipo e zero ou mais atributos podem também ser declarados no elemento de objeto, com um ou mais espaços separando o par nome="valor" de cada atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="f8831-134">Por fim, uma das seguintes condições deve ser verdadeira:</span><span class="sxs-lookup"><span data-stu-id="f8831-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="f8831-135">O elemento e a marca devem ser fechadas por uma barra (/) seguida imediatamente de um colchete angular direito (>).</span><span class="sxs-lookup"><span data-stu-id="f8831-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="f8831-136">A marca de abertura deve ser concluída por um colchete angular direito (>).</span><span class="sxs-lookup"><span data-stu-id="f8831-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="f8831-137">Outros elementos de objeto, elementos de propriedade ou texto interno podem vir após a marca de abertura.</span><span class="sxs-lookup"><span data-stu-id="f8831-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="f8831-138">Exatamente que conteúdo pode estar contido aqui é normalmente restrito pelo modelo de objeto do elemento.</span><span class="sxs-lookup"><span data-stu-id="f8831-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="f8831-139">A marca de fechamento equivalente para o elemento de objeto também deve existir, com aninhamento e equilíbrio adequados em relação a outros pares de marca de abertura e fechamento.</span><span class="sxs-lookup"><span data-stu-id="f8831-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="f8831-140">XAML, conforme implementado pelo .NET, tem um conjunto de regras que mapeiam elementos de objeto para tipos, atributos para propriedades ou eventos e, por fim namespaces XAML para namespaces CLR mais assembly.</span><span class="sxs-lookup"><span data-stu-id="f8831-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="f8831-141">Para WPF e .NET, os elementos de objeto XAML são mapeados para tipos .NET, conforme definido em assemblies referenciados, e os atributos são mapeados para os membros desses tipos.</span><span class="sxs-lookup"><span data-stu-id="f8831-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="f8831-142">Quando você referencia um tipo CLR em XAML, você tem acesso também aos membros herdados desse tipo.</span><span class="sxs-lookup"><span data-stu-id="f8831-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="f8831-143">Por exemplo, o exemplo a seguir é uma sintaxe de elemento de objeto que instancia uma nova instância da classe <xref:System.Windows.Controls.Button> e também especifica um atributo <xref:System.Windows.FrameworkElement.Name%2A> e um valor para esse atributo:</span><span class="sxs-lookup"><span data-stu-id="f8831-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="f8831-144">O exemplo a seguir é uma sintaxe de elemento de objeto que também inclui a sintaxe de propriedade de conteúdo XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="f8831-145">O texto interno contido em será usado para definir a propriedade de conteúdo <xref:System.Windows.Controls.TextBox> XAML, <xref:System.Windows.Controls.TextBox.Text%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8831-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="f8831-146">Modelos de conteúdo</span><span class="sxs-lookup"><span data-stu-id="f8831-146">Content Models</span></span>  
 <span data-ttu-id="f8831-147">Uma classe pode dar suporte a um uso como um elemento de objeto XAML em termos da sintaxe, mas esse elemento só funcionará corretamente em um aplicativo ou página quando ele for colocado em uma posição esperada de uma árvore de elementos ou modelo de conteúdo geral.</span><span class="sxs-lookup"><span data-stu-id="f8831-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="f8831-148">Por exemplo, um <xref:System.Windows.Controls.MenuItem> normalmente deve ser colocado apenas como um filho de uma classe derivada de <xref:System.Windows.Controls.Primitives.MenuBase>, como <xref:System.Windows.Controls.Menu>.</span><span class="sxs-lookup"><span data-stu-id="f8831-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="f8831-149">Modelos de conteúdo para elementos específicos são documentados como parte dos comentários nas páginas de classe para controles e outras classes [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] que podem ser usadas como elementos XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="f8831-150">Propriedades de elementos de objeto</span><span class="sxs-lookup"><span data-stu-id="f8831-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="f8831-151">Propriedades em XAML são definidas por uma variedade de sintaxes possíveis.</span><span class="sxs-lookup"><span data-stu-id="f8831-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="f8831-152">Qual sintaxe pode ser usada para uma determinada propriedade é algo que varia com base nas características do sistema de tipos subjacente da propriedade que você está configurando.</span><span class="sxs-lookup"><span data-stu-id="f8831-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="f8831-153">configurando valores de propriedades, você adiciona recursos ou características a objetos que existem no grafo de objeto em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f8831-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="f8831-154">O estado inicial do objeto criado a partir de um elemento Object é baseado no comportamento do construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f8831-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="f8831-155">Normalmente, seu aplicativo usará algo diferente de uma instância completamente padronizada de um determinado objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="f8831-156">Sintaxe de atributo (Propriedades)</span><span class="sxs-lookup"><span data-stu-id="f8831-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="f8831-157">Sintaxe de atributo é a sintaxe de marcação XAML que define um valor para uma propriedade, declarando um atributo em um elemento de objeto existente.</span><span class="sxs-lookup"><span data-stu-id="f8831-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="f8831-158">O nome do atributo deve corresponder ao nome do membro CLR da propriedade da classe dá suporte ao elemento de objeto relevante.</span><span class="sxs-lookup"><span data-stu-id="f8831-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="f8831-159">O nome do atributo é seguido por um operador de atribuição (=).</span><span class="sxs-lookup"><span data-stu-id="f8831-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="f8831-160">O valor do atributo deve ser uma cadeia de caracteres entre aspas.</span><span class="sxs-lookup"><span data-stu-id="f8831-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f8831-161">Você pode usar aspas alternadas para colocar aspas literais dentro de um atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="f8831-162">Por exemplo, você pode usar aspas simples como meio para declarar uma cadeia de caracteres que contém um caractere de aspas duplas.</span><span class="sxs-lookup"><span data-stu-id="f8831-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="f8831-163">Independentemente de você usar aspas simples ou duplas, você deve usar um par correspondente para abrir e fechar a cadeia de caracteres de valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="f8831-164">Também há sequências de escape ou outras técnicas disponíveis para contornar as restrições de caracteres impostas por qualquer sintaxe XAML específica.</span><span class="sxs-lookup"><span data-stu-id="f8831-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="f8831-165">Consulte [Entidades de caractere XML e XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="f8831-166">Para ser configurada via sintaxe de atributo, uma propriedade deve ser pública e deve ser gravável.</span><span class="sxs-lookup"><span data-stu-id="f8831-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="f8831-167">O valor da propriedade no sistema de tipos de suporte deve ser um tipo de valor ou deve ser um tipo de referência que possa ser instanciado ou referenciado por um processador XAML ao acessar o tipo de suporte relevante.</span><span class="sxs-lookup"><span data-stu-id="f8831-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="f8831-168">Para eventos de XAML WPF, o evento que é referenciado como o nome do atributo deve ser público e ter um delegado público.</span><span class="sxs-lookup"><span data-stu-id="f8831-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="f8831-169">A propriedade ou evento deve ser um membro da classe ou estrutura que é instanciada pelo elemento de objeto recipiente.</span><span class="sxs-lookup"><span data-stu-id="f8831-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="f8831-170">Processamento de valores de atributo</span><span class="sxs-lookup"><span data-stu-id="f8831-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="f8831-171">O valor de cadeia de caracteres dentro das aspas de abertura e fechamento é processado por um processador XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="f8831-172">Para propriedades, o comportamento padrão de processamento é determinado pelo tipo da propriedade CLR subjacente.</span><span class="sxs-lookup"><span data-stu-id="f8831-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="f8831-173">O valor do atributo é preenchido por um dos seguintes, usando esta ordem de processamento:</span><span class="sxs-lookup"><span data-stu-id="f8831-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="f8831-174">Se o processador XAML encontrar uma chave ou um elemento Object derivado de <xref:System.Windows.Markup.MarkupExtension>, a extensão de marcação referenciada será avaliada primeiro, em vez de processar o valor como uma cadeia de caracteres, e o objeto retornado pela extensão de marcação será usado como o valor.</span><span class="sxs-lookup"><span data-stu-id="f8831-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="f8831-175">Em muitos casos, o objeto retornado por uma extensão de marcação será uma referência a um objeto existente ou então uma expressão que adia a avaliação até o tempo de execução, mas não será um objeto recém-instanciado.</span><span class="sxs-lookup"><span data-stu-id="f8831-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="f8831-176">Se a propriedade for declarada com um <xref:System.ComponentModel.TypeConverter>atribuído, ou o tipo de valor dessa propriedade for declarado com um <xref:System.ComponentModel.TypeConverter>atribuído, o valor da cadeia de caracteres do atributo será enviado para o conversor de tipo como uma entrada de conversão e o conversor retornará uma nova instância de objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="f8831-177">Se não houver <xref:System.ComponentModel.TypeConverter>, uma conversão direta para o tipo de propriedade será tentada.</span><span class="sxs-lookup"><span data-stu-id="f8831-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="f8831-178">Esse nível final é uma conversão direta do valor nativo do analisador entre tipos primitivos de linguagem XAML ou então uma verificação de nomes de constantes nomeadas em uma enumeração (o analisador então acessa os valores correspondentes).</span><span class="sxs-lookup"><span data-stu-id="f8831-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="f8831-179">Valores de atributo de enumeração</span><span class="sxs-lookup"><span data-stu-id="f8831-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="f8831-180">Enumerações em XAML são processadas intrinsecamente pelos analisadores XAML e os membros de uma enumeração devem ser definidos especificando-se o nome da cadeia de caracteres de uma das constantes nomeadas da enumeração.</span><span class="sxs-lookup"><span data-stu-id="f8831-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="f8831-181">Para valores de enumeração não sinalizadores, o comportamento nativo é processar a cadeia de caracteres de um valor de atributo e resolvê-lo para um dos valores de enumeração.</span><span class="sxs-lookup"><span data-stu-id="f8831-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="f8831-182">Você não especifica a enumeração no formato *Enumeração*.*Valor*, do modo como você faz no código.</span><span class="sxs-lookup"><span data-stu-id="f8831-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="f8831-183">Em vez disso, você especifica somente *Valor*, enquanto *Enumeração* é inferido pelo tipo da propriedade você está configurando.</span><span class="sxs-lookup"><span data-stu-id="f8831-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="f8831-184">Se você especificar um atributo no formato *Enumeração*.*Valor*, ele não será resolvido corretamente.</span><span class="sxs-lookup"><span data-stu-id="f8831-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="f8831-185">Para enumerações flagwise, o comportamento é baseado no método <xref:System.Enum.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f8831-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f8831-186">Você pode especificar vários valores para uma enumeração sinalizadora, separando cada valor com uma vírgula.</span><span class="sxs-lookup"><span data-stu-id="f8831-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="f8831-187">No entanto, não é possível combinar valores de enumeração que não reconhecem sinalizadores.</span><span class="sxs-lookup"><span data-stu-id="f8831-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="f8831-188">Por exemplo, você não pode usar a sintaxe de vírgula para tentar criar uma <xref:System.Windows.Trigger> que atue em várias condições de uma enumeração não sinalizada:</span><span class="sxs-lookup"><span data-stu-id="f8831-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="f8831-189">Enumerações sinalizadoras que dão suporte a atributos que são configuráveis no XAML são raras no WPF.</span><span class="sxs-lookup"><span data-stu-id="f8831-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="f8831-190">No entanto, uma enumeração desse tipo é <xref:System.Windows.Media.StyleSimulations>.</span><span class="sxs-lookup"><span data-stu-id="f8831-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="f8831-191">Você poderia, por exemplo, usar a sintaxe de atributo flagwise delimitada por vírgula para modificar o exemplo fornecido nos comentários para a classe de <xref:System.Windows.Documents.Glyphs>; `StyleSimulations = "BoldSimulation"` pode se tornar `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span><span class="sxs-lookup"><span data-stu-id="f8831-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="f8831-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> é outra propriedade em que mais de um valor de enumeração pode ser especificado.</span><span class="sxs-lookup"><span data-stu-id="f8831-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="f8831-193">No entanto, essa propriedade é um caso especial, porque a enumeração de <xref:System.Windows.Input.ModifierKeys> dá suporte a seu próprio conversor de tipo.</span><span class="sxs-lookup"><span data-stu-id="f8831-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="f8831-194">O conversor de tipo para modificadores usa um sinal de adição (+) como um delimitador em vez de uma vírgula (,).</span><span class="sxs-lookup"><span data-stu-id="f8831-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="f8831-195">Essa conversão dá suporte à sintaxe mais tradicional para representar combinações de teclas na programação do Microsoft Windows, como "Ctrl + Alt".</span><span class="sxs-lookup"><span data-stu-id="f8831-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="f8831-196">Propriedades e referências de nome de membro de evento</span><span class="sxs-lookup"><span data-stu-id="f8831-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="f8831-197">Ao especificar um atributo, você pode referenciar qualquer propriedade ou evento existente como um membro do tipo CLR que você instanciou para o elemento de objeto que o contém.</span><span class="sxs-lookup"><span data-stu-id="f8831-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="f8831-198">Ou você pode fazer referência a uma propriedade anexada ou evento anexado, independente do elemento de objeto que o contém.</span><span class="sxs-lookup"><span data-stu-id="f8831-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="f8831-199">(Propriedades anexadas são discutidas em uma seção posterior).</span><span class="sxs-lookup"><span data-stu-id="f8831-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="f8831-200">Você também pode nomear qualquer evento de qualquer objeto que possa ser acessado através do namespace padrão usando um nome parcialmente qualificado *typeName*.*evento*; essa sintaxe dá suporte à anexação de manipuladores para eventos roteados em que o manipulador destina-se a manipular o roteamento de eventos de elementos filho, mas o elemento pai também não tem esse evento em sua tabela de membros.</span><span class="sxs-lookup"><span data-stu-id="f8831-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="f8831-201">Essa sintaxe é semelhante a uma sintaxe de evento anexado, mas o evento aqui não é um evento anexado verdadeiro.</span><span class="sxs-lookup"><span data-stu-id="f8831-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="f8831-202">Em vez disso, você está referenciando um evento com um nome qualificado.</span><span class="sxs-lookup"><span data-stu-id="f8831-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="f8831-203">Para obter mais informações, consulte [Visão geral de eventos roteados](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="f8831-204">Em alguns cenários, os nomes de propriedade às vezes são fornecidos como o valor de um atributo, em vez do nome do atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="f8831-205">Esse nome de propriedade também pode incluir qualificadores como a propriedade especificada no formato *ownerType*.*dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="f8831-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="f8831-206">Esse cenário é comum ao escrever estilos ou modelos em XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="f8831-207">As regras de processamento para nomes de propriedade fornecidos como um valor de atributo são diferentes e são regidas pelo tipo da propriedade sendo definida ou os comportamentos de subsistemas do WPF específicos.</span><span class="sxs-lookup"><span data-stu-id="f8831-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="f8831-208">Para obter detalhes, consulte [Estilo e modelagem](../controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-208">For details, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="f8831-209">Outro uso para nomes de propriedade é quando um valor de atributo descreve uma relação propriedade-propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="f8831-210">Esse recurso é usado para vinculação de dados e para destinos de storyboard e é habilitado pela classe <xref:System.Windows.PropertyPath> e seu conversor de tipo.</span><span class="sxs-lookup"><span data-stu-id="f8831-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="f8831-211">Para obter uma descrição mais completa da semântica de pesquisa, consulte [Sintaxe XAML PropertyPath](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="f8831-212">Sintaxe de elemento de propriedade</span><span class="sxs-lookup"><span data-stu-id="f8831-212">Property Element Syntax</span></span>  
 <span data-ttu-id="f8831-213">*Sintaxe de elemento de propriedade* é uma sintaxe que diverge um pouco das regras de sintaxe XML básicas para elementos.</span><span class="sxs-lookup"><span data-stu-id="f8831-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="f8831-214">Em XML, o valor de um atributo é uma cadeia de caracteres de fato, com a única variação possível sendo qual formato de codificação de cadeia de caracteres está sendo usado.</span><span class="sxs-lookup"><span data-stu-id="f8831-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="f8831-215">Em XAML, você pode atribuir outros elementos de objeto para serem o valor de uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="f8831-216">Essa funcionalidade é habilitada pela sintaxe de elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="f8831-217">Em vez de a propriedade ser especificada como um atributo na marca de elemento, a propriedade é especificada usando uma marca de elemento de abertura na forma *elementTypeName*.*propertyName*, o valor da propriedade é especificado ali e então o elemento de propriedade é fechado.</span><span class="sxs-lookup"><span data-stu-id="f8831-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="f8831-218">Especificamente, a sintaxe começa com um colchete angular esquerdo (\<), seguido imediatamente do nome do tipo da classe ou estrutura dentro da qual a sintaxe de elemento de propriedade está contida.</span><span class="sxs-lookup"><span data-stu-id="f8831-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="f8831-219">Isso é seguido imediatamente por um único ponto (.), depois pelo nome de uma propriedade e, em seguida, por um sinal de maior (>).</span><span class="sxs-lookup"><span data-stu-id="f8831-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="f8831-220">Assim como acontece com a sintaxe de atributo, essa propriedade deve existir nos membros públicos declarados do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="f8831-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="f8831-221">O valor a ser atribuído à propriedade está contido dentro do elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="f8831-222">Normalmente, o valor é fornecido como um ou mais elementos de objeto, porque a especificação de objetos como valores é o cenário que essa sintaxe de elemento de propriedade destina-se a solucionar.</span><span class="sxs-lookup"><span data-stu-id="f8831-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="f8831-223">Por fim, uma marca de fechamento equivalente especificando a mesma combinação *elementTypeName*.*propertyName* deve ser fornecida, com aninhamento e equilíbrio adequados em relação a outras marcas de elemento.</span><span class="sxs-lookup"><span data-stu-id="f8831-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="f8831-224">Por exemplo, a seguir está a sintaxe do elemento Property para a propriedade <xref:System.Windows.FrameworkElement.ContextMenu%2A> de um <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="f8831-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="f8831-225">O valor dentro de um elemento de propriedade também pode ser fornecido como texto interno, em casos em que o tipo de propriedade especificado é um tipo de valor primitivo, como <xref:System.String>ou uma enumeração em que um nome é especificado.</span><span class="sxs-lookup"><span data-stu-id="f8831-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="f8831-226">Esses dois usos são um pouco incomuns, pois cada um desses casos também pode usar uma sintaxe de atributo mais simples.</span><span class="sxs-lookup"><span data-stu-id="f8831-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="f8831-227">Um cenário para preencher um elemento de propriedade com uma cadeia de caracteres é para propriedades que não são a propriedade de conteúdo XAML, mas que ainda são usadas para representação de texto da interface do usuário, e elementos de espaço em branco específicos, como alimentação de linha, devem aparecer nesse texto da interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="f8831-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="f8831-228">A sintaxe do atributo não pode preservar a alimentação de discagem, mas a sintaxe do elemento de propriedade pode, desde que a preservação de espaço em branco significativa esteja ativa (para obter detalhes, consulte [processamento de espaço em branco em XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span><span class="sxs-lookup"><span data-stu-id="f8831-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="f8831-229">Outro cenário é aquele no qual a [Política x:Uid](../../../desktop-wpf/xaml-services/xuid-directive.md) pode ser aplicada ao elemento de propriedade e, portanto, marca o valor dentro dele como um valor que deve ser localizado BAML de saída do no WPF ou por outras técnicas.</span><span class="sxs-lookup"><span data-stu-id="f8831-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="f8831-230">Um elemento de propriedade não é representado na árvore lógica do WPF.</span><span class="sxs-lookup"><span data-stu-id="f8831-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="f8831-231">Um elemento de propriedade é apenas uma sintaxe específica para definir uma propriedade e não é um elemento que disponha do suporte de uma instância ou objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="f8831-232">(Para obter detalhes sobre o conceito de árvore lógica, consulte [Árvores no WPF](trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="f8831-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="f8831-233">Para propriedades onde há suporte para a sintaxe de elemento de propriedade e atributo, as duas sintaxes geralmente têm o mesmo resultado, embora as sutilezas, como tratamento de espaço em branco, possam variar um pouco entre as sintaxes.</span><span class="sxs-lookup"><span data-stu-id="f8831-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="f8831-234">Sintaxe de coleção</span><span class="sxs-lookup"><span data-stu-id="f8831-234">Collection Syntax</span></span>  
 <span data-ttu-id="f8831-235">A especificação da linguagem XAML requer implementações de processador XAML para identificar propriedades nas quais o tipo de valor é uma coleção.</span><span class="sxs-lookup"><span data-stu-id="f8831-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="f8831-236">A implementação geral de processador XAML no .NET é baseada em código gerenciado e no CLR e identifica os tipos de coleção por meio de um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="f8831-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="f8831-237">O tipo implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="f8831-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="f8831-238">O tipo implementa <xref:System.Collections.IDictionary>.</span><span class="sxs-lookup"><span data-stu-id="f8831-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="f8831-239">O tipo deriva de <xref:System.Array> (para obter mais informações sobre matrizes em XAML, consulte [X:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)).</span><span class="sxs-lookup"><span data-stu-id="f8831-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="f8831-240">Se o tipo de uma propriedade é uma coleção, o tipo da coleção inferido não precisa ser especificado na marcação como um elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="f8831-241">Em vez disso, os elementos a se tornarem itens na coleção são especificados como um ou mais elementos filho do elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="f8831-242">Cada um desses itens é avaliado para um objeto durante o carregamento e adicionado à coleção chamando o método `Add` da coleção implícita.</span><span class="sxs-lookup"><span data-stu-id="f8831-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="f8831-243">Por exemplo, a propriedade <xref:System.Windows.Style.Triggers%2A> de <xref:System.Windows.Style> usa o tipo de coleção especializado <xref:System.Windows.TriggerCollection>, que implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="f8831-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="f8831-244">Não é necessário criar uma instância de um elemento de objeto <xref:System.Windows.TriggerCollection> na marcação.</span><span class="sxs-lookup"><span data-stu-id="f8831-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="f8831-245">Em vez disso, você especifica um ou mais itens de <xref:System.Windows.Trigger> como elementos dentro do elemento de propriedade `Style.Triggers`, em que <xref:System.Windows.Trigger> (ou uma classe derivada) é o tipo esperado como o tipo de item para a <xref:System.Windows.TriggerCollection>fortemente tipada e implícita.</span><span class="sxs-lookup"><span data-stu-id="f8831-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="f8831-246">Uma propriedade pode ser tanto um tipo de coleção quanto a propriedade de conteúdo XAML para esse tipo e tipos derivados, o que é abordado na próxima seção deste tópico.</span><span class="sxs-lookup"><span data-stu-id="f8831-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="f8831-247">Um elemento de coleção implícita cria um membro na representação de árvore lógica, mesmo que ele não apareça na marcação como um elemento.</span><span class="sxs-lookup"><span data-stu-id="f8831-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="f8831-248">Geralmente o construtor do tipo pai faz a instanciação para a coleção que é uma de suas propriedades e a coleção inicialmente vazia torna-se parte da árvore de objetos.</span><span class="sxs-lookup"><span data-stu-id="f8831-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f8831-249">Não há suporte para a lista genérica e as interfaces de dicionário (<xref:System.Collections.Generic.IList%601> e <xref:System.Collections.Generic.IDictionary%602>) para detecção de coleção.</span><span class="sxs-lookup"><span data-stu-id="f8831-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="f8831-250">No entanto, você pode usar a classe <xref:System.Collections.Generic.List%601> como uma classe base, porque ela implementa <xref:System.Collections.IList> diretamente ou <xref:System.Collections.Generic.Dictionary%602> como uma classe base, pois implementa <xref:System.Collections.IDictionary> diretamente.</span><span class="sxs-lookup"><span data-stu-id="f8831-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="f8831-251">Nas páginas de referência do .NET para tipos de coleção, essa sintaxe com a omissão deliberada do elemento de objeto para uma coleção é ocasionalmente mencionada nas seções de sintaxe XAML como sintaxe de coleção implícita.</span><span class="sxs-lookup"><span data-stu-id="f8831-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="f8831-252">Com exceção do elemento raiz, cada elemento de objeto em um arquivo XAML que está aninhado como um elemento filho de outro elemento é na realidade um elemento que se enquadra em um ou ambos os casos a seguir: um membro de uma propriedade de coleção implícita do seu elemento pai ou então um elemento que especifica o valor da propriedade de conteúdo XAML para o elemento pai (propriedades de conteúdo XAML serão discutidas em uma seção posterior).</span><span class="sxs-lookup"><span data-stu-id="f8831-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="f8831-253">Em outras palavras, a relação dos elementos pai e filho em uma página de marcação é na verdade um único objeto na raiz, sendo que todo elemento de objeto abaixo da raiz é uma instância única que fornece um valor da propriedade do pai ou então é um dos itens dentro de uma coleção que é também um valor da propriedade de tipo de coleção do pai.</span><span class="sxs-lookup"><span data-stu-id="f8831-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="f8831-254">Esse conceito de raiz única é comum com XML e é frequentemente reforçado no comportamento de APIs que carregam XAML, como <xref:System.Windows.Markup.XamlReader.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8831-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="f8831-255">O exemplo a seguir é uma sintaxe com o elemento Object para uma coleção (<xref:System.Windows.Media.GradientStopCollection>) especificada explicitamente.</span><span class="sxs-lookup"><span data-stu-id="f8831-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="f8831-256">Observe que nem sempre é possível declarar explicitamente a coleção.</span><span class="sxs-lookup"><span data-stu-id="f8831-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="f8831-257">Por exemplo, tentar declarar <xref:System.Windows.TriggerCollection> explicitamente no exemplo de <xref:System.Windows.Style.Triggers%2A> mostrado anteriormente falharia.</span><span class="sxs-lookup"><span data-stu-id="f8831-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="f8831-258">Declarar explicitamente a coleção requer que a classe de coleção tenha suporte para um construtor sem parâmetros e <xref:System.Windows.TriggerCollection> não tenha um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f8831-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="f8831-259">Propriedades de conteúdo XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-259">XAML Content Properties</span></span>  
 <span data-ttu-id="f8831-260">Sintaxe de conteúdo XAML é uma sintaxe que só é habilitada em classes que especificam o <xref:System.Windows.Markup.ContentPropertyAttribute> como parte de sua declaração de classe.</span><span class="sxs-lookup"><span data-stu-id="f8831-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="f8831-261">O <xref:System.Windows.Markup.ContentPropertyAttribute> referencia o nome da propriedade que é a propriedade de conteúdo para esse tipo de elemento (incluindo classes derivadas).</span><span class="sxs-lookup"><span data-stu-id="f8831-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="f8831-262">Quando processados por um processador XAML, quaisquer elementos filho ou texto interno que sejam encontrados entre as marcas de abertura e fechamento do elemento de objeto serão atribuídos como sendo o valor da propriedade de conteúdo XAML para esse objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="f8831-263">Você tem permissão para especificar elementos de propriedade explícitos para a propriedade de conteúdo, mas esse uso geralmente não é mostrado nas seções de sintaxe XAML na referência do .NET.</span><span class="sxs-lookup"><span data-stu-id="f8831-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="f8831-264">A técnica explícita/detalhada tem valor ocasional para fins de esclarecimento de marcação ou como uma questão de estilo de marcação, mas a intenção de uma propriedade de conteúdo costuma ser simplificar a marcação para que os elementos relacionados intuitivamente como pai/filho possam ser diretamente aninhados.</span><span class="sxs-lookup"><span data-stu-id="f8831-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="f8831-265">Marcas de elemento de propriedade para outras propriedades em um elemento não são atribuídas como "conteúdo" segundo uma definição estrita de linguagem XAML; eles são processados anteriormente na ordem de processamento do analisador XAML e não são considerados "conteúdo".</span><span class="sxs-lookup"><span data-stu-id="f8831-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="f8831-266">Valores de propriedade de conteúdo XAML devem ser contíguos</span><span class="sxs-lookup"><span data-stu-id="f8831-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="f8831-267">O valor de uma propriedade de conteúdo XAML deve ser fornecido inteiramente antes ou inteiramente depois de todos os outros elementos de propriedade nesse elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="f8831-268">Isso é verdadeiro se o valor de uma propriedade de conteúdo XAML é especificado como uma cadeia de caracteres ou como um ou mais objetos.</span><span class="sxs-lookup"><span data-stu-id="f8831-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="f8831-269">Por exemplo, a marcação a seguir não analisa:</span><span class="sxs-lookup"><span data-stu-id="f8831-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="f8831-270">Isso é ilegal essencialmente porque se essa sintaxe tivesse sido tornada explícita usando sintaxe de elemento de propriedade para a propriedade de conteúdo, a propriedade de conteúdo seria definida duas vezes:</span><span class="sxs-lookup"><span data-stu-id="f8831-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="f8831-271">Um exemplo similarmente ilegal é no caso de a propriedade de conteúdo ser uma coleção e elementos filho serem intercalados com elementos de propriedade:</span><span class="sxs-lookup"><span data-stu-id="f8831-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="f8831-272">Propriedades de conteúdo e sintaxe de coleção combinados</span><span class="sxs-lookup"><span data-stu-id="f8831-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="f8831-273">Para aceitar mais de um único elemento de objeto como conteúdo, o tipo da propriedade de conteúdo deve ser especificamente um tipo de coleção.</span><span class="sxs-lookup"><span data-stu-id="f8831-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="f8831-274">Semelhante à sintaxe de elemento de propriedade para tipos de coleção, um processador XAML deve identificar tipos que são tipos de coleção.</span><span class="sxs-lookup"><span data-stu-id="f8831-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="f8831-275">Se um elemento tem uma propriedade de conteúdo XAML e o tipo da propriedade de conteúdo XAML é uma coleção, o tipo de coleção sugerido não precisa ser especificado na marcação como um elemento de objeto e a propriedade de conteúdo XAML não precisa ser especificada como um elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="f8831-276">Portanto, o modelo de conteúdo aparente na marcação agora pode ter mais de um elemento filho atribuído como o conteúdo.</span><span class="sxs-lookup"><span data-stu-id="f8831-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="f8831-277">Veja a seguir a sintaxe de conteúdo para uma classe derivada de <xref:System.Windows.Controls.Panel>.</span><span class="sxs-lookup"><span data-stu-id="f8831-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="f8831-278">Todos os <xref:System.Windows.Controls.Panel> classes derivadas estabelecem a propriedade de conteúdo XAML a ser <xref:System.Windows.Controls.Panel.Children%2A>, o que requer um valor do tipo <xref:System.Windows.Controls.UIElementCollection>.</span><span class="sxs-lookup"><span data-stu-id="f8831-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="f8831-279">Observe que nem o elemento Property para <xref:System.Windows.Controls.Panel.Children%2A> nem o elemento para o <xref:System.Windows.Controls.UIElementCollection> é necessário na marcação.</span><span class="sxs-lookup"><span data-stu-id="f8831-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="f8831-280">Esse é um recurso de design do XAML para que elementos recursivamente contidos que definem um [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] sejam representados mais intuitivamente como uma árvore de elementos aninhados com relações pai/filho imediatas, sem objetos de coleção ou marcas entrepostas.</span><span class="sxs-lookup"><span data-stu-id="f8831-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="f8831-281">Na verdade, <xref:System.Windows.Controls.UIElementCollection> não pode ser especificado explicitamente na marcação como um elemento Object, por design.</span><span class="sxs-lookup"><span data-stu-id="f8831-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="f8831-282">Como seu único uso pretendido é como uma coleção implícita, <xref:System.Windows.Controls.UIElementCollection> não expõe um construtor público sem parâmetros e, portanto, não pode ser instanciado como um elemento Object.</span><span class="sxs-lookup"><span data-stu-id="f8831-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="f8831-283">Combinação de elementos de propriedade e elementos de objeto em um objeto com uma propriedade de conteúdo</span><span class="sxs-lookup"><span data-stu-id="f8831-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="f8831-284">A especificação da linguagem XAML declara que um processador XAML pode impor que elementos de objeto que são usados para preencher a propriedade de conteúdo XAML dentro de um elemento de objeto precisem ser contíguos e não possam ser misturados.</span><span class="sxs-lookup"><span data-stu-id="f8831-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="f8831-285">Essa restrição contra misturar elementos de propriedade e conteúdo é imposta pelos processadores XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="f8831-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="f8831-286">Você pode ter um elemento de objeto filho como a primeira marcação imediata dentro de um elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="f8831-287">Em seguida, você pode introduzir elementos de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-287">Then you can introduce property elements.</span></span> <span data-ttu-id="f8831-288">Ou ainda, você pode especificar um ou mais elementos de propriedade, então conteúdo e depois mais elementos de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="f8831-289">Mas uma vez que um elemento de propriedade segue o conteúdo, você não pode introduzir nenhum conteúdo adicional, você só pode adicionar elementos de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="f8831-290">Este requisito de ordem de elementos de propriedade/conteúdo não se aplica ao texto interno usado como conteúdo.</span><span class="sxs-lookup"><span data-stu-id="f8831-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="f8831-291">No entanto, ele ainda é um bom estilo de marcação para manter o texto interno contíguo, pois será difícil detectar um espaço em branco significativo visualmente na marcação se os elementos de propriedade estiverem intercalados com texto interno.</span><span class="sxs-lookup"><span data-stu-id="f8831-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="f8831-292">Namespaces XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-292">XAML Namespaces</span></span>  
 <span data-ttu-id="f8831-293">Nenhum dos exemplos de sintaxe anteriores especificaram um namespace XAML diferente do namespace XAML padrão.</span><span class="sxs-lookup"><span data-stu-id="f8831-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="f8831-294">Em aplicativos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] típicos, o namespace XAML padrão é especificado como sendo o namespace [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="f8831-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="f8831-295">Você pode especificar namespaces XAML diferentes do namespace XAML padrão e ainda assim usar uma sintaxe semelhante.</span><span class="sxs-lookup"><span data-stu-id="f8831-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="f8831-296">Mas nesse casso, em qualquer lugar em que for nomeada uma classe não acessível dentro do namespace XAML padrão, esse nome de classe deverá ser precedido do prefixo do namespace XAML conforme mapeado para o namespace CLR correspondente.</span><span class="sxs-lookup"><span data-stu-id="f8831-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="f8831-297">Por exemplo, `<custom:Example/>` é a sintaxe de elemento de objeto para criar uma instância da classe `Example`, em que o namespace CLR que contém essa classe (e possivelmente as informações de assembly externo que contêm tipos de suporte) foi anteriormente mapeado para o prefixo `custom`.</span><span class="sxs-lookup"><span data-stu-id="f8831-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="f8831-298">Para obter mais informações sobre namespaces XAML, consulte [Namespaces XAML e mapeamento de namespace para XAML WPF](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="f8831-299">Extensões de marcação</span><span class="sxs-lookup"><span data-stu-id="f8831-299">Markup Extensions</span></span>  
 <span data-ttu-id="f8831-300">O XAML define uma entidade de programação de extensão de marcação que habilita um escape da manipulação normal de valores de atributo de cadeia de caracteres ou elementos de objeto pelo processador XAML e adia o processamento para uma classe de suporte.</span><span class="sxs-lookup"><span data-stu-id="f8831-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="f8831-301">O caractere que identifica um extensão de marcação para um processador XAML ao usar a sintaxe de atributo é a chave de abertura ({), seguida por qualquer caractere que não seja uma chave de fechamento (}).</span><span class="sxs-lookup"><span data-stu-id="f8831-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="f8831-302">A primeira cadeia de caracteres após a chave de abertura deve fazer referência à classe que oferece o comportamento de extensão específico, em que a referência pode omitir a subcadeia de caracteres "Extension" se essa subcadeia faz parte do verdadeiro nome de classe.</span><span class="sxs-lookup"><span data-stu-id="f8831-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="f8831-303">Depois disso, pode aparecer um único espaço e, em seguida, cada caractere subsequente é usado como entrada pela implementação de extensão até que a chave de fechamento é encontrada.</span><span class="sxs-lookup"><span data-stu-id="f8831-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="f8831-304">A implementação do XAML do .NET usa a classe abstrata <xref:System.Windows.Markup.MarkupExtension> como a base para todas as extensões de marcação com suporte do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], bem como outras estruturas ou tecnologias.</span><span class="sxs-lookup"><span data-stu-id="f8831-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="f8831-305">As extensões de marcação que [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementa especificamente geralmente se destinam a fornecer um meio para fazer referência a outros objetos existentes ou fazer referências adiadas a objetos que serão avaliados em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f8831-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="f8831-306">Por exemplo, uma vinculação de dados simples do WPF é feita especificando a extensão de marcação `{Binding}` no lugar do valor que uma propriedade específica normalmente aceitaria.</span><span class="sxs-lookup"><span data-stu-id="f8831-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="f8831-307">Muitas das extensões de marcação do WPF permitem uma sintaxe de atributo para propriedades em que a sintaxe de atributo não seria possível de outra maneira.</span><span class="sxs-lookup"><span data-stu-id="f8831-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="f8831-308">Por exemplo, um objeto <xref:System.Windows.Style> é um tipo relativamente complexo que contém uma série aninhada de objetos e propriedades.</span><span class="sxs-lookup"><span data-stu-id="f8831-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="f8831-309">Os estilos no WPF normalmente são definidos como um recurso em um <xref:System.Windows.ResourceDictionary>e, em seguida, referenciados por meio de uma das duas extensões de marcação do WPF que solicitam um recurso.</span><span class="sxs-lookup"><span data-stu-id="f8831-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="f8831-310">A extensão de marcação adia a avaliação do valor da propriedade para uma pesquisa de recurso e habilita o fornecimento do valor da propriedade <xref:System.Windows.FrameworkElement.Style%2A>, usando o tipo <xref:System.Windows.Style>, na sintaxe do atributo, como no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="f8831-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="f8831-311">Aqui, `StaticResource` identifica a classe <xref:System.Windows.StaticResourceExtension> que fornece a implementação da extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="f8831-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="f8831-312">A próxima cadeia de caracteres `MyStyle` é usada como entrada para o construtor de <xref:System.Windows.StaticResourceExtension> não padrão, em que o parâmetro como tirado da cadeia de caracteres de extensão declara a <xref:System.Windows.ResourceKey>solicitada.</span><span class="sxs-lookup"><span data-stu-id="f8831-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="f8831-313">Espera-se que `MyStyle` seja o valor de [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) de um <xref:System.Windows.Style> definido como um recurso.</span><span class="sxs-lookup"><span data-stu-id="f8831-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="f8831-314">O uso da [extensão de marcação StaticResource](staticresource-markup-extension.md) solicita que o recurso seja usado para fornecer o valor da propriedade <xref:System.Windows.Style> por meio da lógica de pesquisa de recursos estáticos no tempo de carregamento.</span><span class="sxs-lookup"><span data-stu-id="f8831-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="f8831-315">Para obter mais informações sobre extensões de marcação, consulte [Extensões de marcação e XAML WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="f8831-316">Para obter uma referência de extensões de marcação e outros recursos de programação em XAML habilitados na implementação geral do XAML no .NET, consulte [Recursos de linguagem (x:) do namespace XAML](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="f8831-317">Para extensões de marcação específicas de WPF, consulte [Extensões XAML WPF](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="f8831-318">Propriedades Anexadas</span><span class="sxs-lookup"><span data-stu-id="f8831-318">Attached Properties</span></span>  
 <span data-ttu-id="f8831-319">Propriedades anexadas são um conceito de programação introduzido no XAML no qual propriedades podem pertencer a um determinado tipo ou ser definidas por ele, mas definidas como atributos ou elementos de propriedade em qualquer elemento.</span><span class="sxs-lookup"><span data-stu-id="f8831-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="f8831-320">O cenário principal para o qual propriedades anexadas se destinam é habilitar elementos filho em uma estrutura de marcação para relatar informações a um elemento pai sem exigir um modelo de objeto amplamente compartilhado entre todos os elementos.</span><span class="sxs-lookup"><span data-stu-id="f8831-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="f8831-321">Por outro lado, propriedades anexadas podem ser usadas pelos elementos pai para relatar informações para elementos filhos.</span><span class="sxs-lookup"><span data-stu-id="f8831-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="f8831-322">Para obter mais informações sobre o objetivo de propriedades anexadas e como criar suas próprias propriedades anexadas, consulte [Visão geral das propriedades anexadas](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="f8831-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="f8831-323">Propriedades anexadas utilizam uma sintaxe que superficialmente se assemelha à sintaxe de elemento de propriedade, em que você também especifica uma combinação *typeName*.*propertyName*.</span><span class="sxs-lookup"><span data-stu-id="f8831-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="f8831-324">Há duas diferenças importantes:</span><span class="sxs-lookup"><span data-stu-id="f8831-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="f8831-325">Você pode usar a combinação *typeName*.*propertyName* mesmo ao definir uma propriedade anexada por meio da sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="f8831-326">Propriedades anexadas são o único caso em que a qualificação do nome da propriedade é um requisito em uma sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="f8831-327">Você também pode usar a sintaxe de elemento de propriedade para propriedades anexadas.</span><span class="sxs-lookup"><span data-stu-id="f8831-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="f8831-328">No entanto, para a sintaxe de elemento de propriedade típica, o *typeName* que você especifica é o elemento de objeto que contém o elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="f8831-329">Se você estiver fazendo referência a uma propriedade anexada, o *typeName* será a classe que define a propriedade anexada, não o elemento de objeto que a contém.</span><span class="sxs-lookup"><span data-stu-id="f8831-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="f8831-330">Eventos Anexados</span><span class="sxs-lookup"><span data-stu-id="f8831-330">Attached Events</span></span>  
 <span data-ttu-id="f8831-331">Eventos anexados são outro conceito de programação introduzido em XAML em que os eventos podem ser definidos por um tipo específico, mas manipuladores podem ser anexados a qualquer elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="f8831-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="f8831-332">Na implementação WOF, geralmente o tipo que define um evento anexado é um tipo estático que define um serviço e, às vezes, esses eventos anexados são expostos por um alias de evento roteado em tipos que expõem o serviço.</span><span class="sxs-lookup"><span data-stu-id="f8831-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="f8831-333">Manipuladores para eventos anexados são especificados pela sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="f8831-334">Assim como ocorre com eventos anexados, a sintaxe de atributo é expandida para eventos anexados para permitir um uso de *typeName*.*eventName*, em que *typeName* é a classe que fornece os acessadores de manipuladores de eventos `Add` e `Remove` para a infraestrutura de evento anexado e *eventName* é o nome do evento.</span><span class="sxs-lookup"><span data-stu-id="f8831-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="f8831-335">Anatomia de um elemento raiz XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="f8831-336">A tabela a seguir mostra um típico elemento raiz XAML, mostrando os atributos específicos de um elemento raiz:</span><span class="sxs-lookup"><span data-stu-id="f8831-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="f8831-337">Elemento de objeto de abertura do elemento raiz</span><span class="sxs-lookup"><span data-stu-id="f8831-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="f8831-338">O namespace XAML padrão ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)])</span><span class="sxs-lookup"><span data-stu-id="f8831-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="f8831-339">Namespace XAML de linguagem XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="f8831-340">A declaração de classe parcial que conecta a marcação a qualquer code-behind definido para a classe parcial</span><span class="sxs-lookup"><span data-stu-id="f8831-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="f8831-341">Final do elemento de objeto para a raiz.</span><span class="sxs-lookup"><span data-stu-id="f8831-341">End of object element for the root.</span></span> <span data-ttu-id="f8831-342">Objeto ainda não foi fechado porque o elemento contém elementos filho</span><span class="sxs-lookup"><span data-stu-id="f8831-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="f8831-343">Usos de XAML opcionais e não recomendados</span><span class="sxs-lookup"><span data-stu-id="f8831-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="f8831-344">As seções a seguir descrevem os usos de XAML que são tecnicamente suportados pelos processadores XAML, mas que produzem detalhes ou outros problemas estéticos que interferem com arquivos XAML restantes que podem ser lidos por pessoas quando você desenvolve aplicativos que contêm fontes XAML.</span><span class="sxs-lookup"><span data-stu-id="f8831-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="f8831-345">Usos de elemento de propriedade opcional</span><span class="sxs-lookup"><span data-stu-id="f8831-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="f8831-346">Usos de elemento de propriedade opcional incluem escrever explicitamente propriedades de conteúdo de elemento que o processador XAML considera implícitas.</span><span class="sxs-lookup"><span data-stu-id="f8831-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="f8831-347">Por exemplo, ao declarar o conteúdo de um <xref:System.Windows.Controls.Menu>, você pode optar por declarar explicitamente a coleção de <xref:System.Windows.Controls.ItemsControl.Items%2A> do <xref:System.Windows.Controls.Menu> como uma marca de elemento de propriedade de `<Menu.Items>` e colocar cada <xref:System.Windows.Controls.MenuItem> em `<Menu.Items>`, em vez de usar o comportamento de processador XAML implícito que todos os elementos filho de um <xref:System.Windows.Controls.Menu> devem ser um <xref:System.Windows.Controls.MenuItem> e são colocados na coleção de <xref:System.Windows.Controls.ItemsControl.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8831-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="f8831-348">Às vezes os usos opcionais podem ajudar a esclarecer visualmente a estrutura do objeto conforme representada na marcação.</span><span class="sxs-lookup"><span data-stu-id="f8831-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="f8831-349">Ou, às vezes, um uso de elemento de propriedade explícito pode evitar uma marcação que é tecnicamente funcional, mas visualmente confusa, assim como extensões de marcação aninhadas dentro de um valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8831-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="f8831-350">Atributos qualificados typeName.memberName completos</span><span class="sxs-lookup"><span data-stu-id="f8831-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="f8831-351">A forma *typeName*.*memberName* para um atributo realmente funciona mais universalmente do que apenas para o caso de evento roteado.</span><span class="sxs-lookup"><span data-stu-id="f8831-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="f8831-352">Em outras situações, no entanto, essa forma é supérflua e você deve evitá-la, mesmo que apenas por motivos de estilo de marcação e legibilidade.</span><span class="sxs-lookup"><span data-stu-id="f8831-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="f8831-353">No exemplo a seguir, cada uma das três referências ao atributo <xref:System.Windows.Controls.Control.Background%2A> são completamente equivalentes:</span><span class="sxs-lookup"><span data-stu-id="f8831-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="f8831-354">`Button.Background` funciona porque a pesquisa qualificada para essa propriedade em <xref:System.Windows.Controls.Button> é bem-sucedida (<xref:System.Windows.Controls.Control.Background%2A> foi herdado do controle) e <xref:System.Windows.Controls.Button> é a classe do elemento Object ou uma classe base.</span><span class="sxs-lookup"><span data-stu-id="f8831-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="f8831-355">`Control.Background` funciona porque a classe <xref:System.Windows.Controls.Control> realmente define <xref:System.Windows.Controls.Control.Background%2A> e <xref:System.Windows.Controls.Control> é uma classe base <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="f8831-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="f8831-356">No entanto, exemplo de formato de *typeName*.*memberName* a seguir não funciona e, portanto, é mostrado comentado:</span><span class="sxs-lookup"><span data-stu-id="f8831-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="f8831-357"><xref:System.Windows.Controls.Label> é outra classe derivada de <xref:System.Windows.Controls.Control>e, se você tiver especificado `Label.Background` em um elemento de objeto <xref:System.Windows.Controls.Label>, esse uso funcionaria.</span><span class="sxs-lookup"><span data-stu-id="f8831-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="f8831-358">No entanto, como <xref:System.Windows.Controls.Label> não é a classe ou classe base de <xref:System.Windows.Controls.Button>, o comportamento do processador XAML especificado é, então, processar `Label.Background` como uma propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="f8831-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="f8831-359">`Label.Background` não é uma propriedade anexada disponível e esse uso falha.</span><span class="sxs-lookup"><span data-stu-id="f8831-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="f8831-360">Elementos de propriedade baseTypeName.memberName</span><span class="sxs-lookup"><span data-stu-id="f8831-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="f8831-361">De maneira semelhante ao modo como o formulário *typeName*.*memberName* funciona para a sintaxe de atributo, uma sintaxe *baseTypeName*.*memberName* funciona para a sintaxe de elemento de propriedade.</span><span class="sxs-lookup"><span data-stu-id="f8831-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="f8831-362">Por exemplo, a sintaxe a seguir funciona:</span><span class="sxs-lookup"><span data-stu-id="f8831-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="f8831-363">Aqui o elemento de propriedade foi fornecido como `Control.Background`, embora o elemento de propriedade estivesse contido em `Button`.</span><span class="sxs-lookup"><span data-stu-id="f8831-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="f8831-364">Mas assim como o formato *typeName*.*memberName* para atributos, *baseTypeName*.*memberName* é um estilo ruim de marcação e você deve evitá-lo.</span><span class="sxs-lookup"><span data-stu-id="f8831-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f8831-365">Consulte também</span><span class="sxs-lookup"><span data-stu-id="f8831-365">See also</span></span>

- [<span data-ttu-id="f8831-366">Visão geral de XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="f8831-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="f8831-367">Recursos da linguagem (x:) do namespace de XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="f8831-368">Extensões XAML WPF</span><span class="sxs-lookup"><span data-stu-id="f8831-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="f8831-369">Visão geral das propriedades da dependência</span><span class="sxs-lookup"><span data-stu-id="f8831-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="f8831-370">TypeConverters e XAML</span><span class="sxs-lookup"><span data-stu-id="f8831-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="f8831-371">XAML e classes personalizadas para WPF</span><span class="sxs-lookup"><span data-stu-id="f8831-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
