---
title: Propriedades de dependência somente leitura
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
ms.openlocfilehash: 8adc90182f0f42f52e6ace4e13c68acb3539516b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187176"
---
# <a name="read-only-dependency-properties"></a><span data-ttu-id="a03ab-102">Propriedades de dependência somente leitura</span><span class="sxs-lookup"><span data-stu-id="a03ab-102">Read-Only Dependency Properties</span></span>
<span data-ttu-id="a03ab-103">Este tópico descreve propriedades de dependência somente leitura, incluindo as propriedades de dependência somente leitura existentes e os cenários e técnicas para criação de uma propriedade de dependência somente leitura personalizada.</span><span class="sxs-lookup"><span data-stu-id="a03ab-103">This topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="a03ab-104">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="a03ab-104">Prerequisites</span></span>  
 <span data-ttu-id="a03ab-105">Este tópico pressupõe que você compreenda os cenários básicos de implementar uma propriedade de dependência e como os metadados são aplicados a uma propriedade de dependência personalizada.</span><span class="sxs-lookup"><span data-stu-id="a03ab-105">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="a03ab-106">Consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md) e [Metadados de propriedade de dependência](dependency-property-metadata.md) para ver o contexto.</span><span class="sxs-lookup"><span data-stu-id="a03ab-106">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="existing"></a>
## <a name="existing-read-only-dependency-properties"></a><span data-ttu-id="a03ab-107">Propriedades de dependência somente leitura existentes</span><span class="sxs-lookup"><span data-stu-id="a03ab-107">Existing Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="a03ab-108">Algumas das propriedades de dependência definidas na estrutura de [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] são somente leitura.</span><span class="sxs-lookup"><span data-stu-id="a03ab-108">Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only.</span></span> <span data-ttu-id="a03ab-109">A razão típica para especificar uma propriedade de dependência somente leitura é que elas são propriedades que devem ser usadas para determinação do estado, mas quando esse estado é influenciado por uma variedade de fatores. No entanto, apenas configurar a propriedade para esse estado não é desejável de uma perspectiva de design de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="a03ab-109">The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective.</span></span> <span data-ttu-id="a03ab-110">Por exemplo, <xref:System.Windows.UIElement.IsMouseOver%2A> a propriedade é realmente apenas um estado de superfície, conforme determinado a partir da entrada do mouse.</span><span class="sxs-lookup"><span data-stu-id="a03ab-110">For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input.</span></span> <span data-ttu-id="a03ab-111">Qualquer tentativa de definir esse valor de maneira programática evitando a entrada de mouse verdadeira seria imprevisível e poderia causar inconsistência.</span><span class="sxs-lookup"><span data-stu-id="a03ab-111">Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.</span></span>  
  
 <span data-ttu-id="a03ab-112">Em virtude de não ser configurável, propriedades de dependência somente leitura não são adequadas para muitos dos cenários para os quais as propriedades de dependência normalmente oferecem uma solução (por exemplo, vinculação de dados, estilizável diretamente para um valor, validação, animação, herança).</span><span class="sxs-lookup"><span data-stu-id="a03ab-112">By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance).</span></span> <span data-ttu-id="a03ab-113">Apesar de não serem configuráveis, as propriedades de dependência somente leitura ainda têm alguns recursos adicionais com suporte de propriedades de dependência no sistema de propriedades.</span><span class="sxs-lookup"><span data-stu-id="a03ab-113">Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system.</span></span> <span data-ttu-id="a03ab-114">A capacidade restante mais importante é que a propriedade de dependência somente leitura ainda pode ser usada como um gatilho de propriedade em um estilo.</span><span class="sxs-lookup"><span data-stu-id="a03ab-114">The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style.</span></span> <span data-ttu-id="a03ab-115">Você não pode habilitar gatilhos com uma propriedade normal de tempo de execução de linguagem comum (CLR); ele precisa ser uma propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="a03ab-115">You can't enable triggers with a normal common language runtime (CLR) property; it needs to be a dependency property.</span></span> <span data-ttu-id="a03ab-116">A propriedade acima <xref:System.Windows.UIElement.IsMouseOver%2A> mencionada é um exemplo perfeito de um cenário onde pode ser bastante útil definir um estilo para um controle, onde alguma propriedade visível, como um fundo, primeiro plano ou propriedades similares de elementos compostos dentro do controle mudará quando o usuário coloca um mouse sobre alguma região definida do seu controle.</span><span class="sxs-lookup"><span data-stu-id="a03ab-116">The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control.</span></span> <span data-ttu-id="a03ab-117">Alterações em uma propriedade de dependência somente leitura também podem ser detectadas e relatadas pelos processos de invalidação inerentes do sistema de propriedades e isso na verdade dá suporte à funcionalidade de gatilho de propriedade internamente.</span><span class="sxs-lookup"><span data-stu-id="a03ab-117">Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.</span></span>  
  
<a name="new"></a>
## <a name="creating-custom-read-only-dependency-properties"></a><span data-ttu-id="a03ab-118">Criando propriedades de dependência somente leitura personalizadas</span><span class="sxs-lookup"><span data-stu-id="a03ab-118">Creating Custom Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="a03ab-119">Certifique-se de ler a seção acima sobre por que as propriedades de dependência somente leitura não funcionarão para muitos cenários típicos de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="a03ab-119">Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios.</span></span> <span data-ttu-id="a03ab-120">Mas, se tiver um cenário apropriado, você poderá querer criar sua própria propriedade de dependência somente leitura.</span><span class="sxs-lookup"><span data-stu-id="a03ab-120">But if you have an appropriate scenario, you may wish to create your own read-only dependency property.</span></span>  
  
 <span data-ttu-id="a03ab-121">Grande parte do processo de criar uma propriedade de dependência somente leitura é igual ao processo descrito nos tópicos [Propriedades de dependência personalizadas](custom-dependency-properties.md) e [Implementar uma propriedade de dependência](how-to-implement-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="a03ab-121">Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](custom-dependency-properties.md) and [Implement a Dependency Property](how-to-implement-a-dependency-property.md) topics.</span></span> <span data-ttu-id="a03ab-122">Há três diferenças importantes:</span><span class="sxs-lookup"><span data-stu-id="a03ab-122">There are three important differences:</span></span>  
  
- <span data-ttu-id="a03ab-123">Ao registrar sua propriedade, <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> ligue para <xref:System.Windows.DependencyProperty.Register%2A> o método em vez do método normal para registro de propriedades.</span><span class="sxs-lookup"><span data-stu-id="a03ab-123">When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration.</span></span>  
  
- <span data-ttu-id="a03ab-124">Ao implementar a propriedade "wrapper" CLR, certifique-se de que o invólucro também não tenha uma implementação definida, para que não haja inconsistência no estado somente leitura para o invólucro público que você expõe.</span><span class="sxs-lookup"><span data-stu-id="a03ab-124">When implementing the CLR "wrapper" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.</span></span>  
  
- <span data-ttu-id="a03ab-125">O objeto devolvido pelo registro somente <xref:System.Windows.DependencyPropertyKey> leitura <xref:System.Windows.DependencyProperty>é em vez de .</span><span class="sxs-lookup"><span data-stu-id="a03ab-125">The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="a03ab-126">Você ainda deve armazenar esse campo como um membro, mas normalmente você não faria dele um membro público do tipo.</span><span class="sxs-lookup"><span data-stu-id="a03ab-126">You should still store this field as a member but typically you would not make it a public member of the type.</span></span>  
  
 <span data-ttu-id="a03ab-127">Qualquer valor ou campo particular que você tiver como suporte para sua propriedade de dependência somente leitura pode ser totalmente gravável usando qualquer lógica que você decidir.</span><span class="sxs-lookup"><span data-stu-id="a03ab-127">Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide.</span></span> <span data-ttu-id="a03ab-128">No entanto, a maneira mais simples de definir a propriedade inicialmente ou como parte da lógica de tempo de execução é usar as APIs do sistema de propriedade, em vez de contornar o sistema de propriedade e definir o campo de apoio privado diretamente.</span><span class="sxs-lookup"><span data-stu-id="a03ab-128">However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's APIs, rather than circumventing the property system and setting the private backing field directly.</span></span> <span data-ttu-id="a03ab-129">Em particular, há uma <xref:System.Windows.DependencyObject.SetValue%2A> assinatura que aceita um <xref:System.Windows.DependencyPropertyKey>parâmetro do tipo .</span><span class="sxs-lookup"><span data-stu-id="a03ab-129">In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>.</span></span> <span data-ttu-id="a03ab-130">Como e onde você define esse valor de forma programática dentro da <xref:System.Windows.DependencyPropertyKey> lógica do aplicativo afetará a forma como você pode desejar definir o acesso no criado quando você registrou a propriedade de dependência pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="a03ab-130">How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property.</span></span> <span data-ttu-id="a03ab-131">Se manipular toda essa lógica dentro da classe, você pode torná-la particular ou, se exigir que ela seja definida de outras partes do assembly, poderá defini-la como interna.</span><span class="sxs-lookup"><span data-stu-id="a03ab-131">If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal.</span></span> <span data-ttu-id="a03ab-132">Uma abordagem <xref:System.Windows.DependencyObject.SetValue%2A> é chamar dentro de um manipulador de eventos de classe de um evento relevante que informa uma instância de classe que o valor da propriedade armazenada precisa ser alterado.</span><span class="sxs-lookup"><span data-stu-id="a03ab-132">One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed.</span></span> <span data-ttu-id="a03ab-133">Outra abordagem é amarrar as propriedades <xref:System.Windows.PropertyChangedCallback> de <xref:System.Windows.CoerceValueCallback> dependência em conjunto usando os retornos emparelhados e de chamada como parte dos metadados dessas propriedades durante o registro.</span><span class="sxs-lookup"><span data-stu-id="a03ab-133">Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration.</span></span>  
  
 <span data-ttu-id="a03ab-134">Como <xref:System.Windows.DependencyPropertyKey> o é privado e não é propagado pelo sistema de propriedade fora do seu código, uma propriedade de dependência somente leitura tem segurança de configuração melhor do que uma propriedade de dependência de leitura e gravação.</span><span class="sxs-lookup"><span data-stu-id="a03ab-134">Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property.</span></span> <span data-ttu-id="a03ab-135">Para uma propriedade de dependência de leitura/gravação, o campo de identificação é implicitamente ou explicitamente público e, portanto, a propriedade é amplamente configurável.</span><span class="sxs-lookup"><span data-stu-id="a03ab-135">For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable.</span></span> <span data-ttu-id="a03ab-136">Para obter informações mais específicas, consulte [Segurança das propriedades de dependência](dependency-property-security.md).</span><span class="sxs-lookup"><span data-stu-id="a03ab-136">For more specifics, see [Dependency Property Security](dependency-property-security.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a03ab-137">Confira também</span><span class="sxs-lookup"><span data-stu-id="a03ab-137">See also</span></span>

- [<span data-ttu-id="a03ab-138">Visão geral das propriedades de dependência</span><span class="sxs-lookup"><span data-stu-id="a03ab-138">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="a03ab-139">Propriedades de dependência personalizada</span><span class="sxs-lookup"><span data-stu-id="a03ab-139">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="a03ab-140">Estilo e modelagem</span><span class="sxs-lookup"><span data-stu-id="a03ab-140">Styling and Templating</span></span>](../../../desktop-wpf/fundamentals/styles-templates-overview.md)
