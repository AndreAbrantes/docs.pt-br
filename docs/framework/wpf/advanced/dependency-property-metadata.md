---
title: Metadados de propriedade da dependência
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186362"
---
# <a name="dependency-property-metadata"></a>Metadados de propriedade da dependência
O [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] sistema de propriedade inclui um sistema de relatórios de metadados que vai além do que pode ser relatado sobre uma propriedade através de reflexão ou características gerais de tempo de execução da linguagem comum (CLR). Os metadados de uma propriedade de dependência também podem ser atribuídos exclusivamente pela classe que define uma propriedade de dependência, podem ser alterados quando a propriedade de dependência é adicionada a uma classe diferente e podem ser substituídos especificamente por todas as classes derivadas que herdam a propriedade de dependência da classe base de definição.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Pré-requisitos  
 Este tópico pressupõe que você entende as propriedades de dependência da perspectiva de um consumidor de propriedades de dependência existentes nas classes [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] e que leu a [Visão geral das propriedades de dependência](dependency-properties-overview.md). Para seguir os exemplos deste tópico, você também deve ter noções básicas de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e saber como escrever aplicativos do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a>Como os metadados de propriedade de dependência são usados  
 Os metadados de propriedade de dependência existem como um objeto que pode ser consultado para examinar as características de uma propriedade de dependência. Esses metadados também são acessados frequentemente pelo sistema de propriedades enquanto ele processa qualquer propriedade de dependência. O objeto de metadados de uma propriedade de dependência pode conter os seguintes tipos de informações:  
  
- Valor padrão para a propriedade de dependência, se nenhum outro valor pode ser determinado para a propriedade de dependência por valor local, estilo, herança, etc. Para uma discussão minuciosa sobre como os valores padrão participam da precedência usada pelo sistema de propriedades ao atribuir valores para propriedades de dependência, consulte [Precedência](dependency-property-value-precedence.md)de Valor de Propriedade de Dependência .  
  
- Referências às implementações de retorno de chamada que afetam os comportamentos de coerção ou de notificação de alteração com base no tipo de proprietário. Observe que esses retornos de chamada são frequentemente definidos com um nível de acesso não público, de modo que obter as referências reais dos metadados geralmente não é possível, a menos que as referências estejam dentro de seu escopo de acesso permitido. Para obter mais informações sobre os retornos de chamada de propriedade de dependência, consulte [Retornos de chamada de propriedade de dependência e validação](dependency-property-callbacks-and-validation.md).  
  
- Se a propriedade de dependência em questão for considerada uma propriedade de nível de estrutura do WPF, os metadados poderão conter características das propriedades de dependência no nível da estrutura do WPF, que relatam informações e estados de serviço como a lógica da herança de propriedade e do mecanismo de layout no nível da estrutura do WPF. Para obter mais informações sobre este aspecto dos metadados de propriedade de dependência, consulte [Metadados de propriedade de estrutura](framework-property-metadata.md).  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a>APIs de metadados  
 O tipo que relata a maioria das informações de <xref:System.Windows.PropertyMetadata> metadados usadas pelo sistema de propriedade é a classe. Instâncias de metadados são especificadas opcionalmente quando as propriedades de dependência são registradas no sistema de propriedades e podem ser especificadas novamente para tipos adicionais que se adicionarem como proprietários ou substituírem os metadados que eles herdam da definição de propriedade de dependência da classe base. (Para os casos em que um registro <xref:System.Windows.PropertyMetadata> de propriedade não especifica metadados, um padrão é criado com valores padrão para essa classe.) Os metadados registrados são <xref:System.Windows.PropertyMetadata> retornados como <xref:System.Windows.DependencyProperty.GetMetadata%2A> quando você chama as várias sobrecargas <xref:System.Windows.DependencyObject> que recebem metadados de uma propriedade de dependência em uma instância.  
  
 A <xref:System.Windows.PropertyMetadata> classe é então derivada para fornecer metadados mais específicos para divisões arquitetônicas, como as classes de nível de estrutura wpf. <xref:System.Windows.UIPropertyMetadata>adiciona relatórios <xref:System.Windows.FrameworkPropertyMetadata> de animação e fornece as propriedades de nível de estrutura do WPF mencionadas na seção anterior. Quando as propriedades de dependência são registradas, <xref:System.Windows.PropertyMetadata> elas podem ser registradas nessas classes derivadas. Quando os metadados são examinados, o tipo base <xref:System.Windows.PropertyMetadata> pode potencialmente ser lançado para as classes derivadas para que você possa examinar as propriedades mais específicas.  
  
> [!NOTE]
> As características da propriedade que <xref:System.Windows.FrameworkPropertyMetadata> podem ser especificadas são às vezes referidas nesta documentação como "bandeiras". Quando você cria novas instâncias de metadados para uso em registros de propriedades de dependência <xref:System.Windows.FrameworkPropertyMetadataOptions> ou substituições de metadados, você especifica esses <xref:System.Windows.FrameworkPropertyMetadata> valores usando a enumeração flagwise e, em seguida, fornece valores possivelmente concatenados da enumeração ao construtor. No entanto, uma vez construídas, <xref:System.Windows.FrameworkPropertyMetadata> essas características de opção são expostas dentro de uma série de propriedades booleanas em vez do valor de enumeração de construção. As propriedades boolianas permitem que você verifique cada condicional, em vez de exigirem que você aplique uma máscara a um valor de enumeração sinalizadora para obter as informações que lhe interessam. O construtor usa o concatenado <xref:System.Windows.FrameworkPropertyMetadataOptions> para manter razoável o comprimento da assinatura do construtor, enquanto os metadados construídos reais expõem as propriedades discretas para tornar a consulta dos metadados mais intuitiva.  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Quando substituir metadados, quando derivar uma classe  
 O sistema de propriedades [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] estabeleceu capacidades para alterar algumas características das propriedades de dependência sem exigir que elas sejam totalmente reimplementadas. Isso é feito construindo uma instância diferente dos metadados de propriedade para a propriedade de dependência conforme ela existe em um tipo específico. Observe que a maioria das propriedades de dependência existentes não são propriedades virtuais, assim, "reimplementá-las" literalmente nas classes herdadas somente pode ser feito sombreando o membro existente.  
  
 Se o cenário que você está tentando habilitar para uma propriedade de dependência em um tipo não pode ser realizado modificando as características das propriedades de dependência existentes, talvez seja necessário criar uma classe derivada e, em seguida, declarar uma propriedade de dependência personalizada na sua classe derivada. Uma propriedade de dependência personalizada se comporta de forma [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] idêntica às propriedades de dependência definidas pelas APIs. Para obter mais detalhes sobre propriedades de dependência personalizadas, consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md).  
  
 Uma característica notável de uma propriedade de dependência que você não pode substituir é seu tipo de valor. Se você estiver herdando uma propriedade de dependência que tenha o comportamento próximo do necessário, mas precisar de um tipo diferente para ela, será necessário implementar uma propriedade de dependência personalizada e talvez vincular as propriedades por meio de conversão de tipos ou outra implementação em sua classe personalizada. Além disso, você não <xref:System.Windows.ValidateValueCallback>pode substituir um existente, porque esse retorno de chamada existe no próprio campo de registro e não dentro de seus metadados.  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a>Cenários de alteração de metadados existentes  
 Se você estiver trabalhando com os metadados de uma propriedade de dependência existente, um cenário comum para alterar os metadados de propriedade de dependência é alterar o valor padrão. Alterar ou adicionar retornos de chamada do sistema de propriedades é um cenário mais avançado. Você talvez queira fazer isso se sua implementação de uma classe derivada tiver diferentes inter-relações entre as propriedades de dependência. Uma das condicionais de ter um modelo de programação que dá suporte a código e uso declarativo é que as propriedades devem permitir serem definidas em qualquer ordem. Assim, todas as propriedades dependentes precisam ser definidas Just-In-Time sem contexto e não podem depender de conhecer uma ordem de configuração como pode ser encontrada em um construtor. Para obter mais informações sobre esse aspecto do sistema de propriedades, consulte [Retornos de chamada de propriedade de dependência e validação](dependency-property-callbacks-and-validation.md). Observe que os retornos de chamada de validação não fazem parte dos metadados; eles fazem parte do identificador de propriedade de dependência. Portanto, os retornos de chamada de validação não podem ser alterados substituindo os metadados.  
  
 Em alguns casos, também convém alterar as opções de metadados de propriedade de nível de estrutura do WPF nas propriedades de dependência existentes. Essas opções comunicam determinadas condicionais conhecidas sobre as propriedades de nível de estrutura do WPF para outros processos de nível de estrutura do WPF, como o sistema de layout.  A definição das opções geralmente é feita apenas ao registrar uma nova propriedade de dependência, mas também é <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> <xref:System.Windows.DependencyProperty.AddOwner%2A> possível alterar os metadados de propriedade de nível de estrutura do WPF como parte de uma ou chamada. Para obter os valores específicos a serem usados e mais informações, consulte [Metadados de propriedade de estrutura](framework-property-metadata.md). Para obter mais informações sobre como essas opções devem ser definidas para uma propriedade de dependência recém-registrada, consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a>Substituindo metadados  
 A finalidade da substituição de metadados é principalmente que você tenha a oportunidade de alterar os vários comportamentos derivados de metadados que são aplicados à propriedade de dependência conforme ela existe no seu tipo. As razões para isso são explicadas em mais detalhes na seção [Metadados](#dp_metadata_contents). Para obter mais informações incluindo alguns exemplos de código, consulte [Substituir metadados para uma propriedade de dependência](how-to-override-metadata-for-a-dependency-property.md).  
  
 Os metadados de propriedade podem ser fornecidos<xref:System.Windows.DependencyProperty.Register%2A>para uma propriedade de dependência durante a chamada de registro ( ). No entanto, em muitos casos, convém fornecer os metadados específicos do tipo da sua classe quando ela herda essa propriedade de dependência. Você pode fazer isso <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chamando o método.  Por exemplo, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as APIs, a <xref:System.Windows.FrameworkElement> classe é o <xref:System.Windows.UIElement.Focusable%2A> tipo que registra primeiro a propriedade de dependência. Mas <xref:System.Windows.Controls.Control> a classe substitui metadados para que a propriedade de dependência `false` forneça `true`seu próprio valor padrão <xref:System.Windows.UIElement.Focusable%2A> inicial, alterando-o de para , e de outra forma reutiliza a implementação original.  
  
 Quando você substitui metadados, as diferentes características dos metadados são mescladas ou substituídas.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>é fundido. Se você adicionar <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>um novo, esse retorno de chamada será armazenado nos metadados. Se você não <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> especificar um na substituição, o valor de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> é promovido como uma referência do ancestral mais próximo que o especificou em metadados.  
  
- O comportamento real <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> do sistema de propriedade é que as implementações para todos os proprietários de metadados na hierarquia são retidas e adicionadas a uma tabela, com ordem de execução pelo sistema de propriedade sendo que os retornos de classe mais derivados são invocados primeiro.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>é substituído. Se você não <xref:System.Windows.PropertyMetadata.DefaultValue%2A> especificar um na substituição, o valor vem do <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ancestral mais próximo que o especificou em metadados.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>implementações são substituídas. Se você adicionar <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>um novo, esse retorno de chamada será armazenado nos metadados. Se você não <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> especificar um na substituição, o valor de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> é promovido como uma referência do ancestral mais próximo que o especificou em metadados.  
  
- O comportamento do sistema <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> de propriedade é que apenas os metadados imediatos são invocados. Não são mantidas referências a outras <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementações na hierarquia.  
  
 Esse comportamento é <xref:System.Windows.PropertyMetadata.Merge%2A>implementado por , e pode ser substituído em classes de metadados derivadas.  
  
#### <a name="overriding-attached-property-metadata"></a>Substituindo metadados de propriedade anexada  
 No [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], as propriedades anexadas são implementadas como propriedades de dependência. Isso significa que elas também têm metadados de propriedade, que as classes individuais podem substituir. As considerações de escopo para [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uma propriedade anexada são geralmente que qualquer <xref:System.Windows.DependencyObject> um pode ter uma propriedade anexada sobre eles. Portanto, qualquer <xref:System.Windows.DependencyObject> classe derivada pode substituir os metadados de qualquer propriedade anexada, pois pode ser definido em uma instância da classe. Você pode substituir os valores padrão, os retornos de chamada ou as propriedades de relatório de características de nível de estrutura do WPF. Se a propriedade anexada for definida em uma instância da sua classe, aquelas características de metadados de propriedade de substituição serão aplicadas. Por exemplo, você pode substituir o valor padrão, de modo que o valor de substituição seja relatado como o valor da propriedade anexada nas instâncias da sua classe, sempre que a propriedade não é definida de outra forma.  
  
> [!NOTE]
> A <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propriedade não é relevante para propriedades anexadas.  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Adicionando uma classe como um proprietário de uma propriedade de dependência existente  
 Uma classe pode se adicionar como proprietária de um imóvel de dependência <xref:System.Windows.DependencyProperty.AddOwner%2A> que já foi registrado, usando o método. Isso permite que a classe use uma propriedade de dependência que foi registrada originalmente para um tipo diferente. A classe adicionada, normalmente, não é uma classe derivada do tipo que registrou primeiro essa propriedade de dependência como proprietária. Na verdade, isso permite que sua classe e suas classes derivadas "herdem" uma implementação de propriedade de dependência sem que a classe proprietária original e a classe adicionada estejam na mesma hierarquia de classe verdadeira. Além disso, a classe adicionada (e também as classes derivadas) pode fornecer metadados específicos para o tipo da propriedade de dependência original.  
  
 Além de adicionar-se como proprietária por meio de métodos de utilitário do sistema de propriedades, a classe adicionada deve declarar membros públicos adicionais em si mesma para tornar a propriedade de dependência um participante completo do sistema de propriedades com exposição em código e marcação. Uma classe que adiciona uma propriedade de dependência existente tem as mesmas responsabilidades que expor o modelo de objeto para essa propriedade de dependência como uma classe que define uma nova propriedade de dependência personalizada. O primeiro membro a ser exposto é um campo identificador de propriedade de dependência. Este campo deve `public static readonly` ser <xref:System.Windows.DependencyProperty>um campo de tipo, que <xref:System.Windows.DependencyProperty.AddOwner%2A> é atribuído ao valor de retorno da chamada. O segundo membro a definir é a propriedade "wrapper" de tempo de execução de idioma comum (CLR). O invólucro torna muito mais conveniente manipular sua propriedade <xref:System.Windows.DependencyObject.SetValue%2A> de dependência em código (você evita chamadas para cada vez, e pode fazer essa chamada apenas uma vez no próprio invólucro). O wrapper é implementado igual seria implementado se você estivesse registrando uma propriedade de dependência personalizada. Para obter mais informações de como implementar uma propriedade de dependência, consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md) e [Adicionar um tipo de proprietário para uma propriedade de dependência](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner e propriedades anexadas  
 Você pode <xref:System.Windows.DependencyProperty.AddOwner%2A> solicitar uma propriedade de dependência definida como uma propriedade anexada pela classe proprietário. Geralmente o motivo para isso é expor a propriedade anexada anteriormente como uma propriedade de dependência não anexada. Em seguida, <xref:System.Windows.DependencyProperty.AddOwner%2A> você exporá `public static readonly` o valor de retorno como um campo para uso como identificador de propriedade de dependência e definirá propriedades apropriadas de "invólucro" para que a propriedade apareça na tabela de membros e suporte um uso de propriedade não anexado em sua classe.  
  
## <a name="see-also"></a>Confira também

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Visão geral das propriedades de dependência](dependency-properties-overview.md)
- [Metadados de propriedade de estrutura](framework-property-metadata.md)
