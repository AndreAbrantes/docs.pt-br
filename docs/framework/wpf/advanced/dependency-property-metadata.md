---
title: Metadados de propriedade da dependência
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186362"
---
# <a name="dependency-property-metadata"></a><span data-ttu-id="11dc0-102">Metadados de propriedade da dependência</span><span class="sxs-lookup"><span data-stu-id="11dc0-102">Dependency Property Metadata</span></span>
<span data-ttu-id="11dc0-103">O [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] sistema de propriedade inclui um sistema de relatórios de metadados que vai além do que pode ser relatado sobre uma propriedade através de reflexão ou características gerais de tempo de execução da linguagem comum (CLR).</span><span class="sxs-lookup"><span data-stu-id="11dc0-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general common language runtime (CLR) characteristics.</span></span> <span data-ttu-id="11dc0-104">Os metadados de uma propriedade de dependência também podem ser atribuídos exclusivamente pela classe que define uma propriedade de dependência, podem ser alterados quando a propriedade de dependência é adicionada a uma classe diferente e podem ser substituídos especificamente por todas as classes derivadas que herdam a propriedade de dependência da classe base de definição.</span><span class="sxs-lookup"><span data-stu-id="11dc0-104">Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="11dc0-105">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="11dc0-105">Prerequisites</span></span>  
 <span data-ttu-id="11dc0-106">Este tópico pressupõe que você entende as propriedades de dependência da perspectiva de um consumidor de propriedades de dependência existentes nas classes [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] e que leu a [Visão geral das propriedades de dependência](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="11dc0-107">Para seguir os exemplos deste tópico, você também deve ter noções básicas de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e saber como escrever aplicativos do [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="11dc0-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a><span data-ttu-id="11dc0-108">Como os metadados de propriedade de dependência são usados</span><span class="sxs-lookup"><span data-stu-id="11dc0-108">How Dependency Property Metadata is Used</span></span>  
 <span data-ttu-id="11dc0-109">Os metadados de propriedade de dependência existem como um objeto que pode ser consultado para examinar as características de uma propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-109">Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</span></span> <span data-ttu-id="11dc0-110">Esses metadados também são acessados frequentemente pelo sistema de propriedades enquanto ele processa qualquer propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-110">This metadata is also accessed frequently by the property system as it processes any given dependency property.</span></span> <span data-ttu-id="11dc0-111">O objeto de metadados de uma propriedade de dependência pode conter os seguintes tipos de informações:</span><span class="sxs-lookup"><span data-stu-id="11dc0-111">The metadata object for a dependency property can contain the following types of information:</span></span>  
  
- <span data-ttu-id="11dc0-112">Valor padrão para a propriedade de dependência, se nenhum outro valor pode ser determinado para a propriedade de dependência por valor local, estilo, herança, etc. Para uma discussão minuciosa sobre como os valores padrão participam da precedência usada pelo sistema de propriedades ao atribuir valores para propriedades de dependência, consulte [Precedência](dependency-property-value-precedence.md)de Valor de Propriedade de Dependência .</span><span class="sxs-lookup"><span data-stu-id="11dc0-112">Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see [Dependency Property Value Precedence](dependency-property-value-precedence.md).</span></span>  
  
- <span data-ttu-id="11dc0-113">Referências às implementações de retorno de chamada que afetam os comportamentos de coerção ou de notificação de alteração com base no tipo de proprietário.</span><span class="sxs-lookup"><span data-stu-id="11dc0-113">References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</span></span> <span data-ttu-id="11dc0-114">Observe que esses retornos de chamada são frequentemente definidos com um nível de acesso não público, de modo que obter as referências reais dos metadados geralmente não é possível, a menos que as referências estejam dentro de seu escopo de acesso permitido.</span><span class="sxs-lookup"><span data-stu-id="11dc0-114">Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</span></span> <span data-ttu-id="11dc0-115">Para obter mais informações sobre os retornos de chamada de propriedade de dependência, consulte [Retornos de chamada de propriedade de dependência e validação](dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-115">For more information on dependency property callbacks, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>  
  
- <span data-ttu-id="11dc0-116">Se a propriedade de dependência em questão for considerada uma propriedade de nível de estrutura do WPF, os metadados poderão conter características das propriedades de dependência no nível da estrutura do WPF, que relatam informações e estados de serviço como a lógica da herança de propriedade e do mecanismo de layout no nível da estrutura do WPF.</span><span class="sxs-lookup"><span data-stu-id="11dc0-116">If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</span></span> <span data-ttu-id="11dc0-117">Para obter mais informações sobre este aspecto dos metadados de propriedade de dependência, consulte [Metadados de propriedade de estrutura](framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-117">For more information on this aspect of dependency property metadata, see [Framework Property Metadata](framework-property-metadata.md).</span></span>  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a><span data-ttu-id="11dc0-118">APIs de metadados</span><span class="sxs-lookup"><span data-stu-id="11dc0-118">Metadata APIs</span></span>  
 <span data-ttu-id="11dc0-119">O tipo que relata a maioria das informações de <xref:System.Windows.PropertyMetadata> metadados usadas pelo sistema de propriedade é a classe.</span><span class="sxs-lookup"><span data-stu-id="11dc0-119">The type that reports most of the metadata information used by the property system is the <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="11dc0-120">Instâncias de metadados são especificadas opcionalmente quando as propriedades de dependência são registradas no sistema de propriedades e podem ser especificadas novamente para tipos adicionais que se adicionarem como proprietários ou substituírem os metadados que eles herdam da definição de propriedade de dependência da classe base.</span><span class="sxs-lookup"><span data-stu-id="11dc0-120">Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</span></span> <span data-ttu-id="11dc0-121">(Para os casos em que um registro <xref:System.Windows.PropertyMetadata> de propriedade não especifica metadados, um padrão é criado com valores padrão para essa classe.) Os metadados registrados são <xref:System.Windows.PropertyMetadata> retornados como <xref:System.Windows.DependencyProperty.GetMetadata%2A> quando você chama as várias sobrecargas <xref:System.Windows.DependencyObject> que recebem metadados de uma propriedade de dependência em uma instância.</span><span class="sxs-lookup"><span data-stu-id="11dc0-121">(For cases where a property registration does not specify metadata, a default <xref:System.Windows.PropertyMetadata> is created with default values for that class.)The registered metadata is returned as <xref:System.Windows.PropertyMetadata> when you call the various <xref:System.Windows.DependencyProperty.GetMetadata%2A> overloads that get metadata from a dependency property on a <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 <span data-ttu-id="11dc0-122">A <xref:System.Windows.PropertyMetadata> classe é então derivada para fornecer metadados mais específicos para divisões arquitetônicas, como as classes de nível de estrutura wpf.</span><span class="sxs-lookup"><span data-stu-id="11dc0-122">The <xref:System.Windows.PropertyMetadata> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</span></span> <span data-ttu-id="11dc0-123"><xref:System.Windows.UIPropertyMetadata>adiciona relatórios <xref:System.Windows.FrameworkPropertyMetadata> de animação e fornece as propriedades de nível de estrutura do WPF mencionadas na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="11dc0-123"><xref:System.Windows.UIPropertyMetadata> adds animation reporting, and <xref:System.Windows.FrameworkPropertyMetadata> provides the WPF framework-level properties mentioned in the previous section.</span></span> <span data-ttu-id="11dc0-124">Quando as propriedades de dependência são registradas, <xref:System.Windows.PropertyMetadata> elas podem ser registradas nessas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-124">When dependency properties are registered, they can be registered with these <xref:System.Windows.PropertyMetadata> derived classes.</span></span> <span data-ttu-id="11dc0-125">Quando os metadados são examinados, o tipo base <xref:System.Windows.PropertyMetadata> pode potencialmente ser lançado para as classes derivadas para que você possa examinar as propriedades mais específicas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-125">When the metadata is examined, the base <xref:System.Windows.PropertyMetadata> type can potentially be cast to the derived classes so that you can examine the more specific properties.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="11dc0-126">As características da propriedade que <xref:System.Windows.FrameworkPropertyMetadata> podem ser especificadas são às vezes referidas nesta documentação como "bandeiras".</span><span class="sxs-lookup"><span data-stu-id="11dc0-126">The property characteristics that can be specified in <xref:System.Windows.FrameworkPropertyMetadata> are sometimes referred to in this documentation as "flags".</span></span> <span data-ttu-id="11dc0-127">Quando você cria novas instâncias de metadados para uso em registros de propriedades de dependência <xref:System.Windows.FrameworkPropertyMetadataOptions> ou substituições de metadados, você especifica esses <xref:System.Windows.FrameworkPropertyMetadata> valores usando a enumeração flagwise e, em seguida, fornece valores possivelmente concatenados da enumeração ao construtor.</span><span class="sxs-lookup"><span data-stu-id="11dc0-127">When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> and then you supply possibly concatenated values of the enumeration to the <xref:System.Windows.FrameworkPropertyMetadata> constructor.</span></span> <span data-ttu-id="11dc0-128">No entanto, uma vez construídas, <xref:System.Windows.FrameworkPropertyMetadata> essas características de opção são expostas dentro de uma série de propriedades booleanas em vez do valor de enumeração de construção.</span><span class="sxs-lookup"><span data-stu-id="11dc0-128">However, once constructed, these option characteristics are exposed within a <xref:System.Windows.FrameworkPropertyMetadata> as a series of Boolean properties rather than the constructing enumeration value.</span></span> <span data-ttu-id="11dc0-129">As propriedades boolianas permitem que você verifique cada condicional, em vez de exigirem que você aplique uma máscara a um valor de enumeração sinalizadora para obter as informações que lhe interessam.</span><span class="sxs-lookup"><span data-stu-id="11dc0-129">The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</span></span> <span data-ttu-id="11dc0-130">O construtor usa o concatenado <xref:System.Windows.FrameworkPropertyMetadataOptions> para manter razoável o comprimento da assinatura do construtor, enquanto os metadados construídos reais expõem as propriedades discretas para tornar a consulta dos metadados mais intuitiva.</span><span class="sxs-lookup"><span data-stu-id="11dc0-130">The constructor uses the concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</span></span>  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a><span data-ttu-id="11dc0-131">Quando substituir metadados, quando derivar uma classe</span><span class="sxs-lookup"><span data-stu-id="11dc0-131">When to Override Metadata, When to Derive a Class</span></span>  
 <span data-ttu-id="11dc0-132">O sistema de propriedades [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] estabeleceu capacidades para alterar algumas características das propriedades de dependência sem exigir que elas sejam totalmente reimplementadas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-132">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</span></span> <span data-ttu-id="11dc0-133">Isso é feito construindo uma instância diferente dos metadados de propriedade para a propriedade de dependência conforme ela existe em um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="11dc0-133">This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</span></span> <span data-ttu-id="11dc0-134">Observe que a maioria das propriedades de dependência existentes não são propriedades virtuais, assim, "reimplementá-las" literalmente nas classes herdadas somente pode ser feito sombreando o membro existente.</span><span class="sxs-lookup"><span data-stu-id="11dc0-134">Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</span></span>  
  
 <span data-ttu-id="11dc0-135">Se o cenário que você está tentando habilitar para uma propriedade de dependência em um tipo não pode ser realizado modificando as características das propriedades de dependência existentes, talvez seja necessário criar uma classe derivada e, em seguida, declarar uma propriedade de dependência personalizada na sua classe derivada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-135">If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</span></span> <span data-ttu-id="11dc0-136">Uma propriedade de dependência personalizada se comporta de forma [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] idêntica às propriedades de dependência definidas pelas APIs.</span><span class="sxs-lookup"><span data-stu-id="11dc0-136">A custom dependency property behaves identically to dependency properties defined by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs.</span></span> <span data-ttu-id="11dc0-137">Para obter mais detalhes sobre propriedades de dependência personalizadas, consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-137">For more details about custom dependency properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="11dc0-138">Uma característica notável de uma propriedade de dependência que você não pode substituir é seu tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="11dc0-138">One notable characteristic of a dependency property that you cannot override is its value type.</span></span> <span data-ttu-id="11dc0-139">Se você estiver herdando uma propriedade de dependência que tenha o comportamento próximo do necessário, mas precisar de um tipo diferente para ela, será necessário implementar uma propriedade de dependência personalizada e talvez vincular as propriedades por meio de conversão de tipos ou outra implementação em sua classe personalizada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-139">If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</span></span> <span data-ttu-id="11dc0-140">Além disso, você não <xref:System.Windows.ValidateValueCallback>pode substituir um existente, porque esse retorno de chamada existe no próprio campo de registro e não dentro de seus metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-140">Also, you cannot replace an existing <xref:System.Windows.ValidateValueCallback>, because this callback exists in the registration field itself and not within its metadata.</span></span>  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a><span data-ttu-id="11dc0-141">Cenários de alteração de metadados existentes</span><span class="sxs-lookup"><span data-stu-id="11dc0-141">Scenarios for Changing Existing Metadata</span></span>  
 <span data-ttu-id="11dc0-142">Se você estiver trabalhando com os metadados de uma propriedade de dependência existente, um cenário comum para alterar os metadados de propriedade de dependência é alterar o valor padrão.</span><span class="sxs-lookup"><span data-stu-id="11dc0-142">If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</span></span> <span data-ttu-id="11dc0-143">Alterar ou adicionar retornos de chamada do sistema de propriedades é um cenário mais avançado.</span><span class="sxs-lookup"><span data-stu-id="11dc0-143">Changing or adding property system callbacks is a more advanced scenario.</span></span> <span data-ttu-id="11dc0-144">Você talvez queira fazer isso se sua implementação de uma classe derivada tiver diferentes inter-relações entre as propriedades de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-144">You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</span></span> <span data-ttu-id="11dc0-145">Uma das condicionais de ter um modelo de programação que dá suporte a código e uso declarativo é que as propriedades devem permitir serem definidas em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="11dc0-145">One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</span></span> <span data-ttu-id="11dc0-146">Assim, todas as propriedades dependentes precisam ser definidas Just-In-Time sem contexto e não podem depender de conhecer uma ordem de configuração como pode ser encontrada em um construtor.</span><span class="sxs-lookup"><span data-stu-id="11dc0-146">Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</span></span> <span data-ttu-id="11dc0-147">Para obter mais informações sobre esse aspecto do sistema de propriedades, consulte [Retornos de chamada de propriedade de dependência e validação](dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-147">For more information on this aspect of the property system, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span> <span data-ttu-id="11dc0-148">Observe que os retornos de chamada de validação não fazem parte dos metadados; eles fazem parte do identificador de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-148">Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</span></span> <span data-ttu-id="11dc0-149">Portanto, os retornos de chamada de validação não podem ser alterados substituindo os metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-149">Therefore, validation callbacks cannot be changed by overriding the metadata.</span></span>  
  
 <span data-ttu-id="11dc0-150">Em alguns casos, também convém alterar as opções de metadados de propriedade de nível de estrutura do WPF nas propriedades de dependência existentes.</span><span class="sxs-lookup"><span data-stu-id="11dc0-150">In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</span></span> <span data-ttu-id="11dc0-151">Essas opções comunicam determinadas condicionais conhecidas sobre as propriedades de nível de estrutura do WPF para outros processos de nível de estrutura do WPF, como o sistema de layout.</span><span class="sxs-lookup"><span data-stu-id="11dc0-151">These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</span></span>  <span data-ttu-id="11dc0-152">A definição das opções geralmente é feita apenas ao registrar uma nova propriedade de dependência, mas também é <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> <xref:System.Windows.DependencyProperty.AddOwner%2A> possível alterar os metadados de propriedade de nível de estrutura do WPF como parte de uma ou chamada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-152">Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> or <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="11dc0-153">Para obter os valores específicos a serem usados e mais informações, consulte [Metadados de propriedade de estrutura](framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-153">For the specific values to use and more information, see [Framework Property Metadata](framework-property-metadata.md).</span></span> <span data-ttu-id="11dc0-154">Para obter mais informações sobre como essas opções devem ser definidas para uma propriedade de dependência recém-registrada, consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-154">For more information that is pertinent to how these options should be set for a newly registered dependency property, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a><span data-ttu-id="11dc0-155">Substituindo metadados</span><span class="sxs-lookup"><span data-stu-id="11dc0-155">Overriding Metadata</span></span>  
 <span data-ttu-id="11dc0-156">A finalidade da substituição de metadados é principalmente que você tenha a oportunidade de alterar os vários comportamentos derivados de metadados que são aplicados à propriedade de dependência conforme ela existe no seu tipo.</span><span class="sxs-lookup"><span data-stu-id="11dc0-156">The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</span></span> <span data-ttu-id="11dc0-157">As razões para isso são explicadas em mais detalhes na seção [Metadados](#dp_metadata_contents).</span><span class="sxs-lookup"><span data-stu-id="11dc0-157">The reasons for this are explained in more detail in the [Metadata](#dp_metadata_contents) section.</span></span> <span data-ttu-id="11dc0-158">Para obter mais informações incluindo alguns exemplos de código, consulte [Substituir metadados para uma propriedade de dependência](how-to-override-metadata-for-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-158">For more information including some code examples, see [Override Metadata for a Dependency Property](how-to-override-metadata-for-a-dependency-property.md).</span></span>  
  
 <span data-ttu-id="11dc0-159">Os metadados de propriedade podem ser fornecidos<xref:System.Windows.DependencyProperty.Register%2A>para uma propriedade de dependência durante a chamada de registro ( ).</span><span class="sxs-lookup"><span data-stu-id="11dc0-159">Property metadata can be supplied for a dependency property during the registration call (<xref:System.Windows.DependencyProperty.Register%2A>).</span></span> <span data-ttu-id="11dc0-160">No entanto, em muitos casos, convém fornecer os metadados específicos do tipo da sua classe quando ela herda essa propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-160">However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</span></span> <span data-ttu-id="11dc0-161">Você pode fazer isso <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chamando o método.</span><span class="sxs-lookup"><span data-stu-id="11dc0-161">You can do this by calling the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method.</span></span>  <span data-ttu-id="11dc0-162">Por exemplo, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as APIs, a <xref:System.Windows.FrameworkElement> classe é o <xref:System.Windows.UIElement.Focusable%2A> tipo que registra primeiro a propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-162">For an example from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs, the <xref:System.Windows.FrameworkElement> class is the type that first registers the <xref:System.Windows.UIElement.Focusable%2A> dependency property.</span></span> <span data-ttu-id="11dc0-163">Mas <xref:System.Windows.Controls.Control> a classe substitui metadados para que a propriedade de dependência `false` forneça `true`seu próprio valor padrão <xref:System.Windows.UIElement.Focusable%2A> inicial, alterando-o de para , e de outra forma reutiliza a implementação original.</span><span class="sxs-lookup"><span data-stu-id="11dc0-163">But the <xref:System.Windows.Controls.Control> class overrides metadata for the dependency property to provide its own initial default value, changing it from `false` to `true`, and otherwise re-uses the original <xref:System.Windows.UIElement.Focusable%2A> implementation.</span></span>  
  
 <span data-ttu-id="11dc0-164">Quando você substitui metadados, as diferentes características dos metadados são mescladas ou substituídas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-164">When you override metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="11dc0-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>é fundido.</span><span class="sxs-lookup"><span data-stu-id="11dc0-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="11dc0-166">Se você adicionar <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>um novo, esse retorno de chamada será armazenado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-166">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="11dc0-167">Se você não <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> especificar um na substituição, o valor de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> é promovido como uma referência do ancestral mais próximo que o especificou em metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-167">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="11dc0-168">O comportamento real <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> do sistema de propriedade é que as implementações para todos os proprietários de metadados na hierarquia são retidas e adicionadas a uma tabela, com ordem de execução pelo sistema de propriedade sendo que os retornos de classe mais derivados são invocados primeiro.</span><span class="sxs-lookup"><span data-stu-id="11dc0-168">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</span></span>  
  
- <span data-ttu-id="11dc0-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A>é substituído.</span><span class="sxs-lookup"><span data-stu-id="11dc0-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="11dc0-170">Se você não <xref:System.Windows.PropertyMetadata.DefaultValue%2A> especificar um na substituição, o valor vem do <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ancestral mais próximo que o especificou em metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-170">If you do not specify a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="11dc0-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>implementações são substituídas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="11dc0-172">Se você adicionar <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>um novo, esse retorno de chamada será armazenado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-172">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="11dc0-173">Se você não <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> especificar um na substituição, o valor de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> é promovido como uma referência do ancestral mais próximo que o especificou em metadados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-173">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="11dc0-174">O comportamento do sistema <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> de propriedade é que apenas os metadados imediatos são invocados.</span><span class="sxs-lookup"><span data-stu-id="11dc0-174">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="11dc0-175">Não são mantidas referências a outras <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementações na hierarquia.</span><span class="sxs-lookup"><span data-stu-id="11dc0-175">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
 <span data-ttu-id="11dc0-176">Esse comportamento é <xref:System.Windows.PropertyMetadata.Merge%2A>implementado por , e pode ser substituído em classes de metadados derivadas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-176">This behavior is implemented by <xref:System.Windows.PropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
#### <a name="overriding-attached-property-metadata"></a><span data-ttu-id="11dc0-177">Substituindo metadados de propriedade anexada</span><span class="sxs-lookup"><span data-stu-id="11dc0-177">Overriding Attached Property Metadata</span></span>  
 <span data-ttu-id="11dc0-178">No [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], as propriedades anexadas são implementadas como propriedades de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-178">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached properties are implemented as dependency properties.</span></span> <span data-ttu-id="11dc0-179">Isso significa que elas também têm metadados de propriedade, que as classes individuais podem substituir.</span><span class="sxs-lookup"><span data-stu-id="11dc0-179">This means that they also have property metadata, which individual classes can override.</span></span> <span data-ttu-id="11dc0-180">As considerações de escopo para [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uma propriedade anexada são geralmente que qualquer <xref:System.Windows.DependencyObject> um pode ter uma propriedade anexada sobre eles.</span><span class="sxs-lookup"><span data-stu-id="11dc0-180">The scoping considerations for an attached property in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are generally that any <xref:System.Windows.DependencyObject> can have an attached property set on them.</span></span> <span data-ttu-id="11dc0-181">Portanto, qualquer <xref:System.Windows.DependencyObject> classe derivada pode substituir os metadados de qualquer propriedade anexada, pois pode ser definido em uma instância da classe.</span><span class="sxs-lookup"><span data-stu-id="11dc0-181">Therefore, any <xref:System.Windows.DependencyObject> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</span></span> <span data-ttu-id="11dc0-182">Você pode substituir os valores padrão, os retornos de chamada ou as propriedades de relatório de características de nível de estrutura do WPF.</span><span class="sxs-lookup"><span data-stu-id="11dc0-182">You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</span></span> <span data-ttu-id="11dc0-183">Se a propriedade anexada for definida em uma instância da sua classe, aquelas características de metadados de propriedade de substituição serão aplicadas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-183">If the attached property is set on an instance of your class, those override property metadata characteristics apply.</span></span> <span data-ttu-id="11dc0-184">Por exemplo, você pode substituir o valor padrão, de modo que o valor de substituição seja relatado como o valor da propriedade anexada nas instâncias da sua classe, sempre que a propriedade não é definida de outra forma.</span><span class="sxs-lookup"><span data-stu-id="11dc0-184">For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="11dc0-185">A <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propriedade não é relevante para propriedades anexadas.</span><span class="sxs-lookup"><span data-stu-id="11dc0-185">The <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property is not relevant for attached properties.</span></span>  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a><span data-ttu-id="11dc0-186">Adicionando uma classe como um proprietário de uma propriedade de dependência existente</span><span class="sxs-lookup"><span data-stu-id="11dc0-186">Adding a Class as an Owner of an Existing Dependency Property</span></span>  
 <span data-ttu-id="11dc0-187">Uma classe pode se adicionar como proprietária de um imóvel de dependência <xref:System.Windows.DependencyProperty.AddOwner%2A> que já foi registrado, usando o método.</span><span class="sxs-lookup"><span data-stu-id="11dc0-187">A class can add itself as an owner of a dependency property that has already been registered, by using the <xref:System.Windows.DependencyProperty.AddOwner%2A> method.</span></span> <span data-ttu-id="11dc0-188">Isso permite que a classe use uma propriedade de dependência que foi registrada originalmente para um tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="11dc0-188">This enables the class to use a dependency property that was originally registered for a different type.</span></span> <span data-ttu-id="11dc0-189">A classe adicionada, normalmente, não é uma classe derivada do tipo que registrou primeiro essa propriedade de dependência como proprietária.</span><span class="sxs-lookup"><span data-stu-id="11dc0-189">The adding class is typically not a derived class of the type that first registered that dependency property as owner.</span></span> <span data-ttu-id="11dc0-190">Na verdade, isso permite que sua classe e suas classes derivadas "herdem" uma implementação de propriedade de dependência sem que a classe proprietária original e a classe adicionada estejam na mesma hierarquia de classe verdadeira.</span><span class="sxs-lookup"><span data-stu-id="11dc0-190">Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</span></span> <span data-ttu-id="11dc0-191">Além disso, a classe adicionada (e também as classes derivadas) pode fornecer metadados específicos para o tipo da propriedade de dependência original.</span><span class="sxs-lookup"><span data-stu-id="11dc0-191">In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</span></span>  
  
 <span data-ttu-id="11dc0-192">Além de adicionar-se como proprietária por meio de métodos de utilitário do sistema de propriedades, a classe adicionada deve declarar membros públicos adicionais em si mesma para tornar a propriedade de dependência um participante completo do sistema de propriedades com exposição em código e marcação.</span><span class="sxs-lookup"><span data-stu-id="11dc0-192">As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</span></span> <span data-ttu-id="11dc0-193">Uma classe que adiciona uma propriedade de dependência existente tem as mesmas responsabilidades que expor o modelo de objeto para essa propriedade de dependência como uma classe que define uma nova propriedade de dependência personalizada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-193">A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</span></span> <span data-ttu-id="11dc0-194">O primeiro membro a ser exposto é um campo identificador de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="11dc0-194">The first such member to expose is a dependency property identifier field.</span></span> <span data-ttu-id="11dc0-195">Este campo deve `public static readonly` ser <xref:System.Windows.DependencyProperty>um campo de tipo, que <xref:System.Windows.DependencyProperty.AddOwner%2A> é atribuído ao valor de retorno da chamada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-195">This field should be a `public static readonly` field of type <xref:System.Windows.DependencyProperty>, which is assigned to the return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="11dc0-196">O segundo membro a definir é a propriedade "wrapper" de tempo de execução de idioma comum (CLR).</span><span class="sxs-lookup"><span data-stu-id="11dc0-196">The second member to define is the common language runtime (CLR) "wrapper" property.</span></span> <span data-ttu-id="11dc0-197">O invólucro torna muito mais conveniente manipular sua propriedade <xref:System.Windows.DependencyObject.SetValue%2A> de dependência em código (você evita chamadas para cada vez, e pode fazer essa chamada apenas uma vez no próprio invólucro).</span><span class="sxs-lookup"><span data-stu-id="11dc0-197">The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <xref:System.Windows.DependencyObject.SetValue%2A> each time, and can make that call only once in the wrapper itself).</span></span> <span data-ttu-id="11dc0-198">O wrapper é implementado igual seria implementado se você estivesse registrando uma propriedade de dependência personalizada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-198">The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</span></span> <span data-ttu-id="11dc0-199">Para obter mais informações de como implementar uma propriedade de dependência, consulte [Propriedades de dependência personalizadas](custom-dependency-properties.md) e [Adicionar um tipo de proprietário para uma propriedade de dependência](how-to-add-an-owner-type-for-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="11dc0-199">For more information about implementing a dependency property, see [Custom Dependency Properties](custom-dependency-properties.md) and [Add an Owner Type for a Dependency Property](how-to-add-an-owner-type-for-a-dependency-property.md).</span></span>  
  
#### <a name="addowner-and-attached-properties"></a><span data-ttu-id="11dc0-200">AddOwner e propriedades anexadas</span><span class="sxs-lookup"><span data-stu-id="11dc0-200">AddOwner and Attached Properties</span></span>  
 <span data-ttu-id="11dc0-201">Você pode <xref:System.Windows.DependencyProperty.AddOwner%2A> solicitar uma propriedade de dependência definida como uma propriedade anexada pela classe proprietário.</span><span class="sxs-lookup"><span data-stu-id="11dc0-201">You can call <xref:System.Windows.DependencyProperty.AddOwner%2A> for a dependency property that is defined as an attached property by the owner class.</span></span> <span data-ttu-id="11dc0-202">Geralmente o motivo para isso é expor a propriedade anexada anteriormente como uma propriedade de dependência não anexada.</span><span class="sxs-lookup"><span data-stu-id="11dc0-202">Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</span></span> <span data-ttu-id="11dc0-203">Em seguida, <xref:System.Windows.DependencyProperty.AddOwner%2A> você exporá `public static readonly` o valor de retorno como um campo para uso como identificador de propriedade de dependência e definirá propriedades apropriadas de "invólucro" para que a propriedade apareça na tabela de membros e suporte um uso de propriedade não anexado em sua classe.</span><span class="sxs-lookup"><span data-stu-id="11dc0-203">You then will expose the <xref:System.Windows.DependencyProperty.AddOwner%2A> return value as a `public static readonly` field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="11dc0-204">Confira também</span><span class="sxs-lookup"><span data-stu-id="11dc0-204">See also</span></span>

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="11dc0-205">Visão geral das propriedades de dependência</span><span class="sxs-lookup"><span data-stu-id="11dc0-205">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="11dc0-206">Metadados de propriedade de estrutura</span><span class="sxs-lookup"><span data-stu-id="11dc0-206">Framework Property Metadata</span></span>](framework-property-metadata.md)
