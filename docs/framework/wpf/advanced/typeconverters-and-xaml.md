---
title: TypeConverters e XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 6b8b58228e94ed12557e97406e55cc4165753076
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095080"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="1f290-102">TypeConverters e XAML</span><span class="sxs-lookup"><span data-stu-id="1f290-102">TypeConverters and XAML</span></span>
<span data-ttu-id="1f290-103">Este tópico apresenta a finalidade da conversão de tipo de cadeia de caracteres como um recurso de linguagem XAML geral.</span><span class="sxs-lookup"><span data-stu-id="1f290-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="1f290-104">Na .NET Framework, a classe <xref:System.ComponentModel.TypeConverter> atende a uma finalidade específica como parte da implementação de uma classe personalizada gerenciada que pode ser usada como um valor de propriedade no uso do atributo XAML.</span><span class="sxs-lookup"><span data-stu-id="1f290-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="1f290-105">Se você escrever uma classe personalizada e desejar que as instâncias da sua classe sejam utilizáveis como valores de atributo configurável XAML, talvez seja necessário aplicar um <xref:System.ComponentModel.TypeConverterAttribute> à sua classe, escrever uma classe de <xref:System.ComponentModel.TypeConverter> personalizada ou ambos.</span><span class="sxs-lookup"><span data-stu-id="1f290-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="1f290-106">Conceitos de conversão de tipos</span><span class="sxs-lookup"><span data-stu-id="1f290-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="1f290-107">XAML e valores de cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="1f290-107">XAML and String Values</span></span>  
 <span data-ttu-id="1f290-108">Quando um valor de atributo é definido em um arquivo XAML, o tipo inicial desse valor é uma cadeia de caracteres em texto simples.</span><span class="sxs-lookup"><span data-stu-id="1f290-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="1f290-109">Até mesmo outros primitivos, como <xref:System.Double> são cadeias de caracteres de texto inicialmente para um processador XAML.</span><span class="sxs-lookup"><span data-stu-id="1f290-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="1f290-110">Um processador XAML precisa de duas informações para processar um valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="1f290-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="1f290-111">A primeira informação é o tipo de valor da propriedade que está sendo definido.</span><span class="sxs-lookup"><span data-stu-id="1f290-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="1f290-112">Qualquer cadeia de caracteres que define um valor de atributo e que é processada em XAML deve, por fim, ser convertida ou resolvida para um valor desse tipo.</span><span class="sxs-lookup"><span data-stu-id="1f290-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="1f290-113">Caso o valor seja um primitivo compreendido pelo analisador XAML (como um valor numérico), será tentada uma conversão direta da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="1f290-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="1f290-114">Se o valor for uma enumeração, a cadeia de caracteres será usada para verificar se há uma correspondência de nome com uma constante nomeada na enumeração.</span><span class="sxs-lookup"><span data-stu-id="1f290-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="1f290-115">Se o valor não for um primitivo compreendido pelo analisador nem uma enumeração, o tipo em questão deverá ser capaz de fornecer uma instância do tipo ou um valor, com base em uma cadeia de caracteres convertida.</span><span class="sxs-lookup"><span data-stu-id="1f290-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="1f290-116">Isso é feito por meio de indicação de uma classe de conversor de tipos.</span><span class="sxs-lookup"><span data-stu-id="1f290-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="1f290-117">O conversor de tipos é uma classe auxiliar para fornecer valores de outra classe, tanto para o cenário XAML quanto, potencialmente, para chamadas de código no código .NET.</span><span class="sxs-lookup"><span data-stu-id="1f290-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="1f290-118">Usando o comportamento de conversão de tipo existente em XAML</span><span class="sxs-lookup"><span data-stu-id="1f290-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="1f290-119">Dependendo da sua familiaridade com os conceitos fundamentais de XAML, você pode já estar usando o comportamento de conversão de tipos no aplicativo básico XAML sem perceber.</span><span class="sxs-lookup"><span data-stu-id="1f290-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="1f290-120">Por exemplo, o WPF define literalmente centenas de propriedades que usam um valor do tipo <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="1f290-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="1f290-121">Uma <xref:System.Windows.Point> é um valor que descreve uma coordenada em um espaço de coordenadas bidimensional e, na verdade, tem apenas duas propriedades importantes: <xref:System.Windows.Point.X%2A> e <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f290-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="1f290-122">Quando você especifica um ponto no XAML, você o especifica como uma cadeia de caracteres com um delimitador (normalmente uma vírgula) entre o <xref:System.Windows.Point.X%2A> e os valores de <xref:System.Windows.Point.Y%2A> que você fornece.</span><span class="sxs-lookup"><span data-stu-id="1f290-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="1f290-123">Por exemplo: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="1f290-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="1f290-124">Até mesmo esse simples tipo de <xref:System.Windows.Point> e seu uso simples em XAML envolvem um conversor de tipo.</span><span class="sxs-lookup"><span data-stu-id="1f290-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="1f290-125">Nesse caso, essa é a classe <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="1f290-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="1f290-126">O conversor de tipo para <xref:System.Windows.Point> definido no nível de classe simplifica os usos de marcação de todas as propriedades que usam <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="1f290-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="1f290-127">Sem um conversor de tipos aqui, você precisaria da marcação muito mais detalhada a seguir para o mesmo exemplo mostrado anteriormente:</span><span class="sxs-lookup"><span data-stu-id="1f290-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="1f290-128">Usar a cadeia de caracteres de conversão de tipo ou uma sintaxe equivalente mais detalhada geralmente é uma opção de estilo de codificação.</span><span class="sxs-lookup"><span data-stu-id="1f290-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="1f290-129">O fluxo de trabalho das ferramentas XAML também pode influenciar a forma como os valores são definidos.</span><span class="sxs-lookup"><span data-stu-id="1f290-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="1f290-130">Algumas ferramentas XAML tendem a emitir a forma mais detalhada da marcação, porque é mais fácil ir e voltar de modos de exibição de designer ou do próprio mecanismo de serialização.</span><span class="sxs-lookup"><span data-stu-id="1f290-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="1f290-131">Os conversores de tipo existentes geralmente podem ser descobertos em tipos WPF e .NET Framework verificando uma classe (ou Propriedade) quanto à presença de uma <xref:System.ComponentModel.TypeConverterAttribute>aplicada.</span><span class="sxs-lookup"><span data-stu-id="1f290-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="1f290-132">Esse atributo nomeará a classe que é o conversor de tipos de suporte para valores desse tipo, para fins de XAML e, potencialmente, outras finalidades.</span><span class="sxs-lookup"><span data-stu-id="1f290-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="1f290-133">Conversores de tipo e extensões de marcação</span><span class="sxs-lookup"><span data-stu-id="1f290-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="1f290-134">As extensões de marcação e os conversores de tipos exercem funções ortogonais em termos de comportamento do processador XAML e dos cenários aos quais são aplicados.</span><span class="sxs-lookup"><span data-stu-id="1f290-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="1f290-135">Embora o contexto esteja disponível para usos de extensão de marcação, o comportamento de conversão de tipos de propriedades em que uma extensão de marcação fornece um valor geralmente não é verificado em implementações de extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="1f290-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="1f290-136">Em outras palavras, mesmo se uma extensão de marcação retornar uma cadeia de caracteres de texto como saída do `ProvideValue`, o comportamento de conversão de tipo dessa cadeia de caracteres, conforme aplicado a uma propriedade específica ou a um tipo de valor da propriedade, não será chamado. Em geral, a finalidade de uma extensão de marcação é processar uma cadeia de caracteres e retornar um objeto sem nenhum conversor de tipo envolvido.</span><span class="sxs-lookup"><span data-stu-id="1f290-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="1f290-137">Uma situação comum em que uma extensão de marcação é necessária, em vez de um conversor de tipos, é para fazer referência a um objeto que já existe.</span><span class="sxs-lookup"><span data-stu-id="1f290-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="1f290-138">Na melhor das hipóteses, um conversor de tipo sem monitoração de estado pode gerar somente uma nova instância, o que pode não ser desejável.</span><span class="sxs-lookup"><span data-stu-id="1f290-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="1f290-139">Para obter mais informações sobre extensões de marcação, consulte [Extensões de marcação e XAML WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="1f290-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="1f290-140">Conversores de tipos nativos</span><span class="sxs-lookup"><span data-stu-id="1f290-140">Native Type Converters</span></span>  
 <span data-ttu-id="1f290-141">Na implementação do analisador XAML do WPF e do .NET Framework, alguns tipos têm manipulação de conversão de tipos nativos; porém, não são tipos que poderiam ser interpretados, convencionalmente, como primitivos.</span><span class="sxs-lookup"><span data-stu-id="1f290-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="1f290-142">Um exemplo desse tipo é <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="1f290-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="1f290-143">O motivo disso se baseia em como a arquitetura de .NET Framework funciona: o tipo <xref:System.DateTime> é definido em mscorlib, a biblioteca mais básica no .NET.</span><span class="sxs-lookup"><span data-stu-id="1f290-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="1f290-144"><xref:System.DateTime> não tem permissão para ser atribuída a um atributo proveniente de outro assembly que introduz uma dependência (<xref:System.ComponentModel.TypeConverterAttribute> é do sistema), portanto, o mecanismo de descoberta do conversor de tipo usual por atribuição não pode ser suportado.</span><span class="sxs-lookup"><span data-stu-id="1f290-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="1f290-145">Em vez disso, o analisador XAML tem uma lista de tipos que precisam de tal processamento nativo e os processa da mesma forma como os primitivos verdadeiros são processados.</span><span class="sxs-lookup"><span data-stu-id="1f290-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="1f290-146">(No caso de <xref:System.DateTime> isso envolve uma chamada para <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="1f290-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="1f290-147">Implementando um conversor de tipos</span><span class="sxs-lookup"><span data-stu-id="1f290-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="1f290-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="1f290-148">TypeConverter</span></span>  
 <span data-ttu-id="1f290-149">No exemplo de <xref:System.Windows.Point> fornecido anteriormente, a classe <xref:System.Windows.PointConverter> foi mencionada.</span><span class="sxs-lookup"><span data-stu-id="1f290-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="1f290-150">Para implementações do .NET de XAML, todos os conversores de tipo usados para fins XAML são classes que derivam da classe base <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="1f290-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="1f290-151">A classe <xref:System.ComponentModel.TypeConverter> existia em versões do .NET Framework que precedem a existência do XAML; um de seus usos originais era fornecer conversão de cadeia de caracteres para caixas de diálogo de propriedade em designers visuais.</span><span class="sxs-lookup"><span data-stu-id="1f290-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="1f290-152">Para o XAML, a função de <xref:System.ComponentModel.TypeConverter> é expandida para incluir a classe base para as conversões de cadeia de caracteres e de cadeia de caracteres que habilitam a análise de um valor de atributo de cadeia de caracteres e, possivelmente, o processamento de um valor em tempo de execução de uma determinada propriedade de objeto de volta para uma cadeia de caracteres para serialização como um atributo.</span><span class="sxs-lookup"><span data-stu-id="1f290-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="1f290-153"><xref:System.ComponentModel.TypeConverter> define quatro membros que são relevantes para a conversão de e para cadeias de caracteres para fins de processamento XAML:</span><span class="sxs-lookup"><span data-stu-id="1f290-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="1f290-154">Desses, o método mais importante é <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f290-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="1f290-155">Esse método converte a cadeia de caracteres de entrada para o tipo de objeto necessário.</span><span class="sxs-lookup"><span data-stu-id="1f290-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="1f290-156">Estritamente falando, o método <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> poderia ser implementado para converter um intervalo muito mais amplo de tipos no tipo de destino pretendido do conversor e, portanto, atender a finalidades que se estendem além de XAML, como suporte a conversões de tempo de execução, mas para fins de XAML, ele é apenas o caminho de código que pode processar uma entrada de <xref:System.String> que é importante.</span><span class="sxs-lookup"><span data-stu-id="1f290-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="1f290-157">O próximo método mais importante é <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f290-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="1f290-158">Se um aplicativo for convertido em uma representação de marcação (por exemplo, se for salvo em XAML como um arquivo), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> será responsável por produzir uma representação de marcação.</span><span class="sxs-lookup"><span data-stu-id="1f290-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="1f290-159">Nesse caso, o caminho de código que importa para XAML é quando você passa uma `destinationType` de <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="1f290-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="1f290-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> e <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> são métodos de suporte que são usados quando um serviço consulta os recursos da implementação do <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="1f290-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="1f290-161">Esses métodos devem ser implementados para retornar o `true` para casos específicos de tipo aos quais os métodos de conversão equivalentes do seu conversor dão suporte.</span><span class="sxs-lookup"><span data-stu-id="1f290-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="1f290-162">Para fins de XAML, isso geralmente significa o tipo de <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="1f290-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="1f290-163">Informações de cultura e conversores de tipos para XAML</span><span class="sxs-lookup"><span data-stu-id="1f290-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="1f290-164">Cada implementação de <xref:System.ComponentModel.TypeConverter> pode ter sua própria interpretação do que constitui uma cadeia de caracteres válida para uma conversão e também pode usar ou ignorar a descrição do tipo passada como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="1f290-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="1f290-165">Há uma consideração importante em relação à cultura e à conversão de tipos XAML.</span><span class="sxs-lookup"><span data-stu-id="1f290-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="1f290-166">O XAML dá suporte total ao uso de cadeias de caracteres localizáveis como valores de atributos.</span><span class="sxs-lookup"><span data-stu-id="1f290-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="1f290-167">Porém, não há suporte para o uso dessa cadeia de caracteres localizável como entrada do conversor de tipos com exigências específicas de cultura, porque os conversores de tipos para valores de atributos XAML envolvem um comportamento de análise de linguagem necessariamente fixo, usando a cultura do `en-US`.</span><span class="sxs-lookup"><span data-stu-id="1f290-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="1f290-168">Para obter mais informações sobre os motivos de design para essa restrição, você deve consultar a especificação da linguagem XAML ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="1f290-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="1f290-169">Como exemplo de casos em que a cultura pode ser um problema, algumas culturas usam vírgula como delimitador de ponto decimal para números.</span><span class="sxs-lookup"><span data-stu-id="1f290-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="1f290-170">Isso vai de encontro ao comportamento que muitos dos conversores de tipos XAML do WPF têm, que é usar uma vírgula como delimitador (com base em precedentes históricos, como a forma comum X,Y ou listas delimitadas por vírgulas).</span><span class="sxs-lookup"><span data-stu-id="1f290-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="1f290-171">Nem mesmo a passagem de uma cultura no XAML ao redor (definindo `Language` ou `xml:lang` para a cultura do `sl-SI`, um exemplo de cultura que usa vírgula para decimal dessa maneira) resolve o problema.</span><span class="sxs-lookup"><span data-stu-id="1f290-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="1f290-172">Implementando ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="1f290-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="1f290-173">Para ser utilizável como uma implementação <xref:System.ComponentModel.TypeConverter> que dá suporte a XAML, o método <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> para esse conversor deve aceitar uma cadeia de caracteres como o parâmetro `value`.</span><span class="sxs-lookup"><span data-stu-id="1f290-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="1f290-174">Se a cadeia de caracteres estava em um formato válido e puder ser convertida pela implementação de <xref:System.ComponentModel.TypeConverter>, o objeto retornado deverá dar suporte a uma conversão para o tipo esperado pela propriedade.</span><span class="sxs-lookup"><span data-stu-id="1f290-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="1f290-175">Caso contrário, a implementação de <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> deve retornar `null`.</span><span class="sxs-lookup"><span data-stu-id="1f290-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="1f290-176">Cada implementação de <xref:System.ComponentModel.TypeConverter> pode ter sua própria interpretação do que constitui uma cadeia de caracteres válida para uma conversão e também pode usar ou ignorar a descrição do tipo ou contextos de cultura passados como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="1f290-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="1f290-177">No entanto, o processamento de XAML do WPF não pode passar valores para o contexto de descrição de tipo em todos os casos; tampouco consegue passar a cultura com base no `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="1f290-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1f290-178">Não utilize os caracteres de chave, especialmente o {, como elemento possível do formato da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="1f290-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="1f290-179">Esses caracteres são reservados como entrada e saída para uma sequência de extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="1f290-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="1f290-180">Implementando ConvertTo</span><span class="sxs-lookup"><span data-stu-id="1f290-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="1f290-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> é potencialmente usado para suporte de serialização.</span><span class="sxs-lookup"><span data-stu-id="1f290-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="1f290-182">O suporte de serialização por meio de <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> para seu tipo personalizado e seu conversor de tipo não é um requisito absoluto.</span><span class="sxs-lookup"><span data-stu-id="1f290-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="1f290-183">No entanto, se você estiver implementando um controle ou usando a serialização do como parte dos recursos ou do design de sua classe, deverá implementar <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f290-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="1f290-184">Para ser utilizável como uma implementação <xref:System.ComponentModel.TypeConverter> que dá suporte a XAML, o método <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> para esse conversor deve aceitar uma instância do tipo (ou um valor) com suporte como o parâmetro `value`.</span><span class="sxs-lookup"><span data-stu-id="1f290-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="1f290-185">Quando o parâmetro `destinationType` é o tipo <xref:System.String>, o objeto retornado deve ser capaz de ser convertido como <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="1f290-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="1f290-186">A cadeia de caracteres retornada deve representar um valor serializado de `value`.</span><span class="sxs-lookup"><span data-stu-id="1f290-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="1f290-187">O ideal é que o formato de serialização escolhido seja capaz de gerar o mesmo valor se essa cadeia de caracteres fosse passada para a implementação de <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> do mesmo conversor, sem perda significativa de informações.</span><span class="sxs-lookup"><span data-stu-id="1f290-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="1f290-188">Se o valor não puder ser serializado ou o conversor não oferecer suporte à serialização, a implementação de <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> deverá retornar `null`e terá permissão para gerar uma exceção nesse caso.</span><span class="sxs-lookup"><span data-stu-id="1f290-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="1f290-189">Mas se você lançar exceções, deverá informar a incapacidade de usar essa conversão como parte de sua implementação de <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> para que a prática recomendada de verificação com <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> primeiro para evitar exceções seja suportada.</span><span class="sxs-lookup"><span data-stu-id="1f290-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="1f290-190">Se `destinationType` parâmetro não for do tipo <xref:System.String>, você poderá escolher sua própria manipulação de conversor.</span><span class="sxs-lookup"><span data-stu-id="1f290-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="1f290-191">Normalmente, você reverteria para o tratamento de implementação base, que no <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> basemost gera uma exceção específica.</span><span class="sxs-lookup"><span data-stu-id="1f290-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="1f290-192">Implementando CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="1f290-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="1f290-193">Sua implementação de <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> deve retornar `true` para `destinationType` do tipo <xref:System.String>e, caso contrário, adiar para a implementação base.</span><span class="sxs-lookup"><span data-stu-id="1f290-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="1f290-194">Implementando CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="1f290-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="1f290-195">Sua implementação de <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> deve retornar `true` para `sourceType` do tipo <xref:System.String>e, caso contrário, adiar para a implementação base.</span><span class="sxs-lookup"><span data-stu-id="1f290-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="1f290-196">Aplicando o TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="1f290-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="1f290-197">Para que o conversor de tipo personalizado seja usado como o conversor de tipo atuante para uma classe personalizada por um processador XAML, você deve aplicar o <xref:System.ComponentModel.TypeConverterAttribute> à sua definição de classe.</span><span class="sxs-lookup"><span data-stu-id="1f290-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="1f290-198">O <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> especificado por meio do atributo deve ser o nome do tipo do conversor de tipo personalizado.</span><span class="sxs-lookup"><span data-stu-id="1f290-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="1f290-199">Com esse atributo aplicado, quando um processador XAML manipula valores em que o tipo de propriedade usa o tipo de classe personalizada, ele pode processar cadeias de caracteres de entrada e retornar as instâncias de objeto.</span><span class="sxs-lookup"><span data-stu-id="1f290-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="1f290-200">Também é possível fornecer um conversor de tipos por propriedade.</span><span class="sxs-lookup"><span data-stu-id="1f290-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="1f290-201">Em vez de aplicar um <xref:System.ComponentModel.TypeConverterAttribute> à definição de classe, aplique-o a uma definição de propriedade (a definição principal, não o `get`/`set` implementações dentro dele).</span><span class="sxs-lookup"><span data-stu-id="1f290-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="1f290-202">O tipo da propriedade deve corresponder ao tipo que é processado pelo conversor de tipos personalizado.</span><span class="sxs-lookup"><span data-stu-id="1f290-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="1f290-203">Com esse atributo aplicado, quando um processador XAML manipula valores dessa propriedade, ele pode processar cadeias de caracteres de entrada e retornar instâncias de objeto.</span><span class="sxs-lookup"><span data-stu-id="1f290-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="1f290-204">A técnica de conversor de tipo por propriedade é particularmente útil se você optar por usar um tipo de Propriedade do Microsoft .NET Framework ou de alguma outra biblioteca em que você não pode controlar a definição de classe e não pode aplicar um <xref:System.ComponentModel.TypeConverterAttribute> lá.</span><span class="sxs-lookup"><span data-stu-id="1f290-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1f290-205">Confira também</span><span class="sxs-lookup"><span data-stu-id="1f290-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="1f290-206">Visão geral de XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="1f290-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="1f290-207">Extensões de marcação e XAML do WPF</span><span class="sxs-lookup"><span data-stu-id="1f290-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="1f290-208">Sintaxe XAML em detalhes</span><span class="sxs-lookup"><span data-stu-id="1f290-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
