---
title: 'Como: Controlar o preenchimento de uma forma composta'
ms.date: 03/30/2017
helpviewer_keywords:
- shapes [WPF], composite [WPF], controlling fill
- composite shapes [WPF], controlling fill
- graphics [WPF], composite shapes
- fill [WPF], controlling
ms.assetid: c1c94575-9eca-48a5-a49a-2ec65259f229
ms.openlocfilehash: 0ba07d8979a2910ce4ec775493e38c714240f642
ms.sourcegitcommit: d21bee9dbd32b9540ad30f9d0e2e874227040be3
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/09/2019
ms.locfileid: "59427468"
---
# <a name="how-to-control-the-fill-of-a-composite-shape"></a><span data-ttu-id="0b511-102">Como: Controlar o preenchimento de uma forma composta</span><span class="sxs-lookup"><span data-stu-id="0b511-102">How to: Control the Fill of a Composite Shape</span></span>
<span data-ttu-id="0b511-103">O <xref:System.Windows.Media.GeometryGroup.FillRule%2A> propriedade de um <xref:System.Windows.Media.GeometryGroup> ou um <xref:System.Windows.Media.PathGeometry>, especifica uma "regra" que a forma composta usa para determinar se um determinado ponto é parte da geometria.</span><span class="sxs-lookup"><span data-stu-id="0b511-103">The <xref:System.Windows.Media.GeometryGroup.FillRule%2A> property of a <xref:System.Windows.Media.GeometryGroup> or a <xref:System.Windows.Media.PathGeometry>, specifies a "rule" which the composite shape uses to determine whether a given point is part of the geometry.</span></span> <span data-ttu-id="0b511-104">Há dois valores possíveis para <xref:System.Windows.Media.FillRule>: <xref:System.Windows.Media.FillRule.EvenOdd> e <xref:System.Windows.Media.FillRule.Nonzero>.</span><span class="sxs-lookup"><span data-stu-id="0b511-104">There are two possible values for <xref:System.Windows.Media.FillRule>: <xref:System.Windows.Media.FillRule.EvenOdd> and <xref:System.Windows.Media.FillRule.Nonzero>.</span></span> <span data-ttu-id="0b511-105">As seções a seguir descreverão como usar essas duas regras.</span><span class="sxs-lookup"><span data-stu-id="0b511-105">The following sections will describe how to use these two rules.</span></span>  
  
 <span data-ttu-id="0b511-106">**EvenOdd:** Esta regra determina se um ponto está na região de preenchimento desenhando um raio desse ponto até o infinito em qualquer direção e contando o número de segmentos de caminho dentro da forma especificada que o raio cruza.</span><span class="sxs-lookup"><span data-stu-id="0b511-106">**EvenOdd:** This rule determines whether a point is in the fill region by drawing a ray from that point to infinity in any direction and counting the number of path segments within the given shape that the ray crosses.</span></span> <span data-ttu-id="0b511-107">Se esse número for ímpar, o ponto estará dentro, se for par, o ponto estará fora.</span><span class="sxs-lookup"><span data-stu-id="0b511-107">If this number is odd, the point is inside; if even, the point is outside.</span></span>  
  
 <span data-ttu-id="0b511-108">Por exemplo, o XAML abaixo cria uma forma composta composta por uma série de anéis concêntricos (destino) com um <xref:System.Windows.Media.GeometryGroup.FillRule%2A> definido como <xref:System.Windows.Media.FillRule.EvenOdd>.</span><span class="sxs-lookup"><span data-stu-id="0b511-108">For example, the XAML below creates a composite shape made up of a series of concentric rings (target) with a <xref:System.Windows.Media.GeometryGroup.FillRule%2A> set to <xref:System.Windows.Media.FillRule.EvenOdd>.</span></span>  
  
 [!code-xaml[GeometriesMiscSnippets_snip#FillRuleEvenOddValue](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/FillRuleExample.xaml#fillruleevenoddvalue)]  
  
 <span data-ttu-id="0b511-109">A ilustração a seguir mostra a forma criada no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="0b511-109">The following illustration shows the shape created in the previous example.</span></span>  
  
 ![Um círculo composto por um anéis concêntricos de série com cores alternadas.](./media/how-to-control-the-fill-of-a-composite-shape/fillrule-evenodd-property.png)  
  
 <span data-ttu-id="0b511-111">Na ilustração anterior, observe que o centro e o terceiro anel não estão preenchidos.</span><span class="sxs-lookup"><span data-stu-id="0b511-111">In the previous illustration, notice that the center and third ring are not filled.</span></span> <span data-ttu-id="0b511-112">Isso ocorre porque um raio desenhado de qualquer ponto dentro de qualquer um desses dois anéis passa por um número par de segmentos.</span><span class="sxs-lookup"><span data-stu-id="0b511-112">This is because a ray drawn from any point within either of those two rings passes through an even number of segments.</span></span> <span data-ttu-id="0b511-113">Consulte a ilustração a seguir:</span><span class="sxs-lookup"><span data-stu-id="0b511-113">See the following illustration:</span></span>  
  
 ![Diagrama mostrando os raios EvenOdd desenhados no círculo.](./media/how-to-control-the-fill-of-a-composite-shape/fillrule-evenodd-rays.png)  
  
 <span data-ttu-id="0b511-115">**NonZero:** Esta regra determina se um ponto está na região de preenchimento do caminho desenhando um raio desse ponto até o infinito em qualquer direção e, em seguida, examinando os locais em que um segmento da forma cruza o raio.</span><span class="sxs-lookup"><span data-stu-id="0b511-115">**NonZero:** This rule determines whether a point is in the fill region of the path by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray.</span></span> <span data-ttu-id="0b511-116">Começando com uma contagem de zero, adicione um sempre que um segmento cruzar o raio da esquerda para a direita e subtraia um sempre que um segmento de caminho cruzar o raio da direita para a esquerda.</span><span class="sxs-lookup"><span data-stu-id="0b511-116">Starting with a count of zero, add one each time a Segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left.</span></span> <span data-ttu-id="0b511-117">Após a contagem de cruzamentos, se o resultado for zero, o ponto estará fora do caminho.</span><span class="sxs-lookup"><span data-stu-id="0b511-117">After counting the crossings, if the result is zero then the point is outside the path.</span></span> <span data-ttu-id="0b511-118">Caso contrário, ele estará dentro.</span><span class="sxs-lookup"><span data-stu-id="0b511-118">Otherwise, it is inside.</span></span>  
  
 [!code-xaml[GeometriesMiscSnippets_snip#FillRuleNonZeroValueEllipseGeometry](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/FillRuleExample.xaml#fillrulenonzerovalueellipsegeometry)]  
  
 <span data-ttu-id="0b511-119">Usando o exemplo anterior, um valor de <xref:System.Windows.Media.FillRule.Nonzero> para <xref:System.Windows.Media.GeometryGroup.FillRule%2A> fornece a ilustração a seguir como resultado:</span><span class="sxs-lookup"><span data-stu-id="0b511-119">Using the previous example, a value of <xref:System.Windows.Media.FillRule.Nonzero> for <xref:System.Windows.Media.GeometryGroup.FillRule%2A> gives the following illustration as a result:</span></span>  
  
 ![Um círculo composto por uma série anéis concêntricos todos preenchidos com a mesma cor.](./media/how-to-control-the-fill-of-a-composite-shape/fillrule-value-nonzero.png)  
  
 <span data-ttu-id="0b511-121">Como podemos ver, todos os anéis estão preenchidos.</span><span class="sxs-lookup"><span data-stu-id="0b511-121">As you can see, all the rings are filled.</span></span> <span data-ttu-id="0b511-122">Isso acontece porque todos os segmentos estão indo na mesma direção, assim, um raio desenhado de qualquer ponto cruzará um ou mais segmentos e a soma dos cruzamentos não será igual a zero.</span><span class="sxs-lookup"><span data-stu-id="0b511-122">This is because all the segments are running in the same direction and so a ray drawn from any point will cross one or more segments and the sum of the crossings will not equal zero.</span></span> <span data-ttu-id="0b511-123">Por exemplo, na ilustração a seguir, as setas vermelhas representam a direção em que os segmentos são desenhados e a seta branca representa um raio arbitrário que de um ponto em que o anel mais interno.</span><span class="sxs-lookup"><span data-stu-id="0b511-123">For example, in the following illustration, the red arrows represent the direction the segments are drawn and the white arrow represents an arbitrary ray running from a point in the innermost ring.</span></span> <span data-ttu-id="0b511-124">Iniciando com um valor de zero, para cada segmento que o raio cruza, um valor de um é adicionado, já que o segmento cruza o raio da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="0b511-124">Starting with a value of zero, for each segment that the ray crosses, a value of one is added because the segment crosses the ray from left to right.</span></span>  
  
 ![Diagrama mostrando o valor da propriedade FillRule igual a Nonzero.](./media/how-to-control-the-fill-of-a-composite-shape/fillrule-value-equal-nonzero.png)  
  
 <span data-ttu-id="0b511-126">Para demonstrar melhor o comportamento de <xref:System.Windows.Media.FillRule.Nonzero> regra uma forma mais complexa com segmentos indo em direções diferentes é necessária.</span><span class="sxs-lookup"><span data-stu-id="0b511-126">To better demonstrate the behavior of <xref:System.Windows.Media.FillRule.Nonzero> rule a more complex shape with segments running in different directions is required.</span></span> <span data-ttu-id="0b511-127">O código XAML abaixo cria uma forma semelhante ao exemplo anterior, exceto que ela é criada com um <xref:System.Windows.Media.PathGeometry> , em seguida, em vez disso, um <xref:System.Windows.Media.EllipseGeometry> que cria quatro arcos concêntricos, em vez círculos concêntricos totalmente fechados.</span><span class="sxs-lookup"><span data-stu-id="0b511-127">The XAML code below creates a similar shape as the previous example except that it is created with a <xref:System.Windows.Media.PathGeometry> rather then a <xref:System.Windows.Media.EllipseGeometry> which creates four concentric arcs rather then fully closed concentric circles.</span></span>  
  
 [!code-xaml[GeometriesMiscSnippets_snip#FillRuleNonZeroValuePathGeometry](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/FillRuleExample.xaml#fillrulenonzerovaluepathgeometry)]  
  
 <span data-ttu-id="0b511-128">A ilustração a seguir mostra a forma criada no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="0b511-128">The following illustration shows the shape created in the previous example.</span></span>  
  
 ![Um círculo composto por um anéis concêntricos de série com cores alternadas com o terceiro arco não preenchido.](./media/how-to-control-the-fill-of-a-composite-shape/pathgeometry-concentric-arcs.png)  
  
 <span data-ttu-id="0b511-130">Observe que o terceiro arco partindo do centro não está preenchido.</span><span class="sxs-lookup"><span data-stu-id="0b511-130">Notice that the third arc from the center is not filled.</span></span> <span data-ttu-id="0b511-131">A ilustração a seguir mostra por que isso é.</span><span class="sxs-lookup"><span data-stu-id="0b511-131">The following illustration shows why this is.</span></span> <span data-ttu-id="0b511-132">Na ilustração, as setas vermelhas representam a direção em que os segmentos são desenhados.</span><span class="sxs-lookup"><span data-stu-id="0b511-132">In the illustration, the red arrows represent the direction the segments are drawn.</span></span> <span data-ttu-id="0b511-133">As duas setas brancas representam dois raios arbitrários que se movem para fora de um ponto na região "não preenchida".</span><span class="sxs-lookup"><span data-stu-id="0b511-133">The two white arrows represent two arbitrary rays that move out from a point in the "non-filled" region.</span></span> <span data-ttu-id="0b511-134">Como podemos ver na ilustração, a soma dos valores de um determinado raio que cruza os segmentos no seu caminho é zero.</span><span class="sxs-lookup"><span data-stu-id="0b511-134">As can be seen from the illustration, the sum of the values from a given ray crossing the segments in its path is zero.</span></span> <span data-ttu-id="0b511-135">Conforme definido acima, uma soma zero significa que o ponto não faz parte da geometria (não faz parte do preenchimento), enquanto uma soma que *não* é zero, incluindo um valor negativo, faz parte da geometria.</span><span class="sxs-lookup"><span data-stu-id="0b511-135">As defined above, a sum of zero means that the point is not part of the geometry (not part of the fill) while a sum that is *not* zero, including a negative value, is part of the geometry.</span></span>  
  
 ![Diagrama mostrando os segmentos de cruzamento de raios arbitrários.](./media/how-to-control-the-fill-of-a-composite-shape/arbitrary-ray-cross-segment.png)  
  
 <span data-ttu-id="0b511-137">**Observação:** Para fins de <xref:System.Windows.Media.FillRule>, todas as formas são consideradas fechadas.</span><span class="sxs-lookup"><span data-stu-id="0b511-137">**Note:** For the purposes of <xref:System.Windows.Media.FillRule>, all shapes are considered closed.</span></span> <span data-ttu-id="0b511-138">Se houver uma lacuna em um segmento, desenhe uma linha imaginária para fechá-la.</span><span class="sxs-lookup"><span data-stu-id="0b511-138">If there is a gap in a segment, draw an imaginary line to close it.</span></span> <span data-ttu-id="0b511-139">No exemplo acima, existem pequenas lacunas nos anéis.</span><span class="sxs-lookup"><span data-stu-id="0b511-139">In the example above, there are small gaps in the rings.</span></span> <span data-ttu-id="0b511-140">Devido a isso, seria possível erar que um raio que passasse pela lacuna gerasse um resultado diferente que um raio indo para outra direção.</span><span class="sxs-lookup"><span data-stu-id="0b511-140">Given this, one might expect a ray that runs through the gap to give a different result then a ray running in another direction.</span></span> <span data-ttu-id="0b511-141">Abaixo está uma ilustração ampliada de uma dessas lacunas e do "segmento imaginário" (segmento desenhado para fins de aplicar o <xref:System.Windows.Media.FillRule>) que o fecha.</span><span class="sxs-lookup"><span data-stu-id="0b511-141">Below is an enlarged illustration of one of these gaps and the "imaginary segment" (segment that is drawn for purposes of applying the <xref:System.Windows.Media.FillRule>) that closes it.</span></span>  
  
 ![Diagrama mostrando FillRule segmentos que estão sempre fechados.](./media/how-to-control-the-fill-of-a-composite-shape/fillrule-closed-segments.png)  
  
## <a name="example"></a><span data-ttu-id="0b511-143">Exemplo</span><span class="sxs-lookup"><span data-stu-id="0b511-143">Example</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0b511-144">Consulte também</span><span class="sxs-lookup"><span data-stu-id="0b511-144">See also</span></span>

- [<span data-ttu-id="0b511-145">Criar uma forma composta</span><span class="sxs-lookup"><span data-stu-id="0b511-145">Create a Composite Shape</span></span>](how-to-create-a-composite-shape.md)
- [<span data-ttu-id="0b511-146">Visão geral da geometria</span><span class="sxs-lookup"><span data-stu-id="0b511-146">Geometry Overview</span></span>](geometry-overview.md)
