---
title: MDA releaseHandleFailed
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
author: mairaw
ms.author: mairaw
ms.openlocfilehash: ad580ecace07d3d6fdf206ff660dc4bac4bceb09
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64614299"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="e11a3-102">MDA releaseHandleFailed</span><span class="sxs-lookup"><span data-stu-id="e11a3-102">releaseHandleFailed MDA</span></span>
<span data-ttu-id="e11a3-103">O MDA (Assistente de Depuração Gerenciado) de `releaseHandleFailed` é ativado é notificar os desenvolvedores quando o método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> de uma classe derivada de <xref:System.Runtime.InteropServices.SafeHandle> ou <xref:System.Runtime.InteropServices.CriticalHandle> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="e11a3-103">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="e11a3-104">Sintomas</span><span class="sxs-lookup"><span data-stu-id="e11a3-104">Symptoms</span></span>  
 <span data-ttu-id="e11a3-105">Perdas de memória ou de recursos.</span><span class="sxs-lookup"><span data-stu-id="e11a3-105">Resource or memory leaks.</span></span>  <span data-ttu-id="e11a3-106">Se o método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> da classe derivada de <xref:System.Runtime.InteropServices.SafeHandle> ou <xref:System.Runtime.InteropServices.CriticalHandle> falhar, então o recurso encapsulado pela classe talvez não tenha sido liberado ou limpo.</span><span class="sxs-lookup"><span data-stu-id="e11a3-106">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="e11a3-107">Causa</span><span class="sxs-lookup"><span data-stu-id="e11a3-107">Cause</span></span>  
 <span data-ttu-id="e11a3-108">Os usuários devem fornecer a implementação do método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> se eles criarem classes que derivam de <xref:System.Runtime.InteropServices.SafeHandle> ou <xref:System.Runtime.InteropServices.CriticalHandle>; assim, as circunstâncias são específicas do recurso individual.</span><span class="sxs-lookup"><span data-stu-id="e11a3-108">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="e11a3-109">No entanto, os requisitos de configuração são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="e11a3-109">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="e11a3-110">Os tipos <xref:System.Runtime.InteropServices.SafeHandle> e <xref:System.Runtime.InteropServices.CriticalHandle> representam wrappers em torno de recursos vitais do processo.</span><span class="sxs-lookup"><span data-stu-id="e11a3-110"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="e11a3-111">Uma perda de memória inutilizaria o processo ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="e11a3-111">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="e11a3-112">O método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> não deve falhar ao executar sua função.</span><span class="sxs-lookup"><span data-stu-id="e11a3-112">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="e11a3-113">Depois que o processo adquire um recurso desse tipo, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> é a única maneira de liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="e11a3-113">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="e11a3-114">Portanto, a falha implica em perda de recursos.</span><span class="sxs-lookup"><span data-stu-id="e11a3-114">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="e11a3-115">Qualquer falha que ocorra durante a execução de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impedindo a liberação do recurso, é um bug na implementação do método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> em si.</span><span class="sxs-lookup"><span data-stu-id="e11a3-115">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="e11a3-116">É responsabilidade do programador garantir que o contrato seja atendido, mesmo que esse código, para executar sua função, chame código criado por outra pessoa.</span><span class="sxs-lookup"><span data-stu-id="e11a3-116">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="e11a3-117">Resolução</span><span class="sxs-lookup"><span data-stu-id="e11a3-117">Resolution</span></span>  
 <span data-ttu-id="e11a3-118">O código que usa o tipo <xref:System.Runtime.InteropServices.SafeHandle> específico (ou <xref:System.Runtime.InteropServices.CriticalHandle>) que gerou a notificação de MDA deve ser revisado, procurando os locais em que o valor do identificador bruto é extraído do <xref:System.Runtime.InteropServices.SafeHandle> e copiado em outro lugar.</span><span class="sxs-lookup"><span data-stu-id="e11a3-118">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="e11a3-119">Essa é a causa comum de falhas em implementações de <xref:System.Runtime.InteropServices.SafeHandle> ou <xref:System.Runtime.InteropServices.CriticalHandle>, porque o uso do valor do identificador bruto não é mais controlado pelo tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="e11a3-119">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="e11a3-120">Se a cópia de identificador bruto subsequentemente for fechada, isso poderá causar falha em uma chamada <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> posterior porque a tentativa de fechar ocorrerá no mesmo identificador, que será então inválido.</span><span class="sxs-lookup"><span data-stu-id="e11a3-120">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="e11a3-121">Há várias maneiras em que a duplicação de identificador incorreto pode ocorrer:</span><span class="sxs-lookup"><span data-stu-id="e11a3-121">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="e11a3-122">Procure por chamadas para o método <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e11a3-122">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="e11a3-123">Chamadas para esse método deverão ser muito raras e qualquer uma que você encontrar deverá ficar entre chamadas para os métodos <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="e11a3-123">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="e11a3-124">Esses métodos especificam a região do código na qual o valor do identificador bruto pode ser usado com segurança.</span><span class="sxs-lookup"><span data-stu-id="e11a3-124">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="e11a3-125">Fora dessa região ou se a contagem de referência nunca chegar a ser incrementada, o valor do identificador poderá ser invalidado a qualquer momento por uma chamada para <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> em outro thread.</span><span class="sxs-lookup"><span data-stu-id="e11a3-125">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="e11a3-126">Uma vez que todos os usos de <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> tiverem sido identificados, você deverá percorrer o caminho seguido pelo identificador bruto para assegurar que ele não seja cedido a nenhum componente que, eventualmente, chame `CloseHandle` ou outro método nativo de baixo nível que libere o identificador.</span><span class="sxs-lookup"><span data-stu-id="e11a3-126">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="e11a3-127">Verifique se o código usado para inicializar o <xref:System.Runtime.InteropServices.SafeHandle> com um valor de identificador bruto válido é proprietário do identificador.</span><span class="sxs-lookup"><span data-stu-id="e11a3-127">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="e11a3-128">Se você formar um <xref:System.Runtime.InteropServices.SafeHandle> em torno de um identificador que não for propriedade de seu código sem configurar o parâmetro `ownsHandle` como `false` no construtor base, então ambos o <xref:System.Runtime.InteropServices.SafeHandle> e o proprietário do identificador real poderão tentar fechar o identificador, levando a um erro em <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> se o <xref:System.Runtime.InteropServices.SafeHandle> perder a corrida.</span><span class="sxs-lookup"><span data-stu-id="e11a3-128">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="e11a3-129">Quando um <xref:System.Runtime.InteropServices.SafeHandle> sofre marshaling entre domínios de aplicativo, confirme que a derivação <xref:System.Runtime.InteropServices.SafeHandle> sendo usada foi marcada como serializável.</span><span class="sxs-lookup"><span data-stu-id="e11a3-129">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="e11a3-130">Nos raros casos em que uma classe derivada de <xref:System.Runtime.InteropServices.SafeHandle> foi tornada serializável, ela deve implementar a interface <xref:System.Runtime.Serialization.ISerializable> ou usar uma das outras técnicas para controlar o processo de serialização e desserialização manualmente.</span><span class="sxs-lookup"><span data-stu-id="e11a3-130">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="e11a3-131">Isso é necessário porque a ação de serialização padrão é criar um clone bit a bit do valor de identificador bruto anexado, o que resulta em duas instâncias <xref:System.Runtime.InteropServices.SafeHandle> pensando que são proprietárias do mesmo identificador.</span><span class="sxs-lookup"><span data-stu-id="e11a3-131">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="e11a3-132">Ambas tentarão chamar <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> no mesmo identificador em algum momento.</span><span class="sxs-lookup"><span data-stu-id="e11a3-132">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="e11a3-133">O segundo <xref:System.Runtime.InteropServices.SafeHandle> a fazer isso falhará.</span><span class="sxs-lookup"><span data-stu-id="e11a3-133">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="e11a3-134">A maneira correta de serializar um <xref:System.Runtime.InteropServices.SafeHandle> é chamar a função `DuplicateHandle` ou uma função semelhante para seu tipo de identificador nativo fazer uma cópia de identificador legal distinta.</span><span class="sxs-lookup"><span data-stu-id="e11a3-134">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="e11a3-135">Se o tipo de identificador não dá suporte a isso, então o tipo <xref:System.Runtime.InteropServices.SafeHandle> encapsulando-o não pode ser transformado em serializável.</span><span class="sxs-lookup"><span data-stu-id="e11a3-135">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="e11a3-136">É possível acompanhar casos em que um identificador está sendo fechado precocemente, o que leva a uma falha quando o método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> finalmente é chamado, colocando-se um ponto de interrupção do depurador na rotina nativa usada para liberar o identificador, por exemplo, a função `CloseHandle`.</span><span class="sxs-lookup"><span data-stu-id="e11a3-136">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="e11a3-137">Isso talvez não seja possível para cenários de estresse ou até mesmo testes funcionais de tamanho médio em razão do tráfego intenso com que essas rotinas costumam lidar.</span><span class="sxs-lookup"><span data-stu-id="e11a3-137">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="e11a3-138">Talvez seja útil instrumentar o código que chama o método de liberação nativo para capturar a identidade do chamador ou, possivelmente, um rastreamento de pilha completo e o valor do identificador sendo liberado.</span><span class="sxs-lookup"><span data-stu-id="e11a3-138">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="e11a3-139">O valor do identificador pode ser comparado com o valor indicado por esse MDA.</span><span class="sxs-lookup"><span data-stu-id="e11a3-139">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="e11a3-140">Observe que alguns tipos de identificador nativo que podem ser liberados por meio da função `CloseHandle`, tais como Win32, compartilham o mesmo namespace de identificador.</span><span class="sxs-lookup"><span data-stu-id="e11a3-140">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="e11a3-141">Uma liberação incorreta de um tipo de identificador pode causar problemas com outro.</span><span class="sxs-lookup"><span data-stu-id="e11a3-141">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="e11a3-142">Por exemplo, fechar acidentalmente um identificador de evento Win32 duas vezes pode resultar no fechamento prematuro de um identificador de arquivo aparentemente não relacionado.</span><span class="sxs-lookup"><span data-stu-id="e11a3-142">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="e11a3-143">Isso ocorre quando o identificador é liberado e o valor dele se torna disponível para ser usado para acompanhar outro recurso, potencialmente de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="e11a3-143">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="e11a3-144">Se isso ocorre e é seguido por uma segunda liberação errônea, o identificador de um thread não relacionado pode invalidado.</span><span class="sxs-lookup"><span data-stu-id="e11a3-144">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="e11a3-145">Efeito sobre o tempo de execução</span><span class="sxs-lookup"><span data-stu-id="e11a3-145">Effect on the Runtime</span></span>  
 <span data-ttu-id="e11a3-146">Esse MDA não tem efeito sobre o CLR.</span><span class="sxs-lookup"><span data-stu-id="e11a3-146">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="e11a3-147">Saída</span><span class="sxs-lookup"><span data-stu-id="e11a3-147">Output</span></span>  
 <span data-ttu-id="e11a3-148">Uma mensagem indicando que um <xref:System.Runtime.InteropServices.SafeHandle> ou <xref:System.Runtime.InteropServices.CriticalHandle> falhou em liberar o identificador.</span><span class="sxs-lookup"><span data-stu-id="e11a3-148">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="e11a3-149">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="e11a3-149">For example:</span></span>  
  
```  
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'   
failed to properly release the handle with value 0x0000BEEF. This   
usually indicates that the handle was released incorrectly via   
another means (such as extracting the handle using DangerousGetHandle   
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="e11a3-150">Configuração</span><span class="sxs-lookup"><span data-stu-id="e11a3-150">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="e11a3-151">Exemplo</span><span class="sxs-lookup"><span data-stu-id="e11a3-151">Example</span></span>  
 <span data-ttu-id="e11a3-152">A seguir está um exemplo de código que pode ativar o MDA `releaseHandleFailed`.</span><span class="sxs-lookup"><span data-stu-id="e11a3-152">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the   
    // native handle wrapped by this SafeHandle. This method returns   
    // false on failure, but should only fail if the input is invalid   
    // (which should not happen here). The method specifically must not   
    // fail simply because of lack of resources or other transient   
    // failures beyond the user’s control. That would make it unacceptable   
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="e11a3-153">Consulte também</span><span class="sxs-lookup"><span data-stu-id="e11a3-153">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="e11a3-154">Diagnosticando erros com Assistentes de Depuração Gerenciados</span><span class="sxs-lookup"><span data-stu-id="e11a3-154">Diagnosing Errors with Managed Debugging Assistants</span></span>](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="e11a3-155">Marshaling de interoperabilidade</span><span class="sxs-lookup"><span data-stu-id="e11a3-155">Interop Marshaling</span></span>](../../../docs/framework/interop/interop-marshaling.md)
