---
title: Contratos de código
description: Explore os contratos de código, que fornecem uma maneira de especificar pré-condições, condições e invariáveis de objeto em seu código .NET.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904137"
---
# <a name="code-contracts"></a><span data-ttu-id="89e8d-103">Contratos de código</span><span class="sxs-lookup"><span data-stu-id="89e8d-103">Code Contracts</span></span>

<span data-ttu-id="89e8d-104">Os contratos de código fornecem uma maneira de especificar pré-condições, pós-condições e invariáveis de objeto no código.</span><span class="sxs-lookup"><span data-stu-id="89e8d-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="89e8d-105">As pré-condições são requisitos que devem ser atendidos ao inserir um método ou uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="89e8d-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="89e8d-106">As pós-condições descrevem as expectativas no momento em que o código do método ou da propriedade é fechado.</span><span class="sxs-lookup"><span data-stu-id="89e8d-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="89e8d-107">As invariáveis de objeto descrevem o estado esperado de uma classe que está em um bom estado.</span><span class="sxs-lookup"><span data-stu-id="89e8d-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="89e8d-108">Os contratos de código incluem classes para marcação do código, um analisador estático para análise em tempo de compilação e um analisador de runtime.</span><span class="sxs-lookup"><span data-stu-id="89e8d-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="89e8d-109">As classes dos contratos de código podem ser encontradas no namespace <xref:System.Diagnostics.Contracts>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="89e8d-110">Os benefícios dos contratos de código incluem os seguintes:</span><span class="sxs-lookup"><span data-stu-id="89e8d-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="89e8d-111">Testes aprimorados: os contratos de código fornecem verificação de contrato estático, verificação de runtime e geração de documentação.</span><span class="sxs-lookup"><span data-stu-id="89e8d-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="89e8d-112">Ferramentas de teste automático: use contratos de código para gerar testes de unidade mais significativos filtrando argumentos de teste sem sentido que não atendem às pré-condições.</span><span class="sxs-lookup"><span data-stu-id="89e8d-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="89e8d-113">Verificação estática: o verificador estático pode decidir se há violações de contrato sem executar o programa.</span><span class="sxs-lookup"><span data-stu-id="89e8d-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="89e8d-114">Ele verifica se há contratos implícitos, como desreferências nulas e limites da matriz, além de contratos explícitos.</span><span class="sxs-lookup"><span data-stu-id="89e8d-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="89e8d-115">Documentação de referência: o gerador de documentação amplia os arquivos de documentação XML existentes com informações de contrato.</span><span class="sxs-lookup"><span data-stu-id="89e8d-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="89e8d-116">Também há folhas de estilos que podem ser usadas com o [Sandcastle](https://github.com/EWSoftware/SHFB) para que as páginas de documentação geradas tenham seções de contrato.</span><span class="sxs-lookup"><span data-stu-id="89e8d-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="89e8d-117">Todas as linguagens do .NET Framework podem aproveitar os contratos; imediatamente: não é necessário escrever um analisador ou compilador especial.</span><span class="sxs-lookup"><span data-stu-id="89e8d-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="89e8d-118">Um suplemento do Visual Studio permite especificar o nível da análise do contrato de código a ser executado.</span><span class="sxs-lookup"><span data-stu-id="89e8d-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="89e8d-119">Os analisadores podem confirmar se os contratos estão bem formados (verificação de tipo e resolução de nomes) e podem produzir um formato compilado dos contratos no formato da MSIL (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="89e8d-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="89e8d-120">A criação de contratos no Visual Studio permite aproveitar o IntelliSense padrão fornecido pela ferramenta.</span><span class="sxs-lookup"><span data-stu-id="89e8d-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="89e8d-121">A maioria dos métodos da classe de contrato é compilada condicionalmente; ou seja, o compilador emite chamadas para esses métodos somente quando um símbolo especial, CONTRACTS_FULL, é definido, usando a diretiva `#define`.</span><span class="sxs-lookup"><span data-stu-id="89e8d-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="89e8d-122">CONTRACTS_FULL permite escrever contratos no código sem o uso de diretivas `#ifdef`; é possível produzir diferentes builds, alguns com contratos e outras sem eles.</span><span class="sxs-lookup"><span data-stu-id="89e8d-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="89e8d-123">Para obter ferramentas e instruções detalhadas sobre como usar contratos de código, consulte [contratos de código](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) no site do Marketplace do Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="89e8d-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="89e8d-124">Pré-condições</span><span class="sxs-lookup"><span data-stu-id="89e8d-124">Preconditions</span></span>

<span data-ttu-id="89e8d-125">É possível expressar pré-condições usando o método <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="89e8d-126">As pré-condições especificam o estado quando um método é invocado.</span><span class="sxs-lookup"><span data-stu-id="89e8d-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="89e8d-127">Geralmente, elas são usadas para especificar valores de parâmetro válidos.</span><span class="sxs-lookup"><span data-stu-id="89e8d-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="89e8d-128">Todos os membros mencionados nas pré-condições devem ser, pelo menos, tão acessíveis quanto o próprio método; caso contrário, a pré-condição pode não ser compreendida por todos os chamadores de um método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="89e8d-129">A condição não deve ter efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="89e8d-129">The condition must have no side-effects.</span></span> <span data-ttu-id="89e8d-130">O comportamento em runtime de pré-condições com falha é determinado pelo analisador de runtime.</span><span class="sxs-lookup"><span data-stu-id="89e8d-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="89e8d-131">Por exemplo, a pré-condição a seguir expressa que o parâmetro `x` não deve ser nulo.</span><span class="sxs-lookup"><span data-stu-id="89e8d-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="89e8d-132">Se o código precisar gerar uma exceção específica em caso de falha de uma pré-condição, use a sobrecarga genérica de <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, conforme mostrado a seguir.</span><span class="sxs-lookup"><span data-stu-id="89e8d-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="89e8d-133">Instruções Requires herdadas</span><span class="sxs-lookup"><span data-stu-id="89e8d-133">Legacy Requires Statements</span></span>

<span data-ttu-id="89e8d-134">A maior parte do código contém alguma validação de parâmetro na forma do código `if`-`then`-`throw`.</span><span class="sxs-lookup"><span data-stu-id="89e8d-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="89e8d-135">As ferramentas de contrato reconhecem essas instruções como pré-condições nos seguintes casos:</span><span class="sxs-lookup"><span data-stu-id="89e8d-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="89e8d-136">As instruções aparecem antes das outras instruções em um método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="89e8d-137">O conjunto inteiro de instruções desse tipo é seguido por uma chamada de método <xref:System.Diagnostics.Contracts.Contract> explícita, como uma chamada ao método <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> ou <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="89e8d-138">Quando as instruções `if`-`then`-`throw` aparecem neste formato, as ferramentas as reconhecem como instruções `requires` herdadas.</span><span class="sxs-lookup"><span data-stu-id="89e8d-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="89e8d-139">Se nenhum outro contrato seguir a sequência `if`-`then`-`throw`, encerre o código com o método <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="89e8d-140">Observe que a condição no teste anterior é uma pré-condição negada.</span><span class="sxs-lookup"><span data-stu-id="89e8d-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="89e8d-141">(A pré-condição real seria `x != null` .) Uma pré-condição negada é altamente restrita: ela deve ser escrita conforme mostrado no exemplo anterior; ou seja, ele não deve conter `else` cláusulas e o corpo da `then` cláusula deve ser uma única `throw` instrução.</span><span class="sxs-lookup"><span data-stu-id="89e8d-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="89e8d-142">O teste `if` está sujeito às regras de pureza e visibilidade (consulte [Diretrizes de uso](#usage_guidelines)), mas a expressão `throw` está sujeita apenas às regras de pureza.</span><span class="sxs-lookup"><span data-stu-id="89e8d-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="89e8d-143">No entanto, o tipo da exceção gerada deve estar tão visível quanto o método no qual ocorre o contrato.</span><span class="sxs-lookup"><span data-stu-id="89e8d-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="89e8d-144">Pós-condições</span><span class="sxs-lookup"><span data-stu-id="89e8d-144">Postconditions</span></span>

<span data-ttu-id="89e8d-145">Pós-condições são contratos para o estado de um método quando ele termina.</span><span class="sxs-lookup"><span data-stu-id="89e8d-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="89e8d-146">A pós-condição é verificada logo antes do fechamento de um método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="89e8d-147">O comportamento em runtime de pós-condições com falha é determinado pelo analisador de runtime.</span><span class="sxs-lookup"><span data-stu-id="89e8d-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="89e8d-148">Ao contrário das pré-condições, as pós-condições podem referenciar membros com menos visibilidade.</span><span class="sxs-lookup"><span data-stu-id="89e8d-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="89e8d-149">Um cliente pode não conseguir entender nem fazer uso de algumas das informações expressas por uma pós-condição usando o estado particular, mas isso não afeta a capacidade do cliente de usar o método corretamente.</span><span class="sxs-lookup"><span data-stu-id="89e8d-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="89e8d-150">Pós-condições padrão</span><span class="sxs-lookup"><span data-stu-id="89e8d-150">Standard Postconditions</span></span>

<span data-ttu-id="89e8d-151">É possível expressar pós-condições padrão usando o método <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="89e8d-152">As pós-condições expressam uma condição que deve ser `true` após o término normal do método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="89e8d-153">Pós-condições excepcionais</span><span class="sxs-lookup"><span data-stu-id="89e8d-153">Exceptional Postconditions</span></span>

<span data-ttu-id="89e8d-154">Pós-condições excepcionais são pós-condições que devem ser `true` quando uma exceção específica é gerada por um método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="89e8d-155">É possível especificar essas pós-condições usando o método <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="89e8d-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="89e8d-156">O argumento é a condição que deve ser `true` sempre que uma exceção que é um subtipo de `T` é gerada.</span><span class="sxs-lookup"><span data-stu-id="89e8d-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="89e8d-157">Há alguns tipos de exceção que são difíceis de serem usados em uma pós-condição excepcional.</span><span class="sxs-lookup"><span data-stu-id="89e8d-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="89e8d-158">Por exemplo, o uso do tipo <xref:System.Exception> para `T` exige o método para garantir a condição, independentemente do tipo de exceção gerado, mesmo se ele for um excedente de pilha ou outra exceção impossível de ser controlada.</span><span class="sxs-lookup"><span data-stu-id="89e8d-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="89e8d-159">Você deve usar pós-condições excepcionais somente para exceções específicas que podem ser geradas quando um membro é chamado, por exemplo, quando uma <xref:System.InvalidTimeZoneException> é gerada para uma chamada de método <xref:System.TimeZoneInfo>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="89e8d-160">Pós-condições especiais</span><span class="sxs-lookup"><span data-stu-id="89e8d-160">Special Postconditions</span></span>

<span data-ttu-id="89e8d-161">Os seguintes métodos podem ser usados apenas em pós-condições:</span><span class="sxs-lookup"><span data-stu-id="89e8d-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="89e8d-162">É possível se referir aos valores retornados do método nas pós-condições usando a expressão `Contract.Result<T>()`, em que `T` é substituído pelo tipo de retorno do método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="89e8d-163">Quando o compilador não puder inferir o tipo, você deverá fornecê-lo explicitamente.</span><span class="sxs-lookup"><span data-stu-id="89e8d-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="89e8d-164">Por exemplo, o compilador do C# não pode inferir tipos de métodos que não usam nenhum argumento. Portanto, ele exige a seguinte pós-condição: métodos `Contract.Ensures(0 <Contract.Result<int>())` com um tipo de retorno `void` não podem se referir a `Contract.Result<T>()` em suas pós-condições.</span><span class="sxs-lookup"><span data-stu-id="89e8d-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="89e8d-165">Um valor de pré-estado em uma pós-condição refere-se ao valor de uma expressão no início de um método ou uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="89e8d-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="89e8d-166">Ele usa a expressão `Contract.OldValue<T>(e)`, em que `T` é o tipo de `e`.</span><span class="sxs-lookup"><span data-stu-id="89e8d-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="89e8d-167">É possível omitir o argumento de tipo genérico sempre que o compilador pode inferir seu tipo.</span><span class="sxs-lookup"><span data-stu-id="89e8d-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="89e8d-168">(Por exemplo, o compilador C# sempre infere o tipo porque ele usa um argumento). Há várias restrições sobre o que pode ocorrer no `e` e os contextos nos quais uma expressão antiga pode aparecer.</span><span class="sxs-lookup"><span data-stu-id="89e8d-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="89e8d-169">Uma expressão antiga não pode conter outra expressão antiga.</span><span class="sxs-lookup"><span data-stu-id="89e8d-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="89e8d-170">O mais importante é que uma expressão antiga deve se referir a um valor que existia no estado de pré-condição do método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="89e8d-171">Em outras palavras, ela deve ser uma expressão que possa ser avaliada, desde que a pré-condição do método seja `true`.</span><span class="sxs-lookup"><span data-stu-id="89e8d-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="89e8d-172">Veja a seguir várias instâncias dessa regra.</span><span class="sxs-lookup"><span data-stu-id="89e8d-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="89e8d-173">O valor deve existir no estado de pré-condição do método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="89e8d-174">Para fazer referência a um campo em um objeto, as pré-condições devem garantir que o objeto seja sempre não nulo.</span><span class="sxs-lookup"><span data-stu-id="89e8d-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="89e8d-175">Não é possível se referir ao valor retornado do método em uma expressão antiga:</span><span class="sxs-lookup"><span data-stu-id="89e8d-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="89e8d-176">Não é possível se referir aos parâmetros `out` em uma expressão antiga.</span><span class="sxs-lookup"><span data-stu-id="89e8d-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="89e8d-177">Uma expressão antiga não poderá depender da variável associada de um quantificador se o intervalo do quantificador depender do valor retornado do método:</span><span class="sxs-lookup"><span data-stu-id="89e8d-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="89e8d-178">Uma expressão antiga não pode se referir ao parâmetro do representante anônimo em uma chamada <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> ou <xref:System.Diagnostics.Contracts.Contract.Exists%2A>, a menos que ela seja usada como um indexador ou um argumento para uma chamada de método:</span><span class="sxs-lookup"><span data-stu-id="89e8d-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="89e8d-179">Uma expressão antiga não pode ocorrer no corpo de um representante anônimo se o valor da expressão antiga depender de um dos parâmetros do representante anônimo, a menos que o representante anônimo seja um argumento para o método <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> ou <xref:System.Diagnostics.Contracts.Contract.Exists%2A>:</span><span class="sxs-lookup"><span data-stu-id="89e8d-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="89e8d-180">Os parâmetros `Out` apresentam um problema porque os contratos aparecem antes do corpo do método e a maioria dos compiladores não permite referências aos parâmetros `out` em pós-condições.</span><span class="sxs-lookup"><span data-stu-id="89e8d-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="89e8d-181">Para resolver esse problema, a classe <xref:System.Diagnostics.Contracts.Contract> fornece o método <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>, que permite uma pós-condição com base em um parâmetro `out`.</span><span class="sxs-lookup"><span data-stu-id="89e8d-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="89e8d-182">Assim como ocorre com o método <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, é possível omitir o parâmetro de tipo genérico sempre que o compilador pode inferir seu tipo.</span><span class="sxs-lookup"><span data-stu-id="89e8d-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="89e8d-183">O reescritor de contrato substitui a chamada de método pelo valor do parâmetro `out`.</span><span class="sxs-lookup"><span data-stu-id="89e8d-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="89e8d-184">O método <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> pode aparecer somente em pós-condições.</span><span class="sxs-lookup"><span data-stu-id="89e8d-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="89e8d-185">O argumento para o método deve ser um parâmetro `out` ou um campo de um parâmetro `out` de estrutura.</span><span class="sxs-lookup"><span data-stu-id="89e8d-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="89e8d-186">Esse último também é útil ao se referir a campos na pós-condição de um construtor de estrutura.</span><span class="sxs-lookup"><span data-stu-id="89e8d-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="89e8d-187">Atualmente, as ferramentas de análise de contrato de código não verificam se os parâmetros `out` são inicializados corretamente e desconsideram sua menção na pós-condição.</span><span class="sxs-lookup"><span data-stu-id="89e8d-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="89e8d-188">Portanto, no exemplo anterior, se a linha após o contrato tiver usado o valor `x` em vez de atribuir um inteiro a ele, um compilador não emitirá o erro correto.</span><span class="sxs-lookup"><span data-stu-id="89e8d-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="89e8d-189">No entanto, em um build no qual o símbolo do pré-processador CONTRACTS_FULL não está definido (como o build de versão ASA), o compilador emitirá um erro.</span><span class="sxs-lookup"><span data-stu-id="89e8d-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="89e8d-190">Invariáveis</span><span class="sxs-lookup"><span data-stu-id="89e8d-190">Invariants</span></span>

<span data-ttu-id="89e8d-191">Invariáveis de objeto são condições que devem ser verdadeiras para cada instância de uma classe, sempre que o objeto está visível para um cliente.</span><span class="sxs-lookup"><span data-stu-id="89e8d-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="89e8d-192">Elas expressam as condições nas quais o objeto é considerado correto.</span><span class="sxs-lookup"><span data-stu-id="89e8d-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="89e8d-193">Os métodos invariáveis são identificados sendo marcados com o atributo <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="89e8d-194">Os métodos invariáveis não devem conter nenhum código, exceto uma sequência de chamadas ao método <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>, cada uma delas especificando uma invariável individual, conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="89e8d-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="89e8d-195">As invariáveis são definidas condicionalmente pelo símbolo do pré-processador CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="89e8d-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="89e8d-196">Durante a verificação em tempo de execução, as invariáveis são verificadas ao final de cada método público.</span><span class="sxs-lookup"><span data-stu-id="89e8d-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="89e8d-197">Se uma invariável mencionar um método público na mesma classe, a verificação de invariáveis que normalmente ocorre ao final do método público será desabilitada.</span><span class="sxs-lookup"><span data-stu-id="89e8d-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="89e8d-198">Em vez disso, a verificação ocorrerá somente ao final da chamada de método externa para essa classe.</span><span class="sxs-lookup"><span data-stu-id="89e8d-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="89e8d-199">Isso também ocorrerá se a classe for inserida novamente devido a uma chamada a um método em outra classe.</span><span class="sxs-lookup"><span data-stu-id="89e8d-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="89e8d-200">As invariáveis não são verificadas para um finalizador de objeto e uma <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação.</span><span class="sxs-lookup"><span data-stu-id="89e8d-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="89e8d-201">Diretrizes de uso</span><span class="sxs-lookup"><span data-stu-id="89e8d-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="89e8d-202">Ordenação de contrato</span><span class="sxs-lookup"><span data-stu-id="89e8d-202">Contract Ordering</span></span>

<span data-ttu-id="89e8d-203">A tabela a seguir mostra a ordem dos elementos que deve ser usada ao escrever contratos de método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="89e8d-204">Pré-condições públicas compatíveis com versões anteriores</span><span class="sxs-lookup"><span data-stu-id="89e8d-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="89e8d-205">Todas as pré-condições públicas.</span><span class="sxs-lookup"><span data-stu-id="89e8d-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="89e8d-206">Todas as pós-condições públicas (normais).</span><span class="sxs-lookup"><span data-stu-id="89e8d-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="89e8d-207">Todas as pós-condições excepcionais públicas.</span><span class="sxs-lookup"><span data-stu-id="89e8d-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="89e8d-208">Todas as pós-condições particulares/internas (normais).</span><span class="sxs-lookup"><span data-stu-id="89e8d-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="89e8d-209">Todas as pós-condições excepcionais particulares/internas.</span><span class="sxs-lookup"><span data-stu-id="89e8d-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="89e8d-210">Se você estiver usando pré-condições de estilo `if`-`then`-`throw` sem nenhum outro contrato, faça uma chamada a <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> para indicar que as verificações anteriores são pré-condições.</span><span class="sxs-lookup"><span data-stu-id="89e8d-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="89e8d-211">Pureza</span><span class="sxs-lookup"><span data-stu-id="89e8d-211">Purity</span></span>

<span data-ttu-id="89e8d-212">Todos os métodos chamados em um contrato devem ser puros; ou seja, eles não devem atualizar nenhum estado preexistente.</span><span class="sxs-lookup"><span data-stu-id="89e8d-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="89e8d-213">Um método puro tem permissão para modificar os objetos que foram criados após a entrada no método puro.</span><span class="sxs-lookup"><span data-stu-id="89e8d-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="89e8d-214">Atualmente, as ferramentas de contrato de código supõem que os seguintes elementos de código são puros:</span><span class="sxs-lookup"><span data-stu-id="89e8d-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="89e8d-215">Métodos marcados com o <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="89e8d-216">Tipos marcados com o <xref:System.Diagnostics.Contracts.PureAttribute> (o atributo se aplica a todos os métodos do tipo).</span><span class="sxs-lookup"><span data-stu-id="89e8d-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="89e8d-217">Acessadores get da propriedade.</span><span class="sxs-lookup"><span data-stu-id="89e8d-217">Property get accessors.</span></span>

- <span data-ttu-id="89e8d-218">Operadores (métodos estáticos cujos nomes começam com “op” e que têm um ou dois parâmetros e um tipo de retorno não nulo).</span><span class="sxs-lookup"><span data-stu-id="89e8d-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="89e8d-219">Qualquer método cujo nome totalmente qualificado começa com “System.Diagnostics.Contracts.Contract”, “System.String”, “System.IO.Path” ou “System.Type”.</span><span class="sxs-lookup"><span data-stu-id="89e8d-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="89e8d-220">Qualquer representante invocado, desde que o próprio tipo de representante seja atribuído com o <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="89e8d-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="89e8d-221">Os tipos de representante <xref:System.Predicate%601?displayProperty=nameWithType> e <xref:System.Comparison%601?displayProperty=nameWithType> são considerados puros.</span><span class="sxs-lookup"><span data-stu-id="89e8d-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="89e8d-222">Visibilidade</span><span class="sxs-lookup"><span data-stu-id="89e8d-222">Visibility</span></span>

<span data-ttu-id="89e8d-223">Todos os membros mencionados em um contrato devem ser, pelo menos, tão visíveis quanto o método no qual aparecem.</span><span class="sxs-lookup"><span data-stu-id="89e8d-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="89e8d-224">Por exemplo, um campo particular não pode ser mencionado em uma pré-condição de um método público; os clientes não podem validar um contrato desse tipo antes de chamarem o método.</span><span class="sxs-lookup"><span data-stu-id="89e8d-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="89e8d-225">No entanto, se o campo estiver marcado com o <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, ele estará isento dessas regras.</span><span class="sxs-lookup"><span data-stu-id="89e8d-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="89e8d-226">Exemplo</span><span class="sxs-lookup"><span data-stu-id="89e8d-226">Example</span></span>

<span data-ttu-id="89e8d-227">O exemplo a seguir mostra o uso de contratos de código.</span><span class="sxs-lookup"><span data-stu-id="89e8d-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
