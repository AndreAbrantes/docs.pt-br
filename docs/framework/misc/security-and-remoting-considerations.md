---
title: Considerações sobre segurança e comunicação remota
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 46e2e1c327a683782b68069ace2ad6c40bbc856e
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59225281"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="c0fa1-102">Considerações sobre segurança e comunicação remota</span><span class="sxs-lookup"><span data-stu-id="c0fa1-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="c0fa1-103">Comunicação remota permite que você configure transparente chamando entre domínios de aplicativos, processos ou computadores.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="c0fa1-104">No entanto, a movimentação de pilha de segurança de acesso de código não pode cruzar os limites de processo ou computadores (Aplicar entre domínios de aplicativo do mesmo processo).</span><span class="sxs-lookup"><span data-stu-id="c0fa1-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="c0fa1-105">Qualquer classe que é remota (derivado de um <xref:System.MarshalByRefObject> classe) precisa para assumir a responsabilidade pela segurança.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="c0fa1-106">Tanto o código deve ser usado somente em ambientes fechados em que o código de chamada pode ser implicitamente confiável, ou chamadas de comunicação remota devem ser projetadas para que eles não sujeito código protegido a entrada externa que poderia ser usada maliciosamente.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="c0fa1-107">Em geral, você deve nunca exponha métodos, propriedades ou eventos que são protegidos pelo declarativa [LinkDemand](../../../docs/framework/misc/link-demands.md) e <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> verificações de segurança.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](../../../docs/framework/misc/link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="c0fa1-108">Com a comunicação remota, essas verificações não são impostas.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="c0fa1-109">Outro security verifica, tais como <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md)e assim por diante, funcionam entre domínios do aplicativo dentro de um processo, mas não funcionam em cenários entre processos ou entre computadores.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="c0fa1-110">Objetos protegidos</span><span class="sxs-lookup"><span data-stu-id="c0fa1-110">Protected objects</span></span>  
 <span data-ttu-id="c0fa1-111">Alguns objetos mantêm o estado de segurança em si.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="c0fa1-112">Esses objetos não devem ser passados para código não confiável, que, em seguida, poderia adquirir a autorização de segurança, além de suas próprias permissões.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="c0fa1-113">Um exemplo é criar um <xref:System.IO.FileStream> objeto.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="c0fa1-114">O <xref:System.Security.Permissions.FileIOPermission> é solicitada no momento da criação e, se tiver êxito, o objeto de arquivo é retornado.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="c0fa1-115">No entanto, se essa referência de objeto é passada para código sem permissões de arquivo, o objeto será capaz de ler e gravar nesse arquivo específico.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="c0fa1-116">A defesa mais simples para esse objeto é solicitar o mesmo **FileIOPermission** de qualquer código que tenta obter a referência de objeto por meio de um elemento de API público.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="c0fa1-117">Problemas do cruzamento de domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="c0fa1-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="c0fa1-118">Para isolar o código em ambientes de hospedagem gerenciadas, é comum gerar vários domínios de aplicativo filho com diretiva explícita, reduzindo os níveis de permissão para vários assemblies.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="c0fa1-119">No entanto, a política para esses assemblies permanece inalterada no domínio do aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="c0fa1-120">Se um dos domínios de aplicativo filho pode forçar o domínio de aplicativo padrão para carregar um assembly, o efeito de isolamento de código será perdido e os tipos no assembly carregado à força será capazes de executar código em um nível mais alto de confiança.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="c0fa1-121">Um domínio de aplicativo pode forçar outro domínio de aplicativo para carregar um assembly e executar o código contido nele, chamando um proxy para um objeto hospedado no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="c0fa1-122">Para obter um proxy entre domínios de aplicativo, o domínio de aplicativo que hospeda o objeto deve distribuir o meio de um valor de parâmetro ou retorno de chamada do método.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="c0fa1-123">Ou, se o domínio do aplicativo acabou de ser criado, o criador tem um proxy para o <xref:System.AppDomain> objeto por padrão.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="c0fa1-124">Portanto, para evitar a interrupção de isolamento de código, um domínio de aplicativo com um nível mais alto de confiança deve não distribuir as referências a objetos de marshaling por referência (instâncias de classes derivam de <xref:System.MarshalByRefObject>) em seu domínio para domínios de aplicativo com inferior níveis de confiança.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="c0fa1-125">Normalmente, o domínio de aplicativo padrão cria o filho domínios de aplicativo com um objeto de controle em cada um.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="c0fa1-126">O objeto de controle gerencia o novo domínio de aplicativo e, ocasionalmente, recebe pedidos de domínio de aplicativo padrão, mas ele não pode, na verdade, entre em contato com o domínio diretamente.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="c0fa1-127">Ocasionalmente, o domínio de aplicativo padrão chama seu proxy para o objeto de controle.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="c0fa1-128">No entanto, pode haver casos em que é necessário para o objeto de controle para o retorno de chamada para o domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="c0fa1-129">Nesses casos, o domínio de aplicativo padrão passa um objeto de retorno de chamada de marshaling por referência para o construtor do objeto de controle.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="c0fa1-130">É responsabilidade do objeto de controle para proteger esse proxy.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="c0fa1-131">Se o objeto de controle colocar o proxy em um campo estático público de uma classe pública ou expor publicamente o proxy, caso contrário, isso abriria um mecanismo perigoso para outro código de retorno de chamada no domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="c0fa1-132">Por esse motivo, os objetos de controle são sempre implicitamente confiáveis para manter o proxy particulares.</span><span class="sxs-lookup"><span data-stu-id="c0fa1-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c0fa1-133">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c0fa1-133">See also</span></span>

- [<span data-ttu-id="c0fa1-134">Diretrizes de codificação segura</span><span class="sxs-lookup"><span data-stu-id="c0fa1-134">Secure Coding Guidelines</span></span>](../../../docs/standard/security/secure-coding-guidelines.md)
