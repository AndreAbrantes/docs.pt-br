---
title: Visão geral da criação de perfil
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: cf29260c36437aaf679498f648d0fcac5d65f321
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558323"
---
# <a name="profiling-overview"></a><span data-ttu-id="b891d-102">Visão geral da criação de perfil</span><span class="sxs-lookup"><span data-stu-id="b891d-102">Profiling Overview</span></span>

<span data-ttu-id="b891d-103">Um criador de perfil é uma ferramenta que monitora a execução de outro aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="b891d-104">Um criador de perfil Common Language Runtime (CLR) é uma DLL (biblioteca de vínculo dinâmico) que consiste em funções que recebem mensagens e enviam mensagens para o CLR usando a API de criação de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="b891d-105">A DLL do criador de perfil é carregada pelo CLR em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="b891d-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="b891d-106">As ferramentas de criação de perfil tradicionais se concentram em medir a execução do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="b891d-107">Ou seja, eles medem o tempo gasto em cada função ou o uso de memória do aplicativo ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="b891d-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="b891d-108">A API de criação de perfil tem como alvo uma classe mais ampla de ferramentas de diagnóstico, como utilitários de cobertura de código e até mesmo auxílios de depuração avançados.</span><span class="sxs-lookup"><span data-stu-id="b891d-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="b891d-109">Esses usos são todos os diagnósticos por natureza.</span><span class="sxs-lookup"><span data-stu-id="b891d-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="b891d-110">A API de criação de perfil não apenas mede, mas também monitora a execução de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="b891d-111">Por esse motivo, a API de criação de perfil nunca deve ser usada pelo próprio aplicativo, e a execução do aplicativo não deve depender (ou ser afetada pelo) o criador de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="b891d-112">A criação de perfil de um aplicativo CLR requer mais suporte do que a criação de perfil de código de máquina compilado de uma convenção.</span><span class="sxs-lookup"><span data-stu-id="b891d-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="b891d-113">Isso ocorre porque o CLR apresenta conceitos como domínios de aplicativo, coleta de lixo, tratamento de exceção gerenciada, compilação JIT (just-in-time) de código (convertendo a linguagem intermediária da Microsoft ou MSIL, código no código do computador nativo) e recursos semelhantes.</span><span class="sxs-lookup"><span data-stu-id="b891d-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="b891d-114">Os mecanismos de criação de perfil convencionais não podem identificar ou fornecer informações úteis sobre esses recursos.</span><span class="sxs-lookup"><span data-stu-id="b891d-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="b891d-115">A API de criação de perfil fornece essas informações ausentes com eficiência, com efeito mínimo sobre o desempenho do CLR e do aplicativo de criação de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="b891d-116">A compilação JIT em tempo de execução fornece boas oportunidades de criação de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="b891d-117">A API de criação de perfil permite que um criador de perfil altere o fluxo de código MSIL na memória para uma rotina antes de ser compilado em JIT.</span><span class="sxs-lookup"><span data-stu-id="b891d-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="b891d-118">Dessa maneira, o criador de perfil pode adicionar dinamicamente o código de instrumentação a rotinas específicas que precisam de uma investigação mais profunda.</span><span class="sxs-lookup"><span data-stu-id="b891d-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="b891d-119">Embora essa abordagem seja possível em cenários convencionais, é muito mais fácil implementar para o CLR usando a API de criação de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="b891d-120">A API de criação de perfil</span><span class="sxs-lookup"><span data-stu-id="b891d-120">The Profiling API</span></span>

<span data-ttu-id="b891d-121">Normalmente, a API de criação de perfil é usada para escrever um *criador de perfil de código*, que é um programa que monitora a execução de um aplicativo gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="b891d-122">A API de criação de perfil é usada por uma DLL do criador de perfil, que é carregada no mesmo processo que o aplicativo cujo perfil está sendo criado.</span><span class="sxs-lookup"><span data-stu-id="b891d-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="b891d-123">A DLL do criador de perfil implementa uma interface de retorno de chamada ([ICorProfilerCallback](icorprofilercallback-interface.md) no .NET Framework versão 1,0 e 1,1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) na versão 2,0 e posterior).</span><span class="sxs-lookup"><span data-stu-id="b891d-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="b891d-124">O CLR chama os métodos nessa interface para notificar o criador de perfil de eventos no processo de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="b891d-125">O criador de perfil pode chamar de volta para o tempo de execução usando os métodos nas interfaces [ICorProfilerInfo](icorprofilerinfo-interface.md) e [ICorProfilerInfo2](icorprofilerinfo2-interface.md) para obter informações sobre o estado do aplicativo de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="b891d-126">Somente a parte de coleta de dados da solução do criador de perfil deve estar em execução no mesmo processo que o aplicativo com perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="b891d-127">Toda a interface do usuário e a análise de dados devem ser executadas em um processo separado.</span><span class="sxs-lookup"><span data-stu-id="b891d-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="b891d-128">A ilustração a seguir mostra como a DLL do criador de perfil interage com o aplicativo cujo perfil está sendo criado e o CLR.</span><span class="sxs-lookup"><span data-stu-id="b891d-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![Captura de tela que mostra a arquitetura de criação de perfil.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="b891d-130">As interfaces de notificação</span><span class="sxs-lookup"><span data-stu-id="b891d-130">The Notification Interfaces</span></span>

<span data-ttu-id="b891d-131">[ICorProfilerCallback](icorprofilercallback-interface.md) e [ICorProfilerCallback2](icorprofilercallback2-interface.md) podem ser considerados interfaces de notificação.</span><span class="sxs-lookup"><span data-stu-id="b891d-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="b891d-132">Essas interfaces consistem em métodos como [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md)e [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="b891d-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="b891d-133">Cada vez que o CLR carrega ou descarrega uma classe, compila uma função e assim por diante, ele chama o método correspondente na interface ou do criador de perfil `ICorProfilerCallback` `ICorProfilerCallback2` .</span><span class="sxs-lookup"><span data-stu-id="b891d-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="b891d-134">Por exemplo, um criador de perfil pode medir o desempenho do código por meio de duas funções de notificação: [FunctionEnter2](functionenter2-function.md) e [FunctionLeave2](functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="b891d-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="b891d-135">Apenas os carimbos de data/hora de cada notificação, acumula resultados e gera uma lista que indica quais funções consumiram a maior parte da CPU ou do tempo de entrada de parede durante a execução do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="b891d-136">As interfaces de recuperação de informações</span><span class="sxs-lookup"><span data-stu-id="b891d-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="b891d-137">As outras interfaces principais envolvidas na criação de perfil são [ICorProfilerInfo](icorprofilerinfo-interface.md) e [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="b891d-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="b891d-138">O criador de perfil chama essas interfaces conforme necessário para obter mais informações para ajudar sua análise.</span><span class="sxs-lookup"><span data-stu-id="b891d-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="b891d-139">Por exemplo, sempre que o CLR chama a função [FunctionEnter2](functionenter2-function.md) , ele fornece um identificador de função.</span><span class="sxs-lookup"><span data-stu-id="b891d-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="b891d-140">O criador de perfil pode obter mais informações sobre essa função chamando o método [ICorProfilerInfo2:: GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) para descobrir a classe pai da função, seu nome e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="b891d-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="b891d-141">Recursos com suporte</span><span class="sxs-lookup"><span data-stu-id="b891d-141">Supported Features</span></span>

<span data-ttu-id="b891d-142">A API de criação de perfil fornece informações sobre uma variedade de eventos e ações que ocorrem no Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="b891d-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="b891d-143">Você pode usar essas informações para monitorar o funcionamento interno dos processos e analisar o desempenho do seu aplicativo .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b891d-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="b891d-144">A API de criação de perfil recupera informações sobre as seguintes ações e eventos que ocorrem no CLR:</span><span class="sxs-lookup"><span data-stu-id="b891d-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="b891d-145">Eventos de inicialização e desligamento CLR.</span><span class="sxs-lookup"><span data-stu-id="b891d-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="b891d-146">Eventos de criação e desligamento de domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="b891d-147">Assembly carregando e descarregando eventos.</span><span class="sxs-lookup"><span data-stu-id="b891d-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="b891d-148">Carregando e descarregando eventos do módulo.</span><span class="sxs-lookup"><span data-stu-id="b891d-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="b891d-149">Eventos de criação e destruição COM vtable.</span><span class="sxs-lookup"><span data-stu-id="b891d-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="b891d-150">Compilação JIT (just-in-time) e eventos de densidade de código.</span><span class="sxs-lookup"><span data-stu-id="b891d-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="b891d-151">Carregamento de classe e descarregamento de eventos.</span><span class="sxs-lookup"><span data-stu-id="b891d-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="b891d-152">Criação de threads e eventos de destruição.</span><span class="sxs-lookup"><span data-stu-id="b891d-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="b891d-153">Eventos de entrada e saída de função.</span><span class="sxs-lookup"><span data-stu-id="b891d-153">Function entry and exit events.</span></span>

- <span data-ttu-id="b891d-154">Exceções.</span><span class="sxs-lookup"><span data-stu-id="b891d-154">Exceptions.</span></span>

- <span data-ttu-id="b891d-155">Transições entre a execução de código gerenciado e não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="b891d-156">Transições entre diferentes contextos de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="b891d-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="b891d-157">Informações sobre as suspensões de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="b891d-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="b891d-158">Informações sobre a pilha de memória de tempo de execução e a atividade de coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="b891d-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="b891d-159">A API de criação de perfil pode ser chamada de qualquer linguagem compatível COM COM (não gerenciado).</span><span class="sxs-lookup"><span data-stu-id="b891d-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="b891d-160">A API é eficiente em relação ao consumo de CPU e de memória.</span><span class="sxs-lookup"><span data-stu-id="b891d-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="b891d-161">A criação de perfil não envolve alterações no aplicativo de perfil que são significativas o suficiente para causar resultados enganosos.</span><span class="sxs-lookup"><span data-stu-id="b891d-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="b891d-162">A API de criação de perfil é útil para os infileres de amostragem e não amostragem.</span><span class="sxs-lookup"><span data-stu-id="b891d-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="b891d-163">Um *gerador de perfil de amostragem* inspeciona o perfil em tiques regulares do relógio, digamos, a 5 milissegundos de distância.</span><span class="sxs-lookup"><span data-stu-id="b891d-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="b891d-164">Um *criador de perfil de não amostragem* é informado de um evento de forma síncrona com o thread que causa o evento.</span><span class="sxs-lookup"><span data-stu-id="b891d-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="b891d-165">Funcionalidade sem suporte</span><span class="sxs-lookup"><span data-stu-id="b891d-165">Unsupported Functionality</span></span>

<span data-ttu-id="b891d-166">A API de criação de perfil não oferece suporte para a seguinte funcionalidade:</span><span class="sxs-lookup"><span data-stu-id="b891d-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="b891d-167">Código não gerenciado, que deve ser criado com o uso de métodos Win32 convencionais.</span><span class="sxs-lookup"><span data-stu-id="b891d-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="b891d-168">No entanto, o criador de perfil do CLR inclui eventos de transição para determinar os limites entre código gerenciado e não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="b891d-169">Aplicativos de modificação automática que modificam seu próprio código para fins como programação orientada a aspectos.</span><span class="sxs-lookup"><span data-stu-id="b891d-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="b891d-170">Verificação de limites, porque a API de criação de perfil não fornece essas informações.</span><span class="sxs-lookup"><span data-stu-id="b891d-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="b891d-171">O CLR fornece suporte intrínseco para a verificação de limites de todo o código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="b891d-172">Criação de perfil remota, que não tem suporte pelos seguintes motivos:</span><span class="sxs-lookup"><span data-stu-id="b891d-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="b891d-173">A criação de perfil remota estende o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="b891d-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="b891d-174">Ao usar as interfaces de criação de perfil, você deve minimizar o tempo de execução para que os resultados da criação de perfil não sejam afetados de forma indevidamente.</span><span class="sxs-lookup"><span data-stu-id="b891d-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="b891d-175">Isso é especialmente verdadeiro quando o desempenho da execução está sendo monitorado.</span><span class="sxs-lookup"><span data-stu-id="b891d-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="b891d-176">No entanto, a criação de perfil remota não é uma limitação quando as interfaces de criação de perfil são usadas para monitorar o uso de memória ou para obter informações em tempo de execução sobre quadros de pilha, objetos e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="b891d-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="b891d-177">O criador de perfil de código CLR deve registrar uma ou mais interfaces de retorno de chamada com o tempo de execução no computador local no qual o aplicativo de perfil está sendo executado.</span><span class="sxs-lookup"><span data-stu-id="b891d-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="b891d-178">Isso limita a capacidade de criar um criador de perfil de código remoto.</span><span class="sxs-lookup"><span data-stu-id="b891d-178">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="b891d-179">Threads de notificação</span><span class="sxs-lookup"><span data-stu-id="b891d-179">Notification Threads</span></span>

<span data-ttu-id="b891d-180">Na maioria dos casos, o thread que gera um evento também executa notificações.</span><span class="sxs-lookup"><span data-stu-id="b891d-180">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="b891d-181">Essas notificações (por exemplo, [FunctionEnter](functionenter-function.md) e [FunctionLeave](functionleave-function.md)) não precisam fornecer o Explicit `ThreadID` .</span><span class="sxs-lookup"><span data-stu-id="b891d-181">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="b891d-182">Além disso, o criador de perfil pode decidir usar o armazenamento local de thread para armazenar e atualizar seus blocos de análise em vez de indexar os blocos de análise no armazenamento global, com base no `ThreadID` thread afetado.</span><span class="sxs-lookup"><span data-stu-id="b891d-182">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="b891d-183">Observe que esses retornos de chamada não são serializados.</span><span class="sxs-lookup"><span data-stu-id="b891d-183">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="b891d-184">Os usuários devem proteger seu código criando estruturas de dados thread-safe e bloqueando o código do criador de perfil quando necessário para impedir o acesso paralelo de vários threads.</span><span class="sxs-lookup"><span data-stu-id="b891d-184">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="b891d-185">Portanto, em alguns casos, você pode receber uma sequência incomum de retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="b891d-185">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="b891d-186">Por exemplo, suponha que um aplicativo gerenciado está gerando dois threads que estão executando código idêntico.</span><span class="sxs-lookup"><span data-stu-id="b891d-186">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="b891d-187">Nesse caso, é possível receber um evento [ICorProfilerCallback:: JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) para algumas funções de um thread e um `FunctionEnter` retorno de chamada do outro thread antes de receber o retorno de chamada [ICorProfilerCallback:: JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) .</span><span class="sxs-lookup"><span data-stu-id="b891d-187">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="b891d-188">Nesse caso, o usuário receberá um `FunctionEnter` retorno de chamada para uma função que talvez não tenha sido totalmente compilada JIT (just-in-time) ainda.</span><span class="sxs-lookup"><span data-stu-id="b891d-188">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="b891d-189">Segurança</span><span class="sxs-lookup"><span data-stu-id="b891d-189">Security</span></span>

<span data-ttu-id="b891d-190">Uma DLL do criador de perfil é uma DLL não gerenciada que é executada como parte do mecanismo de execução de Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="b891d-190">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="b891d-191">Como resultado, o código na DLL do criador de perfil não está sujeito às restrições da segurança de acesso ao código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-191">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="b891d-192">As únicas limitações na DLL do criador de perfil são aquelas impostas pelo sistema operacional no usuário que está executando o aplicativo de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-192">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="b891d-193">Os autores do criador de perfil devem tomar as precauções apropriadas para evitar problemas relacionados à segurança.</span><span class="sxs-lookup"><span data-stu-id="b891d-193">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="b891d-194">Por exemplo, durante a instalação, uma DLL do criador de perfil deve ser adicionada a uma ACL (lista de controle de acesso) para que um usuário mal-intencionado não possa modificá-la.</span><span class="sxs-lookup"><span data-stu-id="b891d-194">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="b891d-195">Combinando código gerenciado e não gerenciado em um criador de perfil de código</span><span class="sxs-lookup"><span data-stu-id="b891d-195">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="b891d-196">Um criador de perfil escrito incorretamente pode causar referências circulares a si mesmo, resultando em um comportamento imprevisível.</span><span class="sxs-lookup"><span data-stu-id="b891d-196">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="b891d-197">Uma revisão da API de criação de perfil do CLR pode criar a impressão de que você pode escrever um criador de perfil que contém componentes gerenciados e não gerenciados que chamam uns aos outros por meio de interoperabilidade COM ou chamadas indiretas.</span><span class="sxs-lookup"><span data-stu-id="b891d-197">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="b891d-198">Embora isso seja possível a partir de uma perspectiva de design, a API de criação de perfil não oferece suporte a componentes gerenciados.</span><span class="sxs-lookup"><span data-stu-id="b891d-198">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="b891d-199">Um criador de perfil do CLR deve ser completamente não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-199">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="b891d-200">As tentativas de combinar código gerenciado e não gerenciado em um criador de perfil do CLR podem causar violações de acesso, falha do programa ou deadlocks.</span><span class="sxs-lookup"><span data-stu-id="b891d-200">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="b891d-201">Os componentes gerenciados do criador de perfil irão acionar eventos de volta para seus componentes não gerenciados, o que chamaria posteriormente os componentes gerenciados, resultando em referências circulares.</span><span class="sxs-lookup"><span data-stu-id="b891d-201">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="b891d-202">O único local em que um criador de perfil do CLR pode chamar o código gerenciado com segurança está no corpo da MSIL (Microsoft Intermediate Language) de um método.</span><span class="sxs-lookup"><span data-stu-id="b891d-202">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="b891d-203">A prática recomendada para modificar o corpo da MSIL é usar os métodos de recompilação JIT na interface [ICorProfilerCallback4](icorprofilercallback4-interface.md) .</span><span class="sxs-lookup"><span data-stu-id="b891d-203">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="b891d-204">Também é possível usar os métodos de instrumentação mais antigos para modificar a MSIL.</span><span class="sxs-lookup"><span data-stu-id="b891d-204">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="b891d-205">Antes que a compilação JIT (just-in-time) de uma função seja concluída, o criador de perfil pode inserir chamadas gerenciadas no corpo MSIL de um método e, em seguida, compilá-la JIT (consulte o método [ICorProfilerInfo:: GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) ).</span><span class="sxs-lookup"><span data-stu-id="b891d-205">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="b891d-206">Essa técnica pode ser usada com êxito para instrumentação seletiva de código gerenciado ou para coletar estatísticas e dados de desempenho sobre o JIT.</span><span class="sxs-lookup"><span data-stu-id="b891d-206">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="b891d-207">Como alternativa, um criador de perfil de código pode inserir ganchos nativos no corpo MSIL de cada função gerenciada que chama o código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-207">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="b891d-208">Essa técnica pode ser usada para instrumentação e cobertura.</span><span class="sxs-lookup"><span data-stu-id="b891d-208">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="b891d-209">Por exemplo, um criador de perfil de código poderia inserir ganchos de instrumentação depois de cada bloco MSIL para garantir que o bloco tenha sido executado.</span><span class="sxs-lookup"><span data-stu-id="b891d-209">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="b891d-210">A modificação do corpo MSIL de um método é uma operação muito delicado, e há muitos fatores que devem ser levados em consideração.</span><span class="sxs-lookup"><span data-stu-id="b891d-210">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="b891d-211">Criando perfil de código não gerenciado</span><span class="sxs-lookup"><span data-stu-id="b891d-211">Profiling Unmanaged Code</span></span>

<span data-ttu-id="b891d-212">A API de criação de perfil do Common Language Runtime (CLR) fornece suporte mínimo para a criação de perfil de código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-212">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="b891d-213">A seguinte funcionalidade é fornecida:</span><span class="sxs-lookup"><span data-stu-id="b891d-213">The following functionality is provided:</span></span>

- <span data-ttu-id="b891d-214">Enumeração de cadeias de pilha.</span><span class="sxs-lookup"><span data-stu-id="b891d-214">Enumeration of stack chains.</span></span> <span data-ttu-id="b891d-215">Esse recurso permite que um criador de perfil de código determine o limite entre código gerenciado e código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b891d-215">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="b891d-216">Determinar se uma cadeia de pilha corresponde ao código gerenciado ou ao código nativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-216">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="b891d-217">No .NET Framework versões 1,0 e 1,1, esses métodos estão disponíveis por meio do subconjunto em processo da API de depuração CLR.</span><span class="sxs-lookup"><span data-stu-id="b891d-217">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="b891d-218">Eles são definidos no arquivo CorDebug. idl.</span><span class="sxs-lookup"><span data-stu-id="b891d-218">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="b891d-219">No .NET Framework 2,0 e posterior, você pode usar o método [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) para essa funcionalidade.</span><span class="sxs-lookup"><span data-stu-id="b891d-219">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="b891d-220">Usando COM</span><span class="sxs-lookup"><span data-stu-id="b891d-220">Using COM</span></span>

<span data-ttu-id="b891d-221">Embora as interfaces de criação de perfil sejam definidas como interfaces COM, o Common Language Runtime (CLR) não inicializa de fato COM para usar essas interfaces.</span><span class="sxs-lookup"><span data-stu-id="b891d-221">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="b891d-222">O motivo é evitar a necessidade de definir o modelo de threading usando a função [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) antes que o aplicativo gerenciado tenha a oportunidade de especificar seu modelo de threading desejado.</span><span class="sxs-lookup"><span data-stu-id="b891d-222">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="b891d-223">Da mesma forma, o criador de perfil em si não deve chamar `CoInitialize` , pois pode escolher um modelo de Threading que é incompatível com o aplicativo cujo perfil está sendo criado e pode causar uma falha no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b891d-223">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="b891d-224">Pilhas de Chamadas</span><span class="sxs-lookup"><span data-stu-id="b891d-224">Call Stacks</span></span>

<span data-ttu-id="b891d-225">A API de criação de perfil fornece duas maneiras de obter pilhas de chamadas: um método de instantâneo de pilha, que permite a coleta esparsa de pilhas de chamadas e um método de pilha de sombra, que controla a pilha de chamadas em todos os instantes.</span><span class="sxs-lookup"><span data-stu-id="b891d-225">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="b891d-226">Instantâneo da pilha</span><span class="sxs-lookup"><span data-stu-id="b891d-226">Stack Snapshot</span></span>

<span data-ttu-id="b891d-227">Um instantâneo de pilha é um rastreamento da pilha de um thread em um instante no tempo.</span><span class="sxs-lookup"><span data-stu-id="b891d-227">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="b891d-228">A API de criação de perfil dá suporte ao rastreamento de funções gerenciadas na pilha, mas deixa o rastreamento de funções não gerenciadas para o próprio Stack Walker do criador de perfil.</span><span class="sxs-lookup"><span data-stu-id="b891d-228">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="b891d-229">Para obter mais informações sobre como programar o criador de perfil para movimentar pilhas gerenciadas, consulte o método [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) neste conjunto de documentação e [movimentação de pilha do profiler no .NET Framework 2,0: Noções básicas e além disso](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="b891d-229">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="b891d-230">Pilha de sombra</span><span class="sxs-lookup"><span data-stu-id="b891d-230">Shadow Stack</span></span>

<span data-ttu-id="b891d-231">Usar o método de instantâneo com muita frequência pode criar rapidamente um problema de desempenho.</span><span class="sxs-lookup"><span data-stu-id="b891d-231">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="b891d-232">Se você quiser fazer rastreamentos de pilha com frequência, seu criador de perfil deverá criar uma pilha de sombra usando os retornos de chamada de exceção [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md)e [ICorProfilerCallback2](icorprofilercallback2-interface.md) .</span><span class="sxs-lookup"><span data-stu-id="b891d-232">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="b891d-233">A pilha de sombra é sempre atual e pode ser copiada rapidamente para o armazenamento sempre que um instantâneo de pilha é necessário.</span><span class="sxs-lookup"><span data-stu-id="b891d-233">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="b891d-234">Uma pilha de sombra pode obter argumentos de função, valores de retorno e informações sobre instanciações genéricas.</span><span class="sxs-lookup"><span data-stu-id="b891d-234">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="b891d-235">Essas informações estão disponíveis apenas por meio da pilha de sombra e podem ser obtidas quando o controle é entregue a uma função.</span><span class="sxs-lookup"><span data-stu-id="b891d-235">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="b891d-236">No entanto, essas informações podem não estar disponíveis posteriormente durante a execução da função.</span><span class="sxs-lookup"><span data-stu-id="b891d-236">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="b891d-237">Retornos de chamada e profundidade da pilha</span><span class="sxs-lookup"><span data-stu-id="b891d-237">Callbacks and Stack Depth</span></span>

<span data-ttu-id="b891d-238">Os retornos de chamada do profiler podem ser emitidos em circunstâncias com restrições de pilha e um estouro de pilha em um retorno de chamada do criador de perfil levará a uma saída de processo imediata.</span><span class="sxs-lookup"><span data-stu-id="b891d-238">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="b891d-239">Um criador de perfil deve se certificar de usar a menor pilha possível em resposta a retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="b891d-239">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="b891d-240">Se o criador de perfil for destinado ao uso em processos que são robustos contra estouro de pilha, o criador de perfil em si também deve evitar o disparo do estouro de pilha.</span><span class="sxs-lookup"><span data-stu-id="b891d-240">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b891d-241">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="b891d-241">Related Topics</span></span>

|<span data-ttu-id="b891d-242">Título</span><span class="sxs-lookup"><span data-stu-id="b891d-242">Title</span></span>|<span data-ttu-id="b891d-243">Descrição</span><span class="sxs-lookup"><span data-stu-id="b891d-243">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="b891d-244">Configurando um ambiente de criação de perfil</span><span class="sxs-lookup"><span data-stu-id="b891d-244">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="b891d-245">Explica como inicializar um profiler, definir notificações de eventos e criar um perfil de um serviço do Windows.</span><span class="sxs-lookup"><span data-stu-id="b891d-245">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="b891d-246">Criação de perfil de interfaces</span><span class="sxs-lookup"><span data-stu-id="b891d-246">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="b891d-247">Descreve as interfaces não gerenciadas que a API de criação de perfil usa.</span><span class="sxs-lookup"><span data-stu-id="b891d-247">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="b891d-248">Criando perfil de funções estáticas globais</span><span class="sxs-lookup"><span data-stu-id="b891d-248">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="b891d-249">Descreve as funções estáticas globais não gerenciadas que a API de criação de perfil usa.</span><span class="sxs-lookup"><span data-stu-id="b891d-249">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="b891d-250">Criando perfil de enumerações</span><span class="sxs-lookup"><span data-stu-id="b891d-250">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="b891d-251">Descreve as enumerações não gerenciadas que a API de criação de perfil usa.</span><span class="sxs-lookup"><span data-stu-id="b891d-251">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="b891d-252">Estruturas de criação de perfil</span><span class="sxs-lookup"><span data-stu-id="b891d-252">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="b891d-253">Descreve as estruturas não gerenciadas que a API de criação de perfil usa.</span><span class="sxs-lookup"><span data-stu-id="b891d-253">Describes the unmanaged structures that the profiling API uses.</span></span>|
