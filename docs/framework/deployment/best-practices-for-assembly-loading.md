---
title: Práticas recomendadas para carregamento de assemblies
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
author: mairaw
ms.author: mairaw
ms.openlocfilehash: a95679f659f13956fd230f07e9401af9097a043c
ms.sourcegitcommit: 55f438d4d00a34b9aca9eedaac3f85590bb11565
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/23/2019
ms.locfileid: "71182473"
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="f5be2-102">Práticas recomendadas para carregamento de assemblies</span><span class="sxs-lookup"><span data-stu-id="f5be2-102">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="f5be2-103">Este artigo descreve maneiras de evitar problemas de identidade de tipo que podem levar a <xref:System.InvalidCastException>, <xref:System.MissingMethodException> e outros erros.</span><span class="sxs-lookup"><span data-stu-id="f5be2-103">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="f5be2-104">O artigo aborda as seguintes recomendações:</span><span class="sxs-lookup"><span data-stu-id="f5be2-104">The article discusses the following recommendations:</span></span>  
  
- [<span data-ttu-id="f5be2-105">Entenda as vantagens e as desvantagens dos contextos de carregamento</span><span class="sxs-lookup"><span data-stu-id="f5be2-105">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
- [<span data-ttu-id="f5be2-106">Evite associações em nomes de assembly parciais</span><span class="sxs-lookup"><span data-stu-id="f5be2-106">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
- [<span data-ttu-id="f5be2-107">Evite o carregamento de um assembly em vários contextos</span><span class="sxs-lookup"><span data-stu-id="f5be2-107">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
- [<span data-ttu-id="f5be2-108">Evite o carregamento de várias versões de um assembly no mesmo contexto</span><span class="sxs-lookup"><span data-stu-id="f5be2-108">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
- [<span data-ttu-id="f5be2-109">Considere a possibilidade de alternar para o contexto de carregamento padrão</span><span class="sxs-lookup"><span data-stu-id="f5be2-109">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="f5be2-110">A primeira recomendação, [entenda as vantagens e desvantagens de contextos de carga](#load_contexts), fornece informações de plano de fundo para as outras recomendações, porque todas elas dependem de um conhecimento de contextos de carregamento.</span><span class="sxs-lookup"><span data-stu-id="f5be2-110">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>   
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="f5be2-111">Entenda as vantagens e as desvantagens dos contextos de carregamento</span><span class="sxs-lookup"><span data-stu-id="f5be2-111">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="f5be2-112">Em um domínio do aplicativo, os assemblies podem ser carregados em um dos três contextos ou podem ser carregados sem contexto:</span><span class="sxs-lookup"><span data-stu-id="f5be2-112">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
- <span data-ttu-id="f5be2-113">O contexto de carregamento padrão contém assemblies localizados investigando o cache de assembly global, o armazenamento do assembly do host se o tempo de execução é hospedado (por exemplo, no SQL Server) e o <xref:System.AppDomainSetup.ApplicationBase%2A> e o <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-113">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="f5be2-114">A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.</span><span class="sxs-lookup"><span data-stu-id="f5be2-114">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
- <span data-ttu-id="f5be2-115">O contexto de origem de carregamento contém assemblies carregados a partir de locais que não são pesquisados pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="f5be2-115">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="f5be2-116">Por exemplo, suplementos podem ser instalados em um diretório que não está no caminho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-116">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="f5be2-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> e <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> são exemplos de métodos que carregam pelo caminho.</span><span class="sxs-lookup"><span data-stu-id="f5be2-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
- <span data-ttu-id="f5be2-118">O contexto somente para reflexão contém assemblies carregados com os métodos <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f5be2-118">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="f5be2-119">O código neste contexto não pode ser executado, portanto, não é discutido aqui.</span><span class="sxs-lookup"><span data-stu-id="f5be2-119">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="f5be2-120">Para obter mais informações, confira [Como: carregar assemblies no contexto somente de reflexão](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="f5be2-120">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
- <span data-ttu-id="f5be2-121">Se você gerou um assembly dinâmico transitório usando a emissão de reflexo, o assembly não está em nenhum contexto.</span><span class="sxs-lookup"><span data-stu-id="f5be2-121">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="f5be2-122">Além disso, a maioria dos assemblies carregados usando o método <xref:System.Reflection.Assembly.LoadFile%2A> são carregados sem contexto e os assemblies carregados de matrizes de bytes são carregados sem contexto, a menos que sua identidade (depois que a política é aplicada) estabeleça que estão no cache de assembly global.</span><span class="sxs-lookup"><span data-stu-id="f5be2-122">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="f5be2-123">Os contextos de execução têm vantagens e desvantagens, conforme discutido nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="f5be2-123">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="f5be2-124">Contexto de carregamento padrão</span><span class="sxs-lookup"><span data-stu-id="f5be2-124">Default Load Context</span></span>  
 <span data-ttu-id="f5be2-125">Quando os assemblies são carregados no contexto de carregamento padrão, suas dependências são carregadas automaticamente.</span><span class="sxs-lookup"><span data-stu-id="f5be2-125">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="f5be2-126">As dependências carregadas no contexto de carregamento padrão são encontradas automaticamente para assemblies no contexto de carregamento padrão ou no contexto de origem de carregamento.</span><span class="sxs-lookup"><span data-stu-id="f5be2-126">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="f5be2-127">O carregamento por identidade do assembly aumenta a estabilidade de aplicativos ao garantir que versões desconhecidas do aplicativo não sejam usadas (consulte a seção [Evite associações em nomes de assembly parciais](#avoid_partial_names)).</span><span class="sxs-lookup"><span data-stu-id="f5be2-127">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="f5be2-128">Usar o contexto de carregamento padrão tem as seguintes desvantagens:</span><span class="sxs-lookup"><span data-stu-id="f5be2-128">Using the default load context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="f5be2-129">As dependências carregadas em outros contextos não estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="f5be2-129">Dependencies that are loaded into other contexts are not available.</span></span>  
  
- <span data-ttu-id="f5be2-130">Você não pode carregar assemblies de locais fora do caminho de investigação para o contexto de carregamento padrão.</span><span class="sxs-lookup"><span data-stu-id="f5be2-130">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="f5be2-131">Contexto de origem de carregamento</span><span class="sxs-lookup"><span data-stu-id="f5be2-131">Load-From Context</span></span>  
 <span data-ttu-id="f5be2-132">O contexto de origem de carregamento permite que você carregue um assembly de um caminho que não está no caminho do aplicativo e, portanto, não está incluído na investigação.</span><span class="sxs-lookup"><span data-stu-id="f5be2-132">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="f5be2-133">Ele permite que as dependências sejam localizadas e carregadas a partir desse caminho porque as informações de caminho são mantidas pelo contexto.</span><span class="sxs-lookup"><span data-stu-id="f5be2-133">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="f5be2-134">Além disso, os assemblies nesse contexto podem usar dependências carregadas no contexto de carregamento padrão.</span><span class="sxs-lookup"><span data-stu-id="f5be2-134">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="f5be2-135">Carregar assemblies usando o método <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, ou um dos outros métodos que carregam pelo caminho, tem as seguintes desvantagens:</span><span class="sxs-lookup"><span data-stu-id="f5be2-135">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
- <span data-ttu-id="f5be2-136">Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-136">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
- <span data-ttu-id="f5be2-137">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A> e posteriormente um assembly no contexto de carregamento padrão tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará.</span><span class="sxs-lookup"><span data-stu-id="f5be2-137">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="f5be2-138">Isso pode ocorrer quando um assembly é desserializado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-138">This can occur when an assembly is deserialized.</span></span>  
  
- <span data-ttu-id="f5be2-139">Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A> e o caminho de investigação inclui um assembly com a mesma identidade, mas em um local diferente, um <xref:System.InvalidCastException>, <xref:System.MissingMethodException> ou outro comportamento inesperado pode ocorrer.</span><span class="sxs-lookup"><span data-stu-id="f5be2-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
- <span data-ttu-id="f5be2-140"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-140"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
- <span data-ttu-id="f5be2-141">Se existir uma imagem nativa para o assembly, ela não será usada.</span><span class="sxs-lookup"><span data-stu-id="f5be2-141">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="f5be2-142">O assembly não pode ser carregado como de domínio neutro.</span><span class="sxs-lookup"><span data-stu-id="f5be2-142">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="f5be2-143">Nas versões do .NET Framework 1.0 e 1.1, a política não é aplicada.</span><span class="sxs-lookup"><span data-stu-id="f5be2-143">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="f5be2-144">Sem contexto</span><span class="sxs-lookup"><span data-stu-id="f5be2-144">No Context</span></span>  
 <span data-ttu-id="f5be2-145">O carregamento sem contexto é a única opção para assemblies transitórios que são gerados com a emissão de reflexão.</span><span class="sxs-lookup"><span data-stu-id="f5be2-145">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="f5be2-146">O carregamento sem contexto é a única maneira de carregar vários assemblies que têm a mesma identidade em um domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-146">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="f5be2-147">O custo de investigação é evitado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-147">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="f5be2-148">Os assemblies que são carregados de matrizes de bytes são carregados sem contexto, a menos que a identidade do assembly, que é estabelecida quando a política é aplicada, corresponda à identidade de um assembly no cache de assembly global. Nesse caso, o assembly é carregado do cache de assembly global.</span><span class="sxs-lookup"><span data-stu-id="f5be2-148">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="f5be2-149">Carregar assemblies sem contexto tem as seguintes desvantagens:</span><span class="sxs-lookup"><span data-stu-id="f5be2-149">Loading assemblies without context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="f5be2-150">Outros assemblies não podem ser associados a assemblies que são carregados sem contexto, a menos que você manipule o evento <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5be2-150">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="f5be2-151">As dependências não são carregadas automaticamente.</span><span class="sxs-lookup"><span data-stu-id="f5be2-151">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="f5be2-152">Você pode pré-carregá-las sem contexto, pré-carregá-las no contexto de carregamento padrão ou carregá-las manipulando o evento <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5be2-152">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="f5be2-153">Carregar vários assemblies com a mesma identidade sem contexto pode causar problemas de identidade de tipo semelhantes aos causados por carregar assemblies com a mesma identidade em vários contextos.</span><span class="sxs-lookup"><span data-stu-id="f5be2-153">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="f5be2-154">Consulte [Evite o carregamento de um assembly em vários contextos](#avoid_loading_into_multiple_contexts).</span><span class="sxs-lookup"><span data-stu-id="f5be2-154">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
- <span data-ttu-id="f5be2-155">Se existir uma imagem nativa para o assembly, ela não será usada.</span><span class="sxs-lookup"><span data-stu-id="f5be2-155">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="f5be2-156">O assembly não pode ser carregado como de domínio neutro.</span><span class="sxs-lookup"><span data-stu-id="f5be2-156">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="f5be2-157">Nas versões do .NET Framework 1.0 e 1.1, a política não é aplicada.</span><span class="sxs-lookup"><span data-stu-id="f5be2-157">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>   
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="f5be2-158">Evite associações em nomes de assembly parciais</span><span class="sxs-lookup"><span data-stu-id="f5be2-158">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="f5be2-159">A associação de nome parcial ocorre quando você especifica apenas parte do nome de exibição do assembly (<xref:System.Reflection.Assembly.FullName%2A>) ao carregar um assembly.</span><span class="sxs-lookup"><span data-stu-id="f5be2-159">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="f5be2-160">Por exemplo, você pode chamar o método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> com somente o nome simples do assembly, omitindo a versão, a cultura e o token de chave pública.</span><span class="sxs-lookup"><span data-stu-id="f5be2-160">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="f5be2-161">Ou você pode chamar o método <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>, que primeiro chama o método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> e, se ele falhar em localizar o assembly, pesquisa o cache de assembly global e carrega a versão mais recente disponível do assembly.</span><span class="sxs-lookup"><span data-stu-id="f5be2-161">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="f5be2-162">A associação de nome parcial pode causar vários problemas, incluindo o seguinte:</span><span class="sxs-lookup"><span data-stu-id="f5be2-162">Partial name binding can cause many problems, including the following:</span></span>  
  
- <span data-ttu-id="f5be2-163">O método <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> pode carregar um assembly diferente com o mesmo nome simples.</span><span class="sxs-lookup"><span data-stu-id="f5be2-163">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="f5be2-164">Por exemplo, dois aplicativos podem instalar dois assemblies completamente diferentes que têm o nome simples `GraphicsLibrary` no cache de assembly global.</span><span class="sxs-lookup"><span data-stu-id="f5be2-164">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
- <span data-ttu-id="f5be2-165">O assembly realmente carregado pode não ser compatível com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="f5be2-165">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="f5be2-166">Por exemplo, não especificar a versão pode resultar no carregamento de uma versão muito posterior à versão que seu programa foi originalmente escrito para usar.</span><span class="sxs-lookup"><span data-stu-id="f5be2-166">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="f5be2-167">Alterações na versão mais recente podem causar erros no seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-167">Changes in the later version might cause errors in your application.</span></span>  
  
- <span data-ttu-id="f5be2-168">O assembly realmente carregado pode não ser compatível com versões futuras.</span><span class="sxs-lookup"><span data-stu-id="f5be2-168">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="f5be2-169">Por exemplo, você pode ter compilado e testado seu aplicativo com a versão mais recente de um assembly, mas a associação parcial pode carregar uma versão muito anterior que não possui recursos que seu aplicativo usa.</span><span class="sxs-lookup"><span data-stu-id="f5be2-169">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
- <span data-ttu-id="f5be2-170">Instalar novos aplicativos pode interromper aplicativos existentes.</span><span class="sxs-lookup"><span data-stu-id="f5be2-170">Installing new applications can break existing applications.</span></span> <span data-ttu-id="f5be2-171">Um aplicativo que usa o método <xref:System.Reflection.Assembly.LoadWithPartialName%2A> pode ser interrompido ao instalar uma versão incompatível mais recente de um assembly compartilhado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-171">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
- <span data-ttu-id="f5be2-172">O carregamento de dependência inesperado pode ocorrer.</span><span class="sxs-lookup"><span data-stu-id="f5be2-172">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="f5be2-173">Se você carregar dois assemblies que compartilham uma dependência, carregá-los com a associação parcial pode resultar em um assembly usando um componente com o qual ele não foi compilado ou testado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-173">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="f5be2-174">Devido aos problemas que isso pode causar, o método <xref:System.Reflection.Assembly.LoadWithPartialName%2A> foi marcado como obsoleto.</span><span class="sxs-lookup"><span data-stu-id="f5be2-174">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="f5be2-175">É recomendável que você use o método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> em vez disso e especifique os nomes de exibição completos do assembly.</span><span class="sxs-lookup"><span data-stu-id="f5be2-175">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="f5be2-176">Consulte [Entenda as vantagens e as desvantagens dos contextos de carregamento](#load_contexts) e [Considere a possibilidade de alternar para o contexto de carregamento padrão](#switch_to_default).</span><span class="sxs-lookup"><span data-stu-id="f5be2-176">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="f5be2-177">Se você quiser usar o método <xref:System.Reflection.Assembly.LoadWithPartialName%2A> porque ele facilita o carregamento de assembly, considere que seu aplicativo falhar com uma mensagem de erro que identifica o assembly ausente provavelmente fornecerá uma experiência de usuário melhor do que usar automaticamente uma versão desconhecida do assembly, o que pode causar um comportamento imprevisível e falhas de segurança.</span><span class="sxs-lookup"><span data-stu-id="f5be2-177">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>   
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="f5be2-178">Evite o carregamento de um assembly em vários contextos</span><span class="sxs-lookup"><span data-stu-id="f5be2-178">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="f5be2-179">Carregar um assembly em vários contextos pode causar problemas de identidade de tipo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-179">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="f5be2-180">Se o mesmo tipo for carregado a partir do mesmo assembly em dois contextos diferentes, é como se dois tipos diferentes com o mesmo nome tivessem sido carregados.</span><span class="sxs-lookup"><span data-stu-id="f5be2-180">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="f5be2-181">Uma <xref:System.InvalidCastException> é lançada se você tenta converter um tipo para outro, com a mensagem confusa de que o tipo `MyType` não pode ser convertido para o tipo `MyType`.</span><span class="sxs-lookup"><span data-stu-id="f5be2-181">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="f5be2-182">Por exemplo, suponha que a interface `ICommunicate` é declarada em um assembly chamado `Utility`, que é referenciado por seu programa e também por outros assemblies que seu programa carrega.</span><span class="sxs-lookup"><span data-stu-id="f5be2-182">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="f5be2-183">Esses outros assemblies contêm tipos que implementam a interface `ICommunicate`, permitindo que seu programa os use.</span><span class="sxs-lookup"><span data-stu-id="f5be2-183">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="f5be2-184">Agora, considere o que acontece quando o programa é executado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-184">Now consider what happens when your program is run.</span></span> <span data-ttu-id="f5be2-185">Os assemblies referenciados pelo seu programa são carregados no contexto de carregamento padrão.</span><span class="sxs-lookup"><span data-stu-id="f5be2-185">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="f5be2-186">Se você carregar um assembly de destino por sua identidade, usando o método <xref:System.Reflection.Assembly.Load%2A>, ele estará no contexto de carregamento padrão, assim como suas dependências.</span><span class="sxs-lookup"><span data-stu-id="f5be2-186">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="f5be2-187">O programa e o assembly de destino usarão o mesmo assembly `Utility`.</span><span class="sxs-lookup"><span data-stu-id="f5be2-187">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="f5be2-188">No entanto, suponha que você carregue o assembly de destino por seu caminho de arquivo, usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="f5be2-188">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f5be2-189">O assembly é carregado sem qualquer contexto, portanto, suas dependências não são carregadas automaticamente.</span><span class="sxs-lookup"><span data-stu-id="f5be2-189">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="f5be2-190">Você pode ter um manipulador para o evento <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> para fornecer a dependência e pode carregar o assembly `Utility` sem nenhum contexto usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="f5be2-190">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f5be2-191">Agora quando você cria uma instância de um tipo que está contido no assembly de destino e tente atribuí-la a uma variável do tipo `ICommunicate`, uma <xref:System.InvalidCastException> é gerada porque o tempo de execução considera as interfaces `ICommunicate` em duas cópias do assembly `Utility` para tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="f5be2-191">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="f5be2-192">Há muitos outros cenários em que um assembly pode ser carregado em vários contextos.</span><span class="sxs-lookup"><span data-stu-id="f5be2-192">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="f5be2-193">A melhor abordagem é evitar conflitos realocando o assembly de destino no caminho do aplicativo e usando o método <xref:System.Reflection.Assembly.Load%2A> com o nome de exibição completo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-193">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="f5be2-194">O assembly é então carregado no contexto de carregamento padrão e ambos os assemblies usam o mesmo assembly `Utility`.</span><span class="sxs-lookup"><span data-stu-id="f5be2-194">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="f5be2-195">Se o assembly de destino dever permanecer fora do caminho do aplicativo, você pode usar o método <xref:System.Reflection.Assembly.LoadFrom%2A> para carregá-lo no contexto de origem de carregamento.</span><span class="sxs-lookup"><span data-stu-id="f5be2-195">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="f5be2-196">Se o assembly de destino foi compilado com uma referência ao assembly `Utility` do seu aplicativo, ele usará o assembly `Utility` em que seu aplicativo carregou no contexto de carregamento padrão.</span><span class="sxs-lookup"><span data-stu-id="f5be2-196">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="f5be2-197">Observe que podem ocorrer problemas se o assembly de destino tiver uma dependência em uma cópia do assembly `Utility` localizado fora do caminho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-197">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="f5be2-198">Se o assembly for carregado no contexto de origem de carregamento antes de seu aplicativo carregar o assembly `Utility`, o carregamento do aplicativo falhará.</span><span class="sxs-lookup"><span data-stu-id="f5be2-198">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="f5be2-199">A seção [Considere a possibilidade de alternar para o contexto de carregamento padrão](#switch_to_default) discute alternativas ao uso de cargas de caminho de arquivo como <xref:System.Reflection.Assembly.LoadFile%2A> e <xref:System.Reflection.Assembly.LoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f5be2-199">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>   
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="f5be2-200">Evite o carregamento de várias versões de um assembly no mesmo contexto</span><span class="sxs-lookup"><span data-stu-id="f5be2-200">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="f5be2-201">Carregar várias versões de um assembly em um contexto de carregamento pode causar problemas de identidade de tipo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-201">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="f5be2-202">Se o mesmo tipo for carregado a partir de duas versões do mesmo assembly, é como se dois tipos diferentes com o mesmo nome tivessem sido carregados.</span><span class="sxs-lookup"><span data-stu-id="f5be2-202">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="f5be2-203">Uma <xref:System.InvalidCastException> é lançada se você tenta converter um tipo para outro, com a mensagem confusa de que o tipo `MyType` não pode ser convertido para o tipo `MyType`.</span><span class="sxs-lookup"><span data-stu-id="f5be2-203">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="f5be2-204">Por exemplo, seu programa pode carregar uma versão do assembly `Utility` diretamente e posteriormente ele pode carregar outro assembly que carrega uma versão diferente do assembly `Utility`.</span><span class="sxs-lookup"><span data-stu-id="f5be2-204">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="f5be2-205">Ou um erro de código pode fazer com que dois caminhos de código diferentes no aplicativo carreguem versões diferentes de um assembly.</span><span class="sxs-lookup"><span data-stu-id="f5be2-205">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="f5be2-206">No contexto de carregamento padrão, esse problema pode ocorrer quando você usa o método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> e especifica os nomes de exibição completos do assembly que incluem números de versão diferentes.</span><span class="sxs-lookup"><span data-stu-id="f5be2-206">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="f5be2-207">Para assemblies que são carregados sem contexto, o problema pode ser causado pelo uso do método <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> para carregar o mesmo assembly de diferentes caminhos.</span><span class="sxs-lookup"><span data-stu-id="f5be2-207">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="f5be2-208">O tempo de execução considera dois assemblies que são carregados de caminhos diferentes para serem assemblies diferentes, mesmo que suas identidades sejam as mesmas.</span><span class="sxs-lookup"><span data-stu-id="f5be2-208">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="f5be2-209">Além dos problemas de identidade de tipo, várias versões de um assembly podem causar um <xref:System.MissingMethodException> se um tipo carregado de uma versão do assembly é passado para o código que espera esse tipo de uma versão diferente.</span><span class="sxs-lookup"><span data-stu-id="f5be2-209">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="f5be2-210">Por exemplo, o código pode esperar um método que foi adicionado à versão mais recente.</span><span class="sxs-lookup"><span data-stu-id="f5be2-210">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="f5be2-211">Podem ocorrer erros mais sutis se o comportamento do tipo foi alterado entre as versões.</span><span class="sxs-lookup"><span data-stu-id="f5be2-211">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="f5be2-212">Por exemplo, um método pode lançar uma exceção inesperada ou retornar um valor inesperado.</span><span class="sxs-lookup"><span data-stu-id="f5be2-212">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="f5be2-213">Examine cuidadosamente o código para garantir que apenas uma versão de um assembly esteja carregada.</span><span class="sxs-lookup"><span data-stu-id="f5be2-213">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="f5be2-214">Você pode usar o método <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> para determinar quais assemblies são carregados em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="f5be2-214">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>   
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="f5be2-215">Considere a possibilidade de alternar para o contexto de carregamento padrão</span><span class="sxs-lookup"><span data-stu-id="f5be2-215">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="f5be2-216">Examine os padrões de implantação e carregamento de assembly do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-216">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="f5be2-217">Você pode eliminar os assemblies carregados de matrizes de bytes?</span><span class="sxs-lookup"><span data-stu-id="f5be2-217">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="f5be2-218">Você pode mover assemblies para o caminho de investigação?</span><span class="sxs-lookup"><span data-stu-id="f5be2-218">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="f5be2-219">Se os assemblies estão localizados no cache de assembly global ou caminho de investigação do domínio do aplicativo (isto é, seu <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A>), você pode carregar o assembly por sua identidade.</span><span class="sxs-lookup"><span data-stu-id="f5be2-219">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="f5be2-220">Se não for possível colocar todos os assemblies no caminho de investigação, considere alternativas como usar o modelo de suplemento do .NET Framework, colocar os assemblies no cache de assembly global ou criar domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f5be2-220">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="f5be2-221">Considere usar o modelo de suplemento do Framework .NET</span><span class="sxs-lookup"><span data-stu-id="f5be2-221">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="f5be2-222">Se você estiver usando o contexto de carregamento para implementar suplementos, que normalmente não são instalados na base de aplicativo, use o modelo de suplemento do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f5be2-222">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="f5be2-223">Esse modelo fornece isolamento no nível de domínio ou processo do aplicativo, sem a necessidade de gerenciar domínios do aplicativo por conta própria.</span><span class="sxs-lookup"><span data-stu-id="f5be2-223">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="f5be2-224">Para obter informações sobre o modelo de suplemento, consulte [Suplementos e extensibilidade](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span><span class="sxs-lookup"><span data-stu-id="f5be2-224">For information about the add-in model, see [Add-ins and Extensibility](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="f5be2-225">Considere usar o cache de assembly global</span><span class="sxs-lookup"><span data-stu-id="f5be2-225">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="f5be2-226">Coloque os assemblies no cache de assembly global para obter o benefício de um caminho de assembly compartilhado que está fora da base de aplicativo, sem perder as vantagens do contexto de carregamento padrão ou assumir as desvantagens dos outros contextos.</span><span class="sxs-lookup"><span data-stu-id="f5be2-226">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="f5be2-227">Considere usar domínios do aplicativo</span><span class="sxs-lookup"><span data-stu-id="f5be2-227">Consider Using Application Domains</span></span>  
 <span data-ttu-id="f5be2-228">Se você determinar que alguns de seus assemblies não podem ser implantados no caminho de investigação do aplicativo, considere criar um novo domínio do aplicativo para esses assemblies.</span><span class="sxs-lookup"><span data-stu-id="f5be2-228">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="f5be2-229">Use um <xref:System.AppDomainSetup> para criar o novo domínio do aplicativo e use a propriedade <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> para especificar o caminho que contém os assemblies que você deseja carregar.</span><span class="sxs-lookup"><span data-stu-id="f5be2-229">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="f5be2-230">Se você tiver vários diretórios para investigar, é possível definir a <xref:System.AppDomainSetup.ApplicationBase%2A> para um diretório raiz e usar a propriedade <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> para identificar os subdiretórios a serem investigados.</span><span class="sxs-lookup"><span data-stu-id="f5be2-230">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="f5be2-231">Como alternativa, você pode criar vários domínios de aplicativo e definir o <xref:System.AppDomainSetup.ApplicationBase%2A> de cada domínio do aplicativo para o caminho adequado para seus assemblies.</span><span class="sxs-lookup"><span data-stu-id="f5be2-231">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="f5be2-232">Observe que você pode usar o método <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> para carregar esses assemblies.</span><span class="sxs-lookup"><span data-stu-id="f5be2-232">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="f5be2-233">Como agora eles estão no caminho de investigação, eles serão carregados no contexto de carregamento padrão em vez de no contexto de origem do carregamento.</span><span class="sxs-lookup"><span data-stu-id="f5be2-233">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="f5be2-234">No entanto, recomendamos que você alterne para o método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> e forneça nomes de exibição completos do assembly para garantir que as versões corretas sejam sempre usadas.</span><span class="sxs-lookup"><span data-stu-id="f5be2-234">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f5be2-235">Consulte também</span><span class="sxs-lookup"><span data-stu-id="f5be2-235">See also</span></span>

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
