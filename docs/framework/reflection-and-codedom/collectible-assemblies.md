---
title: "Assemblies de coleção para a geração de tipo dinâmico"
description: 
ms.date: 08/29/2017
ms.prod: .net
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- reflection, dynamic assembly
- assemblies, collectible
- collectible assemblies, retrieving
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 2c9a613f4cc13c3e4189a59ace2e05d01d1bcb4f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="collectible-assemblies-for-dynamic-type-generation"></a><span data-ttu-id="285b6-102">Assemblies de coleção para a geração de tipo dinâmico</span><span class="sxs-lookup"><span data-stu-id="285b6-102">Collectible assemblies for dynamic type generation</span></span>

<span data-ttu-id="285b6-103">*Assemblies de coleção* são assemblies dinâmicos que podem ser baixados sem descarregar o domínio de aplicativo no qual eles foram criados.</span><span class="sxs-lookup"><span data-stu-id="285b6-103">*Collectible assemblies* are dynamic assemblies that can be unloaded without unloading the application domain in which they were created.</span></span> <span data-ttu-id="285b6-104">Pode ser recuperada toda gerenciada e a memória usada por um assembly de coleção e os tipos que ele contém.</span><span class="sxs-lookup"><span data-stu-id="285b6-104">All managed and unmanaged memory used by a collectible assembly and the types it contains can be reclaimed.</span></span> <span data-ttu-id="285b6-105">Informações como o nome do assembly são removidas das tabelas internas.</span><span class="sxs-lookup"><span data-stu-id="285b6-105">Information such as the assembly name is removed from internal tables.</span></span>

<span data-ttu-id="285b6-106">Para habilitar o descarregamento, use o <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> sinalizador quando você cria um assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="285b6-106">To enable unloading, use the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> flag when you create a dynamic assembly.</span></span> <span data-ttu-id="285b6-107">O assembly é transitório (isto é, ele não pode ser salvo) e está sujeita às limitações descritas no [restrições em Assemblies de coleção](#restrictions-on-collectible-assemblies) seção.</span><span class="sxs-lookup"><span data-stu-id="285b6-107">The assembly is transient (that is, it cannot be saved) and is subject to limitations described in the [Restrictions on Collectible Assemblies](#restrictions-on-collectible-assemblies) section.</span></span> <span data-ttu-id="285b6-108">O common language runtime (CLR) descarrega um assembly de coleção automaticamente quando você liberar todos os objetos associados ao assembly.</span><span class="sxs-lookup"><span data-stu-id="285b6-108">The common language runtime (CLR) unloads a collectible assembly automatically when you release all objects associated with the assembly.</span></span> <span data-ttu-id="285b6-109">Em todos os outros aspectos, os assemblies de coleção são criados e usados da mesma maneira como outros assemblies dinâmicos.</span><span class="sxs-lookup"><span data-stu-id="285b6-109">In all other respects, collectible assemblies are created and used in the same way as other dynamic assemblies.</span></span>

## <a name="lifetime-of-collectible-assemblies"></a><span data-ttu-id="285b6-110">Tempo de vida de assemblies de coleção</span><span class="sxs-lookup"><span data-stu-id="285b6-110">Lifetime of collectible assemblies</span></span>

<span data-ttu-id="285b6-111">O tempo de vida de um assembly de coleção é controlado pela existência de referências para os tipos que ele contém e os objetos que são criados a partir desses tipos.</span><span class="sxs-lookup"><span data-stu-id="285b6-111">The lifetime of a collectible assembly is controlled by the existence of references to the types it contains and the objects that are created from those types.</span></span> <span data-ttu-id="285b6-112">O common language runtime não descarregar um assembly como um ou mais dos seguintes existe (`T` é qualquer tipo que é definido no assembly):</span><span class="sxs-lookup"><span data-stu-id="285b6-112">The common language runtime does not unload an assembly as long as one or more of the following exist (`T` is any type that is defined in the assembly):</span></span> 

- <span data-ttu-id="285b6-113">Uma instância de `T`.</span><span class="sxs-lookup"><span data-stu-id="285b6-113">An instance of `T`.</span></span>

- <span data-ttu-id="285b6-114">Uma instância de uma matriz de `T`.</span><span class="sxs-lookup"><span data-stu-id="285b6-114">An instance of an array of `T`.</span></span>
 
- <span data-ttu-id="285b6-115">Uma instância de um tipo genérico que tenha `T` como um de seus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="285b6-115">An instance of a generic type that has `T` as one of its type arguments.</span></span> <span data-ttu-id="285b6-116">Isso inclui coleções genéricas do `T`, mesmo se a coleção está vazia.</span><span class="sxs-lookup"><span data-stu-id="285b6-116">This includes generic collections of `T`, even if that collection is empty.</span></span>

- <span data-ttu-id="285b6-117">Uma instância de <xref:System.Type> ou <xref:System.Reflection.Emit.TypeBuilder> que representa `T`.</span><span class="sxs-lookup"><span data-stu-id="285b6-117">An instance of <xref:System.Type> or <xref:System.Reflection.Emit.TypeBuilder> that represents `T`.</span></span> 

   > [!IMPORTANT]
   > <span data-ttu-id="285b6-118">Você deve liberar todos os objetos que representam as partes do assembly.</span><span class="sxs-lookup"><span data-stu-id="285b6-118">You must release all objects that represent parts of the assembly.</span></span> <span data-ttu-id="285b6-119">O <xref:System.Reflection.Emit.ModuleBuilder> que define `T` mantém uma referência para o <xref:System.Reflection.Emit.TypeBuilder>e o <xref:System.Reflection.Emit.AssemblyBuilder> objeto mantém uma referência para o <xref:System.Reflection.Emit.ModuleBuilder>, portanto, as referências a esses objetos devem ser liberadas.</span><span class="sxs-lookup"><span data-stu-id="285b6-119">The <xref:System.Reflection.Emit.ModuleBuilder> that defines `T` keeps a reference to the <xref:System.Reflection.Emit.TypeBuilder>, and the <xref:System.Reflection.Emit.AssemblyBuilder> object keeps a reference to the <xref:System.Reflection.Emit.ModuleBuilder>, so references to these objects must be released.</span></span> <span data-ttu-id="285b6-120">Até mesmo a existência de um <xref:System.Reflection.Emit.LocalBuilder> ou um <xref:System.Reflection.Emit.ILGenerator> usada na construção de `T` impede descarregar.</span><span class="sxs-lookup"><span data-stu-id="285b6-120">Even the existence of a <xref:System.Reflection.Emit.LocalBuilder> or an <xref:System.Reflection.Emit.ILGenerator> used in the construction of `T` prevents unloading.</span></span>

- <span data-ttu-id="285b6-121">Uma referência estática a `T` por outro tipo definido de forma dinâmica `T1` que é ainda pode ser acessado pelo código em execução.</span><span class="sxs-lookup"><span data-stu-id="285b6-121">A static reference to `T` by another dynamically defined type `T1` that is still reachable by executing code.</span></span> <span data-ttu-id="285b6-122">Por exemplo, `T1` podem derivar de `T`, ou `T` pode ser o tipo de um parâmetro em um método de `T1`.</span><span class="sxs-lookup"><span data-stu-id="285b6-122">For example, `T1` might derive from `T`, or `T` might be the type of a parameter in a method of `T1`.</span></span>
 
- <span data-ttu-id="285b6-123">Um **ByRef** para um campo estático que pertence a `T`.</span><span class="sxs-lookup"><span data-stu-id="285b6-123">A **ByRef** to a static field that belongs to `T`.</span></span>

- <span data-ttu-id="285b6-124">Um <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, ou <xref:System.RuntimeMethodHandle> que se refere a `T` ou a um componente de `T`.</span><span class="sxs-lookup"><span data-stu-id="285b6-124">A <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, or <xref:System.RuntimeMethodHandle> that refers to `T` or to a component of `T`.</span></span>

- <span data-ttu-id="285b6-125">Uma instância de qualquer objeto de reflexão que pode ser usado indiretamente ou diretamente para acessar o <xref:System.Type> objeto que representa `T`.</span><span class="sxs-lookup"><span data-stu-id="285b6-125">An instance of any reflection object that could be used indirectly or directly to access the <xref:System.Type> object that represents `T`.</span></span> <span data-ttu-id="285b6-126">Por exemplo, o <xref:System.Type> de objeto para `T` pode ser obtido de um tipo de matriz cujo tipo de elemento é `T`, ou de um tipo genérico que tenha `T` como um argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="285b6-126">For example, the <xref:System.Type> object for `T` can be obtained from an array type whose element type is `T`, or from a generic type that has `T` as a type argument.</span></span> 

- <span data-ttu-id="285b6-127">Um método `M` na pilha de chamadas de qualquer thread, onde `M` é um método de `T` ou um método de nível de módulo é definido no assembly.</span><span class="sxs-lookup"><span data-stu-id="285b6-127">A method `M` on the call stack of any thread, where `M` is a method of `T` or a module-level method that is defined in the assembly.</span></span>

- <span data-ttu-id="285b6-128">Um delegado a um método estático que é definido em um módulo do assembly.</span><span class="sxs-lookup"><span data-stu-id="285b6-128">A delegate to a static method that is defined in a module of the assembly.</span></span>

<span data-ttu-id="285b6-129">Se houver um item da lista para apenas um tipo ou um método no assembly, apenas o tempo de execução não é possível descarregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="285b6-129">If only one item from this list exists for only one type or one method in the assembly, the runtime cannot unload the assembly.</span></span>

> [!NOTE]
> <span data-ttu-id="285b6-130">O tempo de execução não descarregar, na verdade, o assembly até finalizadores executar para todos os itens na lista.</span><span class="sxs-lookup"><span data-stu-id="285b6-130">The runtime does not actually unload the assembly until finalizers have run for all items in the list.</span></span>

<span data-ttu-id="285b6-131">Para fins de controle de tempo de vida, um construído tipo genérico, como `List<int>` (em c#) ou `List(Of Integer)` (no Visual Basic), que é criado e usado na geração de um assembly de coleção é considerada como tendo sido definido no assembly que contém o genérico definição de tipo ou em um assembly que contém a definição de um de seus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="285b6-131">For purposes of tracking lifetime, a constructed generic type such as `List<int>` (in C#) or `List(Of Integer)` (in Visual Basic) that is created and used in the generation of a collectible assembly is considered to have been defined either in the assembly that contains the generic type definition or in an assembly that contains the definition of one of its type arguments.</span></span> <span data-ttu-id="285b6-132">O conjunto exato usado é um detalhe de implementação e sujeito a alterações.</span><span class="sxs-lookup"><span data-stu-id="285b6-132">The exact assembly that is used is an implementation detail and subject to change.</span></span>
 
## <a name="restrictions-on-collectible-assemblies"></a><span data-ttu-id="285b6-133">Restrições em assemblies de coleção</span><span class="sxs-lookup"><span data-stu-id="285b6-133">Restrictions on collectible assemblies</span></span>

<span data-ttu-id="285b6-134">As seguintes restrições se aplicam a assemblies de coleção:</span><span class="sxs-lookup"><span data-stu-id="285b6-134">The following restrictions apply to collectible assemblies:</span></span> 

- <span data-ttu-id="285b6-135">**Referências estáticas** </span><span class="sxs-lookup"><span data-stu-id="285b6-135">**Static references** </span></span>  
  <span data-ttu-id="285b6-136">Tipos em um assembly dinâmico comum não podem ter referências estáticas para tipos que são definidos em um assembly de coleção.</span><span class="sxs-lookup"><span data-stu-id="285b6-136">Types in an ordinary dynamic assembly cannot have static references to types that are defined in a collectible assembly.</span></span> <span data-ttu-id="285b6-137">Por exemplo, se você definir um tipo comum que herda de um tipo em um assembly de coleção, um <xref:System.NotSupportedException> exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="285b6-137">For example, if you define an ordinary type that inherits from a type in a collectible assembly, a <xref:System.NotSupportedException> exception is thrown.</span></span> <span data-ttu-id="285b6-138">Um tipo em um assembly de coleção pode ter referências estáticas para um tipo em outro assembly de coleção, mas isso aumenta o tempo de vida do assembly referenciado para o tempo de vida do assembly de referência.</span><span class="sxs-lookup"><span data-stu-id="285b6-138">A type in a collectible assembly can have static references to a type in another collectible assembly, but this extends the lifetime of the referenced assembly to the lifetime of the referencing assembly.</span></span>

- <span data-ttu-id="285b6-139">**Interoperabilidade COM** </span><span class="sxs-lookup"><span data-stu-id="285b6-139">**COM interop** </span></span>  
   <span data-ttu-id="285b6-140">Nenhuma interfaces COM podem ser definidos em um assembly de coleção e não há instâncias de tipos em um assembly de coleção podem ser convertidas em objetos COM.</span><span class="sxs-lookup"><span data-stu-id="285b6-140">No COM interfaces can be defined within a collectible assembly, and no instances of types within a collectible assembly can be converted into COM objects.</span></span> <span data-ttu-id="285b6-141">Um tipo em um assembly de coleção não pode servir como um invólucro (CCW) ou (RCW) runtime callable wrapper.</span><span class="sxs-lookup"><span data-stu-id="285b6-141">A type in a collectible assembly cannot serve as a COM callable wrapper (CCW) or runtime callable wrapper (RCW).</span></span> <span data-ttu-id="285b6-142">No entanto, os tipos em assemblies de coleção podem usar objetos que implementam interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="285b6-142">However, types in collectible assemblies can use objects that implement COM interfaces.</span></span>

- <span data-ttu-id="285b6-143">**Invocação de plataforma** </span><span class="sxs-lookup"><span data-stu-id="285b6-143">**Platform invoke** </span></span>  
   <span data-ttu-id="285b6-144">Os métodos que possuem o <xref:System.Runtime.InteropServices.DllImportAttribute> atributo não será compilado quando eles são declarados em um assembly de coleção.</span><span class="sxs-lookup"><span data-stu-id="285b6-144">Methods that have the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute will not compile when they are declared in a collectible assembly.</span></span> <span data-ttu-id="285b6-145">O <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> instrução não pode ser usada na implementação de um tipo em um assembly de coleção e não podem ser empacotados esses tipos para código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="285b6-145">The <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> instruction cannot be used in the implementation of a type in a collectible assembly, and such types cannot be marshaled to unmanaged code.</span></span> <span data-ttu-id="285b6-146">No entanto, você pode chamar código nativo por meio de um ponto de entrada que é declarado em um assembly de coleção.</span><span class="sxs-lookup"><span data-stu-id="285b6-146">However, you can call into native code by using an entry point that is declared in a non-collectible assembly.</span></span>
 
- <span data-ttu-id="285b6-147">**Realização de marshaling** </span><span class="sxs-lookup"><span data-stu-id="285b6-147">**Marshaling** </span></span>  
   <span data-ttu-id="285b6-148">Objetos (em particular, delegados) que são definidos em assemblies de coleção não podem ser empacotados.</span><span class="sxs-lookup"><span data-stu-id="285b6-148">Objects (in particular, delegates) that are defined in collectible assemblies cannot be marshaled.</span></span> <span data-ttu-id="285b6-149">Esta é uma restrição em todos os tipos de emitido transitórios.</span><span class="sxs-lookup"><span data-stu-id="285b6-149">This is a restriction on all transient emitted types.</span></span>

- <span data-ttu-id="285b6-150">**Carregamento do assembly** </span><span class="sxs-lookup"><span data-stu-id="285b6-150">**Assembly loading** </span></span>  
   <span data-ttu-id="285b6-151">Emissão de reflexão é o único mecanismo que tem suporte para o carregamento de assemblies de coleção.</span><span class="sxs-lookup"><span data-stu-id="285b6-151">Reflection emit is the only mechanism that is supported for loading collectible assemblies.</span></span> <span data-ttu-id="285b6-152">Assemblies são carregados por meio de qualquer outra forma de carregamento do assembly não podem ser descarregados.</span><span class="sxs-lookup"><span data-stu-id="285b6-152">Assemblies that are loaded by using any other form of assembly loading cannot be unloaded.</span></span>
 
- <span data-ttu-id="285b6-153">**Objetos associados ao contexto**  </span><span class="sxs-lookup"><span data-stu-id="285b6-153">**Context-bound objects**  </span></span>  
   <span data-ttu-id="285b6-154">Não há suporte para variáveis de contexto estático.</span><span class="sxs-lookup"><span data-stu-id="285b6-154">Context-static variables are not supported.</span></span> <span data-ttu-id="285b6-155">Não é possível estender tipos em um assembly de coleção <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="285b6-155">Types in a collectible assembly cannot extend <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="285b6-156">No entanto, o código em assemblies de coleção pode usar objetos associados a contexto que são definidos em outro lugar.</span><span class="sxs-lookup"><span data-stu-id="285b6-156">However, code in collectible assemblies can use context-bound objects that are defined elsewhere.</span></span>

- <span data-ttu-id="285b6-157">**Dados de thread estático**     </span><span class="sxs-lookup"><span data-stu-id="285b6-157">**Thread-static data**     </span></span>  
   <span data-ttu-id="285b6-158">Não há suporte para variáveis de thread estático.</span><span class="sxs-lookup"><span data-stu-id="285b6-158">Thread-static variables are not supported.</span></span>

## <a name="see-also"></a><span data-ttu-id="285b6-159">Consulte também</span><span class="sxs-lookup"><span data-stu-id="285b6-159">See also</span></span>

[<span data-ttu-id="285b6-160">Emissão de métodos e assemblies dinâmicos</span><span class="sxs-lookup"><span data-stu-id="285b6-160">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
