---
title: 'Como: Definir um método genérico com a emissão de reflexão'
description: Defina um método genérico com emissão de reflexão. Um exemplo cria um método genérico com dois parâmetros de tipo. Um segundo exemplo mostra como emitir o corpo do método.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- reflection emit, generic methods
- generics [.NET Framework], dynamic types
ms.assetid: 93892fa4-90b3-4ec4-b147-4bec9880de2b
ms.openlocfilehash: 3b85fb480e5862daa3b2800f75392adbe92348f2
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865132"
---
# <a name="how-to-define-a-generic-method-with-reflection-emit"></a><span data-ttu-id="83932-105">Como: Definir um método genérico com a emissão de reflexão</span><span class="sxs-lookup"><span data-stu-id="83932-105">How to: Define a Generic Method with Reflection Emit</span></span>

<span data-ttu-id="83932-106">O primeiro procedimento mostra como criar um método genérico simples com dois parâmetros de tipo e como aplicar restrições de classe, restrições de interface e restrições especiais aos parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="83932-106">The first procedure shows how to create a simple generic method with two type parameters, and how to apply class constraints, interface constraints, and special constraints to the type parameters.</span></span>

<span data-ttu-id="83932-107">O segundo procedimento mostra como emitir o corpo do método e como usar os parâmetros de tipo do método genérico para criar instâncias de tipos genéricos e chamar seus métodos.</span><span class="sxs-lookup"><span data-stu-id="83932-107">The second procedure shows how to emit the method body, and how to use the type parameters of the generic method to create instances of generic types and to call their methods.</span></span>

<span data-ttu-id="83932-108">O terceiro procedimento mostra como invocar o método genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-108">The third procedure shows how to invoke the generic method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="83932-109">Um método não é genérico apenas porque pertence a um tipo genérico e usa os parâmetros de tipo desse tipo.</span><span class="sxs-lookup"><span data-stu-id="83932-109">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="83932-110">Um método será genérico somente se ele tiver sua própria lista de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="83932-110">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="83932-111">Um método genérico pode aparecer em um tipo não genérico, como neste exemplo.</span><span class="sxs-lookup"><span data-stu-id="83932-111">A generic method can appear on a nongeneric type, as in this example.</span></span> <span data-ttu-id="83932-112">Para obter um exemplo de um método não genérico em um tipo genérico, consulte [Como definir um tipo genérico com a emissão de reflexão](how-to-define-a-generic-type-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="83932-112">For an example of a nongeneric method on a generic type, see [How to: Define a Generic Type with Reflection Emit](how-to-define-a-generic-type-with-reflection-emit.md).</span></span>

### <a name="to-define-a-generic-method"></a><span data-ttu-id="83932-113">Para definir um método genérico</span><span class="sxs-lookup"><span data-stu-id="83932-113">To define a generic method</span></span>

1. <span data-ttu-id="83932-114">Antes de começar, é útil observar como o método genérico aparece quando escrito usando uma linguagem de alto nível.</span><span class="sxs-lookup"><span data-stu-id="83932-114">Before beginning, it is useful to look at how the generic method appears when written using a high-level language.</span></span> <span data-ttu-id="83932-115">O código a seguir está incluído no código de exemplo deste tópico, juntamente com o código para chamar o método genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-115">The following code is included in the example code for this topic, along with code to call the generic method.</span></span> <span data-ttu-id="83932-116">O método tem dois parâmetros de tipo, `TInput` e `TOutput`, o segundo dos quais deve ser um tipo de referência (`class`), deve ter um construtor sem parâmetros (`new`) e deve implementar `ICollection(Of TInput)` (`ICollection<TInput>` em C#).</span><span class="sxs-lookup"><span data-stu-id="83932-116">The method has two type parameters, `TInput` and `TOutput`, the second of which must be a reference type (`class`), must have a parameterless constructor (`new`), and must implement `ICollection(Of TInput)` (`ICollection<TInput>` in C#).</span></span> <span data-ttu-id="83932-117">Essa restrição de interface garante que o método <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> pode ser usado para adicionar elementos à coleção `TOutput` que o método cria.</span><span class="sxs-lookup"><span data-stu-id="83932-117">This interface constraint ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method can be used to add elements to the `TOutput` collection that the method creates.</span></span> <span data-ttu-id="83932-118">O método tem um parâmetro formal, `input`, que é uma matriz de `TInput`.</span><span class="sxs-lookup"><span data-stu-id="83932-118">The method has one formal parameter, `input`, which is an array of `TInput`.</span></span> <span data-ttu-id="83932-119">O método cria uma coleção do tipo `TOutput` e copia os elementos de `input` para a coleção.</span><span class="sxs-lookup"><span data-stu-id="83932-119">The method creates a collection of type `TOutput` and copies the elements of `input` to the collection.</span></span>

    [!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]
    [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]

2. <span data-ttu-id="83932-120">Defina um assembly dinâmico e um módulo dinâmico para conter o tipo ao qual o método genérico pertence.</span><span class="sxs-lookup"><span data-stu-id="83932-120">Define a dynamic assembly and a dynamic module to contain the type the generic method belongs to.</span></span> <span data-ttu-id="83932-121">Nesse caso, o assembly tem apenas um módulo, chamado `DemoMethodBuilder1` e o nome do módulo é o mesmo nome do assembly com a adição de uma extensão.</span><span class="sxs-lookup"><span data-stu-id="83932-121">In this case, the assembly has only one module, named `DemoMethodBuilder1`, and the module name is the same as the assembly name plus an extension.</span></span> <span data-ttu-id="83932-122">Neste exemplo, o assembly é salvo no disco e também executado, portanto, <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> é especificado.</span><span class="sxs-lookup"><span data-stu-id="83932-122">In this example, the assembly is saved to disk and also executed, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> is specified.</span></span> <span data-ttu-id="83932-123">Você pode usar o [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md) para examinar o DemoMethodBuilder1.dll e compará-lo à MSIL (	Microsoft Intermediate Language) para o método mostrado na etapa 1.</span><span class="sxs-lookup"><span data-stu-id="83932-123">You can use the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md) to examine DemoMethodBuilder1.dll and to compare it to the Microsoft intermediate language (MSIL) for the method shown in step 1.</span></span>

    [!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]
    [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]

3. <span data-ttu-id="83932-124">Defina o tipo ao qual o método genérico pertence.</span><span class="sxs-lookup"><span data-stu-id="83932-124">Define the type the generic method belongs to.</span></span> <span data-ttu-id="83932-125">O tipo não precisa ser genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-125">The type does not have to be generic.</span></span> <span data-ttu-id="83932-126">Um método genérico pode pertencer a um tipo genérico ou não genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-126">A generic method can belong to either a generic or nongeneric type.</span></span> <span data-ttu-id="83932-127">Neste exemplo, o tipo é uma classe, não é genérico e é chamado `DemoType`.</span><span class="sxs-lookup"><span data-stu-id="83932-127">In this example, the type is a class, is not generic, and is named `DemoType`.</span></span>

    [!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]
    [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]

4. <span data-ttu-id="83932-128">Defina o método genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-128">Define the generic method.</span></span> <span data-ttu-id="83932-129">Se os tipos dos parâmetros formais de um método genérico forem especificados por parâmetros de tipo genérico do método genérico, use a sobrecarga do método <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> para definir o método.</span><span class="sxs-lookup"><span data-stu-id="83932-129">If the types of a generic method's formal parameters are specified by generic type parameters of the generic method, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> method overload to define the method.</span></span> <span data-ttu-id="83932-130">Os parâmetros de tipo genérico do método ainda não foram definidos, portanto você não pode especificar os tipos dos parâmetros formais do método na chamada para <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-130">The generic type parameters of the method are not yet defined, so you cannot specify the types of the method's formal parameters in the call to <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span></span> <span data-ttu-id="83932-131">Neste exemplo, o método é chamado `Factory`.</span><span class="sxs-lookup"><span data-stu-id="83932-131">In this example, the method is named `Factory`.</span></span> <span data-ttu-id="83932-132">O método é público e `static` (`Shared` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="83932-132">The method is public and `static` (`Shared` in Visual Basic).</span></span>

    [!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]
    [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]

5. <span data-ttu-id="83932-133">Defina os parâmetros de tipo genérico de `DemoMethod` passando uma matriz de cadeias de caracteres que contém os nomes dos parâmetros para o método <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83932-133">Define the generic type parameters of `DemoMethod` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="83932-134">Isso torna o método um método genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-134">This makes the method a generic method.</span></span> <span data-ttu-id="83932-135">O código a seguir torna `Factory` um método genérico com parâmetros de tipo `TInput` e `TOutput`.</span><span class="sxs-lookup"><span data-stu-id="83932-135">The following code makes `Factory` a generic method with type parameters `TInput` and `TOutput`.</span></span> <span data-ttu-id="83932-136">Para tornar o código mais fácil de ler, variáveis com esses nomes são criadas para conter os objetos <xref:System.Reflection.Emit.GenericTypeParameterBuilder> que representam os dois tipos parâmetros.</span><span class="sxs-lookup"><span data-stu-id="83932-136">To make the code easier to read, variables with these names are created to hold the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the two type parameters.</span></span>

    [!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]
    [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]

6. <span data-ttu-id="83932-137">Opcionalmente, adicione restrições especiais aos parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="83932-137">Optionally add special constraints to the type parameters.</span></span> <span data-ttu-id="83932-138">As restrições especiais são adicionadas usando o método <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-138">Special constraints are added using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="83932-139">Neste exemplo, `TOutput` é restrito para ser um tipo de referência e para ter um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="83932-139">In this example, `TOutput` is constrained to be a reference type and to have a parameterless constructor.</span></span>

    [!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]
    [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]

7. <span data-ttu-id="83932-140">Opcionalmente, adicione restrições de classe e interface aos parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="83932-140">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="83932-141">Neste exemplo, o parâmetro de tipo `TOutput` é restrito a tipos que implementam a interface `ICollection(Of TInput)` (`ICollection<TInput>` em C#).</span><span class="sxs-lookup"><span data-stu-id="83932-141">In this example, type parameter `TOutput` is constrained to types that implement the `ICollection(Of TInput)` (`ICollection<TInput>` in C#) interface.</span></span> <span data-ttu-id="83932-142">Isso garante que o método <xref:System.Collections.Generic.ICollection%601.Add%2A> pode ser usado para adicionar elementos.</span><span class="sxs-lookup"><span data-stu-id="83932-142">This ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A> method can be used to add elements.</span></span>

    [!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]
    [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]

8. <span data-ttu-id="83932-143">Defina os parâmetros formais do método, usando o método <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-143">Define the formal parameters of the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method.</span></span> <span data-ttu-id="83932-144">Neste exemplo, o método `Factory` tem um parâmetro, uma matriz de `TInput`.</span><span class="sxs-lookup"><span data-stu-id="83932-144">In this example, the `Factory` method has one parameter, an array of `TInput`.</span></span> <span data-ttu-id="83932-145">Esse tipo é criado chamando o método <xref:System.Type.MakeArrayType%2A> no <xref:System.Reflection.Emit.GenericTypeParameterBuilder> que representa `TInput`.</span><span class="sxs-lookup"><span data-stu-id="83932-145">This type is created by calling the <xref:System.Type.MakeArrayType%2A> method on the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> that represents `TInput`.</span></span> <span data-ttu-id="83932-146">O argumento de <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> é uma matriz de objetos <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="83932-146">The argument of <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> is an array of <xref:System.Type> objects.</span></span>

    [!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]
    [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]

9. <span data-ttu-id="83932-147">Defina o tipo de retorno para o método, usando o método <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-147">Define the return type for the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method.</span></span> <span data-ttu-id="83932-148">Neste exemplo, uma instância de `TOutput` é retornada.</span><span class="sxs-lookup"><span data-stu-id="83932-148">In this example, an instance of `TOutput` is returned.</span></span>

    [!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]
    [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]

10. <span data-ttu-id="83932-149">Emita o corpo do método usando <xref:System.Reflection.Emit.ILGenerator>.</span><span class="sxs-lookup"><span data-stu-id="83932-149">Emit the method body, using <xref:System.Reflection.Emit.ILGenerator>.</span></span> <span data-ttu-id="83932-150">Para obter detalhes, consulte o procedimento que acompanha este artigo para emitir o corpo do método.</span><span class="sxs-lookup"><span data-stu-id="83932-150">For details, see the accompanying procedure for emitting the method body.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="83932-151">Quando emitir chamadas para métodos de tipos genéricos e os argumentos de tipo desses tipos forem parâmetros de tipo do método genérico, você deverá usar as sobrecargas de método `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29> e <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> da classe <xref:System.Reflection.Emit.TypeBuilder> para obter formulários construídos dos métodos.</span><span class="sxs-lookup"><span data-stu-id="83932-151">When you emit calls to methods of generic types, and the type arguments of those types are type parameters of the generic method, you must use the `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> method overloads of the <xref:System.Reflection.Emit.TypeBuilder> class to obtain constructed forms of the methods.</span></span> <span data-ttu-id="83932-152">O procedimento que acompanha este artigo para emitir o corpo do método demonstra isso.</span><span class="sxs-lookup"><span data-stu-id="83932-152">The accompanying procedure for emitting the method body demonstrates this.</span></span>

11. <span data-ttu-id="83932-153">Complete o tipo que contém o método e salve o assembly.</span><span class="sxs-lookup"><span data-stu-id="83932-153">Complete the type that contains the method and save the assembly.</span></span> <span data-ttu-id="83932-154">O procedimento que acompanha este artigo para invocar o método genérico mostra duas maneiras de invocar o método concluído.</span><span class="sxs-lookup"><span data-stu-id="83932-154">The accompanying procedure for invoking the generic method shows two ways to invoke the completed method.</span></span>

    [!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]
    [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]

<a name="procedureSection1"></a>

### <a name="to-emit-the-method-body"></a><span data-ttu-id="83932-155">Para emitir o corpo do método</span><span class="sxs-lookup"><span data-stu-id="83932-155">To emit the method body</span></span>

1. <span data-ttu-id="83932-156">Obtenha um gerador de código e declare rótulos e variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="83932-156">Get a code generator and declare local variables and labels.</span></span> <span data-ttu-id="83932-157">O método <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> é usado para declarar variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="83932-157">The <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> method is used to declare local variables.</span></span> <span data-ttu-id="83932-158">O método `Factory` tem quatro variáveis locais: `retVal` para manter o novo `TOutput` que é retornado pelo método, `ic` para manter o `TOutput` quando ele é convertido em `ICollection(Of TInput)` (`ICollection<TInput>` em C#), `input` para manter a matriz de entrada de objetos `TInput` e `index` para iterar por meio da matriz.</span><span class="sxs-lookup"><span data-stu-id="83932-158">The `Factory` method has four local variables: `retVal` to hold the new `TOutput` that is returned by the method, `ic` to hold the `TOutput` when it is cast to `ICollection(Of TInput)` (`ICollection<TInput>` in C#), `input` to hold the input array of `TInput` objects, and `index` to iterate through the array.</span></span> <span data-ttu-id="83932-159">O método também tem dois rótulos, um para inserir o loop (`enterLoop`) e outro para a parte superior do loop (`loopAgain`), definida usando o método <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-159">The method also has two labels, one to enter the loop (`enterLoop`) and one for the top of the loop (`loopAgain`), defined using the <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> method.</span></span>

    <span data-ttu-id="83932-160">A primeira coisa que o método faz é carregar seu argumento usando o opcode <xref:System.Reflection.Emit.OpCodes.Ldarg_0> e armazená-los na variável local `input` usando o opcode <xref:System.Reflection.Emit.OpCodes.Stloc_S>.</span><span class="sxs-lookup"><span data-stu-id="83932-160">The first thing the method does is to load its argument using <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode and to store it in the local variable `input` using <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode.</span></span>

    [!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]
    [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]

2. <span data-ttu-id="83932-161">Emita o código para criar uma instância de `TOutput`, usando a sobrecarga de método genérico do método <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83932-161">Emit code to create an instance of `TOutput`, using the generic method overload of the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="83932-162">Usar essa sobrecarga requer que o tipo especificado tenha um construtor sem parâmetros, que é o motivo para adicionar essa restrição a `TOutput`.</span><span class="sxs-lookup"><span data-stu-id="83932-162">Using this overload requires the specified type to have a parameterless constructor, which is the reason for adding that constraint to `TOutput`.</span></span> <span data-ttu-id="83932-163">Crie o método genérico construído passando `TOutput` para <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-163">Create the constructed generic method by passing `TOutput` to <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span></span> <span data-ttu-id="83932-164">Depois de emitir o código para chamar o método, emita o código para armazená-lo na variável local `retVal` usando <xref:System.Reflection.Emit.OpCodes.Stloc_S></span><span class="sxs-lookup"><span data-stu-id="83932-164">After emitting code to call the method, emit code to store it in the local variable `retVal` using <xref:System.Reflection.Emit.OpCodes.Stloc_S></span></span>

    [!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]
    [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]

3. <span data-ttu-id="83932-165">Emita o código para converter o novo objeto `TOutput` em `ICollection(Of TInput)` e armazená-lo na variável local `ic`.</span><span class="sxs-lookup"><span data-stu-id="83932-165">Emit code to cast the new `TOutput` object to `ICollection(Of TInput)` and store it in the local variable `ic`.</span></span>

    [!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]
    [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]

4. <span data-ttu-id="83932-166">Obtenha um <xref:System.Reflection.MethodInfo> que representa o método <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83932-166">Get a <xref:System.Reflection.MethodInfo> representing the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="83932-167">O método está atuando em um `ICollection(Of TInput)` (`ICollection<TInput>` em C#), portanto, é necessário obter o método `Add` específico para o tipo construído.</span><span class="sxs-lookup"><span data-stu-id="83932-167">The method is acting on an `ICollection(Of TInput)` (`ICollection<TInput>` in C#), so it is necessary to get the `Add` method specific to that constructed type.</span></span> <span data-ttu-id="83932-168">Não é possível usar o método <xref:System.Type.GetMethod%2A> para obter esse <xref:System.Reflection.MethodInfo> diretamente de `icollOfTInput`, pois <xref:System.Type.GetMethod%2A> não tem suporte em um tipo que foi construído com um <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span><span class="sxs-lookup"><span data-stu-id="83932-168">You cannot use the <xref:System.Type.GetMethod%2A> method to get this <xref:System.Reflection.MethodInfo> directly from `icollOfTInput`, because <xref:System.Type.GetMethod%2A> is not supported on a type that has been constructed with a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span></span> <span data-ttu-id="83932-169">Em vez disso, chame <xref:System.Type.GetMethod%2A> em `icoll`, que contém a definição de tipo genérico para a interface genérica <xref:System.Collections.Generic.ICollection%601>.</span><span class="sxs-lookup"><span data-stu-id="83932-169">Instead, call <xref:System.Type.GetMethod%2A> on `icoll`, which contains the generic type definition for the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span> <span data-ttu-id="83932-170">Em seguida, use o método <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` para produzir o <xref:System.Reflection.MethodInfo> para o tipo construído.</span><span class="sxs-lookup"><span data-stu-id="83932-170">Then use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` method to produce the <xref:System.Reflection.MethodInfo> for the constructed type.</span></span> <span data-ttu-id="83932-171">O código a seguir demonstra isso.</span><span class="sxs-lookup"><span data-stu-id="83932-171">The following code demonstrates this.</span></span>

    [!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]
    [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]

5. <span data-ttu-id="83932-172">Emita o código para inicializar a variável `index`, carregando um inteiro 0 de 32 bits e armazenando-o na variável.</span><span class="sxs-lookup"><span data-stu-id="83932-172">Emit code to initialize the `index` variable, by loading a 32-bit integer 0 and storing it in the variable.</span></span> <span data-ttu-id="83932-173">Emita o código para fazer o branch para o rótulo `enterLoop`.</span><span class="sxs-lookup"><span data-stu-id="83932-173">Emit code to branch to the label `enterLoop`.</span></span> <span data-ttu-id="83932-174">Esse rótulo ainda não foi marcado, pois ele está dentro do loop.</span><span class="sxs-lookup"><span data-stu-id="83932-174">This label has not yet been marked, because it is inside the loop.</span></span> <span data-ttu-id="83932-175">O código para o loop é emitido na próxima etapa.</span><span class="sxs-lookup"><span data-stu-id="83932-175">Code for the loop is emitted in the next step.</span></span>

    [!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]
    [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]

6. <span data-ttu-id="83932-176">Emita o código para o loop.</span><span class="sxs-lookup"><span data-stu-id="83932-176">Emit code for the loop.</span></span> <span data-ttu-id="83932-177">A primeira etapa é marcar a parte superior do loop, chamando <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> com o rótulo `loopAgain`.</span><span class="sxs-lookup"><span data-stu-id="83932-177">The first step is to mark the top of the loop, by calling <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> with the `loopAgain` label.</span></span> <span data-ttu-id="83932-178">Instruções de branch que usam o rótulo agora farão o branch para esse ponto no código.</span><span class="sxs-lookup"><span data-stu-id="83932-178">Branch statements that use the label will now branch to this point in the code.</span></span> <span data-ttu-id="83932-179">A próxima etapa é enviar por push o objeto `TOutput`, convertido em `ICollection(Of TInput)`, para a pilha.</span><span class="sxs-lookup"><span data-stu-id="83932-179">The next step is to push the `TOutput` object, cast to `ICollection(Of TInput)`, onto the stack.</span></span> <span data-ttu-id="83932-180">Ele não é necessário imediatamente, mas precisa estar na posição para chamar o método `Add`.</span><span class="sxs-lookup"><span data-stu-id="83932-180">It is not needed immediately, but needs to be in position for calling the `Add` method.</span></span> <span data-ttu-id="83932-181">Em seguida a matriz de entrada é enviada por push para a pilha e, em seguida, a variável `index` que contém o índice atual para a matriz.</span><span class="sxs-lookup"><span data-stu-id="83932-181">Next the input array is pushed onto the stack, then the `index` variable containing the current index into the array.</span></span> <span data-ttu-id="83932-182">O opcode <xref:System.Reflection.Emit.OpCodes.Ldelem> retira o índice e a matriz da pilha e envia por push o elemento de matriz indexado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="83932-182">The <xref:System.Reflection.Emit.OpCodes.Ldelem> opcode pops the index and the array off the stack and pushes the indexed array element onto the stack.</span></span> <span data-ttu-id="83932-183">A pilha agora está pronta para a chamada para o método <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType>, que retira a coleção e o novo elemento da pilha e adiciona o elemento à coleção.</span><span class="sxs-lookup"><span data-stu-id="83932-183">The stack is now ready for the call to the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method, which pops the collection and the new element off the stack and adds the element to the collection.</span></span>

    <span data-ttu-id="83932-184">O restante do código no loop incrementa o índice e testa para ver se o loop é concluído: o índice e um inteiro 1 de 32 bits são enviados por push para a pilha e adicionados, deixando a soma na pilha, a soma é armazenada no `index`.</span><span class="sxs-lookup"><span data-stu-id="83932-184">The rest of the code in the loop increments the index and tests to see whether the loop is finished: The index and a 32-bit integer 1 are pushed onto the stack and added, leaving the sum on the stack; the sum is stored in `index`.</span></span> <span data-ttu-id="83932-185"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> é chamado para definir esse ponto como o ponto de entrada para o loop.</span><span class="sxs-lookup"><span data-stu-id="83932-185"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> is called to set this point as the entry point for the loop.</span></span> <span data-ttu-id="83932-186">O índice é carregado novamente.</span><span class="sxs-lookup"><span data-stu-id="83932-186">The index is loaded again.</span></span> <span data-ttu-id="83932-187">A matriz de entrada é enviada por push na pilha e <xref:System.Reflection.Emit.OpCodes.Ldlen> é emitido para obter seu comprimento.</span><span class="sxs-lookup"><span data-stu-id="83932-187">The input array is pushed on the stack, and <xref:System.Reflection.Emit.OpCodes.Ldlen> is emitted to get its length.</span></span> <span data-ttu-id="83932-188">O índice e o comprimento agora estão na pilha e <xref:System.Reflection.Emit.OpCodes.Clt> é emitido para compará-los.</span><span class="sxs-lookup"><span data-stu-id="83932-188">The index and the length are now on the stack, and <xref:System.Reflection.Emit.OpCodes.Clt> is emitted to compare them.</span></span> <span data-ttu-id="83932-189">Se o índice for menor que o comprimento, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> realiza o branch de volta para o início do loop.</span><span class="sxs-lookup"><span data-stu-id="83932-189">If the index is less than the length, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> branches back to the beginning of the loop.</span></span>

    [!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]
    [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]

7. <span data-ttu-id="83932-190">Emita o código para enviar por push o objeto `TOutput` para a pilha e retornar do método.</span><span class="sxs-lookup"><span data-stu-id="83932-190">Emit code to push the `TOutput` object onto the stack and return from the method.</span></span> <span data-ttu-id="83932-191">As variáveis locais `retVal` e `ic` contêm referências para o novo `TOutput`. `ic` é usado somente para acessar o método <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83932-191">The local variables `retVal` and `ic` both contain references to the new `TOutput`; `ic` is used only to access the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span>

    [!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]
    [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]

<a name="procedureSection2"></a>

### <a name="to-invoke-the-generic-method"></a><span data-ttu-id="83932-192">Para invocar o método genérico</span><span class="sxs-lookup"><span data-stu-id="83932-192">To invoke the generic method</span></span>

1. <span data-ttu-id="83932-193">`Factory` é uma definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-193">`Factory` is a generic method definition.</span></span> <span data-ttu-id="83932-194">Para invocá-lo, você deve atribuir tipos para seus parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-194">In order to invoke it, you must assign types to its generic type parameters.</span></span> <span data-ttu-id="83932-195">Use o método <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> para fazer isso.</span><span class="sxs-lookup"><span data-stu-id="83932-195">Use the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method to do this.</span></span> <span data-ttu-id="83932-196">O código a seguir cria um método genérico construído, especificando <xref:System.String> para `TInput` e `List(Of String)` (`List<string>` em C#) para `TOutput` e exibe uma representação de cadeia de caracteres do método.</span><span class="sxs-lookup"><span data-stu-id="83932-196">The following code creates a constructed generic method, specifying <xref:System.String> for `TInput` and `List(Of String)` (`List<string>` in C#) for `TOutput`, and displays a string representation of the method.</span></span>

    [!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]
    [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]

2. <span data-ttu-id="83932-197">Para invocar a método com associação tardia, use o método <xref:System.Reflection.MethodBase.Invoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="83932-197">To invoke the method late-bound, use the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span> <span data-ttu-id="83932-198">O código a seguir cria uma matriz de <xref:System.Object>, contendo como seu único elemento uma matriz de cadeias de caracteres a passa como a lista de argumentos para o método genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-198">The following code creates an array of <xref:System.Object>, containing as its only element an array of strings, and passes it as the argument list for the generic method.</span></span> <span data-ttu-id="83932-199">O primeiro parâmetro de <xref:System.Reflection.MethodBase.Invoke%2A> é uma referência nula, pois o método é `static`.</span><span class="sxs-lookup"><span data-stu-id="83932-199">The first parameter of <xref:System.Reflection.MethodBase.Invoke%2A> is a null reference because the method is `static`.</span></span> <span data-ttu-id="83932-200">O valor retornado é convertido em `List(Of String)` e o primeiro elemento é exibido.</span><span class="sxs-lookup"><span data-stu-id="83932-200">The return value is cast to `List(Of String)`, and its first element is displayed.</span></span>

    [!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]
    [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]

3. <span data-ttu-id="83932-201">Para invocar o método usando um delegado, você deve ter um delegado que corresponda à assinatura do método genérico construído.</span><span class="sxs-lookup"><span data-stu-id="83932-201">To invoke the method using a delegate, you must have a delegate that matches the signature of the constructed generic method.</span></span> <span data-ttu-id="83932-202">Uma maneira fácil de fazer isso é criar um delegado genérico.</span><span class="sxs-lookup"><span data-stu-id="83932-202">An easy way to do this is to create a generic delegate.</span></span> <span data-ttu-id="83932-203">O código a seguir cria uma instância do delegado genérico `D` definida no código de exemplo, usando a sobrecarga de método <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> e invoca o delegado.</span><span class="sxs-lookup"><span data-stu-id="83932-203">The following code creates an instance of the generic delegate `D` defined in the example code, using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> method overload, and invokes the delegate.</span></span> <span data-ttu-id="83932-204">Os delegados funcionam melhor que as chamadas com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="83932-204">Delegates perform better than late-bound calls.</span></span>

    [!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]
    [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]

4. <span data-ttu-id="83932-205">O método emitido também pode ser chamado de um programa que referencia o assembly salvo.</span><span class="sxs-lookup"><span data-stu-id="83932-205">The emitted method can also be called from a program that refers to the saved assembly.</span></span>

## <a name="example"></a><span data-ttu-id="83932-206">Exemplo</span><span class="sxs-lookup"><span data-stu-id="83932-206">Example</span></span>

<span data-ttu-id="83932-207">O exemplo de código a seguir cria um tipo não genérico, `DemoType`, com um método genérico, `Factory`.</span><span class="sxs-lookup"><span data-stu-id="83932-207">The following code example creates a nongeneric type, `DemoType`, with a generic method, `Factory`.</span></span> <span data-ttu-id="83932-208">Esse método tem dois parâmetros de tipo genérico, `TInput` para especificar um tipo de entrada e `TOutput` para especificar um tipo de saída.</span><span class="sxs-lookup"><span data-stu-id="83932-208">This method has two generic type parameters, `TInput` to specify an input type and `TOutput` to specify an output type.</span></span> <span data-ttu-id="83932-209">O parâmetro de tipo `TOutput` é restrito para implementar `ICollection<TInput>` (`ICollection(Of TInput)` no Visual Basic), para ser um tipo de referência e para ter um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="83932-209">The `TOutput` type parameter is constrained to implement `ICollection<TInput>` (`ICollection(Of TInput)` in Visual Basic), to be a reference type, and to have a parameterless constructor.</span></span>

<span data-ttu-id="83932-210">O método tem um parâmetro formal, que é uma matriz de `TInput`.</span><span class="sxs-lookup"><span data-stu-id="83932-210">The method has one formal parameter, which is an array of `TInput`.</span></span> <span data-ttu-id="83932-211">O método retorna uma instância de `TOutput` que contém todos os elementos da matriz de entrada.</span><span class="sxs-lookup"><span data-stu-id="83932-211">The method returns an instance of `TOutput` that contains all the elements of the input array.</span></span> <span data-ttu-id="83932-212">`TOutput` pode ser qualquer tipo de coleção genérica que implementa a interface genérica <xref:System.Collections.Generic.ICollection%601>.</span><span class="sxs-lookup"><span data-stu-id="83932-212">`TOutput` can be any generic collection type that implements the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span>

<span data-ttu-id="83932-213">Quando o código é executado, o assembly dinâmico é salvo como DemoGenericMethod1.dll e pode ser examinado usando o [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="83932-213">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md).</span></span>

> [!NOTE]
> <span data-ttu-id="83932-214">Uma boa maneira de aprender como emitir o código é escrever um programa Visual Basic, C# ou Visual C++ que executa a tarefa que você está tentando emitir e usa o desmontador para examinar o MSIL produzido pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="83932-214">A good way to learn how to emit code is to write a Visual Basic, C#, or Visual C++ program that performs the task you are trying to emit, and use the disassembler to examine the MSIL produced by the compiler.</span></span>

<span data-ttu-id="83932-215">O exemplo de código inclui o código-fonte que é equivalente ao método emitido.</span><span class="sxs-lookup"><span data-stu-id="83932-215">The code example includes source code that is equivalent to the emitted method.</span></span> <span data-ttu-id="83932-216">O método emitido é invocado com associação tardia e também usando um delegado genérico declarado no exemplo de código.</span><span class="sxs-lookup"><span data-stu-id="83932-216">The emitted method is invoked late-bound and also by using a generic delegate declared in the code example.</span></span>

[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)]
[!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]

## <a name="see-also"></a><span data-ttu-id="83932-217">Veja também</span><span class="sxs-lookup"><span data-stu-id="83932-217">See also</span></span>

- <xref:System.Reflection.Emit.MethodBuilder>
- [<span data-ttu-id="83932-218">Como: Definir um tipo genérico com a emissão de reflexão</span><span class="sxs-lookup"><span data-stu-id="83932-218">How to: Define a Generic Type with Reflection Emit</span></span>](how-to-define-a-generic-type-with-reflection-emit.md)
