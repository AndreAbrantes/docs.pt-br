---
title: Carregando e usando tipos dinamicamente
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 085b89de8180a216288e8f547af5b73eaf004457
ms.sourcegitcommit: 56ac30a336668124cb7d95d8ace16bd985875147
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/09/2019
ms.locfileid: "65469672"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="19cf4-102">Carregando e usando tipos dinamicamente</span><span class="sxs-lookup"><span data-stu-id="19cf4-102">Dynamically Loading and Using Types</span></span>
<span data-ttu-id="19cf4-103">A reflexão fornece a infraestrutura usada pelos compiladores de linguagem para implementar a associação tardia implícita.</span><span class="sxs-lookup"><span data-stu-id="19cf4-103">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="19cf4-104">Associação é o processo de localizar a declaração (ou seja, a implementação) que corresponde a um tipo especificado exclusivamente.</span><span class="sxs-lookup"><span data-stu-id="19cf4-104">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="19cf4-105">Quando esse processo ocorre no tempo de execução em vez do tempo de compilação, ele é chamado de associação tardia.</span><span class="sxs-lookup"><span data-stu-id="19cf4-105">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="19cf4-106">O Visual Basic permite que você use associação tardia implícita em seu código. O compilador do Visual Basic chama um método auxiliar que usa a reflexão para obter o tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="19cf4-106">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="19cf4-107">Os argumentos passados para o método auxiliar fazem com que o método apropriado seja invocado no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="19cf4-107">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="19cf4-108">Esses argumentos são a instância (um objeto) na qual o método será invocado, o nome do método invocado (uma cadeia de caracteres) e os argumentos passados para o método invocado (uma matriz de objetos).</span><span class="sxs-lookup"><span data-stu-id="19cf4-108">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="19cf4-109">No exemplo a seguir, o compilador do Visual Basic usa reflexão implicitamente para chamar um método em um objeto cujo tipo não é conhecido no tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="19cf4-109">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="19cf4-110">Uma classe **HelloWorld** tem um método **PrintHello** que imprime “Hello World” concatenado com algum texto que é passado para o método **PrintHello**.</span><span class="sxs-lookup"><span data-stu-id="19cf4-110">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="19cf4-111">O método **PrintHello** chamado neste exemplo é na verdade um <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; o código do Visual Basic permite que o método **PrintHello** seja invocado como se o tipo de objeto (helloObj) fosse conhecido durante o tempo de compilação (associação antecipada) em vez de no tempo de execução (associação tardia).</span><span class="sxs-lookup"><span data-stu-id="19cf4-111">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```  
Imports System  
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="19cf4-112">Associação personalizado</span><span class="sxs-lookup"><span data-stu-id="19cf4-112">Custom Binding</span></span>  
 <span data-ttu-id="19cf4-113">Além de ser usado implicitamente por compiladores para associação tardia, a reflexão pode ser usada explicitamente no código para realizar a associação tardia.</span><span class="sxs-lookup"><span data-stu-id="19cf4-113">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="19cf4-114">O [Common Language Runtime](../../../docs/standard/clr.md) dá suporte a várias linguagens de programação e as regras de associação dessas linguagens são diferentes.</span><span class="sxs-lookup"><span data-stu-id="19cf4-114">The [common language runtime](../../../docs/standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="19cf4-115">No caso de associação antecipada, os geradores de código podem controlar essa associação completamente.</span><span class="sxs-lookup"><span data-stu-id="19cf4-115">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="19cf4-116">No entanto, na associação tardia por meio de reflexão, a associação deve ser controlada pela associação personalizada.</span><span class="sxs-lookup"><span data-stu-id="19cf4-116">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="19cf4-117">A classe <xref:System.Reflection.Binder> fornece controle personalizado do membro de seleção e da invocação.</span><span class="sxs-lookup"><span data-stu-id="19cf4-117">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="19cf4-118">Usando a associação personalizada, você pode carregar um assembly no tempo de execução, obter informações sobre tipos nesse assembly, especificar o tipo que você deseja e, em seguida, invocar métodos ou acessar campos ou propriedades nesse tipo.</span><span class="sxs-lookup"><span data-stu-id="19cf4-118">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="19cf4-119">Essa técnica é útil se você não souber o tipo de um objeto no tempo de compilação, como quando o tipo de objeto depende da entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="19cf4-119">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="19cf4-120">O exemplo a seguir demonstra um associador personalizado simples que não fornece nenhuma conversão de tipo de argumento.</span><span class="sxs-lookup"><span data-stu-id="19cf4-120">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="19cf4-121">O código de `Simple_Type.dll` precede o exemplo principal.</span><span class="sxs-lookup"><span data-stu-id="19cf4-121">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="19cf4-122">Verifique se você compilou `Simple_Type.dll` e incluiu uma referência a ele no projeto no tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="19cf4-122">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="19cf4-123">InvokeMember e CreateInstance</span><span class="sxs-lookup"><span data-stu-id="19cf4-123">InvokeMember and CreateInstance</span></span>  
 <span data-ttu-id="19cf4-124">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> para invocar um membro de um tipo.</span><span class="sxs-lookup"><span data-stu-id="19cf4-124">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="19cf4-125">Os métodos **CreateInstance** de várias classes, como <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, são formas especializadas de **InvokeMember** que criam novas instâncias do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="19cf4-125">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="19cf4-126">A classe **Binder** é usada para resolução de sobrecarga e coerção de argumento nesses métodos.</span><span class="sxs-lookup"><span data-stu-id="19cf4-126">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="19cf4-127">O exemplo a seguir mostra três combinações possíveis de coerção de argumento (conversão de tipo) e seleção de membro.</span><span class="sxs-lookup"><span data-stu-id="19cf4-127">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="19cf4-128">No caso 1, não é necessária nenhuma coerção de argumento ou seleção de membro.</span><span class="sxs-lookup"><span data-stu-id="19cf4-128">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="19cf4-129">No caso 2, somente a seleção de membro é necessária.</span><span class="sxs-lookup"><span data-stu-id="19cf4-129">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="19cf4-130">No caso 3, somente a coerção de argumento é necessária.</span><span class="sxs-lookup"><span data-stu-id="19cf4-130">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="19cf4-131">A resolução de sobrecarga é necessária quando mais de um membro com o mesmo nome está disponível.</span><span class="sxs-lookup"><span data-stu-id="19cf4-131">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="19cf4-132">Os métodos <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> são usados para resolver a associação para um único membro.</span><span class="sxs-lookup"><span data-stu-id="19cf4-132">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="19cf4-133">O **Binder.BindToMethod** também fornece a resolução de propriedade por meio de dos acessadores de propriedade **get** e **set**.</span><span class="sxs-lookup"><span data-stu-id="19cf4-133">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="19cf4-134">O **BindToMethod** retorna o <xref:System.Reflection.MethodBase> a ser invocado ou uma referência nula (**Nothing** no Visual Basic) se tal invocação não for possível.</span><span class="sxs-lookup"><span data-stu-id="19cf4-134">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="19cf4-135">O valor retornado de **MethodBase** não precisa ser um dos contidos no parâmetro *match*, embora isso seja o comum.</span><span class="sxs-lookup"><span data-stu-id="19cf4-135">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="19cf4-136">Quando houver argumentos ByRef, o chamador poderá tentar recuperá-los.</span><span class="sxs-lookup"><span data-stu-id="19cf4-136">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="19cf4-137">Portanto, **Binder** permite a um cliente mapear a matriz de argumentos para sua forma original se **BindToMethod** tiver manipulado a matriz de argumento.</span><span class="sxs-lookup"><span data-stu-id="19cf4-137">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="19cf4-138">Para fazer isso, é necessário garantir ao chamador que a ordem dos argumentos se mantém inalterada.</span><span class="sxs-lookup"><span data-stu-id="19cf4-138">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="19cf4-139">Quando os argumentos são passados por nome, o **Binder** reorganiza a matriz de argumentos e é isso que o chamador vê.</span><span class="sxs-lookup"><span data-stu-id="19cf4-139">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="19cf4-140">Para obter mais informações, consulte <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="19cf4-140">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="19cf4-141">O conjunto de membros disponíveis aqueles definidos no tipo ou em qualquer tipo base.</span><span class="sxs-lookup"><span data-stu-id="19cf4-141">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="19cf4-142">Se <xref:System.Reflection.BindingFlags> for especificado, membros de qualquer acessibilidade serão retornados ao conjunto.</span><span class="sxs-lookup"><span data-stu-id="19cf4-142">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="19cf4-143">Se **BindingFlags.NonPublic** não for especificado, o associador deverá impor regras de acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="19cf4-143">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="19cf4-144">Ao especificar o sinalizador de associação **Public** ou **NonPublic**, você deverá especificar também o sinalizador de associação **Instance** ou **Static** ou nenhum membro será retornado.</span><span class="sxs-lookup"><span data-stu-id="19cf4-144">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="19cf4-145">Se houver somente um membro do nome fornecido, nenhum retorno de chamada é necessário e a associação é realizada nesse método.</span><span class="sxs-lookup"><span data-stu-id="19cf4-145">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="19cf4-146">O caso 1 do exemplo de código ilustra este ponto: Somente um método **PrintBob** está disponível e, portanto, nenhum retorno de chamada é necessário.</span><span class="sxs-lookup"><span data-stu-id="19cf4-146">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="19cf4-147">Se houver mais de um membro do conjunto disponível, todos esses métodos são passados para **BindToMethod**, que seleciona o método apropriado e o retorna.</span><span class="sxs-lookup"><span data-stu-id="19cf4-147">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="19cf4-148">No caso 2 do exemplo de código, há dois métodos chamados **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="19cf4-148">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="19cf4-149">O método apropriado é selecionado pela chamada para **BindToMethod**.</span><span class="sxs-lookup"><span data-stu-id="19cf4-149">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="19cf4-150">O <xref:System.Reflection.Binder.ChangeType%2A> executa a coerção de argumento (conversão de tipo), que converte os argumentos reais para o tipo dos argumentos formais do método selecionado.</span><span class="sxs-lookup"><span data-stu-id="19cf4-150"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="19cf4-151">**ChangeType** é chamado para cada argumento, mesmo se os tipos de corresponderem exatamente.</span><span class="sxs-lookup"><span data-stu-id="19cf4-151">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="19cf4-152">No caso 3 do exemplo de código, um argumento real do tipo **String** com um valor de “5.5” é passado para um método com um argumento formal do tipo **Double**.</span><span class="sxs-lookup"><span data-stu-id="19cf4-152">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="19cf4-153">Para que a invocação seja bem-sucedida, o valor da cadeia de caracteres “5.5” deve ser convertido em um valor duplo.</span><span class="sxs-lookup"><span data-stu-id="19cf4-153">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="19cf4-154">O **ChangeType** executa essa conversão.</span><span class="sxs-lookup"><span data-stu-id="19cf4-154">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="19cf4-155">O **ChangeType** executa apenas [coerções de expansão](../../../docs/standard/base-types/type-conversion.md) ou sem perdas, conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="19cf4-155">**ChangeType** performs only lossless or [widening coercions](../../../docs/standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="19cf4-156">Tipo de origem</span><span class="sxs-lookup"><span data-stu-id="19cf4-156">Source type</span></span>|<span data-ttu-id="19cf4-157">Tipo de destino</span><span class="sxs-lookup"><span data-stu-id="19cf4-157">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="19cf4-158">Qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="19cf4-158">Any type</span></span>|<span data-ttu-id="19cf4-159">O tipo base</span><span class="sxs-lookup"><span data-stu-id="19cf4-159">Its base type</span></span>|  
|<span data-ttu-id="19cf4-160">Qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="19cf4-160">Any type</span></span>|<span data-ttu-id="19cf4-161">Interface implementada</span><span class="sxs-lookup"><span data-stu-id="19cf4-161">Interface it implements</span></span>|  
|<span data-ttu-id="19cf4-162">Char</span><span class="sxs-lookup"><span data-stu-id="19cf4-162">Char</span></span>|<span data-ttu-id="19cf4-163">UInt16, UInt32, Int32, UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-163">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-164">Byte</span><span class="sxs-lookup"><span data-stu-id="19cf4-164">Byte</span></span>|<span data-ttu-id="19cf4-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-166">SByte</span><span class="sxs-lookup"><span data-stu-id="19cf4-166">SByte</span></span>|<span data-ttu-id="19cf4-167">Int16, Int32, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-167">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-168">UInt16</span><span class="sxs-lookup"><span data-stu-id="19cf4-168">UInt16</span></span>|<span data-ttu-id="19cf4-169">UInt32, Int32, UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-169">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-170">Int16</span><span class="sxs-lookup"><span data-stu-id="19cf4-170">Int16</span></span>|<span data-ttu-id="19cf4-171">Int32, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-171">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-172">UInt32</span><span class="sxs-lookup"><span data-stu-id="19cf4-172">UInt32</span></span>|<span data-ttu-id="19cf4-173">UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-173">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-174">Int32</span><span class="sxs-lookup"><span data-stu-id="19cf4-174">Int32</span></span>|<span data-ttu-id="19cf4-175">Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-175">Int64, Single, Double</span></span>|  
|<span data-ttu-id="19cf4-176">UInt64</span><span class="sxs-lookup"><span data-stu-id="19cf4-176">UInt64</span></span>|<span data-ttu-id="19cf4-177">Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-177">Single, Double</span></span>|  
|<span data-ttu-id="19cf4-178">Int64</span><span class="sxs-lookup"><span data-stu-id="19cf4-178">Int64</span></span>|<span data-ttu-id="19cf4-179">Single e Double</span><span class="sxs-lookup"><span data-stu-id="19cf4-179">Single, Double</span></span>|  
|<span data-ttu-id="19cf4-180">Simples</span><span class="sxs-lookup"><span data-stu-id="19cf4-180">Single</span></span>|<span data-ttu-id="19cf4-181">Duplo</span><span class="sxs-lookup"><span data-stu-id="19cf4-181">Double</span></span>|  
|<span data-ttu-id="19cf4-182">Tipo Nonreference</span><span class="sxs-lookup"><span data-stu-id="19cf4-182">Nonreference type</span></span>|<span data-ttu-id="19cf4-183">Tipo Reference</span><span class="sxs-lookup"><span data-stu-id="19cf4-183">Reference type</span></span>|  
  
 <span data-ttu-id="19cf4-184">A classe <xref:System.Type> tem métodos **Get** que usam parâmetros do tipo **Binder** para resolver referências a um determinado membro.</span><span class="sxs-lookup"><span data-stu-id="19cf4-184">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="19cf4-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> e <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> pesquisam um determinado membro do tipo atual, fornecendo informações de assinatura para esse membro.</span><span class="sxs-lookup"><span data-stu-id="19cf4-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="19cf4-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> são chamados de volta para selecionar as informações de determinada assinatura dos métodos apropriados.</span><span class="sxs-lookup"><span data-stu-id="19cf4-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="19cf4-187">Consulte também</span><span class="sxs-lookup"><span data-stu-id="19cf4-187">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="19cf4-188">Exibindo informações de tipo</span><span class="sxs-lookup"><span data-stu-id="19cf4-188">Viewing Type Information</span></span>](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)
- [<span data-ttu-id="19cf4-189">Conversão de tipos no .NET Framework</span><span class="sxs-lookup"><span data-stu-id="19cf4-189">Type Conversion in the .NET Framework</span></span>](../../../docs/standard/base-types/type-conversion.md)
