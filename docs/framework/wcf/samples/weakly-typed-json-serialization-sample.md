---
title: Weakly-typed JSON Serialization Sample
ms.date: 03/30/2017
ms.assetid: 0b30e501-4ef5-474d-9fad-a9d559cf9c52
ms.openlocfilehash: b0e9617ad5d616e8921fbf142085f2758f3e0cd4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62006350"
---
# <a name="weakly-typed-json-serialization-sample"></a><span data-ttu-id="2c86a-102">Weakly-typed JSON Serialization Sample</span><span class="sxs-lookup"><span data-stu-id="2c86a-102">Weakly-typed JSON Serialization Sample</span></span>
<span data-ttu-id="2c86a-103">Ao serializar um tipo definido pelo usuário para um formato com fio fornecida ou desserialização de um formato com fio volta para um tipo definido pelo usuário, de determinado tipo definido pelo usuário deve estar disponível no serviço e no cliente.</span><span class="sxs-lookup"><span data-stu-id="2c86a-103">When serializing a user-defined type to a given wire format, or deserializing a wire format back into a user-defined type, the given user-defined type must be available on both the service and the client.</span></span> <span data-ttu-id="2c86a-104">Normalmente, para fazer isso, o <xref:System.Runtime.Serialization.DataContractAttribute> atributo é aplicado a esses tipos definidos pelo usuário e o <xref:System.Runtime.Serialization.DataMemberAttribute> atributo é aplicado aos seus membros.</span><span class="sxs-lookup"><span data-stu-id="2c86a-104">Usually to accomplish this, the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to these user-defined types and the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute is applied to their members.</span></span> <span data-ttu-id="2c86a-105">Esse mecanismo também se aplica ao trabalhar com objetos de notação JSON (JavaScript Object), conforme descrito no tópico [como: Serializar e desserializar dados JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="2c86a-105">This mechanism also applies when working with JavaScript Object Notation (JSON) objects, as described in the topic [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="2c86a-106">Em alguns cenários, um serviço Windows Communication Foundation (WCF) ou o cliente deve acessar objetos JSON gerados por um serviço ou cliente que está fora do controle do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="2c86a-106">In some scenarios, a Windows Communication Foundation (WCF) service or client must access JSON objects generated by a service or client that is outside of the control of the developer.</span></span> <span data-ttu-id="2c86a-107">Conforme mais serviços Web expõem publicamente as APIs de JSON, ele pode se tornar impraticável para o desenvolvedor do WCF construir os tipos de locais definidas pelo usuário no qual desserializar objetos JSON arbitrários.</span><span class="sxs-lookup"><span data-stu-id="2c86a-107">As more Web services publicly expose JSON APIs, it can become impractical for the WCF developer to construct local user-defined types into which to deserialize arbitrary JSON objects.</span></span> <span data-ttu-id="2c86a-108">Este exemplo fornece um mecanismo que permite que os desenvolvedores do WCF trabalhar com objetos JSON arbitrários, desserializados, sem criar tipos definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="2c86a-108">This sample provides a mechanism that enables WCF developers to work with deserialized, arbitrary JSON objects, without creating user-defined types.</span></span> <span data-ttu-id="2c86a-109">Isso é conhecido como *serialização com tipagem fraca* de objetos JSON, porque o tipo no qual desserializa um objeto JSON não é conhecido em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="2c86a-109">This is known as *weakly-typed serialization* of JSON objects, because the type into which a JSON object deserializes is not known at compile time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c86a-110">As instruções de procedimento e compilação de configuração para este exemplo estão localizadas no final deste tópico.</span><span class="sxs-lookup"><span data-stu-id="2c86a-110">The setup procedure and build instructions for this sample are located at the end of this topic.</span></span>  
  
 <span data-ttu-id="2c86a-111">Por exemplo, uma API pública do serviço Web retorna o seguinte objeto JSON que descreve algumas informações sobre um usuário do serviço.</span><span class="sxs-lookup"><span data-stu-id="2c86a-111">For example, a public Web service API returns the following JSON object, which describes some information about a user of the service.</span></span>  
  
```json  
{"personal": {"name": "Paul", "age": 23, "height": 1.7, "isSingle": true, "luckyNumbers": [5,17,21]}, "favoriteBands": ["Band ABC", "Band XYZ"]}  
```  
  
 <span data-ttu-id="2c86a-112">Para desserializar esse objeto, um cliente WCF deve implementar os seguintes tipos definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="2c86a-112">To deserialize this object, a WCF client must implement the following user-defined types.</span></span>  
  
```  
[DataContract]  
 public class MemberProfile  
 {  
     [DataMember]  
     public PersonalInfo personal;  
  
     [DataMember]  
     public string[] favoriteBands;  
 }  
  
 [DataContract]  
 public class PersonalInfo  
 {  
     [DataMember]  
     public string name;  
  
     [DataMember]  
     public int age;  
  
     [DataMember]  
     public double height;  
  
     [DataMember]  
     public bool isSingle;  
  
     [DataMember]  
     public int[] luckyNumbers;  
 }  
```  
  
 <span data-ttu-id="2c86a-113">Isso pode ser complicado, especialmente se o cliente deve lidar com mais de um tipo de objeto JSON.</span><span class="sxs-lookup"><span data-stu-id="2c86a-113">This can be cumbersome, especially if the client has to handle more than one type of JSON object.</span></span>  
  
 <span data-ttu-id="2c86a-114">O `JsonObject` tipo fornecido por este exemplo apresenta uma representação com tipagem fraca do objeto JSON desserializado.</span><span class="sxs-lookup"><span data-stu-id="2c86a-114">The `JsonObject` type provided by this sample introduces a weakly-typed representation of the deserialized JSON object.</span></span> <span data-ttu-id="2c86a-115">`JsonObject` depende do mapeamento natural entre objetos JSON e [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] dicionários e o mapeamento entre matrizes JSON e [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] matrizes.</span><span class="sxs-lookup"><span data-stu-id="2c86a-115">`JsonObject` relies on the natural mapping between JSON objects and [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] dictionaries, and the mapping between JSON arrays and [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] arrays.</span></span> <span data-ttu-id="2c86a-116">O seguinte código mostra o `JsonObject` tipo.</span><span class="sxs-lookup"><span data-stu-id="2c86a-116">The following code shows the `JsonObject` type.</span></span>  
  
```  
// Instantiation of JsonObject json omitted  
  
string name = json["root"]["personal"]["name"];  
int age = json["root"]["personal"]["age"];  
double height = json["root"]["personal"]["height"];  
bool isSingle = json["root"]["personal"]["isSingle"];  
int[] luckyNumbers = {  
                                     json["root"]["personal"]["luckyNumbers"][0],  
                                     json["root"]["personal"]["luckyNumbers"][1],  
                                     json["root"]["personal"]["luckyNumbers"][2]   
                                 };  
string[] favoriteBands = {  
                                        json["root"]["favoriteBands"][0],  
                                        json["root"]["favoriteBands"][1]  
                                    };  
```  
  
 <span data-ttu-id="2c86a-117">Observe que você pode "Procurar" objetos JSON e matrizes sem a necessidade de declarar o tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="2c86a-117">Note that you can "browse" JSON objects and arrays without the need to declare their type at compile time.</span></span> <span data-ttu-id="2c86a-118">Para obter uma explicação da exigência de nível superior `["root"]` do objeto, consulte o tópico [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="2c86a-118">For an explanation of the requirement for the top-level `["root"]` object, see the topic [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c86a-119">O `JsonObject` classe é fornecida como apenas um exemplo.</span><span class="sxs-lookup"><span data-stu-id="2c86a-119">The `JsonObject` class is provided as an example only.</span></span> <span data-ttu-id="2c86a-120">Ele não foi totalmente testado e não deve ser usado em ambientes de produção.</span><span class="sxs-lookup"><span data-stu-id="2c86a-120">It has not been thoroughly tested, and should not be used in production environments.</span></span> <span data-ttu-id="2c86a-121">Uma implicação óbvia de serialização de JSON com tipagem fraca é a falta de segurança de tipos ao trabalhar com `JsonObject`.</span><span class="sxs-lookup"><span data-stu-id="2c86a-121">An obvious implication of weakly-typed JSON serialization is the lack of type-safety when working with `JsonObject`.</span></span>  
  
 <span data-ttu-id="2c86a-122">Para usar o `JsonObject` tipo de contrato de operação do cliente deve usar <xref:System.ServiceModel.Channels.Message> como seu tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="2c86a-122">To use the `JsonObject` type, the client operation contract must use <xref:System.ServiceModel.Channels.Message> as its return type.</span></span>  
  
```  
[ServiceContract]  
    interface IClientSideProfileService  
    {  
        // There is no need to write a DataContract for the complex type returned by the service.  
        // The client will use a JsonObject to browse the JSON in the received message.  
  
        [OperationContract]  
        [WebGet(ResponseFormat = WebMessageFormat.Json)]  
        Message GetMemberProfile();  
    }  
```  
  
 <span data-ttu-id="2c86a-123">O `JsonObject` é instanciada, em seguida, conforme mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="2c86a-123">The `JsonObject` is then instantiated as shown in the following code.</span></span>  
  
```  
// Code to instantiate IClientSideProfileService channel omitted…  
  
// Make a request to the service and obtain the Json response  
XmlDictionaryReader reader = channel.GetMemberProfile().GetReaderAtBodyContents();  
  
// Go through the Json as though it is a dictionary. There is no need to map it to a .NET CLR type.  
JsonObject json = new JsonObject(reader);  
```  
  
 <span data-ttu-id="2c86a-124">O `JsonObject` construtor usa um <xref:System.Xml.XmlDictionaryReader>, que é obtido por meio de <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2c86a-124">The `JsonObject` constructor takes a <xref:System.Xml.XmlDictionaryReader>, which is obtained through the <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> method.</span></span> <span data-ttu-id="2c86a-125">O leitor contém uma representação XML da mensagem JSON recebida pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="2c86a-125">The reader contains an XML representation of the JSON message received by the client.</span></span> <span data-ttu-id="2c86a-126">Para obter mais informações, consulte o tópico [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="2c86a-126">For more information, see the topic [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
 <span data-ttu-id="2c86a-127">O programa produz a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="2c86a-127">The program produces the following output:</span></span>  
  
```  
Service listening at http://localhost:8000/.  
To view the JSON output from the sample, navigate to http://localhost:8000/GetMemberProfile  
This is Paul's page. I am 23 years old and I am 1.7 meters tall.  
I am single.  
My lucky numbers are 5, 17, and 21.  
My favorite bands are Band ABC and Band XYZ.  
```  
  
### <a name="to-set-up-build-and-run-the-sample"></a><span data-ttu-id="2c86a-128">Para configurar, compilar, e executar o exemplo</span><span class="sxs-lookup"><span data-stu-id="2c86a-128">To set up, build, and run the sample</span></span>  
  
1. <span data-ttu-id="2c86a-129">Certifique-se de que você tenha executado o [procedimento de configuração de uso único para os exemplos do Windows Communication Foundation](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).</span><span class="sxs-lookup"><span data-stu-id="2c86a-129">Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).</span></span>  
  
2. <span data-ttu-id="2c86a-130">Compile a solução WeaklyTypedJson.sln, conforme descrito em [compilando os exemplos do Windows Communication Foundation](../../../../docs/framework/wcf/samples/building-the-samples.md).</span><span class="sxs-lookup"><span data-stu-id="2c86a-130">Build the solution WeaklyTypedJson.sln as described in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).</span></span>  
  
3. <span data-ttu-id="2c86a-131">Execute a solução.</span><span class="sxs-lookup"><span data-stu-id="2c86a-131">Run the solution.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2c86a-132">Os exemplos podem já estar instalados no seu computador.</span><span class="sxs-lookup"><span data-stu-id="2c86a-132">The samples may already be installed on your machine.</span></span> <span data-ttu-id="2c86a-133">Verifique o seguinte diretório (padrão) antes de continuar.</span><span class="sxs-lookup"><span data-stu-id="2c86a-133">Check for the following (default) directory before continuing.</span></span>  
>   
>  `<InstallDrive>:\WF_WCF_Samples`  
>   
>  <span data-ttu-id="2c86a-134">Se este diretório não existir, vá para [Windows Communication Foundation (WCF) e o Windows Workflow Foundation (WF) exemplos do .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) para baixar todos os Windows Communication Foundation (WCF) e [!INCLUDE[wf1](../../../../includes/wf1-md.md)] exemplos.</span><span class="sxs-lookup"><span data-stu-id="2c86a-134">If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples.</span></span> <span data-ttu-id="2c86a-135">Este exemplo está localizado no seguinte diretório.</span><span class="sxs-lookup"><span data-stu-id="2c86a-135">This sample is located in the following directory.</span></span>  
>   
>  `<InstallDrive>:\WF_WCF_Samples\WCF\Scenario\Ajax\WeaklyTypedJson`  
