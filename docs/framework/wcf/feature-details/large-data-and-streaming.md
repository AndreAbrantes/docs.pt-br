---
title: Dados grandes e streaming
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 91e53f66fb0f2f94a315c318eb0b203d78427bae
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184672"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="0dbfe-102">Dados grandes e streaming</span><span class="sxs-lookup"><span data-stu-id="0dbfe-102">Large Data and Streaming</span></span>

<span data-ttu-id="0dbfe-103">O Windows Communication Foundation (WCF) é uma infra-estrutura de comunicações baseada em XML.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="0dbfe-104">Como os dados XML são comumente codificados no formato de texto padrão definido na [especificação XML 1.0,](https://www.w3.org/TR/REC-xml/)desenvolvedores e arquitetos de sistemas conectados estão tipicamente preocupados com a pegada de fio (ou tamanho) das mensagens enviadas pela rede, e a codificação baseada em texto do XML coloca desafios especiais para a transferência eficiente de dados binários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="0dbfe-105">Considerações básicas</span><span class="sxs-lookup"><span data-stu-id="0dbfe-105">Basic Considerations</span></span>  
 <span data-ttu-id="0dbfe-106">Para fornecer informações de fundo sobre as seguintes informações para o WCF, esta seção destaca algumas preocupações gerais e considerações para codificações, dados binários e streaming que geralmente se aplicam a infra-estruturas de sistemas conectados.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="0dbfe-107">Dados de codificação: Texto vs. Binário</span><span class="sxs-lookup"><span data-stu-id="0dbfe-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="0dbfe-108">As preocupações geralmente expressas pelos desenvolvedores incluem a percepção de que o XML tem uma sobrecarga significativa quando comparado com formatos binários devido à natureza repetitiva das marcas de início e de fim, que a codificação de valores numéricos é considerada como sendo significativamente maior porque são expressos em valores de texto, e que os dados binários não podem ser expressos de modo eficiente porque devem ser especialmente codificados para inserção em um formato de texto.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="0dbfe-109">Embora muitas dessas e de outras preocupações semelhantes sejam válidas, a diferença real entre as mensagens codificadas em texto XML em um ambiente de serviços Web XML e as mensagens codificadas em binário em um ambiente herdado de RPC (chamada de procedimento remoto) com frequência muito menos significativa do que a consideração inicial pode sugerir.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="0dbfe-110">Embora as mensagens codificadas em texto XML sejam transparentes e “legíveis pelo usuário”, em comparação, as mensagens binárias geralmente são bastante obscuras e difíceis de serem decodificadas sem ferramentas.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="0dbfe-111">Essa diferença na legibilidade leva um usuário a ignorar que as mensagens binárias, com frequência, também carregam metadados embutidos em sua carga, o que adiciona um sobrecarga da mesma forma como ocorre em mensagens de texto XML.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="0dbfe-112">Isso é especialmente verdadeiro para formatos binários que pretendem fornecer acoplamento flexível e recursos de invocação dinâmica.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="0dbfe-113">No entanto, os formatos binários normalmente carregam essas informações descritivas de metadados em um "cabeçalho", que também declara o layout dos dados para os registros de dados seguintes.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="0dbfe-114">A carga então segue essa declaração comum do bloco de metadados com sobrecarga adicional mínima.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="0dbfe-115">Por outro lado, o XML embute cada item de dados em um elemento ou atributo para que os metadados embutidos sejam incluídos de maneira repetitiva para cada objeto de carga serializado.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="0dbfe-116">Como resultado, o tamanho de um único objeto de carga serializado é semelhante na comparação de representação de texto e binárias, pois alguns metadados descritivos devem ser expressos para ambas, mas o formato binário se beneficia da descrição dos metadados compartilhados com cada objeto de carga adicional que é transferido devido a sobrecarga geral mais baixa.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="0dbfe-117">Ainda assim, para determinados tipos de dados, como números, pode haver uma desvantagem em usar representações numéricas binárias de tamanho fixo, como um tipo decimal de 128 bits, em vez de texto sem formatação, uma vez que a representação de texto sem formatação pode ser menor em vários bytes.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="0dbfe-118">Os dados de texto também podem ter benefícios de tamanho com as opções geralmente mais flexíveis de codificação de texto XML, enquanto alguns formatos binários podem ter seu padrão definido como Unicode de 16 bits ou mesmo de 32 bits, o que não se aplica ao formato XML binário .NET.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="0dbfe-119">Como resultado, decidir entre texto ou binário não é tão fácil quanto supor que mensagens binárias sempre são menores do que mensagens de texto XML.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="0dbfe-120">Uma vantagem clara das mensagens de texto XML é que elas são baseadas em padrões e oferecem a escolha mais abrangente de opções de interoperabilidade e de suporte da plataforma.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="0dbfe-121">Para obter mais informações, consulte a seção "Codificações" mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="0dbfe-122">Conteúdo binário</span><span class="sxs-lookup"><span data-stu-id="0dbfe-122">Binary Content</span></span>  
 <span data-ttu-id="0dbfe-123">Uma área onde as codificações binárias são superiores às codificações baseadas em texto em termos de tamanho da mensagem resultante são os grandes itens de dados binários, como imagens, vídeos, clipes de som ou qualquer outro formulário de dados binários opacos que devem ser trocados entre os serviços e seus usuários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="0dbfe-124">Para ajustar esses tipos de dados em texto XML, a abordagem mais comum é codificá-los usando codificação Base64.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="0dbfe-125">Em uma cadeia de caracteres codificados em Base64, cada caractere representa 6 bits dos dados originais de 8 bits, o que resulta em uma taxa de sobrecarga de codificação de 4:3 para Base64, sem contar os caracteres adicionais de formatação (retorno de carro/alimentação de linha) que normalmente são adicionados por convenção.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="0dbfe-126">Embora a importância das diferenças entre as codificações XML e binárias normalmente dependa do cenário, um ganho em tamanho de mais de 33% ao transmitir uma carga de 500 MB normalmente não é aceitável.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="0dbfe-127">Para evitar essa sobrecarga de codificação, o padrão MTOM (Mecanismo de otimização de transmissão de mensagens) permite exteriorizar grandes elementos de dados contidos em uma mensagem e carregá-los com a mensagem como dados binários sem nenhuma codificação especial.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="0dbfe-128">Com o MTOM, as mensagens são trocadas de forma semelhante às mensagens de e-mail Do Simple Mail Transfer Protocol (SMTP) com anexos ou conteúdo incorporado (imagens e outros conteúdos incorporados); As mensagens MTOM são embaladas como seqüências MIME multiparte/relacionadas, com a parte raiz sendo a mensagem SOAP real.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="0dbfe-129">Uma mensagem SOAP MTOM é modificada de sua versão não codificada de forma que as marcas dos elementos especiais que se referem às respectivas partes MIME tomam o lugar dos elementos originais na mensagem que continha dados binários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="0dbfe-130">Como resultado, a mensagem SOAP faz referência ao conteúdo binário apontando para as partes MIME enviadas com ela, mas por outro lado carrega apenas dados de texto XML.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="0dbfe-131">Como esse modelo está bastante alinhado com o bem-estabelecido modelo SMTP, há um amplo suporte de ferramentas para codificar e decodificar mensagens MTOM em muitas plataformas, o que o torna uma escolha extremamente interoperável.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="0dbfe-132">Ainda assim, como com a Base64, o MTOM também vem com uma sobrecarga necessária para o formato MIME, de forma que as vantagens de se usar o MTOM são consideradas apenas quando o tamanho de um elemento de dados binários excede aproximadamente 1 KB.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="0dbfe-133">Devido à sobrecarga, as mensagens codificadas por MTOM podem ser maiores que as mensagens que usam a codificação de Base64 para dados binários, se a carga de binários permanecer abaixo desse limite.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="0dbfe-134">Para obter mais informações, consulte a seção "Codificações" mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="0dbfe-135">Grande conteúdo de dados</span><span class="sxs-lookup"><span data-stu-id="0dbfe-135">Large Data Content</span></span>  
 <span data-ttu-id="0dbfe-136">Deixando a superfície eletrônica de lado, a carga de 500 MB mencionada anteriormente também representa um grande desafio local para o serviço e o cliente.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="0dbfe-137">Por padrão, o WCF processa mensagens no *modo tampão*.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="0dbfe-138">Isso significa que todo o conteúdo de uma mensagem está presente na memória antes de ser enviado ou depois de ser recebido.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="0dbfe-139">Embora essa seja uma boa estratégia na maioria dos cenários e seja necessária para recursos de mensagens, como assinaturas digitais e entrega confiável, grandes mensagens podem esgotar os recursos do sistema.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="0dbfe-140">A estratégia para manipular cargas grandes é o streaming.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="0dbfe-141">Embora as mensagens, especialmente as expressas em XML, normalmente sejam consideradas como pacotes de dados relativamente compactos, uma mensagem pode ter um tamanho de vários gigabytes e parecer mais um fluxo de dados contínuo do que um pacote de dados.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="0dbfe-142">Quando os dados são transferidos no modo de streaming em vez de no modo com buffer, o remetente torna o conteúdo do corpo da mensagem disponível para o destinatário na forma de um fluxo, e a infraestrutura da mensagem encaminha continuamente os dados do remetente para o destinatário conforme eles se tornam disponíveis.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="0dbfe-143">O cenário mais comum onde ocorrem essas grandes transferências de conteúdo de dados são as transferências de objetos de dados binários que:</span><span class="sxs-lookup"><span data-stu-id="0dbfe-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="0dbfe-144">Não podem ser divididos facilmente em uma sequência de mensagens.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="0dbfe-145">Devem ser entregues em tempo hábil.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="0dbfe-146">Não estão totalmente disponíveis quando a transferência é iniciada.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="0dbfe-147">Para dados que não têm essas restrições, normalmente é melhor enviar sequências de mensagens no escopo de uma sessão do que uma grande mensagem.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="0dbfe-148">Para obter mais informações, consulte a seção "Streaming de dados" mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="0dbfe-149">Ao enviar grandes quantidades de dados, `maxAllowedContentLength` você precisará definir a configuração IIS (para `maxReceivedMessageSize` obter mais informações, consulte [Configuração de limites de solicitação de IIS)](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)e a configuração de vinculação (por [exemplo, System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) ou <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span><span class="sxs-lookup"><span data-stu-id="0dbfe-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="0dbfe-150">A `maxAllowedContentLength` propriedade é padrão de 28,6 MB e a `maxReceivedMessageSize` propriedade é padrão para 64KB.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-150">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="0dbfe-151">Codificações</span><span class="sxs-lookup"><span data-stu-id="0dbfe-151">Encodings</span></span>  
 <span data-ttu-id="0dbfe-152">Uma *codificação* define um conjunto de regras sobre como apresentar mensagens no fio.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="0dbfe-153">Um *codificador* implementa tal codificação e é responsável, no lado do <xref:System.ServiceModel.Channels.Message> remetente, por transformar uma in-memory em um fluxo de byteou buffer de bytes que pode ser enviado através da rede.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="0dbfe-154">No lado do destinatário, o codificador transforma uma sequência de bytes em uma mensagem na memória.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="0dbfe-155">O WCF inclui três codificadores e permite que você escreva e conecte seus próprios codificadores, se necessário.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="0dbfe-156">Cada uma das associações padrão inclui um codificador pré-configurado, por meio do qual as associações com o prefixo Net\* usam o codificador binário (incluindo a classe <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>) enquanto as classes <xref:System.ServiceModel.BasicHttpBinding> e <xref:System.ServiceModel.WSHttpBinding> usam o codificador de mensagem de texto (por meio da classe <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>) por padrão.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="0dbfe-157">Elemento de associação do codificador</span><span class="sxs-lookup"><span data-stu-id="0dbfe-157">Encoder binding element</span></span>|<span data-ttu-id="0dbfe-158">Descrição</span><span class="sxs-lookup"><span data-stu-id="0dbfe-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="0dbfe-159">O codificador de mensagem de texto é o codificador padrão para todas as associações baseadas em HTTP e é a escolha apropriada para todas as associações personalizadas onde a interoperabilidade é a maior preocupação.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="0dbfe-160">Esse codificador lê e grava mensagens de texto SOAP 1.1/SOAP 1.2 padrão sem tratamento especial para dados binários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="0dbfe-161">Se <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> a propriedade de uma <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>mensagem estiver definida como , o invólucro do envelope SOAP será omitido da saída e apenas o conteúdo do corpo da mensagem será serializado.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="0dbfe-162">O codificador de mensagem MTOM é um codificador de texto que implementa o tratamento especial de dados binários e, por padrão, não é usado em nenhuma associação padrão porque é estritamente um utilitário de otimização caso a caso.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="0dbfe-163">Se a mensagem contiver dados binários que excedam um limite onde a codificação MTOM gere um benefício, os dados serão exteriorizados em uma parte MIME seguindo o envelope de mensagem.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="0dbfe-164">Consulte Habilitando o MTOM mais adiante nesta seção.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="0dbfe-165">O codificador de mensagens binárias é o codificador padrão para as vinculações Net\* e a escolha apropriada sempre que ambas as partes de comunicação são baseadas em WCF.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="0dbfe-166">O codificador de mensagem binária usa o formato XML binário .NET, uma representação binária específica da Microsoft para Infosets (Conjuntos de informações XML) que geralmente geram uma superfície menor do que a representação XML 1.0 equivalente e codifica dados binários como um fluxo de bytes.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="0dbfe-167">A codificação de mensagem de texto normalmente é a melhor escolha para qualquer caminho de comunicação que exija interoperabilidade, enquanto a codificação de mensagem binária é a melhor escolha para qualquer outro caminho de comunicação.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="0dbfe-168">A codificação de mensagem binária normalmente gera tamanhos menores de mensagens em comparação com texto para um única mensagem e progressivamente até tamanhos menores de mensagens durante uma sessão de comunicação.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="0dbfe-169">Ao contrário da codificação de texto, a codificação binária não precisa usar tratamento especial para dados binários, como o uso da Base64, mas representa bytes como bytes.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="0dbfe-170">Se sua solução não exigir interoperabilidade, mas se você ainda desejar usar transporte HTTP, poderá compor o <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> em uma associação personalizada que use a classe <xref:System.ServiceModel.Channels.HttpTransportBindingElement> para o transporte.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="0dbfe-171">Se vários clientes em seu serviço exigirem interoperabilidade, será recomendável expor os pontos de extremidade paralelos para que cada um tenha as opções apropriadas de transporte e de codificação para os respectivos clientes habilitados.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="0dbfe-172">Habilitando o MTOM</span><span class="sxs-lookup"><span data-stu-id="0dbfe-172">Enabling MTOM</span></span>  
 <span data-ttu-id="0dbfe-173">Quando a interoperabilidade for um requisito e dados binários grandes precisarem ser enviados, a codificação de mensagem MTOM será a estratégia de codificação alternativa que você pode habilitar nas associações padrão <xref:System.ServiceModel.BasicHttpBinding> ou <xref:System.ServiceModel.WSHttpBinding> definindo a respectiva propriedade `MessageEncoding` como <xref:System.ServiceModel.WSMessageEncoding.Mtom> ou compondo <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> em <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="0dbfe-174">O código de exemplo a seguir, extraído da amostra [de codificação MTOM,](../../../../docs/framework/wcf/samples/mtom-encoding.md) demonstra como ativar o MTOM na configuração.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="0dbfe-175">Conforme mencionado anteriormente, a decisão de usar a codificação MTOM depende do volume de dados que você está enviando.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="0dbfe-176">Além disso, como o MTOM é habilitado no nível da associação, a habilitação do MTOM afeta todas as operações em um determinado ponto de extremidade.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="0dbfe-177">Como o codificador MTOM sempre emite uma mensagem MIME/de várias partes codificada por MTOM independentemente dos dados binários acabarem sendo exteriorizados, geralmente você deve habilitar o MTOM apenas para pontos de extremidade que trocam mensagens com mais de 1 KB de dados binários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="0dbfe-178">Além disso, os contratos de serviço criados para uso com pontos de extremidade habilitados para MTOM devem, quando possível, ser restringidos para especificar essas operações de transferência de dados.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="0dbfe-179">A funcionalidade de controle relacionada deve residir em um contrato separado.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="0dbfe-180">Essa regra de "apenas MTOM" se aplica apenas a mensagens enviadas por meio de um ponto de extremidade habilitado para MTOM. O codificador MTOM também pode decodificar e analisar mensagens de entrada não MTOM.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="0dbfe-181">O uso do codificador MTOM está de acordo com todos os outros recursos do WCF.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="0dbfe-182">Observe que talvez não seja possível seguir essa regra em todos os casos, como quando o suporte à sessão for necessário.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="0dbfe-183">Modelo de Programação</span><span class="sxs-lookup"><span data-stu-id="0dbfe-183">Programming Model</span></span>  
 <span data-ttu-id="0dbfe-184">Independentemente de quais dos três codificadores internos você usar em seu aplicativo, a experiência de programação é idêntica no que diz respeito à transferência de dados binários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="0dbfe-185">A diferença está na forma como o WCF lida com os dados com base em seus tipos de dados.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="0dbfe-186">Ao usar o MTOM, o contrato de dados anterior é serializado de acordo com as seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="0dbfe-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="0dbfe-187">Se `binaryBuffer` não for `null` e individualmente contiver dados suficientes para justificar a sobrecarga de exteriorização do MTOM (cabeçalhos MIME etc.) quando comparado com a codificação Base64, os dados serão exteriorizados e transportados com a mensagem como uma parte MIME binária.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="0dbfe-188">Se o limite não for excedido, os dados serão codificados como Base64.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="0dbfe-189">A cadeia de caracteres (e todos os outros tipos que não sejam binários) sempre é representada como uma cadeia de caracteres no corpo da mensagem, independentemente do tamanho.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="0dbfe-190">O efeito na codificação MTOM será o mesmo se você usar um contrato de dados explícito, conforme mostrado no exemplo anterior, usar uma lista de parâmetros em uma operação, tiver contratos de dados aninhados ou transferir um objeto do contrato de dados em uma coleção.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="0dbfe-191">Matrizes de bytes são sempre candidatas à otimização e serão otimizadas se os limites de otimização estiverem sendo atendidos.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0dbfe-192">Você não deve usar tipos derivados de <xref:System.IO.Stream?displayProperty=nameWithType> em contratos de dados.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="0dbfe-193">Os dados de fluxo devem ser comunicados usando o modelo de streaming, explicado na seção "Dados de streaming".</span><span class="sxs-lookup"><span data-stu-id="0dbfe-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="0dbfe-194">Dados de streaming</span><span class="sxs-lookup"><span data-stu-id="0dbfe-194">Streaming Data</span></span>  
 <span data-ttu-id="0dbfe-195">Quando você tem uma grande quantidade de dados para transferir, o modo de transferência de streaming no WCF é uma alternativa viável ao comportamento padrão de buffering e processamento de mensagens na memória em sua totalidade.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="0dbfe-196">Conforme mencionado anteriormente, habilite o streaming apenas para mensagens grandes (com conteúdo de texto ou binário), se os dados não puderem ser segmentados, se a mensagem precisar ser entregue em tempo hábil ou se os dados ainda não estiverem totalmente disponíveis quando a transferência for iniciada.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="0dbfe-197">Restrições</span><span class="sxs-lookup"><span data-stu-id="0dbfe-197">Restrictions</span></span>  
 <span data-ttu-id="0dbfe-198">Não é possível usar um número significativo de recursos WCF quando o streaming está ativado:</span><span class="sxs-lookup"><span data-stu-id="0dbfe-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="0dbfe-199">As assinaturas digitais do corpo da mensagem não podem ser executadas porque exigem a computação de um hash sobre o conteúdo da mensagem inteira.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="0dbfe-200">No streaming, o conteúdo não está totalmente disponível quando os cabeçalhos da mensagem são construídos e enviados e, portanto, uma assinatura digital não pode ser computada.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="0dbfe-201">A criptografia depende das assinaturas digitais para verificar se os dados foram reconstruídos corretamente.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="0dbfe-202">As sessões confiáveis devem armazenar as mensagens enviadas em buffer no cliente para nova entrega no caso de uma mensagem ser perdida na transferência e devem manter as mensagens no serviço antes de entregá-las para a implementação do serviço para preservar a ordem das mensagens no caso de as mensagens serem recebidas fora da sequência.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="0dbfe-203">Devido a essas restrições funcionais, você pode usar somente opções de segurança em nível de transporte para streaming e não pode ativar sessões confiáveis.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="0dbfe-204">O streaming está disponível somente com as seguintes associações definidas pelo sistema:</span><span class="sxs-lookup"><span data-stu-id="0dbfe-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="0dbfe-205">Como os transportes subjacentes de <xref:System.ServiceModel.NetTcpBinding> e <xref:System.ServiceModel.NetNamedPipeBinding> têm entrega confiável inerente e suporte à sessão com base na conexão, ao contrário do HTTP, na prática, essas duas associações são afetadas somente minimamente por essas restrições.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="0dbfe-206">O streaming não está disponível com o transporte de MSMQ (enfileiramento de mensagens) e, portanto, não pode ser usado com a classe <xref:System.ServiceModel.NetMsmqBinding> ou <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="0dbfe-207">O transporte de enfileiramento de mensagens dá suporte apenas a transferências de dados em buffer com um tamanho restrito de mensagem, enquanto todos os outros transportes não têm nenhum limite prático de tamanho de mensagem para a grande maioria dos cenários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="0dbfe-208">O streaming também não está disponível ao usar o transporte de Canal de mesmo nível, portanto, não está disponível com <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="0dbfe-209">Streaming e sessões</span><span class="sxs-lookup"><span data-stu-id="0dbfe-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="0dbfe-210">Você pode obter um comportamento inesperado durante o streaming de chamadas com uma associação baseada em sessão.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="0dbfe-211">Todas as chamadas de streaming são feitas por um único canal (o canal de datagrama) que não oferece suporte a sessões mesmo que a associação que está sendo usada esteja configurada para usar sessões.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="0dbfe-212">Se vários clientes fizerem chamadas de streaming para o mesmo objeto sobre uma associação baseada em sessão, e o modo de simultaneidade do serviço estiver definido como único, e o modo de contexto de sua instância estiver definido como PerSession, todas as chamadas deverão passar pelo canal de datagrama e, portanto, apenas uma chamada será processada de cada vez.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="0dbfe-213">Um ou mais clientes podem, então, cronometrados. Você pode contornar esse problema definindo o modo de contexto de ocorrência do objeto de serviço como PerCall ou Concurrency para Multiple.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0dbfe-214">MaxConcurrentSessions não tem efeito nesse caso porque há apenas uma "sessão" disponível.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="0dbfe-215">Habilitando o streaming</span><span class="sxs-lookup"><span data-stu-id="0dbfe-215">Enabling Streaming</span></span>  
 <span data-ttu-id="0dbfe-216">Você pode habilitar o streaming das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="0dbfe-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="0dbfe-217">Enviar e aceitar solicitações no modo de streaming e aceitar e retornar respostas no modo com buffer (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="0dbfe-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="0dbfe-218">Enviar e aceitar solicitações no modo com buffer e aceitar e retornar respostas no modo streaming (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="0dbfe-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="0dbfe-219">Enviar e receber solicitações e respostas no modo streaming nas duas direções.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="0dbfe-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="0dbfe-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="0dbfe-221">Você pode desabilitar o streaming definindo o modo de transferência como <xref:System.ServiceModel.TransferMode.Buffered>, que é a configuração padrão em todas as associações.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="0dbfe-222">O código a seguir mostra como definir o modo de transferência na configuração.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="0dbfe-223">Ao criar uma instância de sua associação no código, você deve definir a respectiva propriedade `TransferMode` da associação (ou o elemento de associação de transporte se estiver compondo uma associação personalizada) para um dos valores mencionados anteriormente.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="0dbfe-224">Você pode ativar o streaming para solicitações e respostas ou para as duas direções independentemente, em qualquer lado das partes da comunicação sem afetar a funcionalidade.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="0dbfe-225">No entanto, você deve sempre presumir que o tamanho dos dados transferidos é tão significativo que a habilitação de streaming é justificada nos dois pontos de extremidade de um link de comunicação.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="0dbfe-226">Para a comunicação multiplataforma onde um dos pontos finais não é implementado com o WCF, a capacidade de usar o streaming depende dos recursos de streaming da plataforma.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="0dbfe-227">Outra rara exceção pode ser um cenário orientado pelo consumo de memória, onde um cliente ou um serviço deve minimizar o conjunto de trabalho e possa suportar apenas tamanhos de buffer pequenos.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="0dbfe-228">Habilitando o streaming assíncrono</span><span class="sxs-lookup"><span data-stu-id="0dbfe-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="0dbfe-229">Para habilitar o streaming assíncrono, adicione o comportamento do ponto de extremidade <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> ao host de serviço e defina sua propriedade <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> como `true`.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="0dbfe-230">Também adicionamos o recurso de streaming assíncrono verdadeiro no lado do envio.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="0dbfe-231">Isso melhora a escalabilidade do serviço em cenários onde ele está executando o streaming de mensagens para vários clientes, alguns dos quais estão lendo lentamente, possivelmente devido a congestionamento da rede, ou não estão lendo nada.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="0dbfe-232">Nesses cenários, agora não bloqueamos threads individuais no serviço por cliente.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="0dbfe-233">Isso garante que o serviço possa processar muito mais clientes, melhorando dessa forma a escalabilidade do serviço.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="0dbfe-234">Modelo de programação para transferências por streaming</span><span class="sxs-lookup"><span data-stu-id="0dbfe-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="0dbfe-235">O modelo de programação de streaming é simples.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="0dbfe-236">Para receber dados por streaming, especifique um contrato de operação que tenha um único parâmetro de entrada tipada <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="0dbfe-237">Para retornar dados por streaming, retorne uma referência a <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="0dbfe-238">A operação `Echo` no exemplo anterior recebe e retorna um fluxo e, portanto, deve ser usada em uma associação com <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="0dbfe-239">Para a operação `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> é a melhor opção, porque retorna apenas <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="0dbfe-240">A operação unidirecional é mais adequada para <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="0dbfe-241">Observe que a adição de um segundo parâmetro às seguintes operações de `Echo` ou `ProvideInfo` faz com que o modelo do serviço seja revertido para uma estratégia em buffer e use a representação da serialização do tempo de execução do fluxo.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="0dbfe-242">Apenas operações com um único parâmetro de fluxo de entrada são compatíveis com streaming de solicitação de ponta a ponta.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="0dbfe-243">Essa regra se aplica da mesma forma a contratos de mensagens.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="0dbfe-244">Conforme mostrado no contrato de mensagem a seguir, você pode ter apenas um único membro de corpo em seu contrato de mensagem que seja um fluxo.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="0dbfe-245">Se você desejar comunicar informações adicionais com o fluxo, essas informações deverão ser transportadas em cabeçalhos de mensagem.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="0dbfe-246">O corpo da mensagem é exclusivamente reservado para o conteúdo do fluxo.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="0dbfe-247">Transferências em streaming são encerradas e a mensagem é fechada quando o fluxo atinge o EOF (final do arquivo).</span><span class="sxs-lookup"><span data-stu-id="0dbfe-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="0dbfe-248">Ao enviar uma mensagem (retornando um valor ou <xref:System.IO.FileStream> invocando uma operação), você pode passar a e a infra-estrutura WCF posteriormente retira todos os dados desse fluxo até que o fluxo tenha sido completamente lido e alcançado o EOF.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="0dbfe-249">Para transferir dados em streaming para uma origem onde não existe nenhuma classe derivada <xref:System.IO.Stream> pré-criada, construa essa classe, sobreponha-a sobre a origem do fluxo e use como o argumento ou o valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="0dbfe-250">Ao receber uma mensagem, o WCF constrói um fluxo sobre o conteúdo do corpo de mensagem codificado pela Base64 (ou a respectiva parte MIME se estiver usando MTOM) e o fluxo atinge o EOF quando o conteúdo foi lido.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="0dbfe-251">O streaming em nível de transporte também funciona com qualquer outro tipo de contrato de mensagem (listas de parâmetros, argumentos de contratos de dados e contrato de mensagem explícito), mas como a serialização e a desserialização dessas mensagens tipadas exigem buffer pelo serializador, não é aconselhável usar essas variantes de contrato.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="0dbfe-252">Considerações de segurança especial para grandes dados</span><span class="sxs-lookup"><span data-stu-id="0dbfe-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="0dbfe-253">Todas as associações permitem restringir o tamanho das mensagens de entrada para evitar ataques de negação de serviço.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="0dbfe-254">A, <xref:System.ServiceModel.BasicHttpBinding>por exemplo, expõe uma propriedade [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) que limita o tamanho da mensagem recebida e, portanto, também limita a quantidade máxima de memória que é acessada ao processar a mensagem.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="0dbfe-255">Essa unidade é definida em bytes com um valor padrão de 65.536 bytes.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="0dbfe-256">Uma ameaça de segurança que é específica para o cenário de streaming de dados grandes provoca uma negação de serviço fazendo com que os dados sejam armazenados em buffer quando o receptor espera que os dados sejam enviados por streaming.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="0dbfe-257">Por exemplo, o WCF sempre tampona os cabeçalhos SOAP de uma mensagem e, portanto, um invasor pode construir uma grande mensagem maliciosa que consiste inteiramente de cabeçalhos para forçar que os dados sejam protegidos.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="0dbfe-258">Quando o streaming está habilitado, `MaxReceivedMessageSize` pode ser definido como um valor extremamente grande, porque o receptor nunca espera que a mensagem inteira seja imediatamente armazenada em buffer na memória.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="0dbfe-259">Se o WCF for forçado a tamponar a mensagem, um estouro de memória ocorrerá.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="0dbfe-260">Portanto, restringir o tamanho máximo de mensagens de entrada não é suficiente nesse caso.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="0dbfe-261">A `MaxBufferSize` propriedade é necessária para restringir a memória que o WCF buffers.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="0dbfe-262">É importante definir isso como um valor seguro (ou manter o valor padrão) ao usar streaming.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="0dbfe-263">Por exemplo, suponha que o serviço precise receber arquivos de até 4 GB de tamanho e armazená-los no disco local.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="0dbfe-264">Suponha também que sua memória esteja restrita de tal forma que você possa armazenar apenas 64 KB de dados em buffer de cada vez.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="0dbfe-265">Portanto, você deve definir `MaxReceivedMessageSize` como 4 GB e `MaxBufferSize` como 64 KB.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="0dbfe-266">Além disso, na implementação de seu serviço, garanta que você leia somente o fluxo de entrada em partes de 64 KB e não leia a próxima parte antes que a anterior seja gravada em disco e descartada da memória.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="0dbfe-267">Também é importante entender que essa cota limita apenas o buffering feito pelo WCF e não pode protegê-lo contra qualquer buffering que você faça em seu próprio serviço ou implementação do cliente.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="0dbfe-268">Para obter mais informações sobre considerações adicionais de segurança, consulte [Considerações de segurança para dados](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="0dbfe-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0dbfe-269">A decisão de usar transferência em buffer ou em streaming é uma decisão local do ponto de extremidade.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="0dbfe-270">Para transportes HTTP, o modo de transferência não se propaga para uma conexão ou para servidores proxy e outros intermediários.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="0dbfe-271">A definição do modo de transferência não é refletida na descrição da interface de serviço.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="0dbfe-272">Depois de gerar um cliente WCF para um serviço, você deve editar o arquivo de configuração para serviços destinados a serem usados com transferências transmitidas para definir o modo.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="0dbfe-273">Para transportes TCP e pipe nomeado, o modo de transferência é propagado como uma declaração de política.</span><span class="sxs-lookup"><span data-stu-id="0dbfe-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0dbfe-274">Confira também</span><span class="sxs-lookup"><span data-stu-id="0dbfe-274">See also</span></span>

- [<span data-ttu-id="0dbfe-275">Como habilitar transmissão</span><span class="sxs-lookup"><span data-stu-id="0dbfe-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)
