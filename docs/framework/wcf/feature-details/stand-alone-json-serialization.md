---
title: Serialização JSON autônoma usando DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 39d3c0acd75ffd9a54c5e62a15487a2cd8c465cb
ms.sourcegitcommit: dfad244ba549702b649bfef3bb057e33f24a8fb2
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/12/2020
ms.locfileid: "75904599"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="e0e4f-102">Serialização JSON autônoma usando DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="e0e4f-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="e0e4f-103">Este artigo é sobre <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="e0e4f-104">Para a maioria dos cenários que envolvem a serialização e desserialização do JSON, recomendamos as APIs no [namespace System. Text. JSON](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span> 

<span data-ttu-id="e0e4f-105">O JSON (JavaScript Object Notation) é um formato de dados projetado especificamente para ser usado pelo código JavaScript em execução em páginas da Web dentro do navegador.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="e0e4f-106">É o formato de dados padrão usado pelos serviços AJAX ASP.NET criados no Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="e0e4f-107">Esse formato também pode ser usado ao criar serviços AJAX sem integração com ASP.NET-nesse caso, XML é o padrão, mas JSON pode ser escolhido.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="e0e4f-108">Por fim, se você precisar de suporte a JSON, mas não estiver criando um serviço AJAX, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> torna possível serializar diretamente objetos .NET em dados JSON e desserializar esses dados de volta em instâncias de tipos .NET.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="e0e4f-109">Para obter uma descrição de como fazer isso, consulte [como serializar e desserializar dados JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="e0e4f-110">Ao trabalhar com JSON, os mesmos tipos .NET têm suporte, com algumas exceções, assim como têm suporte pelo <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="e0e4f-111">Para obter uma lista dos tipos com suporte, consulte [tipos com suporte no serializador de contrato de dados](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="e0e4f-112">Isso inclui a maioria dos tipos primitivos, a maioria dos tipos de matriz e coleção, bem como tipos complexos que usam o <xref:System.Runtime.Serialization.DataContractAttribute> e <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="e0e4f-113">Mapeando tipos .NET para tipos JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="e0e4f-114">A tabela a seguir mostra a correspondência entre tipos .NET e tipos JSON/JavaScript quando mapeados por procedimentos de serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="e0e4f-115">Tipos .NET</span><span class="sxs-lookup"><span data-stu-id="e0e4f-115">.NET Types</span></span>|<span data-ttu-id="e0e4f-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="e0e4f-116">JSON/JavaScript</span></span>|<span data-ttu-id="e0e4f-117">{1&gt;Observações&lt;1}</span><span class="sxs-lookup"><span data-stu-id="e0e4f-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="e0e4f-118">Todos os tipos numéricos, por exemplo <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="e0e4f-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="e0e4f-119">Número</span><span class="sxs-lookup"><span data-stu-id="e0e4f-119">Number</span></span>|<span data-ttu-id="e0e4f-120">Valores especiais como `Double.NaN`, `Double.PositiveInfinity` e `Double.NegativeInfinity` não têm suporte e resultam em JSON inválido.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="e0e4f-121">Número</span><span class="sxs-lookup"><span data-stu-id="e0e4f-121">Number</span></span>|<span data-ttu-id="e0e4f-122">Consulte "enumerações e JSON", mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="e0e4f-123">Booliano</span><span class="sxs-lookup"><span data-stu-id="e0e4f-123">Boolean</span></span>|--|
|<span data-ttu-id="e0e4f-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="e0e4f-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="e0e4f-125">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="e0e4f-125">String</span></span>|--|
|<span data-ttu-id="e0e4f-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="e0e4f-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="e0e4f-127">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="e0e4f-127">String</span></span>|<span data-ttu-id="e0e4f-128">O formato desses tipos em JSON é o mesmo que em XML (basicamente, TimeSpan no formato de duração ISO 8601, GUID no formato "12345678-ABCD-ABCD-ABCD-1234567890AB" e URI em seu formulário de cadeia de caracteres natural, como "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="e0e4f-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="e0e4f-129">Para obter informações precisas, consulte [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="e0e4f-130">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="e0e4f-130">String</span></span>|<span data-ttu-id="e0e4f-131">O formato é "nome: namespace" (qualquer coisa antes do primeiro dois-pontos é o nome).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="e0e4f-132">O nome ou o namespace pode estar ausente.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="e0e4f-133">Se não houver nenhum namespace, os dois pontos também poderão ser omitidos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="e0e4f-134"><xref:System.Array> do tipo <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="e0e4f-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="e0e4f-135">Matriz de números</span><span class="sxs-lookup"><span data-stu-id="e0e4f-135">Array of numbers</span></span>|<span data-ttu-id="e0e4f-136">Cada número representa o valor de um byte.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="e0e4f-137">DateTime ou cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="e0e4f-137">DateTime or String</span></span>|<span data-ttu-id="e0e4f-138">Confira datas/horas e JSON mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="e0e4f-139">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-139">Complex type</span></span>|<span data-ttu-id="e0e4f-140">Confira datas/horas e JSON mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="e0e4f-141">Tipos XML e ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="e0e4f-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="e0e4f-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="e0e4f-143">Matrizes de <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="e0e4f-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="e0e4f-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="e0e4f-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="e0e4f-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="e0e4f-146">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="e0e4f-146">String</span></span>|<span data-ttu-id="e0e4f-147">Consulte a seção tipos de XML e JSON deste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="e0e4f-148">Tipo complexo vazio</span><span class="sxs-lookup"><span data-stu-id="e0e4f-148">Empty complex type</span></span>|--|
|<span data-ttu-id="e0e4f-149">Coleções, dicionários e matrizes</span><span class="sxs-lookup"><span data-stu-id="e0e4f-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="e0e4f-150">Matriz</span><span class="sxs-lookup"><span data-stu-id="e0e4f-150">Array</span></span>|<span data-ttu-id="e0e4f-151">Consulte a seção coleções, dicionários e matrizes deste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="e0e4f-152">Tipos complexos (com o <xref:System.Runtime.Serialization.DataContractAttribute> ou <xref:System.SerializableAttribute> aplicados)</span><span class="sxs-lookup"><span data-stu-id="e0e4f-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="e0e4f-153">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-153">Complex type</span></span>|<span data-ttu-id="e0e4f-154">Os membros de dados tornam-se membros do tipo complexo do JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="e0e4f-155">Tipos complexos que implementam a interface <xref:System.Runtime.Serialization.ISerializable>)</span><span class="sxs-lookup"><span data-stu-id="e0e4f-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="e0e4f-156">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-156">Complex type</span></span>|<span data-ttu-id="e0e4f-157">O mesmo que outros tipos complexos, mas não há suporte para alguns tipos de <xref:System.Runtime.Serialization.ISerializable> – consulte a parte de suporte de ISerializable da seção informações avançadas deste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="e0e4f-158">`Null` valor para qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-158">`Null` value for any type</span></span>|<span data-ttu-id="e0e4f-159">Nulo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-159">Null</span></span>|<span data-ttu-id="e0e4f-160">Os tipos anuláveis também têm suporte e são mapeados para JSON da mesma maneira que os tipos não anuláveis.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-160">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="e0e4f-161">Enumerações e JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-161">Enumerations and JSON</span></span>

<span data-ttu-id="e0e4f-162">Os valores de membro de enumeração são tratados como números em JSON, que é diferente de como eles são tratados em contratos de dados, onde eles são incluídos como nomes de membros.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="e0e4f-163">Para obter mais informações sobre o tratamento de contrato de dados, consulte [tipos de enumeração em contratos de dados](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="e0e4f-164">Por exemplo, se você tiver `public enum Color {red, green, blue, yellow, pink}`, a serialização `yellow` produzirá o número 3 e não a cadeia de caracteres "amarelo".</span><span class="sxs-lookup"><span data-stu-id="e0e4f-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="e0e4f-165">Todos os membros de `enum` são serializáveis.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-165">All `enum` members are serializable.</span></span> <span data-ttu-id="e0e4f-166">O <xref:System.Runtime.Serialization.EnumMemberAttribute> e os atributos de <xref:System.NonSerializedAttribute> serão ignorados se forem usados.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="e0e4f-167">É possível desserializar um valor de `enum` inexistente, por exemplo, o valor 87 pode ser desserializado no enum de cor anterior, embora não haja nenhum nome de cor correspondente definido.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="e0e4f-168">Um `enum` de sinalizadores não é especial e é tratado da mesma forma que qualquer outro `enum`.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="e0e4f-169">Datas/horas e JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-169">Dates/Times and JSON</span></span>

<span data-ttu-id="e0e4f-170">O formato JSON não dá suporte direto a datas e horários.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="e0e4f-171">No entanto, eles são muito usados e o ASP.NET AJAX fornece suporte especial para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="e0e4f-172">Ao usar proxies AJAX ASP.NET, o tipo de <xref:System.DateTime> no .NET corresponde totalmente ao tipo de `DateTime` em JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="e0e4f-173">Quando não estiver usando ASP.NET, um tipo de <xref:System.DateTime> será representado em JSON como uma cadeia de caracteres com um formato especial que é descrito na seção informações avançadas deste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="e0e4f-174"><xref:System.DateTimeOffset> é representado em JSON como um tipo complexo: {"DateTime":d ateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="e0e4f-175">O membro de `offsetMinutes` é o deslocamento de hora local do GMT (horário de Greenwich), também conhecido como UTC (tempo Universal Coordenado), associado ao local do evento de interesse.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="e0e4f-176">O membro `dateTime` representa a instância no tempo em que o evento de interesse ocorreu (novamente, ele se torna um `DateTime` em JavaScript quando o ASP.NET AJAX está em uso e uma cadeia de caracteres quando não está).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="e0e4f-177">Na serialização, o membro `dateTime` é sempre serializado em GMT.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="e0e4f-178">Portanto, se descrever o tempo de Nova York 3:00, `dateTime` tem um componente de tempo de 8:00 AM e `offsetMinutes` são 300 (menos de 300 minutos ou 5 horas a partir de GMT).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="e0e4f-179">os objetos <xref:System.DateTime> e <xref:System.DateTimeOffset>, quando serializados para JSON, só preservam as informações para a precisão de milissegundos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="e0e4f-180">Valores de submilissegundos (micro/nanossegundos) são perdidos durante a serialização.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="e0e4f-181">Tipos XML e JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-181">XML Types and JSON</span></span>

<span data-ttu-id="e0e4f-182">Os tipos XML se tornam cadeias de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="e0e4f-183">Por exemplo, se um membro de dados "q" do tipo XElement contiver \<ABC/>, o JSON será {"q": "\<ABC/>"}.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="e0e4f-184">Há algumas regras especiais que especificam como o XML é encapsulado-para obter mais informações, consulte a seção informações avançadas mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="e0e4f-185">Se você estiver usando o ASP.NET AJAX e não quiser usar cadeias de caracteres no JavaScript, mas quiser o DOM XML, defina a propriedade <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> como XML em <xref:System.ServiceModel.Web.WebGetAttribute> ou a propriedade <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> como XML no <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="e0e4f-186">Coleções, dicionários e matrizes</span><span class="sxs-lookup"><span data-stu-id="e0e4f-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="e0e4f-187">Todas as coleções, dicionários e matrizes são representadas em JSON como matrizes.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="e0e4f-188">Qualquer personalização que usa o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> é ignorada na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="e0e4f-189">Os dicionários não são uma maneira de trabalhar diretamente com o JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="e0e4f-190">O dicionário\<cadeia de caracteres, > de objeto pode não ter suporte da mesma maneira no WCF, como esperado, para trabalhar com outras tecnologias JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="e0e4f-191">Por exemplo, se "ABC" for mapeado para "XYZ" e "def" for mapeado para 42 em um dicionário, a representação JSON não é {"ABC": "XYZ", "def": 42} Mas é [{"Key": "ABC", "value": "XYZ"}, {"Key": "def", "value": 42}] em vez disso.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="e0e4f-192">Se você quiser trabalhar com o JSON diretamente (acessando chaves e valores dinamicamente, sem definir previamente um contrato rígido), terá várias opções:</span><span class="sxs-lookup"><span data-stu-id="e0e4f-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="e0e4f-193">Considere usar o exemplo de [SERIALIZAÇÃO JSON (Ajax) de tipo fraco](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) .</span><span class="sxs-lookup"><span data-stu-id="e0e4f-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="e0e4f-194">Considere o uso da interface <xref:System.Runtime.Serialization.ISerializable> e dos construtores de desserialização-esses dois mecanismos permitem acessar pares chave/valor JSON na serialização e desserialização, respectivamente, mas não funcionam em cenários de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="e0e4f-195">Considere trabalhar com o [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) em vez de usar um serializador.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="e0e4f-196">*Polimorfismo* no contexto de serialização refere-se à capacidade de serializar um tipo derivado em que seu tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="e0e4f-197">Há regras especiais específicas de JSON ao usar coleções polimorficamente, quando, por exemplo, atribuir uma coleção a um <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="e0e4f-198">Esse problema é discutido mais detalhadamente na seção informações avançadas, mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="e0e4f-199">Detalhes adicionais</span><span class="sxs-lookup"><span data-stu-id="e0e4f-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="e0e4f-200">Ordem dos membros de dados</span><span class="sxs-lookup"><span data-stu-id="e0e4f-200">Order of Data Members</span></span>

<span data-ttu-id="e0e4f-201">A ordem dos membros de dados não é importante ao usar o JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="e0e4f-202">Especificamente, mesmo se <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> estiver definido, os dados JSON ainda poderão ser desserializados em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="e0e4f-203">Tipos JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-203">JSON Types</span></span>

<span data-ttu-id="e0e4f-204">O tipo JSON não precisa corresponder à tabela anterior na desserialização.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="e0e4f-205">Por exemplo, um `Int` normalmente é mapeado para um número JSON, mas ele também pode ser desserializado com êxito de uma cadeia de caracteres JSON, desde que essa cadeia de caracteres contenha um número válido.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="e0e4f-206">Ou seja, {"q": 42} e {"q": "42"} serão válidos se houver um membro de dados `Int` chamado "q".</span><span class="sxs-lookup"><span data-stu-id="e0e4f-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="e0e4f-207">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-207">Polymorphism</span></span>

<span data-ttu-id="e0e4f-208">A serialização polimórfica consiste na capacidade de serializar um tipo derivado em que seu tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="e0e4f-209">Isso tem suporte para serialização JSON pelo WCF comparável à maneira como a serialização de XML tem suporte.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="e0e4f-210">Por exemplo, você pode serializar `MyDerivedType` onde `MyBaseType` é esperado ou serializar `Int` onde `Object` é esperado.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="e0e4f-211">Informações de tipo podem ser perdidas ao desserializar um tipo derivado se o tipo base for esperado, a menos que você esteja desserializando um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="e0e4f-212">Por exemplo, se <xref:System.Uri> for serializado onde <xref:System.Object> é esperado, ele resultará em uma cadeia de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="e0e4f-213">Se essa cadeia de caracteres for desserializada de volta para o <xref:System.Object>, um <xref:System.String> .NET será retornado.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="e0e4f-214">O desserializador não sabe que a cadeia de caracteres era inicialmente do tipo <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="e0e4f-215">Em geral, ao esperar <xref:System.Object>, todas as cadeias de caracteres JSON são desserializadas como cadeias de caracteres .NET, e todas as matrizes JSON usadas para serializar coleções, dicionários e matrizes do .NET são desserializadas como .NET <xref:System.Array> do tipo <xref:System.Object>, independentemente do tipo original real.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="e0e4f-216">Um booliano JSON é mapeado para um <xref:System.Boolean>.NET.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="e0e4f-217">No entanto, ao esperar um <xref:System.Object>, os números JSON são desserializados como .NET <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double>, em que o tipo mais apropriado é escolhido automaticamente.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="e0e4f-218">Ao desserializar em um tipo de interface, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> desserializa como se o tipo declarado fosse Object.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="e0e4f-219">Ao trabalhar com seus próprios tipos base e derivados, o uso do <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> ou um mecanismo equivalente normalmente é necessário.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="e0e4f-220">Por exemplo, se você tiver uma operação que tem um valor de retorno `Animal` e, na verdade, retornar uma instância de `Cat` (derivada de `Animal`), deverá aplicar o <xref:System.Runtime.Serialization.KnownTypeAttribute>, ao tipo `Animal` ou <xref:System.ServiceModel.ServiceKnownTypeAttribute> à operação e especificar o tipo de `Cat` nesses atributos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="e0e4f-221">Para obter mais informações, consulte [tipos conhecidos de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="e0e4f-222">Para obter detalhes de como a serialização polimórfica funciona e uma discussão sobre algumas das limitações que devem ser respeitadas ao usá-la, consulte a seção informações avançadas mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="e0e4f-223">{1&gt;Controle de versão&lt;1}</span><span class="sxs-lookup"><span data-stu-id="e0e4f-223">Versioning</span></span>

<span data-ttu-id="e0e4f-224">Os recursos de controle de versão do contrato de dados, incluindo a interface <xref:System.Runtime.Serialization.IExtensibleDataObject>, têm suporte total em JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="e0e4f-225">Além disso, na maioria dos casos, é possível desserializar um tipo em um formato (por exemplo, XML) e, em seguida, serializá-lo em outro formato (por exemplo, JSON) e ainda preservar os dados em <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="e0e4f-226">Para obter mais informações, consulte [Contratos de dados compatíveis por encaminhamento](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="e0e4f-227">Lembre-se de que JSON não é ordenado, portanto, qualquer informação de pedido é perdida.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="e0e4f-228">Além disso, o JSON não dá suporte a vários pares de chave/valor com o mesmo nome de chave.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="e0e4f-229">Por fim, todas as operações em <xref:System.Runtime.Serialization.IExtensibleDataObject> são inerentemente polimórficas – que é o tipo derivado atribuído a <xref:System.Object>, o tipo base para todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="e0e4f-230">JSON em URLs</span><span class="sxs-lookup"><span data-stu-id="e0e4f-230">JSON in URLs</span></span>

<span data-ttu-id="e0e4f-231">Ao usar pontos de extremidade do ASP.NET AJAX com o verbo HTTP GET (usando o atributo <xref:System.ServiceModel.Web.WebGetAttribute>), os parâmetros de entrada aparecem na URL da solicitação em vez do corpo da mensagem.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="e0e4f-232">O JSON tem suporte mesmo na URL de solicitação, portanto, se você tiver uma operação que usa um `Int` chamado "Number" e um tipo complexo `Person` chamado "p", a URL poderá ser semelhante à URL a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="e0e4f-233">Se você estiver usando um controle e proxy do Gerenciador de script do ASP.NET AJAX para chamar o serviço, essa URL será gerada automaticamente pelo proxy e não será vista.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="e0e4f-234">JSON não pode ser usado em URLs em pontos de extremidade do non-ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="e0e4f-235">Informações avançadas</span><span class="sxs-lookup"><span data-stu-id="e0e4f-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="e0e4f-236">Suporte a ISerializable</span><span class="sxs-lookup"><span data-stu-id="e0e4f-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="e0e4f-237">Tipos ISerializable com e sem suporte</span><span class="sxs-lookup"><span data-stu-id="e0e4f-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="e0e4f-238">Em geral, os tipos que implementam a interface <xref:System.Runtime.Serialization.ISerializable> são totalmente suportados ao serializar/desserializar JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="e0e4f-239">No entanto, alguns desses tipos (incluindo alguns tipos de .NET Framework) são implementados de forma que os aspectos de serialização específicos do JSON façam com que eles não sejam desserializados corretamente:</span><span class="sxs-lookup"><span data-stu-id="e0e4f-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="e0e4f-240">Com <xref:System.Runtime.Serialization.ISerializable>, o tipo de membros de dados individuais nunca é conhecido com antecedência.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="e0e4f-241">Isso leva a uma situação polimórfica semelhante à desserialização de tipos em um objeto.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="e0e4f-242">Como mencionado anteriormente, isso pode levar à perda de informações de tipo em JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="e0e4f-243">Por exemplo, um tipo que serializa um `enum` em sua implementação de <xref:System.Runtime.Serialization.ISerializable> e tenta desserializar diretamente em um `enum` (sem as conversões apropriadas) falha, porque um `enum` é serializado usando números em JSON e números JSON desserializam em tipos numéricos .NET internos (Int32, decimal ou Double).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="e0e4f-244">Portanto, o fato de que o número usado para ser um `enum` valor é perdido.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="e0e4f-245">Um tipo de <xref:System.Runtime.Serialization.ISerializable> que depende de uma determinada ordem de desserialização em seu construtor de desserialização também pode falhar ao desserializar alguns dados JSON, pois a maioria dos serializadores JSON não garante nenhum pedido específico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="e0e4f-246">Tipos de fábrica</span><span class="sxs-lookup"><span data-stu-id="e0e4f-246">Factory Types</span></span>

<span data-ttu-id="e0e4f-247">Embora a interface <xref:System.Runtime.Serialization.IObjectReference> tenha suporte em JSON em geral, todos os tipos que exigem o recurso "tipo de fábrica" (retornando uma instância de um tipo diferente de <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> do que o tipo que implementa a interface) não têm suporte.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="e0e4f-248">Formato de fio de DateTime</span><span class="sxs-lookup"><span data-stu-id="e0e4f-248">DateTime Wire Format</span></span>

<span data-ttu-id="e0e4f-249"><xref:System.DateTime> valores aparecem como cadeias de caracteres JSON na forma de "/Date (700000 + 0500)/", em que o primeiro número (700000 no exemplo fornecido) é o número de milissegundos no fuso horário GMT, tempo normal (economia que não é de verão) desde a meia-noite, 1º de janeiro de 1970.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="e0e4f-250">O número pode ser negativo para representar os horários anteriores.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="e0e4f-251">A parte que consiste em "+ 0500" no exemplo é opcional e indica que a hora é do tipo de <xref:System.DateTimeKind.Local>, ou seja, deve ser convertida no fuso horário local na desserialização.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="e0e4f-252">Se estiver ausente, o tempo será desserializado como <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="e0e4f-253">O número real ("0500" neste exemplo) e seu sinal (+ ou-) são ignorados.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="e0e4f-254">Ao serializar <xref:System.DateTime>, os tempos de <xref:System.DateTimeKind.Local> e <xref:System.DateTimeKind.Unspecified> são gravados com um deslocamento e <xref:System.DateTimeKind.Utc> são gravados sem.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="e0e4f-255">O código JavaScript do cliente ASP.NET AJAX converte automaticamente essas cadeias de caracteres em instâncias de `DateTime` do JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="e0e4f-256">Se houver outras cadeias de caracteres que tenham um formato semelhante que não seja do tipo <xref:System.DateTime> no .NET, elas também serão convertidas.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="e0e4f-257">A conversão só ocorrerá se os caracteres "/" tiverem escape (ou seja, o JSON for semelhante a "\\/Date (700000 + 0500)\\/") e, por esse motivo, o codificador JSON do WCF (habilitado pela <xref:System.ServiceModel.WebHttpBinding>) sempre irá escapar do caractere "/".</span><span class="sxs-lookup"><span data-stu-id="e0e4f-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="e0e4f-258">XML em cadeias de caracteres JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="e0e4f-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="e0e4f-259">XmlElement</span></span>

<span data-ttu-id="e0e4f-260"><xref:System.Xml.XmlElement> é serializado como está, sem encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="e0e4f-261">Por exemplo, o membro de dados "x" do tipo <xref:System.Xml.XmlElement> que contém \<ABC/> é representado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="e0e4f-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="e0e4f-262">Matrizes de XmlNode</span><span class="sxs-lookup"><span data-stu-id="e0e4f-262">Arrays of XmlNode</span></span>

<span data-ttu-id="e0e4f-263"><xref:System.Array> objetos do tipo <xref:System.Xml.XmlNode> são encapsulados em um elemento chamado ArrayOfXmlNode no namespace de contrato de dados padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="e0e4f-264">Se "x" for uma matriz que contém o nó de atributo "N" no namespace "NS" que contém "value" e um nó de elemento vazio "M", a representação será a seguinte.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="e0e4f-265">Não há suporte para atributos no namespace vazio no início de matrizes XmlNode (antes de outros elementos).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="e0e4f-266">Tipos IXmlSerializable, incluindo XElement e DataSet</span><span class="sxs-lookup"><span data-stu-id="e0e4f-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="e0e4f-267">os tipos de <xref:System.Runtime.Serialization.ISerializable> subdividam em "tipos de conteúdo", "tipos de conjunto de conjuntos" e "tipos de elemento".</span><span class="sxs-lookup"><span data-stu-id="e0e4f-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="e0e4f-268">Para obter definições desses tipos, consulte [tipos XML e ADO.net em contratos de dados](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="e0e4f-269">Os tipos "content" e "DataSet" são serializados de forma semelhante a <xref:System.Array> objetos de <xref:System.Xml.XmlNode> discutidos na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="e0e4f-270">Eles são encapsulados em um elemento cujo nome e namespace correspondem ao nome do contrato de dados e ao namespace do tipo em questão.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="e0e4f-271">Tipos de "elemento", como <xref:System.Xml.Linq.XElement>, são serializados como estão, semelhante a <xref:System.Xml.XmlElement> discutido anteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="e0e4f-272">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="e0e4f-273">Preservando informações de tipo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-273">Preserving Type Information</span></span>

<span data-ttu-id="e0e4f-274">Como mencionado anteriormente, o polimorfismo tem suporte em JSON com algumas limitações.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="e0e4f-275">O JavaScript é uma linguagem de tipo fraco e a identidade de tipos normalmente não é um problema.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="e0e4f-276">No entanto, ao usar o JSON para se comunicar entre um sistema fortemente tipado (.NET) e um sistema de tipo fraco (JavaScript), é útil preservar a identidade do tipo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="e0e4f-277">Por exemplo, tipos com nomes de contrato de dados "Square" e "Circle" derivam de um tipo com um nome de contrato de dados de "Shape".</span><span class="sxs-lookup"><span data-stu-id="e0e4f-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="e0e4f-278">Se "Circle" for enviado do .NET para o JavaScript e, posteriormente, for retornado a um método .NET que espera "Shape", será útil para o lado do .NET saber que o objeto em questão foi originalmente um "Circle"; caso contrário, qualquer informação específica ao tipo derivado (por exemplo, , o membro de dados "RADIUS" em "Circle") pode ser perdido.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="e0e4f-279">Para preservar a identidade do tipo, ao serializar tipos complexos para JSON, é possível adicionar uma "dica de tipo", e o desserializador reconhece a dica e age adequadamente.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="e0e4f-280">A "dica de tipo" é um par chave/valor JSON com o nome de chave "\_\_tipo" (dois sublinhados seguidos da palavra "tipo").</span><span class="sxs-lookup"><span data-stu-id="e0e4f-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="e0e4f-281">O valor é uma cadeia de caracteres JSON no formato "datacontractname: DataContractNamespace" (algo até o primeiro dois pontos é o nome).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="e0e4f-282">Usando o exemplo anterior, "Circle" pode ser serializado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="e0e4f-283">A dica de tipo é muito semelhante ao atributo `xsi:type` definido pelo padrão de instância de esquema XML e usado ao serializar/desserializar XML.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="e0e4f-284">Os membros de dados chamados "\_tipo de \_" são proibidos devido a um possível conflito com a dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="e0e4f-285">Reduzindo o tamanho das dicas de tipo</span><span class="sxs-lookup"><span data-stu-id="e0e4f-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="e0e4f-286">Para reduzir o tamanho das mensagens JSON, o prefixo do namespace do contrato de dados padrão (`http://schemas.datacontract.org/2004/07/`) é substituído pelo caractere "#".</span><span class="sxs-lookup"><span data-stu-id="e0e4f-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="e0e4f-287">(Para fazer essa substituição reversível, uma regra de escape é usada: se o namespace começar com os caracteres "#" ou "\\", eles serão anexados com um caractere "\\" extra.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="e0e4f-288">Portanto, se "Circle" for um tipo no namespace .NET "MyApp. Shapes", seu namespace de contrato de dados padrão será `http://schemas.datacontract.org/2004/07/MyApp`.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="e0e4f-289">As formas e a representação JSON são as seguintes.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="e0e4f-290">Tanto o truncado (#MyApp. Shapes) quanto o completo (nomes de http://schemas.datacontract.org/2004/07/MyApp.Shapes) são compreendidos na desserialização.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="e0e4f-291">Posição de dica de tipo em objetos JSON</span><span class="sxs-lookup"><span data-stu-id="e0e4f-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="e0e4f-292">Observe que a dica de tipo deve aparecer primeiro na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="e0e4f-293">Esse é o único caso em que a ordem dos pares chave/valor é importante no processamento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="e0e4f-294">Por exemplo, a seguir não é uma maneira válida de especificar a dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="e0e4f-295">Os <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> usados pelas páginas do cliente WCF e ASP.NET AJAX sempre emitem a dica de tipo primeiro.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="e0e4f-296">Dicas de tipo aplicam-se somente a tipos complexos</span><span class="sxs-lookup"><span data-stu-id="e0e4f-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="e0e4f-297">Não é possível emitir uma dica de tipo para tipos não complexos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="e0e4f-298">Por exemplo, se uma operação tiver um tipo de retorno <xref:System.Object>, mas retornar um círculo, a representação JSON poderá ser conforme mostrado anteriormente e as informações de tipo serão preservadas.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="e0e4f-299">No entanto, se o URI for retornado, a representação JSON será uma cadeia de caracteres e o fato de que a cadeia de caracteres usada para representar um URI será perdida.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="e0e4f-300">Isso se aplica não apenas a tipos primitivos, mas também a coleções e matrizes.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="e0e4f-301">Quando as dicas de tipo são emitidas</span><span class="sxs-lookup"><span data-stu-id="e0e4f-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="e0e4f-302">Dicas de tipo podem aumentar significativamente o tamanho da mensagem (uma maneira de mitigar isso é usar namespaces de contrato de dados menores, se possível).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="e0e4f-303">Portanto, as regras a seguir regem se as dicas de tipo são emitidas:</span><span class="sxs-lookup"><span data-stu-id="e0e4f-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="e0e4f-304">Ao usar o ASP.NET AJAX, as dicas de tipo sempre são emitidas sempre que possível, mesmo que não haja nenhuma atribuição base/derivada, por exemplo, mesmo se um círculo for atribuído a um círculo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="e0e4f-305">(Isso é necessário para habilitar totalmente o processo de chamada do ambiente JSON de tipo fraco para o ambiente .NET fortemente tipado sem perda surpreendente de informações.)</span><span class="sxs-lookup"><span data-stu-id="e0e4f-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="e0e4f-306">Ao usar serviços AJAX sem integração ASP.NET, as dicas de tipo são emitidas somente quando há uma atribuição base/derivada, ou seja, emitida quando o círculo é atribuído à forma ou <xref:System.Object>, mas não quando atribuído a um círculo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="e0e4f-307">Isso fornece as informações mínimas necessárias para implementar corretamente um cliente JavaScript, melhorando assim o desempenho, mas não protege contra perda de informações de tipo em clientes incorretamente projetados.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="e0e4f-308">Evite as atribuições de base/derivadas totalmente no servidor se desejar evitar lidar com esse problema no cliente.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="e0e4f-309">Ao usar o tipo de <xref:System.Runtime.Serialization.DataContractSerializer>, o parâmetro de Construtor `alwaysEmitTypeInformation` permite que você escolha entre os dois modos anteriores, com o padrão sendo "`false`" (apenas as dicas de tipo de emissão quando necessário).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="e0e4f-310">Nomes de membros de dados duplicados</span><span class="sxs-lookup"><span data-stu-id="e0e4f-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="e0e4f-311">As informações de tipo derivado estão presentes no mesmo objeto JSON junto com informações de tipo base e podem ocorrer em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="e0e4f-312">Por exemplo, `Shape` pode ser representado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="e0e4f-313">Enquanto o círculo pode ser representado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="e0e4f-314">Se o tipo de `Shape` base também contivesse um membro de dados chamado "`radius`", isso leva a uma colisão na serialização (porque os objetos JSON não podem ter nomes de chave repetidos) e a desserialização (porque ele não está claro se "RADIUS" refere-se a `Shape.radius` ou `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="e0e4f-315">Portanto, embora o conceito de "ocultação de propriedade" (membros de dados de mesmo nome em classes derivadas e baseadas) geralmente não seja recomendado em classes de contrato de dados, na verdade é proibido no caso do JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="e0e4f-316">Tipos polimorfismo e IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="e0e4f-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="e0e4f-317">os tipos de <xref:System.Xml.Serialization.IXmlSerializable> podem ser polimorficamente atribuídos entre si como de costume, desde que os requisitos de tipos conhecidos sejam atendidos, de acordo com as regras de contrato de dados usuais.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="e0e4f-318">No entanto, serializar um tipo de <xref:System.Xml.Serialization.IXmlSerializable> no lugar de <xref:System.Object> resulta na perda de informações de tipo, pois o resultado é uma cadeia de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="e0e4f-319">Polimorfismo e determinados tipos de interface</span><span class="sxs-lookup"><span data-stu-id="e0e4f-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="e0e4f-320">É proibido serializar um tipo de coleção ou um tipo que implementa <xref:System.Xml.Serialization.IXmlSerializable> em que um tipo de não coleção que não é <xref:System.Xml.Serialization.IXmlSerializable> (exceto para <xref:System.Object>) é esperado.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="e0e4f-321">Por exemplo, uma interface personalizada chamada `IMyInterface` e um tipo `MyType` que implementam ambos <xref:System.Collections.Generic.IEnumerable%601> do tipo `int` e `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="e0e4f-322">É proibido retornar `MyType` de uma operação cujo tipo de retorno é `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="e0e4f-323">Isso ocorre porque `MyType` deve ser serializado como uma matriz JSON e requer uma dica de tipo e, conforme declarado antes que você não possa incluir uma dica de tipo com matrizes, somente com tipos complexos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="e0e4f-324">Tipos e configurações conhecidos</span><span class="sxs-lookup"><span data-stu-id="e0e4f-324">Known Types and Configuration</span></span>

<span data-ttu-id="e0e4f-325">Todos os mecanismos de tipo conhecidos usados pelo <xref:System.Runtime.Serialization.DataContractSerializer> também têm suporte da mesma forma pelo <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="e0e4f-326">Ambos os serializadores lêem o mesmo elemento de configuração, [\<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) no [\<System. Runtime. Serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), para descobrir tipos conhecidos adicionados por meio de um arquivo de configuração.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="e0e4f-327">Coleções atribuídas ao objeto</span><span class="sxs-lookup"><span data-stu-id="e0e4f-327">Collections Assigned to Object</span></span>

<span data-ttu-id="e0e4f-328">As coleções atribuídas ao objeto são serializadas como se fossem coleções que implementam <xref:System.Collections.Generic.IEnumerable%601>: uma matriz JSON com cada entrada que tenha uma dica de tipo, se for um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="e0e4f-329">Por exemplo, um <xref:System.Collections.Generic.List%601> do tipo `Shape` atribuído a <xref:System.Object> é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="e0e4f-330">Quando desserializada de volta para o <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="e0e4f-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="e0e4f-331">`Shape` deve estar na lista tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="e0e4f-332">Ter <xref:System.Collections.Generic.List%601> do tipo `Shape` em tipos conhecidos não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="e0e4f-333">Observe que você não precisa adicionar `Shape` a tipos conhecidos na serialização, nesse caso, isso é feito automaticamente.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="e0e4f-334">A coleção é desserializada como um <xref:System.Array> do tipo <xref:System.Object> que contém instâncias de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="e0e4f-335">Coleções derivadas atribuídas a coleções base</span><span class="sxs-lookup"><span data-stu-id="e0e4f-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="e0e4f-336">Quando uma coleção derivada é atribuída a uma coleção de base, a coleção geralmente é serializada como se fosse uma coleção do tipo base.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="e0e4f-337">No entanto, se o tipo de item da coleção derivada não puder ser atribuído ao tipo de item da coleção base, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="e0e4f-338">Dicas de tipo e dicionários</span><span class="sxs-lookup"><span data-stu-id="e0e4f-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="e0e4f-339">Quando um dicionário é atribuído a um <xref:System.Object>, cada entrada de chave e valor no dicionário é tratada como se fosse atribuída a <xref:System.Object> e obtém uma dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="e0e4f-340">Ao serializar tipos de dicionário, o objeto JSON que contém os membros de "chave" e "valor" não é afetado pela configuração de `alwaysEmitTypeInformation` e contém apenas uma dica de tipo quando as regras de coleção anteriores exigem isso.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="e0e4f-341">Nomes de chave JSON válidos</span><span class="sxs-lookup"><span data-stu-id="e0e4f-341">Valid JSON Key Names</span></span>

<span data-ttu-id="e0e4f-342">O serializador XML-codifica nomes de chave que não são nomes XML válidos.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="e0e4f-343">Por exemplo, um membro de dados com o nome de "123" teria um nome codificado como "\_x0031\_\_x0032\_\_x0033\_" porque "123" é um nome de elemento XML inválido (começa com um dígito).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="e0e4f-344">Uma situação semelhante pode surgir com alguns conjuntos de caracteres internacionais não válidos em nomes XML.</span><span class="sxs-lookup"><span data-stu-id="e0e4f-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="e0e4f-345">Para obter uma explicação desse efeito de XML no processamento JSON, consulte [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="e0e4f-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e0e4f-346">Veja também</span><span class="sxs-lookup"><span data-stu-id="e0e4f-346">See also</span></span>

- [<span data-ttu-id="e0e4f-347">Suporte para JSON e outros formatos de transferência de dados</span><span class="sxs-lookup"><span data-stu-id="e0e4f-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
