---
title: Serialização JSON autônoma usando DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 614776a905ec319624f76876762c25bfca15a357
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249442"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="c6f9d-102">Serialização JSON autônoma usando DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="c6f9d-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="c6f9d-103">Este artigo <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>é sobre .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="c6f9d-104">Para a maioria dos cenários que envolvem serialização e desserialização do JSON, recomendamos as APIs no [namespace System.Text.Json](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="c6f9d-105">JSON (JavaScript Object Notation) é um formato de dados que foi projetado especificamente para ser usado pelo código JavaScript em execução em páginas da Web dentro do navegador.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="c6f9d-106">É o formato de dados padrão usado por ASP.NET serviços AJAX criados na Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="c6f9d-107">Esse formato também pode ser usado ao criar serviços AJAX sem se integrar à ASP.NET - neste caso, o XML é o padrão, mas o JSON pode ser escolhido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="c6f9d-108">Finalmente, se você precisar de suporte json, mas <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> não estiver criando um serviço AJAX, é possível serializar diretamente objetos .NET em dados JSON e desserializar esses dados de volta em instâncias de tipos .NET.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="c6f9d-109">Para obter uma descrição de como fazer isso, consulte [Como: Serializar e Desserializar dados JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="c6f9d-110">Ao trabalhar com JSON, os mesmos tipos .NET são suportados, com <xref:System.Runtime.Serialization.DataContractSerializer>algumas exceções, como são suportados pelo .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="c6f9d-111">Para obter uma lista dos tipos suportados, consulte [Tipos suportados pelo Serializador de contrato de dados](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="c6f9d-112">Isso inclui a maioria dos tipos primitivos, a maioria dos <xref:System.Runtime.Serialization.DataContractAttribute> <xref:System.Runtime.Serialization.DataMemberAttribute>tipos de matriz e coleção, bem como tipos complexos que usam o e .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="c6f9d-113">Mapeamento de tipos .NET para tipos JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="c6f9d-114">A tabela a seguir mostra a correspondência entre os tipos .NET e os tipos JSON/JavaScript quando mapeados por procedimentos de serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="c6f9d-115">.NET Tipos</span><span class="sxs-lookup"><span data-stu-id="c6f9d-115">.NET Types</span></span>|<span data-ttu-id="c6f9d-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="c6f9d-116">JSON/JavaScript</span></span>|<span data-ttu-id="c6f9d-117">Observações</span><span class="sxs-lookup"><span data-stu-id="c6f9d-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="c6f9d-118">Todos os tipos numéricos, por exemplo, <xref:System.Int32> <xref:System.Decimal> ou<xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="c6f9d-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="c6f9d-119">Número</span><span class="sxs-lookup"><span data-stu-id="c6f9d-119">Number</span></span>|<span data-ttu-id="c6f9d-120">Valores especiais `Double.NaN` `Double.PositiveInfinity` como `Double.NegativeInfinity` , e não são suportados e resultam em JSON inválido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="c6f9d-121">Número</span><span class="sxs-lookup"><span data-stu-id="c6f9d-121">Number</span></span>|<span data-ttu-id="c6f9d-122">Consulte "Enumerações e JSON" mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="c6f9d-123">Boolean</span><span class="sxs-lookup"><span data-stu-id="c6f9d-123">Boolean</span></span>|--|
|<span data-ttu-id="c6f9d-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="c6f9d-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="c6f9d-125">String</span><span class="sxs-lookup"><span data-stu-id="c6f9d-125">String</span></span>|--|
|<span data-ttu-id="c6f9d-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="c6f9d-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="c6f9d-127">String</span><span class="sxs-lookup"><span data-stu-id="c6f9d-127">String</span></span>|<span data-ttu-id="c6f9d-128">O formato desses tipos em JSON é o mesmo do formato XML (essencialmente, TimeSpan no formato ISO 8601 Duration, GUID no formato "12345678-ABCD-ABCD-ABCD-ABCD-1234567890AB" e URI em sua forma natural de string como " ").http://www.example.com</span><span class="sxs-lookup"><span data-stu-id="c6f9d-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="c6f9d-129">Para obter informações precisas, consulte [Referência esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="c6f9d-130">String</span><span class="sxs-lookup"><span data-stu-id="c6f9d-130">String</span></span>|<span data-ttu-id="c6f9d-131">O formato é "name:namespace" (qualquer coisa antes do primeiro cólon é o nome).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="c6f9d-132">Ou o nome ou o namespace podem estar faltando.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="c6f9d-133">Se não houver espaço de nome, o cólon também pode ser omitido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="c6f9d-134"><xref:System.Array> do tipo <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="c6f9d-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="c6f9d-135">Matriz de números</span><span class="sxs-lookup"><span data-stu-id="c6f9d-135">Array of numbers</span></span>|<span data-ttu-id="c6f9d-136">Cada número representa o valor de um byte.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="c6f9d-137">DateTime ou String</span><span class="sxs-lookup"><span data-stu-id="c6f9d-137">DateTime or String</span></span>|<span data-ttu-id="c6f9d-138">Consulte Dates/Times e JSON mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="c6f9d-139">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-139">Complex type</span></span>|<span data-ttu-id="c6f9d-140">Consulte Dates/Times e JSON mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="c6f9d-141">XML e ADO.NET<xref:System.Xml.XmlElement>tipos ( ,</span><span class="sxs-lookup"><span data-stu-id="c6f9d-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="c6f9d-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="c6f9d-143">Matrizes <xref:System.Xml.XmlNode>de,</span><span class="sxs-lookup"><span data-stu-id="c6f9d-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="c6f9d-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="c6f9d-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="c6f9d-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="c6f9d-146">String</span><span class="sxs-lookup"><span data-stu-id="c6f9d-146">String</span></span>|<span data-ttu-id="c6f9d-147">Consulte a seção XML Types e JSON deste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="c6f9d-148">Tipo complexo vazio</span><span class="sxs-lookup"><span data-stu-id="c6f9d-148">Empty complex type</span></span>|--|
|<span data-ttu-id="c6f9d-149">Coleções, dicionários e matrizes</span><span class="sxs-lookup"><span data-stu-id="c6f9d-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="c6f9d-150">Array</span><span class="sxs-lookup"><span data-stu-id="c6f9d-150">Array</span></span>|<span data-ttu-id="c6f9d-151">Consulte a seção Coleções, Dicionários e Matrizes deste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="c6f9d-152">Tipos complexos <xref:System.Runtime.Serialization.DataContractAttribute> (com o ou <xref:System.SerializableAttribute> aplicado)</span><span class="sxs-lookup"><span data-stu-id="c6f9d-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="c6f9d-153">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-153">Complex type</span></span>|<span data-ttu-id="c6f9d-154">Os membros de dados tornam-se membros do tipo complexo JavaScript.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="c6f9d-155">Tipos complexos <xref:System.Runtime.Serialization.ISerializable> implementando a interface)</span><span class="sxs-lookup"><span data-stu-id="c6f9d-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="c6f9d-156">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-156">Complex type</span></span>|<span data-ttu-id="c6f9d-157">O mesmo que outros <xref:System.Runtime.Serialization.ISerializable> tipos complexos, mas alguns tipos não são suportados – veja a parte de Suporte ISerializable da seção Informações Avançadas deste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="c6f9d-158">`Null`valor para qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-158">`Null` value for any type</span></span>|<span data-ttu-id="c6f9d-159">Nulo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-159">Null</span></span>|<span data-ttu-id="c6f9d-160">Os tipos de valor anulados também são suportados e mapeiam para JSON da mesma forma que os tipos de valor não anulados.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="c6f9d-161">Enumerações e JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-161">Enumerations and JSON</span></span>

<span data-ttu-id="c6f9d-162">Os valores dos membros de enumeração são tratados como números no JSON, o que é diferente de como eles são tratados em contratos de dados, onde são incluídos como nomes de membros.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="c6f9d-163">Para obter mais informações sobre o tratamento do contrato de dados, consulte [Tipos de Enumeração em Contratos de Dados](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="c6f9d-164">Por exemplo, se `public enum Color {red, green, blue, yellow, pink}`você `yellow` tiver, serializar produz o número 3 e não a string "amarelo".</span><span class="sxs-lookup"><span data-stu-id="c6f9d-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="c6f9d-165">Todos `enum` os membros são serializáveis.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-165">All `enum` members are serializable.</span></span> <span data-ttu-id="c6f9d-166">Os <xref:System.Runtime.Serialization.EnumMemberAttribute> atributos e os atributos <xref:System.NonSerializedAttribute> são ignorados se usados.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="c6f9d-167">É possível desserializar um `enum` valor inexistente - por exemplo, o valor 87 pode ser desserializado no enum de cor anterior, embora não haja um nome de cor correspondente definido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="c6f9d-168">Uma `enum` bandeira não é especial e é `enum`tratada como qualquer outra.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="c6f9d-169">Datas/Horários e JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-169">Dates/Times and JSON</span></span>

<span data-ttu-id="c6f9d-170">O formato JSON não suporta diretamente datas e horários.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="c6f9d-171">No entanto, eles são muito comumente usados e ASP.NET AJAX fornece suporte especial para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="c6f9d-172">Ao usar ASP.NET proxies <xref:System.DateTime> AJAX, o tipo em `DateTime` .NET corresponde totalmente ao tipo em JavaScript.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="c6f9d-173">Quando não usa <xref:System.DateTime> ASP.NET, um tipo é representado no JSON como uma string com um formato especial descrito na seção Informações Avançadas deste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="c6f9d-174"><xref:System.DateTimeOffset>é representado no JSON como um tipo complexo: {"DateTime":dateTime",OffsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="c6f9d-175">O `offsetMinutes` membro é o deslocamento do horário local de Greenwich Mean Time (GMT), também agora referido como Tempo Universal Coordenado (UTC), associado à localização do evento de interesse.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="c6f9d-176">O `dateTime` membro representa a instância no momento em que o evento `DateTime` de interesse ocorreu (novamente, torna-se um em JavaScript quando ASP.NET AJAX está em uso e uma string quando não está).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="c6f9d-177">Na serialização, `dateTime` o membro é sempre serializado em GMT.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="c6f9d-178">Então, se descrever 3:00 am horário `dateTime` de Nova York, tem um `offsetMinutes` componente de tempo de 8:00 AM e são 300 (menos 300 minutos ou 5 horas de GMT).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="c6f9d-179"><xref:System.DateTime>e <xref:System.DateTimeOffset> objetos, quando serializados para JSON, apenas preservam informações com precisão de milissegundos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="c6f9d-180">Os valores de submilissegundos (micro/nanossegundos) são perdidos durante a serialização.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="c6f9d-181">Tipos XML e JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-181">XML Types and JSON</span></span>

<span data-ttu-id="c6f9d-182">Os tipos XML tornam-se strings JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="c6f9d-183">Por exemplo, se um membro de dados \<"q" do tipo XElement contiver\<abc/>, o JSON é {"q":" abc/>"}.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="c6f9d-184">Existem algumas regras especiais que especificam como o XML é embrulhado - para obter mais informações, consulte a seção Informações Avançadas mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="c6f9d-185">Se você estiver usando ASP.NET AJAX e não quiser usar strings no JavaScript, mas <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> quiser que <xref:System.ServiceModel.Web.WebGetAttribute> o <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> XML DOM <xref:System.ServiceModel.Web.WebInvokeAttribute>em vez disso, defina a propriedade como XML on ou a propriedade para XML no .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="c6f9d-186">Coleções, Dicionários e Matrizes</span><span class="sxs-lookup"><span data-stu-id="c6f9d-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="c6f9d-187">Todas as coleções, dicionários e matrizes são representados no JSON como matrizes.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="c6f9d-188">Qualquer personalização que <xref:System.Runtime.Serialization.CollectionDataContractAttribute> use o é ignorada na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="c6f9d-189">Dicionários não são uma maneira de trabalhar diretamente com json.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="c6f9d-190">A\<seqüência de dicionários,> de objetos podem não ser suportados da mesma forma no WCF como esperado de trabalhar com outras tecnologias JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="c6f9d-191">Por exemplo, se "abc" for mapeado para "xyz" e "def" é mapeado para 42 em um dicionário, a representação JSON não é {"abc":"xyz","def":42} mas é [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] em vez disso.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="c6f9d-192">Se você gostaria de trabalhar diretamente com jSON (acessando chaves e valores dinamicamente, sem pré-definir um contrato rígido), você tem várias opções:</span><span class="sxs-lookup"><span data-stu-id="c6f9d-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="c6f9d-193">Considere usar a amostra [AJAX (AJAX) de serialização de tipo fraca.](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)</span><span class="sxs-lookup"><span data-stu-id="c6f9d-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="c6f9d-194">Considere usar <xref:System.Runtime.Serialization.ISerializable> os construtores de interface e desserialização - esses dois mecanismos permitem que você acesse os pares de teclas/valor json na serialização e desserialização, respectivamente, mas não funcionam em cenários de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="c6f9d-195">Considere trabalhar com o [Mapeamento Entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) em vez de usar um serializador.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="c6f9d-196">*Polimorfismo* no contexto da serialização refere-se à capacidade de serializar um tipo derivado onde seu tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="c6f9d-197">Existem regras especiais específicas do JSON ao usar coleções polimorficamente, quando, por exemplo, atribuir uma coleção a um <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="c6f9d-198">Esta questão é mais discutida na seção Informações Avançadas mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="c6f9d-199">Detalhes adicionais</span><span class="sxs-lookup"><span data-stu-id="c6f9d-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="c6f9d-200">Ordem dos Membros de Dados</span><span class="sxs-lookup"><span data-stu-id="c6f9d-200">Order of Data Members</span></span>

<span data-ttu-id="c6f9d-201">A ordem dos membros de dados não é importante ao usar o JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="c6f9d-202">Especificamente, mesmo <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> que seja definido, os dados JSON ainda podem ser desserializados em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="c6f9d-203">Tipos JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-203">JSON Types</span></span>

<span data-ttu-id="c6f9d-204">O tipo JSON não precisa corresponder à tabela anterior sobre desserialização.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="c6f9d-205">Por exemplo, `Int` um normalmente mapeia para um número JSON, mas também pode ser desserializado com sucesso de uma seqüência JSON, desde que essa seqüência contenha um número válido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="c6f9d-206">Ou seja, tanto {"q":42} quanto {"q":"42"} `Int` são válidos se houver um membro de dados chamado "q".</span><span class="sxs-lookup"><span data-stu-id="c6f9d-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="c6f9d-207">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-207">Polymorphism</span></span>

<span data-ttu-id="c6f9d-208">A serialização polimórfica consiste na capacidade de serializar um tipo derivado onde seu tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="c6f9d-209">Isso é suportado para serialização JSON por WCF comparável à maneira como a serialização XML é suportada.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="c6f9d-210">Por exemplo, você `MyDerivedType` pode `MyBaseType` serializar onde `Int` é `Object` esperado ou serializar onde é esperado.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="c6f9d-211">As informações de tipo podem ser perdidas ao desserializar um tipo derivado se o tipo de base for esperado, a menos que você esteja desserializando um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="c6f9d-212">Por exemplo, <xref:System.Uri> se for <xref:System.Object> serializado onde é esperado, ele resulta em uma seqüência JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="c6f9d-213">Se essa seqüência for <xref:System.Object>desserializada <xref:System.String> de volta para , uma .NET será devolvida.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="c6f9d-214">O desserializador não sabe que <xref:System.Uri>a seqüência era inicialmente do tipo .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="c6f9d-215">Geralmente, quando <xref:System.Object>espera, todas as strings JSON são desserializadas como strings .NET, e todas as matrizes JSON usadas para <xref:System.Array> serializar coleções.NET, dicionários e matrizes são desserializadas como .NET do tipo, <xref:System.Object>independentemente do que o tipo original real tinha sido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="c6f9d-216">Um json boolean maps <xref:System.Boolean>para um .NET .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="c6f9d-217">No <xref:System.Object>entanto, ao esperar um , os números <xref:System.Int32> <xref:System.Decimal> JSON são desserializados como .NET , ou <xref:System.Double>, onde o tipo mais apropriado é escolhido automaticamente.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="c6f9d-218">Ao desserializar em um <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> tipo de interface, o desserializa como se o tipo declarado fosse objeto.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="c6f9d-219">Ao trabalhar com sua própria base e <xref:System.Runtime.Serialization.KnownTypeAttribute> <xref:System.ServiceModel.ServiceKnownTypeAttribute> tipos derivados, o uso do mecanismo , ou um mecanismo equivalente é normalmente necessário.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="c6f9d-220">Por exemplo, se você tiver `Animal` uma operação que tenha um `Cat` valor de `Animal`retorno e ele <xref:System.Runtime.Serialization.KnownTypeAttribute>realmente `Animal` retornar <xref:System.ServiceModel.ServiceKnownTypeAttribute> uma instância de `Cat` (derivada), você deve aplicar o , ao tipo ou à operação e especificar o tipo nesses atributos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="c6f9d-221">Para obter mais informações, consulte [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="c6f9d-222">Para obter detalhes sobre como funciona a serialização polimórfica e uma discussão sobre algumas das limitações que devem ser respeitadas ao usá-la, consulte a seção Informações Avançadas mais tarde neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="c6f9d-223">Controle de versão</span><span class="sxs-lookup"><span data-stu-id="c6f9d-223">Versioning</span></span>

<span data-ttu-id="c6f9d-224">Os recursos de versão do <xref:System.Runtime.Serialization.IExtensibleDataObject> contrato de dados, incluindo a interface, são totalmente suportados no JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="c6f9d-225">Além disso, na maioria dos casos é possível desserializar um tipo em um formato (por exemplo, XML) e, em <xref:System.Runtime.Serialization.IExtensibleDataObject>seguida, serializá-lo em outro formato (por exemplo, JSON) e ainda preservar os dados em .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="c6f9d-226">Para obter mais informações, consulte [Contratos de dados compatíveis por encaminhamento](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="c6f9d-227">Lembre-se que jSON é desordenado para que qualquer informação de ordem seja perdida.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="c6f9d-228">Além disso, o JSON não suporta vários pares de tecla/valor com o mesmo nome de chave.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="c6f9d-229">Finalmente, todas <xref:System.Runtime.Serialization.IExtensibleDataObject> as operações são inerentemente polimórficas <xref:System.Object>- ou seja, seu tipo derivado são atribuídos , o tipo base para todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="c6f9d-230">JSON em URLs</span><span class="sxs-lookup"><span data-stu-id="c6f9d-230">JSON in URLs</span></span>

<span data-ttu-id="c6f9d-231">Ao usar ASP.NET pontos finais do AJAX com <xref:System.ServiceModel.Web.WebGetAttribute> o verbo HTTP GET (usando o atributo), os parâmetros de entrada aparecem na URL de solicitação em vez do corpo da mensagem.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="c6f9d-232">O JSON é suportado até mesmo na URL de solicitação, portanto, se você tiver uma operação chamada `Int` "número" e um `Person` tipo complexo chamado "p", a URL pode se assemelhar à URL a seguir.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="c6f9d-233">Se você estiver usando um ASP.NET controle e proxy do AJAX Script Manager para chamar o serviço, essa URL é gerada automaticamente pelo proxy e não é vista.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="c6f9d-234">O JSON não pode ser usado em URLs em non-ASP.NET pontos finais do AJAX.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="c6f9d-235">Informações avançadas</span><span class="sxs-lookup"><span data-stu-id="c6f9d-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="c6f9d-236">Suporte ISerializable</span><span class="sxs-lookup"><span data-stu-id="c6f9d-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="c6f9d-237">Tipos ISerializable suportados e não suportados</span><span class="sxs-lookup"><span data-stu-id="c6f9d-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="c6f9d-238">Em geral, os <xref:System.Runtime.Serialization.ISerializable> tipos que implementam a interface são totalmente suportados ao serializar/desserializar o JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="c6f9d-239">No entanto, alguns desses tipos (incluindo alguns tipos de framework .NET) são implementados de tal forma que os aspectos de serialização específicos do JSON fazem com que eles não desserialifiquem corretamente:</span><span class="sxs-lookup"><span data-stu-id="c6f9d-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="c6f9d-240">Com <xref:System.Runtime.Serialization.ISerializable>, o tipo de membros de dados individuais nunca é conhecido com antecedência.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="c6f9d-241">Isso leva a uma situação polimórfica semelhante a desserializar tipos em um objeto.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="c6f9d-242">Como mencionado anteriormente, isso pode levar à perda de informações de tipo no JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="c6f9d-243">Por exemplo, um tipo que `enum` serializa um em sua <xref:System.Runtime.Serialization.ISerializable> implementação `enum` e tenta desserializar de `enum` volta diretamente em um (sem moldes adequados) falha, porque um é serializado usando números em números JSON e JSON desserializar em tipos numéricos .NET incorporados (Int32, Decimal ou Double).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="c6f9d-244">Então o fato de que o `enum` número costumava ser um valor é perdido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="c6f9d-245">Um <xref:System.Runtime.Serialization.ISerializable> tipo que depende de uma determinada ordem de desserialização em seu construtor de desserialização também pode não desserializar alguns dados JSON, porque a maioria dos serializadores JSON não garantem nenhuma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="c6f9d-246">Tipos de fábrica</span><span class="sxs-lookup"><span data-stu-id="c6f9d-246">Factory Types</span></span>

<span data-ttu-id="c6f9d-247">Embora <xref:System.Runtime.Serialization.IObjectReference> a interface seja suportada no JSON em geral, todos os tipos que requerem o <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> recurso "tipo de fábrica" (retornando uma instância de um tipo diferente do tipo que implementa a interface) não são suportados.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="c6f9d-248">Formato de fio de data de data</span><span class="sxs-lookup"><span data-stu-id="c6f9d-248">DateTime Wire Format</span></span>

<span data-ttu-id="c6f9d-249"><xref:System.DateTime>os valores aparecem como strings JSON na forma de "/Date(700000+0500)/", onde o primeiro número (700000 no exemplo fornecido) é o número de milissegundos no fuso horário GMT, horário regular (não-diurno) desde a meia-noite de 1 º de janeiro de 1970.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="c6f9d-250">O número pode ser negativo para representar tempos anteriores.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="c6f9d-251">A parte que consiste em "+0500" no exemplo é opcional <xref:System.DateTimeKind.Local> e indica que o tempo é do tipo - ou seja, deve ser convertido para o fuso horário local na desserialização.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="c6f9d-252">Se ele estiver ausente, o tempo <xref:System.DateTimeKind.Utc>é desserializado como .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="c6f9d-253">O número real ("0500" neste exemplo) e seu sinal (+ ou -) são ignorados.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="c6f9d-254">Ao <xref:System.DateTime>serializar <xref:System.DateTimeKind.Local> <xref:System.DateTimeKind.Unspecified> , e os tempos <xref:System.DateTimeKind.Utc> são escritos com um deslocamento, e é escrito sem.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="c6f9d-255">O código JavaScript do cliente ajax ASP.NET converte `DateTime` automaticamente essas strings em instâncias JavaScript.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="c6f9d-256">Se houver outras strings que tenham uma <xref:System.DateTime> forma semelhante que não são do tipo em .NET, elas também serão convertidas.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="c6f9d-257">A conversão só ocorre se os caracteres "/" forem escapados\\(ou seja, o JSON se\\parece com " /Date (700000+0500) <xref:System.ServiceModel.WebHttpBinding>/"), e por essa razão o codificador JSON da WCF (habilitado pelo) sempre escapa do caractere "/".</span><span class="sxs-lookup"><span data-stu-id="c6f9d-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="c6f9d-258">XML em Cordas JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="c6f9d-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="c6f9d-259">XmlElement</span></span>

<span data-ttu-id="c6f9d-260"><xref:System.Xml.XmlElement>é serializado como é, sem embrulho.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="c6f9d-261">Por exemplo, o membro de <xref:System.Xml.XmlElement> dados \<"x" do tipo que contém abc/> é representado da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="c6f9d-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="c6f9d-262">Matrizes de XmlNode</span><span class="sxs-lookup"><span data-stu-id="c6f9d-262">Arrays of XmlNode</span></span>

<span data-ttu-id="c6f9d-263"><xref:System.Array>objetos <xref:System.Xml.XmlNode> de tipo são embrulhados em um elemento chamado ArrayOfXmlNode no espaço de nome padrão do contrato de dados para o tipo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="c6f9d-264">Se "x" é uma matriz que contém nó de atributo "N" no namespace "ns" que contém "valor" e um nó de elemento vazio "M", a representação é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="c6f9d-265">Atributos no namespace vazio no início das matrizes XmlNode (antes de outros elementos) não são suportados.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="c6f9d-266">IXmlTiposserializáveis, incluindo XElement e DataSet</span><span class="sxs-lookup"><span data-stu-id="c6f9d-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="c6f9d-267"><xref:System.Runtime.Serialization.ISerializable>tipos subdivididos em "tipos de conteúdo", "tipos de dados" e "tipos de elementos".</span><span class="sxs-lookup"><span data-stu-id="c6f9d-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="c6f9d-268">Para definições desses tipos, consulte [XML e ADO.NET Tipos em Contratos de Dados](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="c6f9d-269">Os tipos "Conteúdo" e "DataSet" <xref:System.Array> são <xref:System.Xml.XmlNode> serializados semelhantes aos objetos discutidos na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="c6f9d-270">Eles são envoltos em um elemento cujo nome e namespace correspondem ao nome do contrato de dados e espaço de nome do tipo em questão.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="c6f9d-271">Tipos de "elemento", como <xref:System.Xml.Linq.XElement> são serializados <xref:System.Xml.XmlElement> como é, semelhante ao discutido anteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="c6f9d-272">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="c6f9d-273">Preservando informações de tipo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-273">Preserving Type Information</span></span>

<span data-ttu-id="c6f9d-274">Como dito anteriormente, o polimorfismo é suportado no JSON com algumas limitações.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="c6f9d-275">JavaScript é uma linguagem de tipo com digitação fraca e a identidade de tipo normalmente não é um problema.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="c6f9d-276">No entanto, ao usar o JSON para se comunicar entre um sistema fortemente digitado (.NET) e um sistema de tipo fraco (JavaScript), é útil para preservar a identidade do tipo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="c6f9d-277">Por exemplo, tipos com nomes de contratos de dados "Quadrado" e "Círculo" derivam de um tipo com um nome de contrato de dados de "Forma".</span><span class="sxs-lookup"><span data-stu-id="c6f9d-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="c6f9d-278">Se "Circle" for enviado de .NET para JavaScript e posteriormente for devolvido a um método .NET que espera "Shape", é útil para o lado .NET saber que o objeto em questão era originalmente um "Círculo" - caso contrário, qualquer informação específica para o tipo derivado (por exemplo, , o membro de dados "radius" em "Circle") pode ser perdido.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="c6f9d-279">Para preservar a identidade do tipo, ao serializar tipos complexos para JSON, uma "dica de tipo" pode ser adicionada, e o desumicionante reconhece a dica e age adequadamente.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="c6f9d-280">A "dica de tipo" é um par de tecla/valor JSON com o nome-chave de "\_\_tipo" (dois sublinhados seguidos pela palavra "tipo").</span><span class="sxs-lookup"><span data-stu-id="c6f9d-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="c6f9d-281">O valor é uma seqüência JSON do formulário "DataContractName:DataContractNamespace" (qualquer coisa até o primeiro cólon é o nome).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="c6f9d-282">Usando o exemplo anterior, "Circle" pode ser serializado da seguinte forma.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="c6f9d-283">A dica de tipo `xsi:type` é muito semelhante ao atributo definido pelo padrão XML Schema Instance e usado ao serializar/desserializar XML.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="c6f9d-284">Membros de\_\_dados chamados "tipo" são proibidos devido a um potencial conflito com a dica do tipo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="c6f9d-285">Reduzindo o tamanho das dicas de tipo</span><span class="sxs-lookup"><span data-stu-id="c6f9d-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="c6f9d-286">Para reduzir o tamanho das mensagens JSON, o`http://schemas.datacontract.org/2004/07/`prefixo de namespace do contrato de dados padrão ( ) é substituído pelo caractere "#".</span><span class="sxs-lookup"><span data-stu-id="c6f9d-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="c6f9d-287">(Para tornar essa substituição reversível, uma regra de fuga é usada: se\\o namespace começa com os\\caracteres "#" ou " " " eles são anexados com um caractere extra ").</span><span class="sxs-lookup"><span data-stu-id="c6f9d-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="c6f9d-288">Assim, se "Circle" for um tipo no namespace "MyApp.Shapes", seu `http://schemas.datacontract.org/2004/07/MyApp`namespace padrão de contrato de dados é .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="c6f9d-289">Formas e a representação JSON são as seguintes.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="c6f9d-290">Tanto o truncado (#MyApp.Shapes)http://schemas.datacontract.org/2004/07/MyApp.Shapes) quanto o completo (os nomes são entendidos na desserialização.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="c6f9d-291">Posição de dica de tipo em objetos JSON</span><span class="sxs-lookup"><span data-stu-id="c6f9d-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="c6f9d-292">Observe que a dica de tipo deve aparecer primeiro na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="c6f9d-293">Este é o único caso em que a ordem dos pares de chave/valor é importante no processamento do JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="c6f9d-294">Por exemplo, o seguinte não é uma maneira válida de especificar a dica do tipo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="c6f9d-295">Tanto <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> as páginas de clientes WCF quanto ASP.NET AJAX sempre emitem a dica do tipo primeiro.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="c6f9d-296">Dicas de tipo aplicam-se apenas a tipos complexos</span><span class="sxs-lookup"><span data-stu-id="c6f9d-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="c6f9d-297">Não há como emitir uma dica de tipo para tipos não complexos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="c6f9d-298">Por exemplo, se uma <xref:System.Object> operação tiver um tipo de retorno, mas retornar um Círculo, a representação JSON pode ser mostrada anteriormente e as informações do tipo são preservadas.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="c6f9d-299">No entanto, se Uri for devolvido, a representação JSON é uma string e o fato de que a string usada para representar um Uri é perdida.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="c6f9d-300">Isso se aplica não apenas a tipos primitivos, mas também a coleções e matrizes.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="c6f9d-301">Quando são dicas de tipo emitidas</span><span class="sxs-lookup"><span data-stu-id="c6f9d-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="c6f9d-302">As dicas de tipo podem aumentar significativamente o tamanho da mensagem (uma maneira de mitigar isso é usar espaços de nomes de contratos de dados mais curtos, se possível).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="c6f9d-303">Portanto, as seguintes regras regem se as dicas de tipo são emitidas:</span><span class="sxs-lookup"><span data-stu-id="c6f9d-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="c6f9d-304">Ao usar ASP.NET AJAX, as dicas de tipo são sempre emitidas sempre que possível, mesmo que não haja atribuição base/derivada - por exemplo, mesmo se um Círculo for atribuído a um Círculo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="c6f9d-305">(Isso é necessário para habilitar totalmente o processo de chamada do ambiente JSON de tipo fraco para o ambiente .NET fortemente digitado, sem nenhuma perda surpreendente de informações.)</span><span class="sxs-lookup"><span data-stu-id="c6f9d-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="c6f9d-306">Ao usar serviços AJAX sem integração ASP.NET, as dicas de tipo só são emitidas quando há uma <xref:System.Object> atribuição base/derivada - ou seja, emitida sem que o Circle seja atribuído à Forma ou não quando atribuído ao Circle.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="c6f9d-307">Isso fornece as informações mínimas necessárias para implementar corretamente um cliente JavaScript, melhorando assim o desempenho, mas não protege contra a perda de informações de tipo em clientes projetados incorretamente.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="c6f9d-308">Evite atribuições base/derivadas completamente no servidor se você quiser evitar lidar com esse problema no cliente.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="c6f9d-309">Ao usar <xref:System.Runtime.Serialization.DataContractSerializer> o `alwaysEmitTypeInformation` tipo, o parâmetro construtor permite que você escolha entre os`false`dois modos anteriores, com o padrão sendo " " (apenas emitir dicas de tipo quando necessário).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="c6f9d-310">Nomes de membros de dados duplicados</span><span class="sxs-lookup"><span data-stu-id="c6f9d-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="c6f9d-311">As informações de tipo derivadas estão presentes no mesmo objeto JSON juntamente com informações do tipo base, e podem ocorrer em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="c6f9d-312">Por exemplo, `Shape` pode ser representado da seguinte forma.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="c6f9d-313">Considerando que o Círculo pode ser representado da seguinte forma.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="c6f9d-314">Se o `Shape` tipo base também continha`radius`um membro de dados chamado " ", isso leva a uma colisão tanto na serialização (porque os objetos JSON não podem ter nomes de chave repetitivos) quanto na desserialização (porque não está claro se "raio" se refere `Shape.radius` ou `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="c6f9d-315">Portanto, embora o conceito de "ocultação de propriedade" (membros de dados de mesmo nome em classes baseadas e derivadas) geralmente não seja recomendado em classes de contratos de dados, é realmente proibido no caso do JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="c6f9d-316">Polimorfismo e Tipos IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="c6f9d-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="c6f9d-317"><xref:System.Xml.Serialization.IXmlSerializable>os tipos podem ser polimorficamente atribuídos uns aos outros, desde que os requisitos de Tipos Conhecidos sejam atendidos, de acordo com as regras usuais do contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="c6f9d-318">No entanto, <xref:System.Xml.Serialization.IXmlSerializable> serializar <xref:System.Object> um tipo no lugar de resulta na perda de informações de tipo como o resultado é uma seqüência JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="c6f9d-319">Polimorfismo e certos tipos de interface</span><span class="sxs-lookup"><span data-stu-id="c6f9d-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="c6f9d-320">É proibido serializar um tipo de coleta ou <xref:System.Xml.Serialization.IXmlSerializable> um tipo que implemente <xref:System.Xml.Serialization.IXmlSerializable> onde <xref:System.Object>um tipo de não coleta que não seja (exceto ) é esperado.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="c6f9d-321">Por exemplo, uma `IMyInterface` interface personalizada `MyType` chamada <xref:System.Collections.Generic.IEnumerable%601> e `int` um `IMyInterface`tipo que implementa ambos de tipo e .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="c6f9d-322">É proibido retornar `MyType` de uma operação cujo `IMyInterface`tipo de retorno é .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="c6f9d-323">Isso porque `MyType` deve ser serializado como uma matriz JSON e requer uma dica de tipo, e como indicado antes você não pode incluir uma dica de tipo com matrizes, apenas com tipos complexos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="c6f9d-324">Tipos e configuração conhecidos</span><span class="sxs-lookup"><span data-stu-id="c6f9d-324">Known Types and Configuration</span></span>

<span data-ttu-id="c6f9d-325">Todos os mecanismos de <xref:System.Runtime.Serialization.DataContractSerializer> tipo conhecido utilizados pelo também <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>são suportados da mesma forma pelo .</span><span class="sxs-lookup"><span data-stu-id="c6f9d-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="c6f9d-326">Ambos os serializadores lêem o mesmo elemento de configuração, [ \<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) no [ \<system.runtime.serialization>, ](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)para descobrir tipos conhecidos adicionados através de um arquivo de configuração.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="c6f9d-327">Coleções atribuídas ao objeto</span><span class="sxs-lookup"><span data-stu-id="c6f9d-327">Collections Assigned to Object</span></span>

<span data-ttu-id="c6f9d-328">As coleções atribuídas ao Objeto são serializadas <xref:System.Collections.Generic.IEnumerable%601>como se fossem coleções que implementam: uma matriz JSON com cada entrada que tenha uma dica de tipo se for um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="c6f9d-329">Por exemplo, <xref:System.Collections.Generic.List%601> um `Shape` tipo <xref:System.Object> atribuído a parece o seguinte.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="c6f9d-330">Quando desserializado <xref:System.Object>de volta em:</span><span class="sxs-lookup"><span data-stu-id="c6f9d-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="c6f9d-331">`Shape`deve estar na lista Tipos Conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="c6f9d-332">Ter <xref:System.Collections.Generic.List%601> um `Shape` tipo em tipos conhecidos não tem efeito.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="c6f9d-333">Observe que você não `Shape` precisa adicionar aos tipos conhecidos sobre serialização neste caso - isso é feito automaticamente.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="c6f9d-334">A coleção é desserializada <xref:System.Object> como `Shape` um <xref:System.Array> tipo que contém instâncias.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="c6f9d-335">Coleções derivadas atribuídas a coleções base</span><span class="sxs-lookup"><span data-stu-id="c6f9d-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="c6f9d-336">Quando uma coleção derivada é atribuída a uma coleção base, a coleção geralmente é serializada como se fosse uma coleção do tipo base.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="c6f9d-337">No entanto, se o tipo de item da coleção derivada não puder ser atribuído ao tipo de item da coleção base, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="c6f9d-338">Dicas de tipo e dicionários</span><span class="sxs-lookup"><span data-stu-id="c6f9d-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="c6f9d-339">Quando um dicionário é <xref:System.Object>atribuído a uma entrada de Tecla e Valor no <xref:System.Object> dicionário é tratada como se fosse atribuída e recebe uma dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="c6f9d-340">Ao serializar tipos de dicionário, o objeto JSON que contém os membros `alwaysEmitTypeInformation` "Chave" e "Valor" não é afetado pela configuração e só contém uma dica de tipo quando as regras de coleta anteriores exigem isso.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="c6f9d-341">Nomes-chave json válidos</span><span class="sxs-lookup"><span data-stu-id="c6f9d-341">Valid JSON Key Names</span></span>

<span data-ttu-id="c6f9d-342">O serializador XML codifica nomes-chave que não são nomes XML válidos.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="c6f9d-343">Por exemplo, um membro de dados com o nome "123"\_teria um nome\_\_codificado como\_\_" x0031 x0032 x0033\_" porque "123" é um nome de elemento XML inválido (começa com um dígito).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="c6f9d-344">Uma situação semelhante pode surgir com alguns conjuntos de caracteres internacionais não válidos em nomes XML.</span><span class="sxs-lookup"><span data-stu-id="c6f9d-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="c6f9d-345">Para obter uma explicação desse efeito do XML no processamento JSON, consulte [Mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="c6f9d-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c6f9d-346">Confira também</span><span class="sxs-lookup"><span data-stu-id="c6f9d-346">See also</span></span>

- [<span data-ttu-id="c6f9d-347">Suporte para JSON e outros formatos de transferência de dados</span><span class="sxs-lookup"><span data-stu-id="c6f9d-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
