---
title: Serialização JSON autônoma
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 701ad05b7432c36950ff514ad8c7c18a54c7f020
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64586192"
---
# <a name="stand-alone-json-serialization"></a><span data-ttu-id="a081d-102">Serialização JSON autônoma</span><span class="sxs-lookup"><span data-stu-id="a081d-102">Stand-Alone JSON Serialization</span></span>
<span data-ttu-id="a081d-103">JSON (JavaScript Object Notation) é um formato de dados que foi especificamente desenvolvido para ser usado pelo código JavaScript em execução em páginas da Web dentro do navegador.</span><span class="sxs-lookup"><span data-stu-id="a081d-103">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="a081d-104">É o formato de dados padrão usado pelos serviços do ASP.NET AJAX criados no Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="a081d-104">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>  
  
 <span data-ttu-id="a081d-105">Esse formato também pode ser usado quando a criação de serviços AJAX sem integração com o ASP.NET - nesse caso, o XML é o padrão, mas JSON pode ser escolhido.</span><span class="sxs-lookup"><span data-stu-id="a081d-105">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>  
  
 <span data-ttu-id="a081d-106">Por fim, se você precisar de suporte do JSON, mas não estiver criando um serviço de AJAX, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> torna possível para diretamente serializar objetos .NET em dados JSON e desserializar esses dados em instâncias de tipos do .NET.</span><span class="sxs-lookup"><span data-stu-id="a081d-106">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="a081d-107">Para obter uma descrição de como fazer isso, consulte [como: Serializar e desserializar dados JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-107">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="a081d-108">Ao trabalhar com JSON, os mesmos tipos de .NET têm suporte com raras exceções, conforme são compatíveis com o <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a081d-108">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="a081d-109">Para obter uma lista dos tipos suportados, consulte [tipos com suporte pelo serializador de contrato de dados](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-109">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="a081d-110">Isso inclui tipos mais primitivos, a maioria de matriz e tipos de coleção, complexos, bem como tipos que usam o <xref:System.Runtime.Serialization.DataContractAttribute> e <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a081d-110">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="a081d-111">Mapeando tipos de .NET para tipos de JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-111">Mapping .NET types to JSON Types</span></span>  
 <span data-ttu-id="a081d-112">A tabela a seguir mostra a correspondência entre tipos .NET e tipos de JSON/JavaScript quando mapeado pelos procedimentos de serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="a081d-112">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>  
  
|<span data-ttu-id="a081d-113">Tipos do .NET</span><span class="sxs-lookup"><span data-stu-id="a081d-113">.NET Types</span></span>|<span data-ttu-id="a081d-114">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="a081d-114">JSON/JavaScript</span></span>|<span data-ttu-id="a081d-115">Observações</span><span class="sxs-lookup"><span data-stu-id="a081d-115">Notes</span></span>|  
|----------------|----------------------|-----------|  
|<span data-ttu-id="a081d-116">Todos os tipos numéricos, por exemplo <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="a081d-116">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="a081d-117">Número</span><span class="sxs-lookup"><span data-stu-id="a081d-117">Number</span></span>|<span data-ttu-id="a081d-118">Valores especiais, como `Double.NaN`, `Double.PositiveInfinity` e `Double.NegativeInfinity` não têm suporte e resultar em JSON inválido.</span><span class="sxs-lookup"><span data-stu-id="a081d-118">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|  
|<xref:System.Enum>|<span data-ttu-id="a081d-119">Número</span><span class="sxs-lookup"><span data-stu-id="a081d-119">Number</span></span>|<span data-ttu-id="a081d-120">Consulte "Enumerações e JSON", mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-120">See "Enumerations and JSON" later in this topic.</span></span>|  
|<xref:System.Boolean>|<span data-ttu-id="a081d-121">Boolean</span><span class="sxs-lookup"><span data-stu-id="a081d-121">Boolean</span></span>|--|  
|<span data-ttu-id="a081d-122"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="a081d-122"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="a081d-123">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="a081d-123">String</span></span>|--|  
|<span data-ttu-id="a081d-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="a081d-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="a081d-125">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="a081d-125">String</span></span>|<span data-ttu-id="a081d-126">O formato desses tipos em JSON é o mesmo do XML (essencialmente, o período de tempo no formato ISO 8601 duração, GUID no formato "12345678-ABCD-ABCD-ABCD-1234567890AB" e o URI em sua forma natural de cadeia de caracteres, como "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="a081d-126">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="a081d-127">Para obter informações precisas, consulte [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-127">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|  
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="a081d-128">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="a081d-128">String</span></span>|<span data-ttu-id="a081d-129">O formato é "nome: namespace" (qualquer coisa antes da primeira vírgula é o nome).</span><span class="sxs-lookup"><span data-stu-id="a081d-129">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="a081d-130">O nome ou o namespace pode ser ausente.</span><span class="sxs-lookup"><span data-stu-id="a081d-130">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="a081d-131">Se não houver nenhum namespace os dois-pontos podem ser omitido também.</span><span class="sxs-lookup"><span data-stu-id="a081d-131">If there is no namespace the colon can be omitted as well.</span></span>|  
|<span data-ttu-id="a081d-132"><xref:System.Array> do tipo <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="a081d-132"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="a081d-133">Matriz de números</span><span class="sxs-lookup"><span data-stu-id="a081d-133">Array of numbers</span></span>|<span data-ttu-id="a081d-134">Cada número representa o valor de um byte.</span><span class="sxs-lookup"><span data-stu-id="a081d-134">Each number represents the value of one byte.</span></span>|  
|<xref:System.DateTime>|<span data-ttu-id="a081d-135">Data e hora ou cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="a081d-135">DateTime or String</span></span>|<span data-ttu-id="a081d-136">Consulte as datas / horas e JSON neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-136">See Dates/Times and JSON later in this topic.</span></span>|  
|<xref:System.DateTimeOffset>|<span data-ttu-id="a081d-137">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="a081d-137">Complex type</span></span>|<span data-ttu-id="a081d-138">Consulte as datas / horas e JSON neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-138">See Dates/Times and JSON later in this topic.</span></span>|  
|<span data-ttu-id="a081d-139">Tipos de XML e ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="a081d-139">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="a081d-140"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a081d-140"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="a081d-141">Matrizes de <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="a081d-141">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="a081d-142"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="a081d-142"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="a081d-143"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="a081d-143"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="a081d-144">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="a081d-144">String</span></span>|<span data-ttu-id="a081d-145">Consulte a seção de tipos XML e JSON deste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-145">See the XML Types and JSON section of this topic.</span></span>|  
|<xref:System.DBNull>|<span data-ttu-id="a081d-146">Tipo complexo vazio</span><span class="sxs-lookup"><span data-stu-id="a081d-146">Empty complex type</span></span>|--|  
|<span data-ttu-id="a081d-147">Coleções, dicionários e matrizes</span><span class="sxs-lookup"><span data-stu-id="a081d-147">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="a081d-148">Matriz</span><span class="sxs-lookup"><span data-stu-id="a081d-148">Array</span></span>|<span data-ttu-id="a081d-149">Consulte a seção de coleções, dicionários e matrizes deste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-149">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|  
|<span data-ttu-id="a081d-150">Tipos complexos (com o <xref:System.Runtime.Serialization.DataContractAttribute> ou <xref:System.SerializableAttribute> aplicadas)</span><span class="sxs-lookup"><span data-stu-id="a081d-150">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="a081d-151">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="a081d-151">Complex type</span></span>|<span data-ttu-id="a081d-152">Membros de dados se tornarem membros do tipo complexo de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a081d-152">Data members become members of the JavaScript complex type.</span></span>|  
|<span data-ttu-id="a081d-153">Tipos complexos Implementando o <xref:System.Runtime.Serialization.ISerializable> interface)</span><span class="sxs-lookup"><span data-stu-id="a081d-153">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="a081d-154">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="a081d-154">Complex type</span></span>|<span data-ttu-id="a081d-155">Mesmo que outros tipos complexos, mas alguns <xref:System.Runtime.Serialization.ISerializable> tipos não têm suporte – consulte a parte do suporte de ISerializable da seção de informações avançadas deste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-155">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|  
|<span data-ttu-id="a081d-156">`Null` valor para qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="a081d-156">`Null` value for any type</span></span>|<span data-ttu-id="a081d-157">Nulo</span><span class="sxs-lookup"><span data-stu-id="a081d-157">Null</span></span>|<span data-ttu-id="a081d-158">Tipos anuláveis também têm suporte e mapear para o JSON da mesma forma como os tipos não anuláveis.</span><span class="sxs-lookup"><span data-stu-id="a081d-158">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|  
  
### <a name="enumerations-and-json"></a><span data-ttu-id="a081d-159">Enumerações e JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-159">Enumerations and JSON</span></span>  
 <span data-ttu-id="a081d-160">Valores de membro de enumeração são tratados como números em JSON, que é diferente de como elas são tratadas em contratos de dados, onde eles são incluídos como nomes de membro.</span><span class="sxs-lookup"><span data-stu-id="a081d-160">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="a081d-161">Para obter mais informações sobre o tratamento de contrato de dados, consulte [tipos de enumeração em contratos de dados](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-161">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>  
  
- <span data-ttu-id="a081d-162">Por exemplo, se você tiver `public enum Color {red, green, blue, yellow, pink}`, serializar `yellow` produz o número 3 e não é a cadeia de caracteres "amarelo".</span><span class="sxs-lookup"><span data-stu-id="a081d-162">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>  
  
- <span data-ttu-id="a081d-163">Todos os `enum` membros são serializáveis.</span><span class="sxs-lookup"><span data-stu-id="a081d-163">All `enum` members are serializable.</span></span> <span data-ttu-id="a081d-164">O <xref:System.Runtime.Serialization.EnumMemberAttribute> e o <xref:System.NonSerializedAttribute> atributos são ignorados, se usado.</span><span class="sxs-lookup"><span data-stu-id="a081d-164">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>  
  
- <span data-ttu-id="a081d-165">É possível desserializar um inexistente `enum` valor - por exemplo, o valor 87 pode ser desserializado na enum cor anterior, embora não exista nenhum nome de cor correspondente definido.</span><span class="sxs-lookup"><span data-stu-id="a081d-165">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>  
  
- <span data-ttu-id="a081d-166">Um sinalizadores `enum` não é especial e é tratado da mesma forma que qualquer outro `enum`.</span><span class="sxs-lookup"><span data-stu-id="a081d-166">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>  
  
### <a name="datestimes-and-json"></a><span data-ttu-id="a081d-167">As datas/horas e JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-167">Dates/Times and JSON</span></span>  
 <span data-ttu-id="a081d-168">O formato JSON não oferece suporte diretamente datas e horas.</span><span class="sxs-lookup"><span data-stu-id="a081d-168">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="a081d-169">No entanto, elas são comumente utilizadas e ASP.NET AJAX fornece suporte especial para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="a081d-169">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="a081d-170">Ao usar proxies do ASP.NET AJAX, o <xref:System.DateTime> tipo no .NET totalmente corresponde ao `DateTime` tipo em JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a081d-170">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>  
  
- <span data-ttu-id="a081d-171">Quando não estiver usando ASP.NET, um <xref:System.DateTime> tipo é representado em JSON como uma cadeia de caracteres com um formato especial que é descrito na seção avançada informações deste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-171">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>  
  
- <span data-ttu-id="a081d-172"><xref:System.DateTimeOffset> é representado no JSON como um tipo complexo: {"DateTime": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="a081d-172"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="a081d-173">O `offsetMinutes` membro é o deslocamento de hora local da hora de Greenwich (GMT), agora também conhecido como tempo Universal Coordenado (UTC), associado com o local do evento de interesse.</span><span class="sxs-lookup"><span data-stu-id="a081d-173">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="a081d-174">O `dateTime` membro representa a instância na hora em que ocorreu o evento de interesse (novamente, ele se torna um `DateTime` em JavaScript quando o ASP.NET AJAX está em uso e uma cadeia de caracteres quando ela não estiver).</span><span class="sxs-lookup"><span data-stu-id="a081d-174">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="a081d-175">Na serialização, o `dateTime` membro sempre é serializado em GMT.</span><span class="sxs-lookup"><span data-stu-id="a081d-175">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="a081d-176">Portanto, se descrever 3 11h, hora de Nova York, `dateTime` tem um componente de tempo às 8H e `offsetMinutes` são 300 (menos de 300 minutos ou horas 5 do GMT).</span><span class="sxs-lookup"><span data-stu-id="a081d-176">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a081d-177"><xref:System.DateTime> e <xref:System.DateTimeOffset> objetos, quando serializados para JSON, apenas preservam as informações para a precisão de milissegundos.</span><span class="sxs-lookup"><span data-stu-id="a081d-177"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="a081d-178">Valores inferiores a milissegundos (micro/nanossegundos) serão perdidas durante a serialização.</span><span class="sxs-lookup"><span data-stu-id="a081d-178">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>  
  
### <a name="xml-types-and-json"></a><span data-ttu-id="a081d-179">Tipos XML e JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-179">XML Types and JSON</span></span>  
 <span data-ttu-id="a081d-180">Tipos XML se tornam cadeias de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-180">XML types become JSON strings.</span></span>  
  
- <span data-ttu-id="a081d-181">Por exemplo, se um membro de dados "q" do tipo XElement conterá \<abc / >, o JSON é {"q": "\<abc / >"}.</span><span class="sxs-lookup"><span data-stu-id="a081d-181">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>  
  
- <span data-ttu-id="a081d-182">Há algumas regras especiais que especificam como o XML está envolvida - para obter mais informações, consulte a seção de informações avançadas mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-182">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>  
  
- <span data-ttu-id="a081d-183">Se você estiver usando o ASP.NET AJAX e não quiser usar cadeias de caracteres em JavaScript, mas deseja que o DOM XML em vez disso, defina a <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> propriedade para XML no <xref:System.ServiceModel.Web.WebGetAttribute> ou o <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> propriedade como XML no <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a081d-183">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>  
  
### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="a081d-184">Coleções, dicionários e matrizes</span><span class="sxs-lookup"><span data-stu-id="a081d-184">Collections, Dictionaries and Arrays</span></span>  
 <span data-ttu-id="a081d-185">Todas as coleções, matrizes e dicionários são representadas em JSON, como matrizes.</span><span class="sxs-lookup"><span data-stu-id="a081d-185">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>  
  
- <span data-ttu-id="a081d-186">Qualquer personalização que usa o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> é ignorada na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-186">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>  
  
- <span data-ttu-id="a081d-187">Os dicionários não são uma maneira de trabalhar diretamente com JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-187">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="a081d-188">Dicionário\<string, object > podem não ter suporte da mesma maneira no WCF conforme o esperado do trabalho com outras tecnologias JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-188">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="a081d-189">Por exemplo, se "abc" é mapeada para "xyz" e "def" é mapeada para 42 em um dicionário, a representação JSON não é {"abc": "xyz", "def": 42}, mas é [{"Chave": "abc", "Valor": "xyz"}, {"Chave": "def", "Value": 42}] em vez disso.</span><span class="sxs-lookup"><span data-stu-id="a081d-189">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>  
  
- <span data-ttu-id="a081d-190">Se você quiser trabalhar diretamente com JSON (acesso a chaves e valores dinamicamente, sem definir previamente um contrato rígido), você tem várias opções:</span><span class="sxs-lookup"><span data-stu-id="a081d-190">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>  
  
    - <span data-ttu-id="a081d-191">Considere o uso de [serialização JSON (AJAX) de com tipagem fraca](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) exemplo.</span><span class="sxs-lookup"><span data-stu-id="a081d-191">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>  
  
    - <span data-ttu-id="a081d-192">Considere o uso de <xref:System.Runtime.Serialization.ISerializable> construtores de interface e a desserialização - esses dois mecanismos permitem que você acesse os pares de chave/valor JSON na serialização e desserialização, respectivamente, mas não funcionam em cenários de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="a081d-192">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>  
  
    - <span data-ttu-id="a081d-193">Considere a possibilidade de trabalhar com o [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) em vez de usar um serializador.</span><span class="sxs-lookup"><span data-stu-id="a081d-193">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>  
  
    - <span data-ttu-id="a081d-194">*Polimorfismo* no contexto de serialização refere-se à capacidade de serializar um tipo derivado de onde se espera que seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="a081d-194">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="a081d-195">Há regras especiais de JSON específico ao usar coleções polimorficamente, quando, por exemplo, atribuindo uma coleção para um <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a081d-195">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="a081d-196">Esse problema será abordado mais detalhadamente na seção informações avançadas, mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-196">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>  
  
## <a name="additional-details"></a><span data-ttu-id="a081d-197">Detalhes adicionais</span><span class="sxs-lookup"><span data-stu-id="a081d-197">Additional Details</span></span>  
  
### <a name="order-of-data-members"></a><span data-ttu-id="a081d-198">Ordem dos membros de dados</span><span class="sxs-lookup"><span data-stu-id="a081d-198">Order of Data Members</span></span>  
 <span data-ttu-id="a081d-199">Ordem de membros de dados não é importante ao usar o JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-199">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="a081d-200">Especificamente, mesmo se <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> for definido, o JSON dados ainda podem ser desserializados em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="a081d-200">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>  
  
### <a name="json-types"></a><span data-ttu-id="a081d-201">Tipos de JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-201">JSON Types</span></span>  
 <span data-ttu-id="a081d-202">O tipo JSON não precisa corresponder à tabela anterior na desserialização.</span><span class="sxs-lookup"><span data-stu-id="a081d-202">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="a081d-203">Por exemplo, um `Int` normalmente é mapeado para um número JSON, mas ele também pode ser desserializado com êxito de uma cadeia de caracteres JSON desde que essa cadeia de caracteres contém um número válido.</span><span class="sxs-lookup"><span data-stu-id="a081d-203">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="a081d-204">Ou seja, ambos {"q": 42} e {"q": "42"} são válidas se houver um `Int` membro de dados chamado "q".</span><span class="sxs-lookup"><span data-stu-id="a081d-204">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="a081d-205">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="a081d-205">Polymorphism</span></span>  
 <span data-ttu-id="a081d-206">Serialização polimórfica consiste a capacidade de serializar um tipo derivado de onde se espera que seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="a081d-206">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="a081d-207">Isso é suportado para serialização JSON pelo WCF comparável da maneira que há suporte para serialização de XML.</span><span class="sxs-lookup"><span data-stu-id="a081d-207">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="a081d-208">Por exemplo, você pode serializar `MyDerivedType` onde `MyBaseType` é esperado ou serializar `Int` onde `Object` é esperado.</span><span class="sxs-lookup"><span data-stu-id="a081d-208">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>  
  
 <span data-ttu-id="a081d-209">Informações de tipo podem ser perdidas durante a desserialização de um tipo derivado se for esperado que o tipo base, a menos que você está sendo desserializado de um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="a081d-209">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="a081d-210">Por exemplo, se <xref:System.Uri> é serializado onde <xref:System.Object> esperado, isso resulta em uma cadeia de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-210">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="a081d-211">Se essa cadeia de caracteres é desserializada, em seguida, de volta para <xref:System.Object>, um .NET <xref:System.String> é retornado.</span><span class="sxs-lookup"><span data-stu-id="a081d-211">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="a081d-212">O desserializador não sabe que a cadeia de caracteres era inicialmente do tipo <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="a081d-212">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="a081d-213">Em geral, quando esperando <xref:System.Object>, todas as cadeias de caracteres JSON são desserializadas como cadeias de caracteres do .NET e todas as matrizes JSON usado para serializar coleções do .NET, dicionários, e matrizes são desserializadas como .NET <xref:System.Array> do tipo <xref:System.Object>, independentemente do que o tipo original real tivesse sido.</span><span class="sxs-lookup"><span data-stu-id="a081d-213">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="a081d-214">Um booliano JSON é mapeado para um .NET <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="a081d-214">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="a081d-215">No entanto quando esperando por um <xref:System.Object>, os números JSON são desserializados como o .NET <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double>, onde o tipo mais apropriado é selecionado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a081d-215">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>  
  
 <span data-ttu-id="a081d-216">Durante a desserialização de um tipo de interface, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> desserializa como se o tipo declarado eram o objeto.</span><span class="sxs-lookup"><span data-stu-id="a081d-216">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>  
  
 <span data-ttu-id="a081d-217">Ao trabalhar com seus próprios tipos de base e derivados, usando o <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> ou um mecanismo equivalente normalmente é necessário.</span><span class="sxs-lookup"><span data-stu-id="a081d-217">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="a081d-218">Por exemplo, se você tiver uma operação que tem um `Animal` valor de retorno e ele realmente retorna uma instância do `Cat` (derivado de `Animal`), você deve aplicar o <xref:System.Runtime.Serialization.KnownTypeAttribute>, para o `Animal` tipo ou o <xref:System.ServiceModel.ServiceKnownTypeAttribute> para a operação e especifique o `Cat` tipo nesses atributos.</span><span class="sxs-lookup"><span data-stu-id="a081d-218">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="a081d-219">Para obter mais informações, consulte [tipos conhecidos de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-219">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="a081d-220">Para obter detalhes de como polimórfico funciona de serialização e uma discussão sobre algumas das limitações que devem ser respeitadas ao usá-lo, consulte a seção de informações avançadas mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-220">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>  
  
### <a name="versioning"></a><span data-ttu-id="a081d-221">Controle de versão</span><span class="sxs-lookup"><span data-stu-id="a081d-221">Versioning</span></span>  
 <span data-ttu-id="a081d-222">O contrato de dados recursos de controle de versão, incluindo o <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, são totalmente compatíveis em JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-222">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="a081d-223">Além disso, na maioria dos casos é possível desserializar um tipo em um formato (por exemplo, XML) e, em seguida, serializá-lo em outro formato (por exemplo, JSON) e ainda preservar os dados nas <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="a081d-223">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="a081d-224">Para obter mais informações, consulte [Contratos de dados compatíveis por encaminhamento](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-224">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="a081d-225">Lembre-se de que as JSON é não ordenada, portanto, qualquer informação de ordem é perdida.</span><span class="sxs-lookup"><span data-stu-id="a081d-225">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="a081d-226">Além disso, o JSON não dá suporte a vários pares de chave/valor com o mesmo nome de chave.</span><span class="sxs-lookup"><span data-stu-id="a081d-226">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="a081d-227">Por fim, todas as operações em <xref:System.Runtime.Serialization.IExtensibleDataObject> são inerentemente polimórfico - que é seu tipo derivado são atribuídos a <xref:System.Object>, o tipo base para todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="a081d-227">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>  
  
## <a name="json-in-urls"></a><span data-ttu-id="a081d-228">JSON em URLs</span><span class="sxs-lookup"><span data-stu-id="a081d-228">JSON in URLs</span></span>  
 <span data-ttu-id="a081d-229">Ao usar pontos de extremidade do ASP.NET AJAX com o verbo HTTP GET (usando o <xref:System.ServiceModel.Web.WebGetAttribute> atributo), os parâmetros de entrada aparecem na URL da solicitação em vez do corpo da mensagem.</span><span class="sxs-lookup"><span data-stu-id="a081d-229">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="a081d-230">JSON é com suporte até mesmo na URL da solicitação, portanto, se você tiver uma operação que utiliza um `Int` chamado "number" e um `Person` chamado "p", a URL de tipo complexo pode ser semelhante ao seguinte URL.</span><span class="sxs-lookup"><span data-stu-id="a081d-230">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 <span data-ttu-id="a081d-231">Se você estiver usando um controle de Gerenciador de Script ASP.NET AJAX e o proxy para chamar o serviço, essa URL é gerada automaticamente pelo proxy e não é visto.</span><span class="sxs-lookup"><span data-stu-id="a081d-231">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="a081d-232">JSON não pode ser usado em URLs nos pontos de extremidade do ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="a081d-232">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>  
  
## <a name="advanced-information"></a><span data-ttu-id="a081d-233">Informações avançadas</span><span class="sxs-lookup"><span data-stu-id="a081d-233">Advanced information</span></span>  
  
### <a name="iserializable-support"></a><span data-ttu-id="a081d-234">Suporte de iSerializable</span><span class="sxs-lookup"><span data-stu-id="a081d-234">ISerializable Support</span></span>  
  
#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="a081d-235">Tipos ISerializable compatíveis e sem suportados</span><span class="sxs-lookup"><span data-stu-id="a081d-235">Supported and Unsupported ISerializable Types</span></span>  
 <span data-ttu-id="a081d-236">Em geral, tipos que implementam o <xref:System.Runtime.Serialization.ISerializable> interface são totalmente compatíveis durante a serialização/desserialização JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-236">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="a081d-237">No entanto, alguns desses tipos (incluindo alguns tipos do .NET Framework) são implementadas de forma que os aspectos de serialização JSON específico fazer com que eles não desserializar corretamente:</span><span class="sxs-lookup"><span data-stu-id="a081d-237">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>  
  
- <span data-ttu-id="a081d-238">Com <xref:System.Runtime.Serialization.ISerializable>, o tipo dos membros de dados individuais nunca é conhecido de antemão.</span><span class="sxs-lookup"><span data-stu-id="a081d-238">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="a081d-239">Isso leva a uma situação polimórfica semelhante a desserialização de tipos em um objeto.</span><span class="sxs-lookup"><span data-stu-id="a081d-239">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="a081d-240">Como mencionado anteriormente, isso pode levar à perda de informações de tipo em JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-240">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="a081d-241">Por exemplo, um tipo que serializa uma `enum` no seu <xref:System.Runtime.Serialization.ISerializable> implementação e tenta desserializar volta diretamente para um `enum` (sem conversões adequados) falhar, porque um `enum` é serializado usando números em JSON e JSON números de desserializar em .NET tipos numéricos internos (Int32, Decimal ou dupla).</span><span class="sxs-lookup"><span data-stu-id="a081d-241">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="a081d-242">Portanto, o fato de que o número usado para ser um `enum` valor é perdido.</span><span class="sxs-lookup"><span data-stu-id="a081d-242">So the fact that the number used to be an `enum` value is lost.</span></span>  
  
- <span data-ttu-id="a081d-243">Um <xref:System.Runtime.Serialization.ISerializable> tipo depende de uma determinada ordem de desserialização em seu construtor de desserialização também poderá falhar ao desserializar alguns dados JSON, pois a maioria dos serializadores JSON não garantem uma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="a081d-243">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>  
  
#### <a name="factory-types"></a><span data-ttu-id="a081d-244">Tipos de fábrica</span><span class="sxs-lookup"><span data-stu-id="a081d-244">Factory Types</span></span>  
 <span data-ttu-id="a081d-245">Enquanto o <xref:System.Runtime.Serialization.IObjectReference> interface tem suporte em JSON em geral, quaisquer tipos que exigem o recurso de "tipo de fábrica" (retornando uma instância de um tipo diferente de <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> que o tipo que implementa a interface) não têm suporte.</span><span class="sxs-lookup"><span data-stu-id="a081d-245">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>  
  
### <a name="datetime-wire-format"></a><span data-ttu-id="a081d-246">Formato de data e hora de conexão</span><span class="sxs-lookup"><span data-stu-id="a081d-246">DateTime Wire Format</span></span>  
 <span data-ttu-id="a081d-247"><xref:System.DateTime> os valores aparecem como cadeias de caracteres JSON na forma de "Date(700000+0500) /", em que o primeiro número (700000 no exemplo fornecido) é o número de milissegundos no GMT fuso horário, regular (não-horário de verão) de tempo desde a meia-noite de 1º de janeiro de 1970.</span><span class="sxs-lookup"><span data-stu-id="a081d-247"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="a081d-248">O número pode ser negativo para representar horas anteriores.</span><span class="sxs-lookup"><span data-stu-id="a081d-248">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="a081d-249">A parte que consiste em "+0500" no exemplo é opcional e indica que o tempo é do <xref:System.DateTimeKind.Local> tipo – ou seja, deve ser convertido para o fuso horário local na desserialização.</span><span class="sxs-lookup"><span data-stu-id="a081d-249">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="a081d-250">Se ele estiver ausente, o tempo é desserializado como <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="a081d-250">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="a081d-251">O número real ("0500" neste exemplo) e o sinal (+ ou -) são ignorados.</span><span class="sxs-lookup"><span data-stu-id="a081d-251">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>  
  
 <span data-ttu-id="a081d-252">Ao serializar <xref:System.DateTime>, <xref:System.DateTimeKind.Local> e <xref:System.DateTimeKind.Unspecified> vezes são gravados com um deslocamento e <xref:System.DateTimeKind.Utc> é escrita sem.</span><span class="sxs-lookup"><span data-stu-id="a081d-252">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>  
  
 <span data-ttu-id="a081d-253">O código JavaScript do cliente ASP.NET AJAX converte automaticamente tais cadeias de caracteres em JavaScript `DateTime` instâncias.</span><span class="sxs-lookup"><span data-stu-id="a081d-253">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="a081d-254">Se não houver outras cadeias de caracteres que tem um formulário semelhante que não são do tipo <xref:System.DateTime> no .NET, eles são convertidos também.</span><span class="sxs-lookup"><span data-stu-id="a081d-254">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>  
  
 <span data-ttu-id="a081d-255">A conversão ocorre apenas se o caractere "/" será ignorado (ou seja, o JSON se parece com "\\/Date(700000+0500)\\/") e para o codificador JSON do WCF este motivo (habilitada pelo <xref:System.ServiceModel.WebHttpBinding>) sempre escapa o caractere "/".</span><span class="sxs-lookup"><span data-stu-id="a081d-255">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>  
  
### <a name="xml-in-json-strings"></a><span data-ttu-id="a081d-256">XML em cadeias de caracteres JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-256">XML in JSON Strings</span></span>  
  
#### <a name="xmlelement"></a><span data-ttu-id="a081d-257">XmlElement</span><span class="sxs-lookup"><span data-stu-id="a081d-257">XmlElement</span></span>  
 <span data-ttu-id="a081d-258"><xref:System.Xml.XmlElement> é serializado como é, com nenhum encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="a081d-258"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="a081d-259">Por exemplo, membro de dados "x" do tipo <xref:System.Xml.XmlElement> que contém \<abc / > é conforme representado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="a081d-259">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="a081d-260">Matrizes de XmlNode</span><span class="sxs-lookup"><span data-stu-id="a081d-260">Arrays of XmlNode</span></span>  
 <span data-ttu-id="a081d-261"><xref:System.Array> objetos do tipo <xref:System.Xml.XmlNode> são encapsuladas em um elemento chamado ArrayOfXmlNode no namespace do contrato de dados padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="a081d-261"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="a081d-262">Se "x" é uma matriz que contém o nó de atributo "N" no namespace "ns" que contém "valor" e um nó de elemento vazio "M", a representação é da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="a081d-262">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 <span data-ttu-id="a081d-263">Atributos no namespace vazio no início de matrizes de XmlNode (antes de outros elementos) não têm suportados.</span><span class="sxs-lookup"><span data-stu-id="a081d-263">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="a081d-264">Tipos IXmlSerializable incluindo XElement e o conjunto de dados</span><span class="sxs-lookup"><span data-stu-id="a081d-264">IXmlSerializable Types including XElement and DataSet</span></span>  
 <span data-ttu-id="a081d-265"><xref:System.Runtime.Serialization.ISerializable> tipos de subdividem em "tipos de conteúdo", "Tipos de conjunto de dados" e "tipos de elemento".</span><span class="sxs-lookup"><span data-stu-id="a081d-265"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="a081d-266">Para obter definições desses tipos, consulte [XML e tipos ADO.NET em contratos de dados](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-266">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>  
  
 <span data-ttu-id="a081d-267">"Conteúdo" e "Conjunto de dados" tipos são serializados semelhante à <xref:System.Array> objetos do <xref:System.Xml.XmlNode> discutidos na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="a081d-267">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="a081d-268">Eles são encapsulados em um elemento cujo nome e namespace corresponde ao nome do contrato de dados e o namespace do tipo em questão.</span><span class="sxs-lookup"><span data-stu-id="a081d-268">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>  
  
 <span data-ttu-id="a081d-269">Tipos de "Element", como <xref:System.Xml.Linq.XElement> são serializados como está, semelhante ao <xref:System.Xml.XmlElement> discutido anteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="a081d-269">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="a081d-270">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="a081d-270">Polymorphism</span></span>  
  
#### <a name="preserving-type-information"></a><span data-ttu-id="a081d-271">Preservando informações de tipo</span><span class="sxs-lookup"><span data-stu-id="a081d-271">Preserving Type Information</span></span>  
 <span data-ttu-id="a081d-272">Conforme mencionado anteriormente, polimorfismo tem suporte em JSON com algumas limitações.</span><span class="sxs-lookup"><span data-stu-id="a081d-272">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="a081d-273">JavaScript é uma linguagem fracamente tipada e identidade de tipo normalmente não é um problema.</span><span class="sxs-lookup"><span data-stu-id="a081d-273">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="a081d-274">No entanto, ao usar o JSON para a comunicação entre um sistema fortemente tipado (.NET) e um sistema com tipagem fraca (JavaScript), é útil preservar a identidade de tipo.</span><span class="sxs-lookup"><span data-stu-id="a081d-274">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="a081d-275">Por exemplo, tipos de dados "Quadrado" e "Círculo" deriva de um tipo com um nome de contrato de dados de "Forma" de nomes de contrato.</span><span class="sxs-lookup"><span data-stu-id="a081d-275">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="a081d-276">Se "Círculo" é enviado do .NET para JavaScript e mais tarde é retornado para um método do .NET que espera "Forma", é útil para o lado do .NET para saber que o objeto em questão foi originalmente "Círculo" - caso contrário, todas as informações específicas para o tipo derivado (por exemplo membro de dados do "raio" em "Círculo") podem ser perdidos.</span><span class="sxs-lookup"><span data-stu-id="a081d-276">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>  
  
 <span data-ttu-id="a081d-277">Para preservar a identidade de tipo quando serializar tipos complexos como uma "dica de tipo" do JSON pode ser adicionado, e o desserializador reconhece a dica e funciona adequadamente.</span><span class="sxs-lookup"><span data-stu-id="a081d-277">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="a081d-278">A "dica de tipo" é um par chave/valor JSON com o nome da chave de "\_\_tipo" (dois sublinhados seguido pela palavra "type").</span><span class="sxs-lookup"><span data-stu-id="a081d-278">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="a081d-279">O valor é uma cadeia de caracteres JSON do formulário "DataContractName:DataContractNamespace" (nada até a primeira vírgula é o nome).</span><span class="sxs-lookup"><span data-stu-id="a081d-279">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="a081d-280">Usando o exemplo anterior, "Círculo" pode ser serializado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="a081d-280">Using the earlier example, "Circle" can be serialized as follows.</span></span>  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="a081d-281">A dica de tipo é muito semelhante ao `xsi:type` atributo definido pelo padrão de instância do esquema XML e usados quando serializar/desserializar XML.</span><span class="sxs-lookup"><span data-stu-id="a081d-281">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>  
  
 <span data-ttu-id="a081d-282">Membros de dados chamados "\_\_tipo" são proibidos devido a conflito potencial com a dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="a081d-282">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>  
  
#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="a081d-283">Reduzindo o tamanho de dicas de tipo</span><span class="sxs-lookup"><span data-stu-id="a081d-283">Reducing the Size of Type Hints</span></span>  
 <span data-ttu-id="a081d-284">Para reduzir o tamanho do JSON de mensagens, o prefixo de namespace de contrato de dados padrão (`http://schemas.datacontract.org/2004/07/`) é substituído pelo caractere "#".</span><span class="sxs-lookup"><span data-stu-id="a081d-284">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="a081d-285">(Para fazer essa substituição reversível, uma regra de escape é usada: se o espaço para nome começa com "#" ou "\\" caracteres, eles são acrescentados com um extra "\\" caractere).</span><span class="sxs-lookup"><span data-stu-id="a081d-285">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="a081d-286">Portanto, se "Círculo" é um tipo no namespace .NET "MyApp.Shapes", seu namespace de contrato de dados padrão é `http://schemas.datacontract.org/2004/07/MyApp`.</span><span class="sxs-lookup"><span data-stu-id="a081d-286">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="a081d-287">Formas e a representação JSON é da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="a081d-287">Shapes and the JSON representation is as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="a081d-288">Truncado (#MyApp.Shapes) e completo (http://schemas.datacontract.org/2004/07/MyApp.Shapes) nomes é compreendido na desserialização.</span><span class="sxs-lookup"><span data-stu-id="a081d-288">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>  
  
#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="a081d-289">Posição de dica de tipo em objetos JSON</span><span class="sxs-lookup"><span data-stu-id="a081d-289">Type Hint Position in JSON Objects</span></span>  
 <span data-ttu-id="a081d-290">Observe que a dica de tipo deve aparecer primeira na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-290">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="a081d-291">Isso é o único caso em que a ordem dos pares chave/valor é importante no processamento de JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-291">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="a081d-292">Por exemplo, o seguinte não é uma maneira válida de especificar a dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="a081d-292">For example, the following is not a valid way to specify the type hint.</span></span>  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 <span data-ttu-id="a081d-293">Os dois o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> usado pelo WCF e ASP.NET AJAX páginas do cliente sempre emitem a dica de tipo pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="a081d-293">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>  
  
#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="a081d-294">Dicas de tipo se aplicam somente a tipos complexos</span><span class="sxs-lookup"><span data-stu-id="a081d-294">Type Hints Apply Only to Complex Types</span></span>  
 <span data-ttu-id="a081d-295">Não é possível emitir uma dica de tipo para tipos de não-complexos.</span><span class="sxs-lookup"><span data-stu-id="a081d-295">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="a081d-296">Por exemplo, se uma operação tem um <xref:System.Object> retornar tipo, mas retorna um círculo, a representação JSON pode ser como mostrado anteriormente e as informações de tipo são preservadas.</span><span class="sxs-lookup"><span data-stu-id="a081d-296">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="a081d-297">No entanto, se o Uri é retornado, a representação JSON é uma cadeia de caracteres e o fato de que a cadeia de caracteres usada para representar um Uri é perdida.</span><span class="sxs-lookup"><span data-stu-id="a081d-297">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="a081d-298">Isso se aplica não apenas para tipos primitivos, mas também para coleções e matrizes.</span><span class="sxs-lookup"><span data-stu-id="a081d-298">This applies not only to primitive types but also to collections and arrays.</span></span>  
  
#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="a081d-299">Quando as dicas de tipo são emitidas</span><span class="sxs-lookup"><span data-stu-id="a081d-299">When Are Type Hints Emitted</span></span>  
 <span data-ttu-id="a081d-300">Dicas de tipo podem aumentar significativamente o tamanho de mensagem (uma forma para atenuar isso é usar namespaces de contrato de dados menor, se possível).</span><span class="sxs-lookup"><span data-stu-id="a081d-300">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="a081d-301">Portanto, as regras a seguir controlam se as dicas de tipo são emitidas:</span><span class="sxs-lookup"><span data-stu-id="a081d-301">Therefore, the following rules govern whether type hints are emitted:</span></span>  
  
- <span data-ttu-id="a081d-302">Ao usar o ASP.NET AJAX, dicas de tipo sempre são emitidas sempre que possível, mesmo se não houver nenhuma atribuição de base/derivada - por exemplo, mesmo se um círculo é atribuído a um círculo.</span><span class="sxs-lookup"><span data-stu-id="a081d-302">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="a081d-303">(Isso é necessário para habilitar totalmente o processo de chamada do ambiente de JSON com tipagem fraca no ambiente .NET fortemente tipados sem surpreendente perda de informações.)</span><span class="sxs-lookup"><span data-stu-id="a081d-303">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>  
  
- <span data-ttu-id="a081d-304">Ao usar os serviços AJAX com nenhuma integração do ASP.NET, dicas de tipo são emitidas apenas quando há uma atribuição de base/derivada - que é, emitida quando o círculo é atribuído a forma ou <xref:System.Object> , mas não quando atribuído ao círculo.</span><span class="sxs-lookup"><span data-stu-id="a081d-304">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="a081d-305">Isso fornece as informações mínimas necessárias para implementar corretamente um cliente JavaScript, que melhora o desempenho, mas não protege contra perda de informações de tipo em clientes projetado incorretamente.</span><span class="sxs-lookup"><span data-stu-id="a081d-305">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="a081d-306">Evite atribuições de base/derivada totalmente no servidor se você quiser evitar lidar com esse problema no cliente.</span><span class="sxs-lookup"><span data-stu-id="a081d-306">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>  
  
- <span data-ttu-id="a081d-307">Ao usar o <xref:System.Runtime.Serialization.DataContractSerializer> tipo, o `alwaysEmitTypeInformation` parâmetro de construtor permite que você escolha entre os dois modos anteriores, com o padrão que está sendo "`false`" (emitir somente dicas de tipo quando necessário).</span><span class="sxs-lookup"><span data-stu-id="a081d-307">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>  
  
#### <a name="duplicate-data-member-names"></a><span data-ttu-id="a081d-308">Nomes de membro de dados duplicados</span><span class="sxs-lookup"><span data-stu-id="a081d-308">Duplicate Data Member Names</span></span>  
 <span data-ttu-id="a081d-309">Informações de tipo derivado está presentes no mesmo objeto JSON junto com informações de tipo base e podem ocorrer em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="a081d-309">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="a081d-310">Por exemplo, `Shape` pode ser representada da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="a081d-310">For example, `Shape` may be represented as follows.</span></span>  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 <span data-ttu-id="a081d-311">Enquanto o círculo pode ser representado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="a081d-311">Whereas Circle may be represented as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 <span data-ttu-id="a081d-312">Se a base `Shape` tipo também continha um membro de dados chamado "`radius`", isso leva a uma colisão em ambos os serialização (porque objetos JSON não é possível ter nomes de chave de repetição) e de desserialização (porque não está claro se "raio" refere-se ao `Shape.radius` ou `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="a081d-312">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="a081d-313">Portanto, embora o conceito de "ocultação da propriedade" (membros de dados de mesmo nome na base e classes derivadas) geralmente não é recomendado em classes de contrato de dados, ele é proibido, na verdade, no caso do JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-313">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="a081d-314">Polimorfismo e tipos IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="a081d-314">Polymorphism and IXmlSerializable Types</span></span>  
 <span data-ttu-id="a081d-315"><xref:System.Xml.Serialization.IXmlSerializable> tipos podem ser polimorficamente atribuídos uns aos outros como de costume, desde requisitos de tipos conhecidos são atendidos, de acordo com as regras do contrato de dados normal.</span><span class="sxs-lookup"><span data-stu-id="a081d-315"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="a081d-316">No entanto, Serializando uma <xref:System.Xml.Serialization.IXmlSerializable> de tipo no lugar de <xref:System.Object> resulta na perda de informações de tipo como o resultado é uma cadeia de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="a081d-316">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>  
  
#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="a081d-317">Polimorfismo e determinados tipos de Interface</span><span class="sxs-lookup"><span data-stu-id="a081d-317">Polymorphism and Certain Interface Types</span></span>  
 <span data-ttu-id="a081d-318">É proibido para serializar um tipo de coleção ou um tipo que implementa <xref:System.Xml.Serialization.IXmlSerializable> onde um tipo não seja de coleção que não seja <xref:System.Xml.Serialization.IXmlSerializable> (exceto para <xref:System.Object>) é esperado.</span><span class="sxs-lookup"><span data-stu-id="a081d-318">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="a081d-319">Por exemplo, uma interface personalizada chamada `IMyInterface` e um tipo `MyType` que implementam <xref:System.Collections.Generic.IEnumerable%601> do tipo `int` e `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="a081d-319">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="a081d-320">É proibido para retornar `MyType` de uma operação cujo tipo de retorno é `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="a081d-320">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="a081d-321">Isso ocorre porque `MyType` deve ser serializado como uma matriz JSON e requer uma dica de tipo e indicado antes de você não pode incluir uma dica de tipo com matrizes, apenas com tipos complexos.</span><span class="sxs-lookup"><span data-stu-id="a081d-321">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>  
  
#### <a name="known-types-and-configuration"></a><span data-ttu-id="a081d-322">Configuração e tipos conhecidos</span><span class="sxs-lookup"><span data-stu-id="a081d-322">Known Types and Configuration</span></span>  
 <span data-ttu-id="a081d-323">Todos os mecanismos de tipo conhecido usados pelas <xref:System.Runtime.Serialization.DataContractSerializer> também têm suporte da mesma forma, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a081d-323">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="a081d-324">Elemento de configuração, de leitura de ambos os serializadores [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) na [ \<Serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), para descobrir os tipos conhecidos adicionados por meio de um arquivo de configuração.</span><span class="sxs-lookup"><span data-stu-id="a081d-324">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>  
  
#### <a name="collections-assigned-to-object"></a><span data-ttu-id="a081d-325">Atribuído a um objeto de coleções</span><span class="sxs-lookup"><span data-stu-id="a081d-325">Collections Assigned to Object</span></span>  
 <span data-ttu-id="a081d-326">Coleções atribuídas ao objeto são serializadas como se elas são coleções que implementam <xref:System.Collections.Generic.IEnumerable%601>: uma matriz JSON com cada entrada que tem uma dica de tipo, se for um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="a081d-326">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="a081d-327">Por exemplo, uma <xref:System.Collections.Generic.List%601> do tipo `Shape` atribuído a <xref:System.Object> é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="a081d-327">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 <span data-ttu-id="a081d-328">Quando desserializado de volta para <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="a081d-328">When deserialized back into <xref:System.Object>:</span></span>  
  
- <span data-ttu-id="a081d-329">`Shape` deve estar na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="a081d-329">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="a081d-330">Tendo <xref:System.Collections.Generic.List%601> do tipo `Shape` em tipos conhecidos não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="a081d-330">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="a081d-331">Observe que você não precisa adicionar `Shape` aos tipos conhecidos em serialização nesse caso - isso é feito automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a081d-331">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>  
  
- <span data-ttu-id="a081d-332">A coleção é desserializada como um <xref:System.Array> do tipo <xref:System.Object> que contém `Shape` instâncias.</span><span class="sxs-lookup"><span data-stu-id="a081d-332">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>  
  
#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="a081d-333">Coleções derivadas atribuídas a coleções Base</span><span class="sxs-lookup"><span data-stu-id="a081d-333">Derived Collections Assigned to Base Collections</span></span>  
 <span data-ttu-id="a081d-334">Quando uma coleção derivada é atribuída a uma coleção de base, a coleção geralmente é serializada como se fosse uma coleção do tipo base.</span><span class="sxs-lookup"><span data-stu-id="a081d-334">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="a081d-335">No entanto, se o tipo de item da coleção derivada não pode ser atribuído ao tipo de item da coleção de base, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="a081d-335">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>  
  
#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="a081d-336">Dicas de tipo e dicionários</span><span class="sxs-lookup"><span data-stu-id="a081d-336">Type Hints and Dictionaries</span></span>  
 <span data-ttu-id="a081d-337">Quando um dicionário é atribuído a um <xref:System.Object>, cada entrada de chave e valor no dicionário é tratada como se ele foi atribuído a <xref:System.Object> e obtém uma dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="a081d-337">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>  
  
 <span data-ttu-id="a081d-338">Ao serializar os tipos de dicionário, o objeto JSON que contém os membros de "Chave" e "Valor" não é afetado pelo `alwaysEmitTypeInformation` definindo e contém apenas uma dica de tipo quando as regras de coleta anterior exigirem a ele.</span><span class="sxs-lookup"><span data-stu-id="a081d-338">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>  
  
### <a name="valid-json-key-names"></a><span data-ttu-id="a081d-339">Nomes de chave JSON válido</span><span class="sxs-lookup"><span data-stu-id="a081d-339">Valid JSON Key Names</span></span>  
 <span data-ttu-id="a081d-340">Os nomes de chave do serializador codifica em formato XML que não são nomes XML válidos.</span><span class="sxs-lookup"><span data-stu-id="a081d-340">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="a081d-341">Por exemplo, um membro de dados com o nome de "123" teria um nome codificado como "\_x0031\_\_x0032\_\_x0033\_" como "123" é um nome de elemento XML inválido (começa com um Dígito).</span><span class="sxs-lookup"><span data-stu-id="a081d-341">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="a081d-342">Pode surgir uma situação semelhante com alguns conjuntos de caracteres internacionais não válidos em nomes XML.</span><span class="sxs-lookup"><span data-stu-id="a081d-342">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="a081d-343">Para obter uma explicação do efeito de XML no processamento de JSON, consulte [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="a081d-343">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a081d-344">Consulte também</span><span class="sxs-lookup"><span data-stu-id="a081d-344">See also</span></span>

- [<span data-ttu-id="a081d-345">Suporte para JSON e outros formatos de transferência de dados</span><span class="sxs-lookup"><span data-stu-id="a081d-345">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
