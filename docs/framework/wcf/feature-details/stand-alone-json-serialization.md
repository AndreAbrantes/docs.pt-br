---
title: Serialização JSON autônoma
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
caps.latest.revision: 32
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 1a0a11d613ffb8f71437edd73a8be64fb5f55a4c
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/28/2018
---
# <a name="stand-alone-json-serialization"></a><span data-ttu-id="22bad-102">Serialização JSON autônoma</span><span class="sxs-lookup"><span data-stu-id="22bad-102">Stand-Alone JSON Serialization</span></span>
<span data-ttu-id="22bad-103">JSON (JavaScript Object Notation) é um formato de dados que é projetado especificamente para ser usado pelo código JavaScript em execução em páginas da Web dentro do navegador.</span><span class="sxs-lookup"><span data-stu-id="22bad-103">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="22bad-104">É o formato de dados padrão usado por serviços ASP.NET AJAX criados no [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span><span class="sxs-lookup"><span data-stu-id="22bad-104">It is the default data format used by ASP.NET AJAX services created in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span></span>  
  
 <span data-ttu-id="22bad-105">Esse formato também pode ser usado quando criando serviços AJAX sem integração com o ASP.NET - nesse caso, o XML é o padrão, mas pode ser escolhido JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-105">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>  
  
 <span data-ttu-id="22bad-106">Por fim, se você necessita de suporte a JSON, mas não está criando um serviço de AJAX, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> possibilita diretamente serializar objetos .NET em dados JSON e desserializar tais dados de volta em instâncias de tipos do .NET.</span><span class="sxs-lookup"><span data-stu-id="22bad-106">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="22bad-107">Para obter uma descrição de como fazer isso, consulte [como: serializar e desserializar dados de JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-107">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="22bad-108">Ao trabalhar com JSON, os mesmos tipos de .NET têm suporte, com poucas exceções, como há suporte para o <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="22bad-108">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="22bad-109">Para obter uma lista dos tipos suportados, consulte [tipos suportados pelo serializador de contrato de dados](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-109">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="22bad-110">Isso inclui tipos primitivos mais, a maioria das matriz e tipos de coleção, bem como complexos tipos que usam o <xref:System.Runtime.Serialization.DataContractAttribute> e <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="22bad-110">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="22bad-111">Mapeamento de tipos do .NET em tipos JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-111">Mapping .NET types to JSON Types</span></span>  
 <span data-ttu-id="22bad-112">A tabela a seguir mostra a correspondência entre tipos .NET e JSON/JavaScript quando mapeado por procedimentos de serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="22bad-112">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>  
  
|<span data-ttu-id="22bad-113">Tipos de .NET</span><span class="sxs-lookup"><span data-stu-id="22bad-113">.NET Types</span></span>|<span data-ttu-id="22bad-114">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="22bad-114">JSON/JavaScript</span></span>|<span data-ttu-id="22bad-115">Observações</span><span class="sxs-lookup"><span data-stu-id="22bad-115">Notes</span></span>|  
|----------------|----------------------|-----------|  
|<span data-ttu-id="22bad-116">Todos os tipos numéricos, por exemplo <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="22bad-116">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="22bad-117">Número</span><span class="sxs-lookup"><span data-stu-id="22bad-117">Number</span></span>|<span data-ttu-id="22bad-118">Valores especiais, como `Double.NaN`, `Double.PositiveInfinity` e `Double.NegativeInfinity` não são suportados e resultar em JSON inválido.</span><span class="sxs-lookup"><span data-stu-id="22bad-118">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|  
|<xref:System.Enum>|<span data-ttu-id="22bad-119">Número</span><span class="sxs-lookup"><span data-stu-id="22bad-119">Number</span></span>|<span data-ttu-id="22bad-120">Consulte "Enumerações e JSON", mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-120">See "Enumerations and JSON" later in this topic.</span></span>|  
|<xref:System.Boolean>|<span data-ttu-id="22bad-121">Boolean</span><span class="sxs-lookup"><span data-stu-id="22bad-121">Boolean</span></span>|--|  
|<span data-ttu-id="22bad-122"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="22bad-122"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="22bad-123">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="22bad-123">String</span></span>|--|  
|<span data-ttu-id="22bad-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="22bad-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="22bad-125">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="22bad-125">String</span></span>|<span data-ttu-id="22bad-126">O formato desses tipos nas JSON é o mesmo do XML (essencialmente, o período de tempo no formato ISO 8601 duração, GUID no formato "12345678-ABCD-ABCD-ABCD-1234567890AB" e URI na forma de cadeia de caracteres natural, como "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="22bad-126">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="22bad-127">Para obter informações precisas, consulte [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-127">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|  
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="22bad-128">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="22bad-128">String</span></span>|<span data-ttu-id="22bad-129">O formato é "nome: namespace" (nada antes do primeiro vírgula é o nome).</span><span class="sxs-lookup"><span data-stu-id="22bad-129">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="22bad-130">O nome ou o namespace pode ser ausente.</span><span class="sxs-lookup"><span data-stu-id="22bad-130">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="22bad-131">Se não houver nenhum namespace os dois-pontos podem também ser omitido.</span><span class="sxs-lookup"><span data-stu-id="22bad-131">If there is no namespace the colon can be omitted as well.</span></span>|  
|<span data-ttu-id="22bad-132"><xref:System.Array> do tipo <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="22bad-132"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="22bad-133">Matriz de números</span><span class="sxs-lookup"><span data-stu-id="22bad-133">Array of numbers</span></span>|<span data-ttu-id="22bad-134">Cada número representa o valor de um byte.</span><span class="sxs-lookup"><span data-stu-id="22bad-134">Each number represents the value of one byte.</span></span>|  
|<xref:System.DateTime>|<span data-ttu-id="22bad-135">Data e hora ou cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="22bad-135">DateTime or String</span></span>|<span data-ttu-id="22bad-136">Consulte as datas / horas e JSON neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-136">See Dates/Times and JSON later in this topic.</span></span>|  
|<xref:System.DateTimeOffset>|<span data-ttu-id="22bad-137">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="22bad-137">Complex type</span></span>|<span data-ttu-id="22bad-138">Consulte as datas / horas e JSON neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-138">See Dates/Times and JSON later in this topic.</span></span>|  
|<span data-ttu-id="22bad-139">Tipos de XML e ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="22bad-139">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="22bad-140"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="22bad-140"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="22bad-141">Matrizes de <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="22bad-141">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="22bad-142"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="22bad-142"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="22bad-143"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="22bad-143"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="22bad-144">Cadeia de Caracteres</span><span class="sxs-lookup"><span data-stu-id="22bad-144">String</span></span>|<span data-ttu-id="22bad-145">Consulte a seção de tipos XML e JSON deste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-145">See the XML Types and JSON section of this topic.</span></span>|  
|<xref:System.DBNull>|<span data-ttu-id="22bad-146">Tipo complexo vazio</span><span class="sxs-lookup"><span data-stu-id="22bad-146">Empty complex type</span></span>|--|  
|<span data-ttu-id="22bad-147">Matrizes, dicionários e coleções</span><span class="sxs-lookup"><span data-stu-id="22bad-147">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="22bad-148">Matriz</span><span class="sxs-lookup"><span data-stu-id="22bad-148">Array</span></span>|<span data-ttu-id="22bad-149">Consulte a seção matrizes, dicionários e coleções deste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-149">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|  
|<span data-ttu-id="22bad-150">Tipos complexos (com o <xref:System.Runtime.Serialization.DataContractAttribute> ou <xref:System.SerializableAttribute> aplicadas)</span><span class="sxs-lookup"><span data-stu-id="22bad-150">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="22bad-151">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="22bad-151">Complex type</span></span>|<span data-ttu-id="22bad-152">Membros de dados se tornam membros do tipo complexo de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="22bad-152">Data members become members of the JavaScript complex type.</span></span>|  
|<span data-ttu-id="22bad-153">Tipos complexos Implementando o <xref:System.Runtime.Serialization.ISerializable> interface)</span><span class="sxs-lookup"><span data-stu-id="22bad-153">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="22bad-154">Tipo complexo</span><span class="sxs-lookup"><span data-stu-id="22bad-154">Complex type</span></span>|<span data-ttu-id="22bad-155">Mesmo que outros tipos complexos, mas alguns <xref:System.Runtime.Serialization.ISerializable> não há suporte para tipos – consulte a parte do suporte ISerializable da seção de informações avançadas deste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-155">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|  
|<span data-ttu-id="22bad-156">`Null` valor de qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="22bad-156">`Null` value for any type</span></span>|<span data-ttu-id="22bad-157">Nulo</span><span class="sxs-lookup"><span data-stu-id="22bad-157">Null</span></span>|<span data-ttu-id="22bad-158">Tipos anuláveis também têm suporte e mapear para JSON da mesma maneira como os tipos de não anuláveis.</span><span class="sxs-lookup"><span data-stu-id="22bad-158">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|  
  
### <a name="enumerations-and-json"></a><span data-ttu-id="22bad-159">Enumerações e JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-159">Enumerations and JSON</span></span>  
 <span data-ttu-id="22bad-160">Valores de membro de enumeração são tratados como números em JSON, que é diferente de como elas são tratadas em contratos de dados, onde eles são incluídos como nomes de membros.</span><span class="sxs-lookup"><span data-stu-id="22bad-160">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="22bad-161"> o contrato de dados tratamento, consulte [tipos de enumeração em contratos de dados](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-161"> the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>  
  
-   <span data-ttu-id="22bad-162">Por exemplo, se você tiver `public enum Color {red, green, blue, yellow, pink}`, serializar `yellow` produz o número 3 e não é a cadeia de caracteres "amarelo".</span><span class="sxs-lookup"><span data-stu-id="22bad-162">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>  
  
-   <span data-ttu-id="22bad-163">Todos os `enum` membros são serializáveis.</span><span class="sxs-lookup"><span data-stu-id="22bad-163">All `enum` members are serializable.</span></span> <span data-ttu-id="22bad-164">O <xref:System.Runtime.Serialization.EnumMemberAttribute> e <xref:System.NonSerializedAttribute> atributos são ignorados se usado.</span><span class="sxs-lookup"><span data-stu-id="22bad-164">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>  
  
-   <span data-ttu-id="22bad-165">É possível desserializar um inexistente `enum` valor - por exemplo, o valor 87 pode ser desserializado em enum cor anterior, embora não exista nenhum nome de cor correspondente definido.</span><span class="sxs-lookup"><span data-stu-id="22bad-165">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>  
  
-   <span data-ttu-id="22bad-166">Um sinalizadores `enum` não é especial e é tratado da mesma forma que qualquer outro `enum`.</span><span class="sxs-lookup"><span data-stu-id="22bad-166">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>  
  
### <a name="datestimes-and-json"></a><span data-ttu-id="22bad-167">Datas/hora e JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-167">Dates/Times and JSON</span></span>  
 <span data-ttu-id="22bad-168">O formato JSON não dá suporte diretamente as datas e horas.</span><span class="sxs-lookup"><span data-stu-id="22bad-168">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="22bad-169">No entanto, eles normalmente são usados e ASP.NET AJAX fornece suporte especial para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="22bad-169">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="22bad-170">Ao usar proxies do ASP.NET AJAX, o <xref:System.DateTime> tipo no .NET totalmente corresponde ao `DateTime` tipo em JavaScript.</span><span class="sxs-lookup"><span data-stu-id="22bad-170">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>  
  
-   <span data-ttu-id="22bad-171">Ao usar o ASP.NET, não um <xref:System.DateTime> tipo é representado em JSON como uma cadeia de caracteres com um formato especial que é descrito na seção avançada informações deste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-171">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>  
  
-   <span data-ttu-id="22bad-172"><xref:System.DateTimeOffset> é representado em JSON como um tipo complexo: {"DateTime": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="22bad-172"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="22bad-173">O `offsetMinutes` membro é o deslocamento de hora local da hora de Greenwich (GMT), também conhecido como tempo Universal Coordenado (UTC), associado com o local do evento de interesse.</span><span class="sxs-lookup"><span data-stu-id="22bad-173">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="22bad-174">O `dateTime` membro representa a instância na hora em que ocorreu o evento de interesse (novamente, ele se torna um `DateTime` em JavaScript quando ASP.NET AJAX está em uso e uma cadeia de caracteres quando ele não estiver).</span><span class="sxs-lookup"><span data-stu-id="22bad-174">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="22bad-175">Na serialização, o `dateTime` membro sempre é serializado em GMT.</span><span class="sxs-lookup"><span data-stu-id="22bad-175">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="22bad-176">Portanto, se descrevendo o tempo de Nova York 3:00 AM, `dateTime` tem um componente de tempo de 8:00 AM e `offsetMinutes` são 300 (menos de 300 minutos ou horas 5 do GMT).</span><span class="sxs-lookup"><span data-stu-id="22bad-176">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="22bad-177"><xref:System.DateTime> e <xref:System.DateTimeOffset> objetos, quando serializado para JSON, somente preservam as informações para a precisão de milissegundos.</span><span class="sxs-lookup"><span data-stu-id="22bad-177"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="22bad-178">Valores de menos de um milissegundo (micro/nanossegundos) serão perdidos durante a serialização.</span><span class="sxs-lookup"><span data-stu-id="22bad-178">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>  
  
### <a name="xml-types-and-json"></a><span data-ttu-id="22bad-179">Tipos XML e JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-179">XML Types and JSON</span></span>  
 <span data-ttu-id="22bad-180">Tipos XML se tornam cadeias de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-180">XML types become JSON strings.</span></span>  
  
-   <span data-ttu-id="22bad-181">Por exemplo, se um membro de dados "q" do tipo XElement contém \<abc / >, o JSON é {"q": "\<abc / >"}.</span><span class="sxs-lookup"><span data-stu-id="22bad-181">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>  
  
-   <span data-ttu-id="22bad-182">Há algumas regras especiais que especifique como o XML é encapsulado - para obter mais informações, consulte a seção informações avançadas, mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-182">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>  
  
-   <span data-ttu-id="22bad-183">Se você estiver usando o ASP.NET AJAX e não deseja usar cadeias de caracteres em JavaScript, mas deseja o XML DOM em vez disso, defina o <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> propriedade XML em <xref:System.ServiceModel.Web.WebGetAttribute> ou <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> propriedade XML no <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="22bad-183">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>  
  
### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="22bad-184">Coleções, dicionários e matrizes</span><span class="sxs-lookup"><span data-stu-id="22bad-184">Collections, Dictionaries and Arrays</span></span>  
 <span data-ttu-id="22bad-185">Todas as coleções, dicionários e matrizes são representadas em JSON como matrizes.</span><span class="sxs-lookup"><span data-stu-id="22bad-185">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>  
  
-   <span data-ttu-id="22bad-186">Qualquer personalização que usa o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> será ignorado na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-186">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>  
  
-   <span data-ttu-id="22bad-187">Dicionários não são uma maneira de trabalhar diretamente com JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-187">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="22bad-188">Dicionário\<de cadeia de caracteres, objeto > talvez não tenham suporte da mesma forma em [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] conforme esperado do trabalho com outras tecnologias JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-188">Dictionary\<string,object> may not be supported in the same way in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] as expected from working with other JSON technologies.</span></span> <span data-ttu-id="22bad-189">Por exemplo, se "abc" é mapeado para "xyz" e "def" é mapeado para 42 em um dicionário, a representação JSON não é {"abc": "xyz", "def": 42}, mas [{"Chave": "abc", "Valor": "xyz"}, {"Chave": "def", "Valor": 42}] em vez disso.</span><span class="sxs-lookup"><span data-stu-id="22bad-189">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>  
  
-   <span data-ttu-id="22bad-190">Se você deseja trabalhar diretamente com JSON (acessam chaves e valores dinamicamente, sem definir previamente um contrato rígido), você tem várias opções:</span><span class="sxs-lookup"><span data-stu-id="22bad-190">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>  
  
    -   <span data-ttu-id="22bad-191">Considere o uso de [serialização JSON (AJAX) de tipo fraco](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) exemplo.</span><span class="sxs-lookup"><span data-stu-id="22bad-191">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>  
  
    -   <span data-ttu-id="22bad-192">Considere o uso de <xref:System.Runtime.Serialization.ISerializable> construtores de interface e a desserialização - esses dois mecanismos permitem acessar pares de chave/valor JSON em serialização e desserialização respectivamente, mas não funcionam em cenários de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="22bad-192">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>  
  
    -   <span data-ttu-id="22bad-193">Considere a possibilidade de trabalhar com o [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) em vez de usar um serializador.</span><span class="sxs-lookup"><span data-stu-id="22bad-193">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>  
  
    -   <span data-ttu-id="22bad-194">*Polimorfismo* no contexto de serialização refere-se à capacidade de serializar um tipo derivado, em que o seu tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="22bad-194">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="22bad-195">Há regras específicas de JSON especiais ao usar coleções polimorficamente, quando, por exemplo, a atribuição de uma coleção para um <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="22bad-195">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="22bad-196">Esse problema é discutido mais detalhadamente na seção informações avançadas, mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-196">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>  
  
## <a name="additional-details"></a><span data-ttu-id="22bad-197">Detalhes adicionais</span><span class="sxs-lookup"><span data-stu-id="22bad-197">Additional Details</span></span>  
  
### <a name="order-of-data-members"></a><span data-ttu-id="22bad-198">Ordem de membros de dados</span><span class="sxs-lookup"><span data-stu-id="22bad-198">Order of Data Members</span></span>  
 <span data-ttu-id="22bad-199">Ordem de membros de dados não é importante ao usar o JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-199">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="22bad-200">Especificamente, mesmo se <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> for definido, JSON dados ainda podem ser desserializados em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="22bad-200">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>  
  
### <a name="json-types"></a><span data-ttu-id="22bad-201">Tipos de JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-201">JSON Types</span></span>  
 <span data-ttu-id="22bad-202">O tipo JSON não precisa corresponder à tabela anterior na desserialização.</span><span class="sxs-lookup"><span data-stu-id="22bad-202">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="22bad-203">Por exemplo, um `Int` normalmente é mapeado para um número JSON, mas ele também pode ser desserializado com êxito de uma cadeia de caracteres JSON como cadeia de caracteres que contém um número válido.</span><span class="sxs-lookup"><span data-stu-id="22bad-203">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="22bad-204">Ou seja, ambos {"q": 42} e {"q": "42"} são válidos, se houver um `Int` membro de dados chamado "p".</span><span class="sxs-lookup"><span data-stu-id="22bad-204">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="22bad-205">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="22bad-205">Polymorphism</span></span>  
 <span data-ttu-id="22bad-206">Serialização polimórfica consiste a capacidade de serializar um tipo derivado, em que o seu tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="22bad-206">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="22bad-207">Isso é suportado para serialização JSON por [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] semelhante à forma como a serialização XML é suportada.</span><span class="sxs-lookup"><span data-stu-id="22bad-207">This is supported for JSON serialization by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="22bad-208">Por exemplo, você pode serializar `MyDerivedType` onde `MyBaseType` é esperado ou serializar `Int` onde `Object` é esperado.</span><span class="sxs-lookup"><span data-stu-id="22bad-208">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>  
  
 <span data-ttu-id="22bad-209">Informações de tipo podem ser perdidas durante a desserialização de um tipo derivado se for esperado o tipo base, a menos que a desserialização de um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="22bad-209">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="22bad-210">Por exemplo, se <xref:System.Uri> é serializado onde <xref:System.Object> é esperado, isso resulta em uma cadeia de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-210">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="22bad-211">Se essa cadeia de caracteres é desserializada no <xref:System.Object>, .NET <xref:System.String> é retornado.</span><span class="sxs-lookup"><span data-stu-id="22bad-211">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="22bad-212">O desserializador não sabe que a cadeia de caracteres era inicialmente do tipo <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="22bad-212">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="22bad-213">Em geral, quando esperando <xref:System.Object>, todas as cadeias de caracteres JSON desserializadas como cadeias de caracteres do .NET e todas as matrizes JSON usado para serializar coleções do .NET, dicionários, e matrizes são desserializadas como .NET <xref:System.Array> do tipo <xref:System.Object>, independentemente do que o tipo original real tivesse sido.</span><span class="sxs-lookup"><span data-stu-id="22bad-213">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="22bad-214">Um booliano JSON é mapeado para um .NET <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="22bad-214">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="22bad-215">No entanto quando esperando um <xref:System.Object>, números JSON desserializados como .NET <xref:System.Int32>, <xref:System.Decimal> ou <xref:System.Double>, em que o tipo mais apropriado é selecionado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="22bad-215">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>  
  
 <span data-ttu-id="22bad-216">Durante a desserialização de um tipo de interface, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> desserializa como se o tipo declarado foram objeto.</span><span class="sxs-lookup"><span data-stu-id="22bad-216">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>  
  
 <span data-ttu-id="22bad-217">Ao trabalhar com seus próprios tipos base e derivados, usando o <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> ou um mecanismo equivalente é geralmente necessário.</span><span class="sxs-lookup"><span data-stu-id="22bad-217">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="22bad-218">Por exemplo, se você tiver uma operação que tenha uma `Animal` retornar o valor e, na verdade, retorna uma instância de `Cat` (derivado de `Animal`), você deve aplicar o <xref:System.Runtime.Serialization.KnownTypeAttribute>, para o `Animal` tipo ou o <xref:System.ServiceModel.ServiceKnownTypeAttribute> para a operação e especifique o `Cat` tipo nesses atributos.</span><span class="sxs-lookup"><span data-stu-id="22bad-218">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="22bad-219">Para obter mais informações, consulte [tipos conhecidos de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-219">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="22bad-220">Para obter detalhes de como polimórfico funciona de serialização e uma discussão sobre algumas das limitações que devem ser respeitadas quando usá-lo, consulte a seção informações avançadas, mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-220">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>  
  
### <a name="versioning"></a><span data-ttu-id="22bad-221">Controle de versão</span><span class="sxs-lookup"><span data-stu-id="22bad-221">Versioning</span></span>  
 <span data-ttu-id="22bad-222">O contrato de dados recursos de controle de versão, incluindo o <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, são totalmente suportados em JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-222">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="22bad-223">Além disso, na maioria dos casos é possível desserializar um tipo em um formato (por exemplo, XML) e, em seguida, serializá-lo em outro formato (por exemplo, JSON) e ainda preservar os dados no <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="22bad-223">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="22bad-224">Para obter mais informações, consulte [Contratos de dados compatíveis por encaminhamento](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-224">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="22bad-225">Lembre-se de que JSON é ordenado, portanto, qualquer informação de ordem é perdida.</span><span class="sxs-lookup"><span data-stu-id="22bad-225">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="22bad-226">Além disso, o JSON não dá suporte a vários pares de chave/valor com o mesmo nome de chave.</span><span class="sxs-lookup"><span data-stu-id="22bad-226">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="22bad-227">Por fim, todas as operações em <xref:System.Runtime.Serialization.IExtensibleDataObject> são inerentemente polimórfico - que é seu tipo derivado são atribuídos a <xref:System.Object>, o tipo base para todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="22bad-227">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>  
  
## <a name="json-in-urls"></a><span data-ttu-id="22bad-228">JSON em URLs</span><span class="sxs-lookup"><span data-stu-id="22bad-228">JSON in URLs</span></span>  
 <span data-ttu-id="22bad-229">Ao usar pontos de extremidade AJAX ASP.NET com o verbo HTTP GET (usando o <xref:System.ServiceModel.Web.WebGetAttribute> atributo), os parâmetros de entrada aparecem na URL da solicitação em vez do corpo da mensagem.</span><span class="sxs-lookup"><span data-stu-id="22bad-229">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="22bad-230">Há suporte JSON mesmo na URL da solicitação, portanto, se você tiver uma operação que utiliza um `Int` chamado "number" e um `Person` tipo complexo chamado "p", a URL pode ser semelhante a URL a seguir.</span><span class="sxs-lookup"><span data-stu-id="22bad-230">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 <span data-ttu-id="22bad-231">Se você estiver usando um controle de Gerenciador de Script do ASP.NET AJAX e o proxy para chamar o serviço, essa URL é gerada automaticamente pelo proxy e não seja visto.</span><span class="sxs-lookup"><span data-stu-id="22bad-231">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="22bad-232">JSON não pode ser usado em URLs em pontos de extremidade do ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="22bad-232">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>  
  
## <a name="advanced-information"></a><span data-ttu-id="22bad-233">Informações avançadas</span><span class="sxs-lookup"><span data-stu-id="22bad-233">Advanced information</span></span>  
  
### <a name="iserializable-support"></a><span data-ttu-id="22bad-234">Suporte de iSerializable</span><span class="sxs-lookup"><span data-stu-id="22bad-234">ISerializable Support</span></span>  
  
#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="22bad-235">Tipos ISerializable compatíveis e sem suportados</span><span class="sxs-lookup"><span data-stu-id="22bad-235">Supported and Unsupported ISerializable Types</span></span>  
 <span data-ttu-id="22bad-236">Em geral, tipos que implementam o <xref:System.Runtime.Serialization.ISerializable> interface têm suporte total ao serializar/desserializar JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-236">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="22bad-237">No entanto, alguns desses tipos (incluindo alguns tipos do .NET Framework) são implementadas de forma que os aspectos de serialização JSON específicos fazer com que eles não desserializar corretamente:</span><span class="sxs-lookup"><span data-stu-id="22bad-237">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>  
  
-   <span data-ttu-id="22bad-238">Com <xref:System.Runtime.Serialization.ISerializable>, o tipo dos membros de dados individuais nunca é conhecido antecipadamente.</span><span class="sxs-lookup"><span data-stu-id="22bad-238">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="22bad-239">Isso leva a uma situação polimórfica semelhante a desserialização de tipos em um objeto.</span><span class="sxs-lookup"><span data-stu-id="22bad-239">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="22bad-240">Como mencionado anteriormente, isso pode levar à perda de informações de tipo em JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-240">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="22bad-241">Por exemplo, um tipo que serializa um `enum` no seu <xref:System.Runtime.Serialization.ISerializable> implementação e tenta desserializar volta diretamente para um `enum` (sem conversão adequada) falha, pois um `enum` é serializado usando números em JSON e JSON números desserializar em .NET tipos numéricos internos (Int32, Decimal ou duplo).</span><span class="sxs-lookup"><span data-stu-id="22bad-241">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="22bad-242">Portanto o fato de que o número usado para ser um `enum` valor é perdido.</span><span class="sxs-lookup"><span data-stu-id="22bad-242">So the fact that the number used to be an `enum` value is lost.</span></span>  
  
-   <span data-ttu-id="22bad-243">Um <xref:System.Runtime.Serialization.ISerializable> tipo depende de uma determinada ordem de desserialização em seu construtor de desserialização também pode falhar ao desserializar alguns dados JSON, porque a maioria dos serializadores JSON não garantem uma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="22bad-243">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>  
  
#### <a name="factory-types"></a><span data-ttu-id="22bad-244">Tipos de fábrica</span><span class="sxs-lookup"><span data-stu-id="22bad-244">Factory Types</span></span>  
 <span data-ttu-id="22bad-245">Enquanto o <xref:System.Runtime.Serialization.IObjectReference> interface é suportada em JSON em geral, quaisquer tipos que exigem o recurso de "tipo de fábrica" (retornar uma instância de um tipo diferente de <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> que o tipo que implementa a interface) não têm suporte.</span><span class="sxs-lookup"><span data-stu-id="22bad-245">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>  
  
### <a name="datetime-wire-format"></a><span data-ttu-id="22bad-246">Formato de data e hora durante a transmissão</span><span class="sxs-lookup"><span data-stu-id="22bad-246">DateTime Wire Format</span></span>  
 <span data-ttu-id="22bad-247"><xref:System.DateTime> os valores aparecem como cadeias de caracteres JSON na forma de "Date(700000+0500) /", onde o primeiro número (700000 no exemplo fornecido) é o número de milissegundos na zona de hora GMT, regular (não horário de verão) tempo desde a meia-noite de 1º de janeiro de 1970.</span><span class="sxs-lookup"><span data-stu-id="22bad-247"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="22bad-248">O número pode ser negativo para representar horas anteriores.</span><span class="sxs-lookup"><span data-stu-id="22bad-248">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="22bad-249">A parte que consiste em "+0500" no exemplo é opcional e indica que o tempo é do <xref:System.DateTimeKind.Local> tipo - ou seja, deve ser convertido para o fuso horário local na desserialização.</span><span class="sxs-lookup"><span data-stu-id="22bad-249">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="22bad-250">Se ele estiver ausente, o tempo é desserializado como <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="22bad-250">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="22bad-251">O número real ("0500" neste exemplo) e o sinal (+ ou -) são ignorados.</span><span class="sxs-lookup"><span data-stu-id="22bad-251">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>  
  
 <span data-ttu-id="22bad-252">Ao serializar <xref:System.DateTime>, <xref:System.DateTimeKind.Local> e <xref:System.DateTimeKind.Unspecified> vezes são gravados com um deslocamento e <xref:System.DateTimeKind.Utc> é gravado sem.</span><span class="sxs-lookup"><span data-stu-id="22bad-252">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>  
  
 <span data-ttu-id="22bad-253">O código JavaScript de cliente do ASP.NET AJAX converte automaticamente como cadeias de caracteres em JavaScript `DateTime` instâncias.</span><span class="sxs-lookup"><span data-stu-id="22bad-253">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="22bad-254">Se não houver outras cadeias de caracteres que têm um formato semelhante que não são do tipo <xref:System.DateTime> no .NET, eles são convertidos também.</span><span class="sxs-lookup"><span data-stu-id="22bad-254">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>  
  
 <span data-ttu-id="22bad-255">A conversão somente ocorre se os caracteres "/" são ignorados (ou seja, o JSON se parece com "\\/Date(700000+0500)\\/") e por esse motivo [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]do codificador JSON (habilitado pelo <xref:System.ServiceModel.WebHttpBinding>) sempre ignora o "/" caractere.</span><span class="sxs-lookup"><span data-stu-id="22bad-255">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>  
  
### <a name="xml-in-json-strings"></a><span data-ttu-id="22bad-256">XML em cadeias de caracteres JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-256">XML in JSON Strings</span></span>  
  
#### <a name="xmlelement"></a><span data-ttu-id="22bad-257">XmlElement</span><span class="sxs-lookup"><span data-stu-id="22bad-257">XmlElement</span></span>  
 <span data-ttu-id="22bad-258"><xref:System.Xml.XmlElement> é serializado como é, com nenhum encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="22bad-258"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="22bad-259">Por exemplo, membro de dados "x" do tipo <xref:System.Xml.XmlElement> que contém \<abc / > é representada da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="22bad-259">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="22bad-260">Matrizes de XmlNode</span><span class="sxs-lookup"><span data-stu-id="22bad-260">Arrays of XmlNode</span></span>  
 <span data-ttu-id="22bad-261"><xref:System.Array> objetos do tipo <xref:System.Xml.XmlNode> são quebrados em um elemento chamado ArrayOfXmlNode no namespace de contrato de dados padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="22bad-261"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="22bad-262">Se o "x" é uma matriz que contém o nó de atributo "N" no namespace "ns" que contém "valor" e um nó de elemento vazio "M", a representação é da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="22bad-262">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 <span data-ttu-id="22bad-263">Atributos no namespace vazio no início de matrizes de XmlNode (antes de outros elementos) não têm suportados.</span><span class="sxs-lookup"><span data-stu-id="22bad-263">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="22bad-264">Tipos de IXmlSerializable incluindo XElement e conjunto de dados</span><span class="sxs-lookup"><span data-stu-id="22bad-264">IXmlSerializable Types including XElement and DataSet</span></span>  
 <span data-ttu-id="22bad-265"><xref:System.Runtime.Serialization.ISerializable> tipos de subdividir em "tipos de conteúdo", "Tipos de conjunto de dados" e "tipos de elemento".</span><span class="sxs-lookup"><span data-stu-id="22bad-265"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="22bad-266">Para obter definições desses tipos, consulte [XML e tipos de ADO.NET em contratos de dados](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-266">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>  
  
 <span data-ttu-id="22bad-267">"Conteúdo" e "Conjunto de dados" tipos são serializados semelhante ao <xref:System.Array> objetos <xref:System.Xml.XmlNode> discutidos na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="22bad-267">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="22bad-268">Eles são dispostos em um elemento cujo nome e namespace corresponde ao nome de contrato de dados e o namespace do tipo em questão.</span><span class="sxs-lookup"><span data-stu-id="22bad-268">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>  
  
 <span data-ttu-id="22bad-269">Tipos de "Element" como <xref:System.Xml.Linq.XElement> são serializados que é semelhante ao <xref:System.Xml.XmlElement> abordado anteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="22bad-269">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="22bad-270">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="22bad-270">Polymorphism</span></span>  
  
#### <a name="preserving-type-information"></a><span data-ttu-id="22bad-271">Preservar informações de tipo</span><span class="sxs-lookup"><span data-stu-id="22bad-271">Preserving Type Information</span></span>  
 <span data-ttu-id="22bad-272">Conforme mencionado anteriormente, polimorfismo tem suporte em JSON com algumas limitações.</span><span class="sxs-lookup"><span data-stu-id="22bad-272">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="22bad-273">O JavaScript é uma linguagem fraca em tipos e identidade normalmente não é um problema.</span><span class="sxs-lookup"><span data-stu-id="22bad-273">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="22bad-274">No entanto, ao usar JSON para comunicação entre um sistema fortemente tipado (.NET) e um sistema de tipo fraco (JavaScript), é útil preservar a identidade de tipo.</span><span class="sxs-lookup"><span data-stu-id="22bad-274">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="22bad-275">Por exemplo, tipos de dados "Quadrado" e "Círculo" deriva de um tipo com um nome de contrato de dados de "Forma" de nomes de contrato.</span><span class="sxs-lookup"><span data-stu-id="22bad-275">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="22bad-276">Se "Círculo" é enviado do .NET para JavaScript e posterior é retornado para um método do .NET que espera "Forma", é útil para o lado do .NET para saber se o objeto em questão foi originalmente "Círculo" - caso contrário, as informações específicas para o tipo derivado (por exemplo membro de dados "radius" em "Círculo") podem ser perdidos.</span><span class="sxs-lookup"><span data-stu-id="22bad-276">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>  
  
 <span data-ttu-id="22bad-277">Para preservar a identidade de tipo quando serializar tipos complexos em JSON uma "dica do tipo" pode ser adicionado, e o desserializador reconhece a dica e funciona adequadamente.</span><span class="sxs-lookup"><span data-stu-id="22bad-277">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="22bad-278">A dica"type" é um par de chave/valor JSON com o nome da chave de type"(dois sublinhados seguidos da palavra"type").</span><span class="sxs-lookup"><span data-stu-id="22bad-278">The "type hint" is a JSON key/value pair with the key name of "__type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="22bad-279">O valor é uma cadeia de caracteres JSON no formato "DataContractName:DataContractNamespace" (nada até o primeira vírgula é o nome).</span><span class="sxs-lookup"><span data-stu-id="22bad-279">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="22bad-280">Usando o exemplo anterior, "Círculo" pode ser serializado da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="22bad-280">Using the earlier example, "Circle" can be serialized as follows.</span></span>  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="22bad-281">A dica de tipo é muito semelhante de `xsi:type` atributo definido pelo padrão a instância do esquema XML e usados quando serializar/desserializar o XML.</span><span class="sxs-lookup"><span data-stu-id="22bad-281">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>  
  
 <span data-ttu-id="22bad-282">Membros de dados chamados type"são proibidos devido a conflito potencial com a dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="22bad-282">Data members called "__type" are forbidden due to potential conflict with the type hint.</span></span>  
  
#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="22bad-283">Reduzir o tamanho do tipo dicas</span><span class="sxs-lookup"><span data-stu-id="22bad-283">Reducing the Size of Type Hints</span></span>  
 <span data-ttu-id="22bad-284">Para reduzir o tamanho do JSON mensagens, o prefixo de namespace de contrato de dados padrão (http://schemas.datacontract.org/2004/07/) é substituído com o caractere "#".</span><span class="sxs-lookup"><span data-stu-id="22bad-284">To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the "#" character.</span></span> <span data-ttu-id="22bad-285">(Para tornar esta substituição reversível, uma regra de escape é usada: se o espaço para nome começa com "#" ou "\\" caracteres, eles serão anexados com um extra "\\" caractere).</span><span class="sxs-lookup"><span data-stu-id="22bad-285">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="22bad-286">Assim, se "Círculo" é um tipo no namespace .NET "MyApp.Shapes", seu namespace de contrato de dados padrão é http://schemas.datacontract.org/2004/07/MyApp.</span><span class="sxs-lookup"><span data-stu-id="22bad-286">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp.</span></span> <span data-ttu-id="22bad-287">Formas e a representação JSON é da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="22bad-287">Shapes and the JSON representation is as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="22bad-288">Truncado (#MyApp.Shapes) e o total (http://schemas.datacontract.org/2004/07/MyApp.Shapes) nomes é entendida na desserialização.</span><span class="sxs-lookup"><span data-stu-id="22bad-288">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>  
  
#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="22bad-289">Posição de dica de tipo de objetos JSON</span><span class="sxs-lookup"><span data-stu-id="22bad-289">Type Hint Position in JSON Objects</span></span>  
 <span data-ttu-id="22bad-290">Observe que a dica de tipo deve aparecer primeira na representação JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-290">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="22bad-291">Este é o único caso em que a ordem de pares chave/valor é importante no processamento de JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-291">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="22bad-292">Por exemplo, o seguinte não é uma maneira válida para especificar a dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="22bad-292">For example, the following is not a valid way to specify the type hint.</span></span>  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 <span data-ttu-id="22bad-293">Ambos os <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> usado pelo [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] e páginas de cliente do ASP.NET AJAX sempre emitir a dica do tipo primeiro.</span><span class="sxs-lookup"><span data-stu-id="22bad-293">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and ASP.NET AJAX client pages always emit the type hint first.</span></span>  
  
#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="22bad-294">Tipo aplicam-se somente a tipos complexos</span><span class="sxs-lookup"><span data-stu-id="22bad-294">Type Hints Apply Only to Complex Types</span></span>  
 <span data-ttu-id="22bad-295">Não é possível emitir uma dica de tipo para tipos não complexos.</span><span class="sxs-lookup"><span data-stu-id="22bad-295">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="22bad-296">Por exemplo, se uma operação tiver um <xref:System.Object> retornar tipo mas retorna um círculo, a representação JSON pode ser como mostrado anteriormente e as informações de tipo são preservadas.</span><span class="sxs-lookup"><span data-stu-id="22bad-296">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="22bad-297">No entanto, se o Uri é retornado, a representação JSON é uma cadeia de caracteres e o fato de que a cadeia de caracteres usada para representar um Uri é perdida.</span><span class="sxs-lookup"><span data-stu-id="22bad-297">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="22bad-298">Isso se aplica não apenas para tipos primitivos, mas também para coleções e matrizes.</span><span class="sxs-lookup"><span data-stu-id="22bad-298">This applies not only to primitive types but also to collections and arrays.</span></span>  
  
#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="22bad-299">Quando as dicas de tipo são emitidas</span><span class="sxs-lookup"><span data-stu-id="22bad-299">When Are Type Hints Emitted</span></span>  
 <span data-ttu-id="22bad-300">Dicas de tipo podem aumentar significativamente o tamanho de mensagem (uma maneira de reduzir isso é usar namespaces de contrato de dados menor se possível).</span><span class="sxs-lookup"><span data-stu-id="22bad-300">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="22bad-301">Portanto, as regras a seguir controlam se as dicas de tipo são emitidas:</span><span class="sxs-lookup"><span data-stu-id="22bad-301">Therefore, the following rules govern whether type hints are emitted:</span></span>  
  
-   <span data-ttu-id="22bad-302">Ao usar o ASP.NET AJAX, dicas de tipo sempre são emitidas sempre que possível, mesmo se não houver nenhuma atribuição de base/derivada - por exemplo, mesmo se um círculo é atribuído a um círculo.</span><span class="sxs-lookup"><span data-stu-id="22bad-302">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="22bad-303">(Isso é necessário para habilitar completamente o processo de chamada do ambiente do JSON tipo fraco no ambiente .NET fortemente tipado sem surpreendentes perda de informações.)</span><span class="sxs-lookup"><span data-stu-id="22bad-303">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>  
  
-   <span data-ttu-id="22bad-304">Ao usar os serviços AJAX com nenhuma integração do ASP.NET, dicas de tipo só são emitidas quando há uma atribuição de base/derivada -, emitidos quando círculo é atribuído a forma ou <xref:System.Object> , mas não quando atribuído ao círculo.</span><span class="sxs-lookup"><span data-stu-id="22bad-304">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="22bad-305">Isso fornece as informações mínimas necessárias para implementar corretamente um cliente JavaScript, melhorando assim o desempenho, mas não protege contra a perda de informações de tipo em clientes incorretamente projetado.</span><span class="sxs-lookup"><span data-stu-id="22bad-305">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="22bad-306">Evite atribuições de base/derivada completamente no servidor se você quiser evitar lidar com esse problema no cliente.</span><span class="sxs-lookup"><span data-stu-id="22bad-306">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>  
  
-   <span data-ttu-id="22bad-307">Ao usar o <xref:System.Runtime.Serialization.DataContractSerializer> tipo, o `alwaysEmitTypeInformation` parâmetro de construtor permite que você escolha entre os dois modos anteriores, com o padrão que está sendo "`false`" (somente emitir dicas de tipo quando necessário).</span><span class="sxs-lookup"><span data-stu-id="22bad-307">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>  
  
#### <a name="duplicate-data-member-names"></a><span data-ttu-id="22bad-308">Nomes de membro de dados duplicados</span><span class="sxs-lookup"><span data-stu-id="22bad-308">Duplicate Data Member Names</span></span>  
 <span data-ttu-id="22bad-309">Informações de tipo derivado está presentes no mesmo objeto JSON junto com informações de tipo base e podem ocorrer em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="22bad-309">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="22bad-310">Por exemplo, `Shape` pode ser representada da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="22bad-310">For example, `Shape` may be represented as follows.</span></span>  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 <span data-ttu-id="22bad-311">Enquanto o círculo pode ser representado como segue.</span><span class="sxs-lookup"><span data-stu-id="22bad-311">Whereas Circle may be represented as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 <span data-ttu-id="22bad-312">Se a base de `Shape` tipo contido também um membro de dados chamado "`radius`", isso leva a uma colisão em ambos os serialização (como objetos JSON não podem ter nomes de chave de repetição) e de desserialização (porque não está claro se "radius" refere-se ao `Shape.radius` ou `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="22bad-312">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="22bad-313">Portanto, embora o conceito de "ocultação de propriedade" (membros de dados de mesmo nome na base e classes derivadas) geralmente não é recomendado em classes de contrato de dados, na verdade é proibido no caso de JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-313">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="22bad-314">Tipos de IXmlSerializable e polimorfismo</span><span class="sxs-lookup"><span data-stu-id="22bad-314">Polymorphism and IXmlSerializable Types</span></span>  
 <span data-ttu-id="22bad-315"><xref:System.Xml.Serialization.IXmlSerializable> tipos podem ser polimorficamente atribuídos ao outro como de costume como requisitos de tipos conhecidos são atendidos, de acordo com a regras de contrato de dados normal.</span><span class="sxs-lookup"><span data-stu-id="22bad-315"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="22bad-316">No entanto, serializar um <xref:System.Xml.Serialization.IXmlSerializable> digite no lugar de <xref:System.Object> resulta na perda de informações de tipo, como o resultado é uma cadeia de caracteres JSON.</span><span class="sxs-lookup"><span data-stu-id="22bad-316">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>  
  
#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="22bad-317">Polimorfismo e determinados tipos de Interface</span><span class="sxs-lookup"><span data-stu-id="22bad-317">Polymorphism and Certain Interface Types</span></span>  
 <span data-ttu-id="22bad-318">É proibido para serializar um tipo de coleção ou um tipo que implementa <xref:System.Xml.Serialization.IXmlSerializable> onde um tipo de coleção não não é <xref:System.Xml.Serialization.IXmlSerializable> (exceto <xref:System.Object>) é esperado.</span><span class="sxs-lookup"><span data-stu-id="22bad-318">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="22bad-319">Por exemplo, uma interface personalizada chamada `IMyInterface` e um tipo `MyType` que implementam ambos <xref:System.Collections.Generic.IEnumerable%601> do tipo `int` e `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="22bad-319">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="22bad-320">É proibido retornar `MyType` de uma operação cujo tipo de retorno é `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="22bad-320">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="22bad-321">Isso ocorre porque `MyType` devem ser serializadas como uma matriz JSON e requer uma dica de tipo e como indicado antes de você não pode incluir uma dica de tipo com matrizes, apenas com tipos complexos.</span><span class="sxs-lookup"><span data-stu-id="22bad-321">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>  
  
#### <a name="known-types-and-configuration"></a><span data-ttu-id="22bad-322">Configuração e tipos conhecidos</span><span class="sxs-lookup"><span data-stu-id="22bad-322">Known Types and Configuration</span></span>  
 <span data-ttu-id="22bad-323">Todos os mecanismos de tipo conhecido usados pelo <xref:System.Runtime.Serialization.DataContractSerializer> também têm suporte da mesma forma, o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="22bad-323">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="22bad-324">Ambos os serializadores ler o mesmo elemento de configuração, [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) na [ \<Serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), para descobrir os tipos conhecidos adicionados por meio de um arquivo de configuração.</span><span class="sxs-lookup"><span data-stu-id="22bad-324">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>  
  
#### <a name="collections-assigned-to-object"></a><span data-ttu-id="22bad-325">Atribuído a um objeto de coleções</span><span class="sxs-lookup"><span data-stu-id="22bad-325">Collections Assigned to Object</span></span>  
 <span data-ttu-id="22bad-326">Coleções atribuídas ao objeto são serializadas como se fossem coleções que implementam <xref:System.Collections.Generic.IEnumerable%601>: uma matriz JSON com cada entrada que tem uma dica de tipo, se for um tipo complexo.</span><span class="sxs-lookup"><span data-stu-id="22bad-326">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="22bad-327">Por exemplo, um <xref:System.Collections.Generic.List%601> do tipo `Shape` atribuído a <xref:System.Object> semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="22bad-327">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 <span data-ttu-id="22bad-328">Quando desserializado de volta para <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="22bad-328">When deserialized back into <xref:System.Object>:</span></span>  
  
-   <span data-ttu-id="22bad-329">`Shape` deve estar na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="22bad-329">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="22bad-330">Tendo <xref:System.Collections.Generic.List%601> do tipo `Shape` em tipos conhecidos não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="22bad-330">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="22bad-331">Observe que você não precisa adicionar `Shape` para tipos conhecidos na serialização nesse caso - isso é feito automaticamente.</span><span class="sxs-lookup"><span data-stu-id="22bad-331">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>  
  
-   <span data-ttu-id="22bad-332">A coleção é desserializada como um <xref:System.Array> do tipo <xref:System.Object> que contém `Shape` instâncias.</span><span class="sxs-lookup"><span data-stu-id="22bad-332">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>  
  
#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="22bad-333">Coleções derivadas atribuídas às coleções de Base</span><span class="sxs-lookup"><span data-stu-id="22bad-333">Derived Collections Assigned to Base Collections</span></span>  
 <span data-ttu-id="22bad-334">Quando uma coleção derivada é atribuída a uma coleção de base, a coleção geralmente é serializada como se fosse uma coleção do tipo base.</span><span class="sxs-lookup"><span data-stu-id="22bad-334">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="22bad-335">No entanto, se o tipo de item da coleção derivada não pode ser atribuído ao tipo de item da coleção de base, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="22bad-335">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>  
  
#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="22bad-336">Dicas de tipo e dicionários</span><span class="sxs-lookup"><span data-stu-id="22bad-336">Type Hints and Dictionaries</span></span>  
 <span data-ttu-id="22bad-337">Quando um dicionário é atribuído a um <xref:System.Object>, cada entrada de chave e valor no dicionário é tratada como se ele foi atribuído à <xref:System.Object> e obtém uma dica de tipo.</span><span class="sxs-lookup"><span data-stu-id="22bad-337">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>  
  
 <span data-ttu-id="22bad-338">Ao serializar os tipos de dicionário, o objeto JSON que contém os membros de "Chave" e "Value" não é afetado pelo `alwaysEmitTypeInformation` configuração e contém somente uma dica de tipo quando as regras de coleta anterior.</span><span class="sxs-lookup"><span data-stu-id="22bad-338">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>  
  
### <a name="valid-json-key-names"></a><span data-ttu-id="22bad-339">Nomes de chave JSON válido</span><span class="sxs-lookup"><span data-stu-id="22bad-339">Valid JSON Key Names</span></span>  
 <span data-ttu-id="22bad-340">Os nomes de chave do serializador codifica XML que não são nomes válidos de XML.</span><span class="sxs-lookup"><span data-stu-id="22bad-340">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="22bad-341">Por exemplo, um membro de dados com o nome de "123" teria um nome codificado como "_x0031\__x0032\__x0033\_" porque "123" é um nome de elemento XML inválido (começa com um dígito).</span><span class="sxs-lookup"><span data-stu-id="22bad-341">For example, a data member with the name of "123" would have an encoded name such as "_x0031\__x0032\__x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="22bad-342">Pode surgir uma situação semelhante com alguns conjuntos de caracteres internacionais não válidos em nomes XML.</span><span class="sxs-lookup"><span data-stu-id="22bad-342">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="22bad-343">Para obter uma explicação do efeito de XML no processamento de JSON, consulte [mapeamento entre JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="22bad-343">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="22bad-344">Consulte também</span><span class="sxs-lookup"><span data-stu-id="22bad-344">See Also</span></span>  
 [<span data-ttu-id="22bad-345">Suporte para JSON e outros formatos de transferência de dados</span><span class="sxs-lookup"><span data-stu-id="22bad-345">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
