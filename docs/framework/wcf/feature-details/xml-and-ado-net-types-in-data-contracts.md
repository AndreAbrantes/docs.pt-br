---
title: Tipos de XML e ADO.NET em contratos de dados
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: ae21174d19ad69f87165427cf5a0bfd29ac872db
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33509086"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="fd2c4-102">Tipos de XML e ADO.NET em contratos de dados</span><span class="sxs-lookup"><span data-stu-id="fd2c4-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="fd2c4-103">O modelo de contrato de dados do Windows Communication Foundation (WCF) oferece suporte a determinados tipos que representam o XML diretamente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="fd2c4-104">Quando esses tipos são serializados em XML, o serializador grava o conteúdo XML desses tipos sem nenhum processamento adicional.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="fd2c4-105">Tipos com suporte são <xref:System.Xml.XmlElement>, matrizes de <xref:System.Xml.XmlNode> (mas não o `XmlNode` digite próprio), bem como tipos que implementam <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="fd2c4-106">O <xref:System.Data.DataSet> e <xref:System.Data.DataTable> tipo, bem como conjuntos de dados tipados, geralmente são usados em programação de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="fd2c4-107">Esses tipos implementam o `IXmlSerializable` interface e são, portanto, pode ser serializado nos dados de modelo de contrato.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="fd2c4-108">Algumas considerações especiais para esses tipos são listadas no final deste tópico.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="fd2c4-109">Tipos XML</span><span class="sxs-lookup"><span data-stu-id="fd2c4-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="fd2c4-110">Elemento XML</span><span class="sxs-lookup"><span data-stu-id="fd2c4-110">Xml Element</span></span>  
 <span data-ttu-id="fd2c4-111">O `XmlElement` tipo é serializado usando seu conteúdo XML.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="fd2c4-112">Por exemplo, usando o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="fd2c4-113">Isso é serializado como XML da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="fd2c4-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="fd2c4-114">Observe que um elemento de membro de dados de wrapper `<myDataMember>` ainda está presente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="fd2c4-115">Não há nenhuma maneira de remover este elemento no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="fd2c4-116">Os serializadores que lidar com esse modelo (o <xref:System.Runtime.Serialization.DataContractSerializer> e <xref:System.Runtime.Serialization.NetDataContractSerializer>) pode emitir atributos especiais para este elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="fd2c4-117">Esses atributos incluem o atributo "nulo" instância do esquema XML padrão (permitindo que o `XmlElement` ser `null`) e o atributo "type" (permitindo que `XmlElement` a ser usado polimorficamente).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="fd2c4-118">Além disso, os seguintes atributos XML são específicos para o WCF: "Id", "Ref", "Tipo" e "Assembly".</span><span class="sxs-lookup"><span data-stu-id="fd2c4-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="fd2c4-119">Esses atributos podem ser emitidos para suporte ao uso de `XmlElement` com o modo de preservação de gráfico de objeto habilitado, ou com o <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="fd2c4-120">(Para obter mais informações sobre o modo de preservação de gráfico de objeto, consulte [serialização e desserialização](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="fd2c4-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="fd2c4-121">Matrizes ou coleções de `XmlElement` são permitidos e são tratadas como qualquer outra matriz ou coleção.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="fd2c4-122">Ou seja, há um elemento wrapper para toda a coleção e um elemento wrapper separado (semelhante a `<myDataMember>` no exemplo anterior) para cada `XmlElement` na matriz.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="fd2c4-123">Na desserialização, um `XmlElement` é criado pelo desserializador do XML de entrada.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="fd2c4-124">Um pai válido <xref:System.Xml.XmlDocument> é fornecido pelo desserializador.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="fd2c4-125">Certifique-se de que o fragmento XML que é desserializado para uma `XmlElement` define todos os prefixos que ele usa e não depende de quaisquer definições de prefixo de elementos de ancestrais.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="fd2c4-126">Essa é uma preocupação apenas ao usar o `DataContractSerializer` para acessar o XML de outro (não -`DataContractSerializer`) fonte.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="fd2c4-127">Quando usado com o `DataContractSerializer`, o `XmlElement` pode ser atribuída polimorficamente, mas somente um membro de dados do tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="fd2c4-128">Mesmo que ele implementa <xref:System.Collections.IEnumerable>, uma `XmlElement` não pode ser usado como um tipo de coleção e não pode ser atribuído a um <xref:System.Collections.IEnumerable> membro de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="fd2c4-129">Assim como acontece com todas as atribuições de polimórfica o `DataContractSerializer` emite o nome do contrato de dados no XML resultante – nesse caso, é "XmlElement" no "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="fd2c4-130">Com o `NetDataContractSerializer`, qualquer atribuição polimórfica válida de `XmlElement` (para `Object` ou `IEnumerable`) é suportado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="fd2c4-131">Não tente usar um dos serializadores com tipos derivados de `XmlElement`, se eles recebem polimorficamente ou não.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="fd2c4-132">Matriz de XmlNode</span><span class="sxs-lookup"><span data-stu-id="fd2c4-132">Array of XmlNode</span></span>  
 <span data-ttu-id="fd2c4-133">Usando matrizes de <xref:System.Xml.XmlNode> é muito semelhante ao uso de `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="fd2c4-134">Usando matrizes de `XmlNode` oferece maior flexibilidade do que usando `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="fd2c4-135">Você pode criar vários elementos dentro do membro de dados no elemento de encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="fd2c4-136">Você também pode inserir o conteúdo que não sejam elementos dentro do membro de dados quebra automática de elemento, como comentários XML.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="fd2c4-137">Por fim, você pode colocar atributos na quebra automática de elemento do membro de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="fd2c4-138">Tudo isso pode ser obtido preenchendo a matriz de `XmlNode` com específico classes derivadas de `XmlNode` como <xref:System.Xml.XmlAttribute>, `XmlElement` ou <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="fd2c4-139">Por exemplo, usando o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="fd2c4-140">Quando serializado, o XML resultante é semelhante ao seguinte código.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="fd2c4-141">Observe que o elemento de wrapper de membro de dados `<myDataMember>` contém dois elementos, um comentário e um atributo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="fd2c4-142">Estes são os quatro `XmlNode` instâncias que foram serializadas.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="fd2c4-143">Uma matriz de `XmlNode` que resulta em um XML inválido não pode ser serializada.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="fd2c4-144">Por exemplo, uma matriz de dois `XmlNode` instâncias em que a primeira é uma `XmlElement` e a segunda é um <xref:System.Xml.XmlAttribute> é inválido, porque essa sequência não corresponde a qualquer instância XML válida (há um local para anexar o atributo para).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="fd2c4-145">Na desserialização de uma matriz de `XmlNode`, nós são criados e populados com informações de entrada XML.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="fd2c4-146">Um pai válido <xref:System.Xml.XmlDocument> é fornecido pelo desserializador.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="fd2c4-147">Todos os nós são desserializados, incluindo os atributos no elemento wrapper de membro de dados, mas excluir os atributos incluídos pelos serializadores WCF (como os atributos usados para indicar a atribuição polimórfica).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="fd2c4-148">A limitação sobre como definir todos os prefixos de namespace no fragmento XML se aplica a desserialização de matrizes de `XmlNode` como é feito para desserializar `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="fd2c4-149">Ao usar os serializadores com preservação de gráfico de objeto ativada, igualdade de objetos é preservada somente no nível de `XmlNode` matrizes, individuais não `XmlNode` instâncias.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="fd2c4-150">Não tente serializar uma matriz de `XmlNode` onde um ou mais de nós está definida como `null`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="fd2c4-151">É permitido para o membro de matriz inteira seja `null`, mas não para qualquer pessoa `XmlNode` contidos na matriz.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="fd2c4-152">Se o membro de matriz inteira for nulo, o elemento de membro de dados de wrapper contém um atributo especial que indica que ele é nulo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="fd2c4-153">Na desserialização, o membro de matriz inteira também é nulo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="fd2c4-154">Apenas matrizes regulares de `XmlNode` são tratados especialmente pelo serializador.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="fd2c4-155">Membros de dados declarado como outros tipos de coleção que contêm `XmlNode`, ou membros de dados declarados como matrizes de tipos derivam de `XmlNode`, não são tratados especialmente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="fd2c4-156">Assim, eles normalmente não são serializáveis, a menos que eles também atenderem a um dos outros critérios de serialização.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="fd2c4-157">Matrizes ou coleções de matrizes de `XmlNode` são permitidos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="fd2c4-158">Há um elemento wrapper para toda a coleção e um elemento wrapper separado (semelhante a `<myDataMember>` no exemplo anterior) para cada matriz de `XmlNode` na matriz externa ou coleção.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="fd2c4-159">Preenchendo um membro de dados do tipo <xref:System.Array> de `Object` ou `Array` de `IEnumerable` com `XmlNode` instâncias não resulta no membro de dados que está sendo tratado como um `Array` de `XmlNode` instâncias.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="fd2c4-160">Cada membro da matriz é serializado separadamente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="fd2c4-161">Quando usado com o `DataContractSerializer`, matrizes de `XmlNode` podem ser atribuídos polimorficamente, mas apenas a um membro de dados do tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="fd2c4-162">Mesmo que ele implementa `IEnumerable`, uma matriz de `XmlNode` não pode ser usado como um tipo de coleção e ser atribuídos a um `IEnumerable` membro de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="fd2c4-163">Assim como acontece com todas as atribuições de polimórfica o `DataContractSerializer` emite o nome do contrato de dados no XML resultante – nesse caso, é "ArrayOfXmlNode" no "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="fd2c4-164">Quando usado com o `NetDataContractSerializer`, qualquer atribuição válida de um `XmlNode` suporte para a matriz.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="fd2c4-165">Considerações de esquema</span><span class="sxs-lookup"><span data-stu-id="fd2c4-165">Schema Considerations</span></span>  
 <span data-ttu-id="fd2c4-166">Para obter detalhes sobre o mapeamento de esquema de tipos XML, consulte [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="fd2c4-167">Esta seção fornece um resumo dos pontos importantes.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="fd2c4-168">Um membro de dados do tipo `XmlElement` é mapeado para um elemento definido usando o seguinte tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="fd2c4-169">Um membro de dados de tipo de matriz de `XmlNode` é mapeado para um elemento definido usando o seguinte tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="fd2c4-170">Tipos que implementam a Interface IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="fd2c4-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="fd2c4-171">Tipos que implementam o `IXmlSerializable` interface têm suporte total a `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="fd2c4-172">O <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atributo sempre deve ser aplicado a esses tipos para controlar seu esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="fd2c4-173">Há três tipos de tipos que implementam `IXmlSerializable`: tipos que representam os tipos de conteúdo, arbitrários que representam um único elemento e herdado <xref:System.Data.DataSet> tipos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="fd2c4-174">Tipos de conteúdo usam um método de provedor de esquema especificado pelo `XmlSchemaProviderAttribute` atributo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="fd2c4-175">O método não retornar `null`e o <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> propriedade no atributo for deixada em seu valor padrão de `false`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="fd2c4-176">Este é o uso mais comum de `IXmlSerializable` tipos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="fd2c4-177">Tipos de elemento são usados quando um `IXmlSerializable` tipo deve controlar seu próprio nome de elemento raiz.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="fd2c4-178">Para marcar um tipo como um tipo de elemento, ou defina o <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> propriedade o <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atributo `true` ou retornar null do método do provedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="fd2c4-179">Ter um método de provedor de esquema é opcional para tipos de elemento – você pode especificar null em vez do nome do método no `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="fd2c4-180">No entanto, se `IsAny` é `true` e um método de provedor de esquema for especificado, o método deve retornar nulo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="fd2c4-181">Herdado <xref:System.Data.DataSet> tipos são `IXmlSerializable` tipos que não são marcados com o `XmlSchemaProviderAttribute` atributo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="fd2c4-182">Em vez disso, eles usam o <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> método para geração de esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="fd2c4-183">Esse padrão é usado para o `DataSet` tipo e seu conjunto de dados tipado deriva de uma classe em versões anteriores do .NET Framework, mas agora está obsoletos e tem suporte apenas por motivos de herança.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="fd2c4-184">Não contam com esse padrão e sempre se aplicam a `XmlSchemaProviderAttribute` para sua `IXmlSerializable` tipos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="fd2c4-185">Tipos de conteúdo IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="fd2c4-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="fd2c4-186">Ao serializar um membro de dados de um tipo que implementa `IXmlSerializable` e é um tipo de conteúdo como definido anteriormente, o serializador grava o elemento para o controle de membro e passagem de dados para o <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="fd2c4-187">O <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementação pode gravar qualquer XML, incluindo a adição de atributos para o elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="fd2c4-188">Depois de `WriteXml` é feito, o serializador fecha o elemento.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="fd2c4-189">Durante a desserialização de um membro de dados de um tipo que implementa `IXmlSerializable` e é um tipo de conteúdo conforme definido anteriormente, as posições de desserializador o leitor de XML no elemento wrapper para o membro de dados e passar o controle para o <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="fd2c4-190">O método deve ler todo o elemento, incluindo as marcas de início e término.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="fd2c4-191">Certifique-se de sua `ReadXml` código trata do caso em que o elemento está vazio.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="fd2c4-192">Além disso, sua `ReadXml` implementação não deve depender o elemento que está sendo nomeado de uma maneira específica.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="fd2c4-193">O nome é escolhido pelo serializador pode variar.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="fd2c4-194">É permitido atribuir `IXmlSerializable` tipos de conteúdo polimorficamente, por exemplo, para dados de membros de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="fd2c4-195">Também é permitido para as instâncias de tipo pode ser nulo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="fd2c4-196">Por fim, é possível usar `IXmlSerializable` tipos com preservação de gráfico de objeto habilitado e o <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="fd2c4-197">Todos esses recursos exigem o serializador WCF anexar determinados atributos no elemento wrapper ("nulo" e "type" no namespace da instância do esquema XML e "Id", "Ref", "Tipo" e "Assembly" em um namespace específico do WCF).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="fd2c4-198">Atributos a serem ignoradas ao implementar ReadXml</span><span class="sxs-lookup"><span data-stu-id="fd2c4-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="fd2c4-199">Antes de passar o controle para o `ReadXml` código, o desserializador examina o elemento XML, detecta desses atributos especiais de XML e age sobre eles.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="fd2c4-200">Por exemplo, se for "nulo" `true`, um valor nulo é desserializado e `ReadXml` não for chamado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="fd2c4-201">Se polimorfismo for detectado, o conteúdo do elemento desserializado como se fosse um tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="fd2c4-202">A implementação do tipo polimorficamente atribuído de `ReadXml` é chamado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="fd2c4-203">Em qualquer caso, um `ReadXml` implementação deve ignorar desses atributos especiais porque eles são tratados pelo desserializador.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="fd2c4-204">Considerações sobre o esquema para tipos de conteúdo IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="fd2c4-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="fd2c4-205">Ao exportar o esquema de um `IXmlSerializable` tipo de conteúdo, o método de provedor de esquema é chamado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="fd2c4-206">Um <xref:System.Xml.Schema.XmlSchemaSet> é passado para o método de provedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="fd2c4-207">O método pode adicionar qualquer esquema válido para o conjunto de esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="fd2c4-208">O conjunto de esquema contém o esquema que já é conhecido no momento quando ocorre a exportação de esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="fd2c4-209">Quando o método de provedor de esquema deve adicionar um item ao conjunto de esquema, ele deve determinar se um <xref:System.Xml.Schema.XmlSchema> com o namespace apropriado já existe no conjunto.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="fd2c4-210">Em caso afirmativo, o método de provedor de esquema deve adicionar o novo item ao existente `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="fd2c4-211">Caso contrário, ele deve criar um novo `XmlSchema` instância.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="fd2c4-212">Isso é importante se matrizes de `IXmlSerializable` tipos estão sendo usados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="fd2c4-213">Por exemplo, se você tiver um `IXmlSerializable` tipo que é exportado como tipo "A" no namespace "B", é possível que, no momento em que o método de provedor de esquema é chamado o esquema definido já contém o esquema para "B" manter o tipo de "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="fd2c4-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="fd2c4-214">Além de adicionar tipos para o <xref:System.Xml.Schema.XmlSchemaSet>, o método de provedor de esquema para tipos de conteúdo deve retornar um valor não nulo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="fd2c4-215">Ele pode retornar um <xref:System.Xml.XmlQualifiedName> que especifica o nome do tipo de esquema a ser usado para o determinado `IXmlSerializable` tipo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="fd2c4-216">Esse nome qualificado também serve como os dados de nome e namespace para o tipo de contrato.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="fd2c4-217">Ele tem permissão para retornar um tipo que não existe no esquema definido imediatamente quando o método de provedor de esquema retorna.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="fd2c4-218">No entanto, é esperado que no momento em todos os relacionados tipos são exportados (o <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> método é chamado para todos os tipos relevantes no <xref:System.Runtime.Serialization.XsdDataContractExporter> e <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> propriedade for acessada), o tipo existe no conjunto de esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="fd2c4-219">Acessando o `Schemas` propriedade antes de todos os relevantes `Export` chamadas feitas pode resultar em um <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="fd2c4-220">Para obter mais informações sobre o processo de exportação, consulte [exportando esquemas de Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-220">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="fd2c4-221">O método de provedor de esquema também pode retornar o <xref:System.Xml.Schema.XmlSchemaType> para usar.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="fd2c4-222">O tipo pode ou não ser anônimo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="fd2c4-223">Se for anônima, o esquema para o `IXmlSerializable` tipo é exportado como um tipo anônimo sempre o `IXmlSerializable` tipo é usado como um membro de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="fd2c4-224">O `IXmlSerializable` tipo ainda tem um nome de contrato de dados e um namespace.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="fd2c4-225">(Isso é determinado conforme descrito em [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md) exceto que o <xref:System.Runtime.Serialization.DataContractAttribute> atributo não pode ser usado para personalizar o nome.) Se não for anônimo, ele deve ser um dos tipos de `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="fd2c4-226">Nesse caso é equivalente ao retornar o `XmlQualifiedName` do tipo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="fd2c4-227">Além disso, uma declaração de elemento global é exportada para o tipo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="fd2c4-228">Se o tipo não tem o <xref:System.Xml.Serialization.XmlRootAttribute> atributo aplicado a ele, o elemento tem o mesmo nome e namespace do contrato de dados e sua propriedade "anulável" é true.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="fd2c4-229">A única exceção a isso é o namespace do esquema ("http://www.w3.org/2001/XMLSchema") – se for de contrato de dados do tipo neste namespace, o elemento global correspondente está no namespace em branco porque é proibido adicionar novos elementos para o namespace do esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="fd2c4-230">Se o tipo tiver o `XmlRootAttribute` atributo aplicado a ele, a declaração do elemento global é exportado usando o seguinte: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> e <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="fd2c4-231">Os padrões com `XmlRootAttribute` aplicadas são o nome do contrato de dados, um namespace em branco e "anulável" sendo verdadeiro.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="fd2c4-232">As mesmas regras de declaração de elemento global se aplicam a tipos de conjunto de dados herdados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="fd2c4-233">Observe que o `XmlRootAttribute` não é possível substituir declarações de elemento global adicionadas por meio de código personalizado, adicionado para o `XmlSchemaSet` usando o método de provedor de esquema ou por meio `GetSchema` para tipos de conjunto de dados herdados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="fd2c4-234">Tipos de elemento IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="fd2c4-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="fd2c4-235">`IXmlSerializable` tipos de elemento tem o `IsAny` propriedade definida como `true` ou ter seu método de provedor de esquema retornar `null`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="fd2c4-236">Serialização e desserialização de um tipo de elemento é muito semelhante a serialização e desserialização de um tipo de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="fd2c4-237">No entanto, há algumas diferenças importantes:</span><span class="sxs-lookup"><span data-stu-id="fd2c4-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="fd2c4-238">O `WriteXml` implementação deve gravar exatamente um elemento (o que naturalmente pode conter vários elementos filho).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="fd2c4-239">Ele não deve ser gravar os atributos fora desse elemento único, vários elementos irmãos ou conteúdo misto.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="fd2c4-240">O elemento pode estar vazio.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="fd2c4-241">O `ReadXml` implementação não deve ler o elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="fd2c4-242">É esperado ao ler um elemento que `WriteXml` produz.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="fd2c4-243">Ao serializar um tipo de elemento regularmente (por exemplo, como um membro de dados em um contrato de dados), o serializador gera um elemento wrapper antes de chamar `WriteXml`, assim como acontece com os tipos de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="fd2c4-244">No entanto, ao serializar um tipo de elemento no nível superior, o serializador não normalmente de saída de um elemento wrapper em todos os ao redor do elemento que `WriteXml` grava, a menos que um nome de raiz e o namespace foram especificados explicitamente ao construir o serializador no `DataContractSerializer` ou `NetDataContractSerializer` construtores.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="fd2c4-245">Para obter mais informações, consulte [serialização e desserialização](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-245">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="fd2c4-246">Ao serializar um tipo de elemento no nível superior, sem especificar o nome raiz e o namespace em tempo de construção, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essencialmente não faz nada e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> chamadas `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="fd2c4-247">Nesse modo, o objeto que está sendo serializado não pode ser nulo e não pode ser atribuído polimorficamente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="fd2c4-248">Além disso, preservação de gráfico de objeto não pode ser habilitado e o `NetDataContractSerializer` não pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="fd2c4-249">Durante a desserialização de um tipo de elemento no nível superior, sem especificar o nome raiz e o namespace em tempo de construção, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> retorna `true` se conseguir encontrar o início de qualquer elemento.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="fd2c4-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> com o `verifyObjectName` parâmetro definido como `true` se comporta da mesma maneira como `IsStartObject` antes de realmente ler o objeto.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="fd2c4-251">`ReadObject` em seguida, passa o controle para `ReadXml` método.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="fd2c4-252">O esquema exportado para tipos de elementos é o mesmo que para o `XmlElement` digite conforme descrito em uma seção anterior, exceto que o método de provedor de esquema pode adicionar qualquer esquema adicional para o <xref:System.Xml.Schema.XmlSchemaSet> assim como acontece com os tipos de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="fd2c4-253">Usando o `XmlRootAttribute` atributo com tipos de elemento não é permitido e declarações de elemento global nunca são emitidas para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="fd2c4-254">Diferenças de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="fd2c4-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="fd2c4-255">O `IXmlSerializable` interface e o `XmlSchemaProviderAttribute` e `XmlRootAttribute` atributos também são entendidos pelo <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="fd2c4-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="fd2c4-256">No entanto, há algumas diferenças na maneira como elas são tratadas no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="fd2c4-257">As diferenças importantes estão resumidas a seguir:</span><span class="sxs-lookup"><span data-stu-id="fd2c4-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="fd2c4-258">O método de provedor de esquema deve ser público para ser usado no `XmlSerializer`, mas não precisa ser público para ser usado no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="fd2c4-259">O método de provedor de esquema é chamado quando `IsAny` for verdadeira no modelo de contrato de dados, mas não com o `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="fd2c4-260">Quando o `XmlRootAttribute` atributo não estiver presente para conteúdo, ou tipos de conjunto de dados herdados, o `XmlSerializer` exporta uma declaração de elemento global no namespace em branco.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="fd2c4-261">No modelo de contrato de dados, o namespace usado normalmente é o namespace de contrato de dados conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="fd2c4-262">Lembre-se dessas diferenças ao criar tipos que são usados com ambas as tecnologias de serialização.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="fd2c4-263">Importando esquema IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="fd2c4-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="fd2c4-264">Ao importar um esquema gerado a partir de `IXmlSerializable` tipos, há algumas possibilidades:</span><span class="sxs-lookup"><span data-stu-id="fd2c4-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="fd2c4-265">O esquema gerado pode ser um esquema de contrato de dados válido, conforme descrito em [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="fd2c4-266">Nesse caso, o esquema pode ser importado como de costume e tipos de contrato de dados regulares são gerados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="fd2c4-267">O esquema gerado não pode ser um esquema de contrato de dados válido.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="fd2c4-268">Por exemplo, o método de provedor de esquema pode gerar o esquema que envolve os atributos XML que não têm suporte no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="fd2c4-269">Nesse caso, você pode importar o esquema como `IXmlSerializable` tipos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="fd2c4-270">Este modo de importação não é ativado por padrão, mas podem facilmente ser habilitado – por exemplo, com o `/importXmlTypes` opção de linha de comando para o [Ferramenta Utilitária de metadados ServiceModel (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="fd2c4-271">Isso é descrito detalhadamente o [Importando esquema para gerar Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="fd2c4-272">Observe que você deve trabalhar diretamente com o XML para suas instâncias de tipo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="fd2c4-273">Você também pode considerar o uso de uma tecnologia de serialização que dá suporte a uma maior variedade de esquema – Consulte o tópico sobre como usar o `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="fd2c4-274">Talvez você queira reutilizar existente `IXmlSerializable` tipos no proxy em vez de gerar novos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="fd2c4-275">Nesse caso, o recurso de tipos referenciados descrito no esquema de importação para o tópico gerar tipos pode ser usado para indicar o tipo para reutilização.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="fd2c4-276">Isso corresponde ao usar o `/reference` alternar svcutil.exe, que especifica o assembly que contém os tipos de reutilizar.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="fd2c4-277">Que representa o XML arbitrário em contratos de dados</span><span class="sxs-lookup"><span data-stu-id="fd2c4-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="fd2c4-278">O `XmlElement`, matriz de `XmlNode` e `IXmlSerializable` tipos permitem que você inserir XML arbitrário no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="fd2c4-279">O `DataContractSerializer` e `NetDataContractSerializer` passar esse XML conteúdo para o gravador de XML em uso, sem interferir no processo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="fd2c4-280">No entanto, os gravadores XML podem impor certas restrições sobre o XML que gravam.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="fd2c4-281">Especificamente, aqui estão alguns exemplos importantes:</span><span class="sxs-lookup"><span data-stu-id="fd2c4-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="fd2c4-282">Os gravadores XML geralmente não permitem uma declaração de documento XML (por exemplo, \<? versão xml ='1.0 '? >) durante a escrita de outro documento.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="fd2c4-283">Você não pode levar a um documento XML completo e serializá-lo como um `Array` de `XmlNode` membro de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="fd2c4-284">Para fazer isso, você precisa ou desfazer a declaração de documento ou usa seu próprio esquema de codificação para representá-lo.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="fd2c4-285">Todos os gravadores XML fornecidos com o WCF rejeitar as instruções de processamento de XML (\<?</span><span class="sxs-lookup"><span data-stu-id="fd2c4-285">All of the XML writers supplied with WCF reject XML processing instructions (\<?</span></span> <span data-ttu-id="fd2c4-286">…</span><span class="sxs-lookup"><span data-stu-id="fd2c4-286">…</span></span> <span data-ttu-id="fd2c4-287">? >) e definições de tipo de documento (\<!</span><span class="sxs-lookup"><span data-stu-id="fd2c4-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="fd2c4-288">…</span><span class="sxs-lookup"><span data-stu-id="fd2c4-288">…</span></span> <span data-ttu-id="fd2c4-289">>), pois eles não são permitidos em mensagens SOAP.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="fd2c4-290">Novamente, você pode usar seu próprio mecanismo de codificação para contornar essa restrição.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="fd2c4-291">Se você deve incluí-las em seu XML resultante, você pode escrever um codificador personalizado que usa os gravadores XML que dão suporte a eles.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="fd2c4-292">Ao implementar `WriteXml`, evite chamar <xref:System.Xml.XmlWriter.WriteRaw%2A> método no gravador de XML.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="fd2c4-293">WCF usa uma variedade de codificações XML (incluindo binário), é muito difícil ou impossível usar `WriteRaw` , de modo que o resultado é utilizável em qualquer codificação.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-293">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="fd2c4-294">Ao implementar `WriteXml`, evite usar o <xref:System.Xml.XmlWriter.WriteEntityRef%2A> e <xref:System.Xml.XmlWriter.WriteNmToken%2A> métodos que não têm suporte nos gravadores XML fornecidos com o WCF.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="fd2c4-295">Usando o conjunto de dados, o conjunto de dados tipado e DataTable</span><span class="sxs-lookup"><span data-stu-id="fd2c4-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="fd2c4-296">O uso desses tipos tem suporte total no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="fd2c4-297">Ao usar esses tipos, considere os seguintes pontos:</span><span class="sxs-lookup"><span data-stu-id="fd2c4-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="fd2c4-298">O esquema para esses tipos (especialmente <xref:System.Data.DataSet> e seu tipo de classes derivadas) pode não ser interoperável com algumas plataformas não WCF, ou pode resultar em baixo usabilidade quando usada com essas plataformas.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="fd2c4-299">Além disso, usando o `DataSet` tipo pode ter implicações de desempenho.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="fd2c4-300">Por fim, ele pode dificultar para você para a versão do seu aplicativo no futuro.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="fd2c4-301">Considere o uso de tipos de contrato de dados explicitamente definidas em vez de `DataSet` tipos em seus contratos.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="fd2c4-302">Ao importar `DataSet` ou `DataTable` esquema, é importante para esses tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="fd2c4-303">Com a ferramenta de linha de comando Svcutil.exe, isso pode ser feito, passando o nome do assembly System.Data.dll para o `/reference` alternar.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="fd2c4-304">Se estiver importando esquema de conjunto de dados tipado, você deve fazer referência a tipo do conjunto de dados tipado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="fd2c4-305">Com Svcutil.exe, passar o local do assembly do tipo do conjunto de dados para o `/reference` alternar.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="fd2c4-306">Para obter mais informações sobre tipos de referência, consulte o [Importando esquema para gerar Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="fd2c4-306">For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="fd2c4-307">Suporte para conjuntos de dados tipados no modelo de contrato de dados é limitado.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="fd2c4-308">DataSets tipados podem ser serializados e desserializados e pode exportar seu esquema.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="fd2c4-309">No entanto, o contrato de dados é de importação de esquema não é possível gerar novos digitados tipos de conjunto de dados do esquema, como ele somente pode reutilizar os existentes.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="fd2c4-310">Você pode apontar para um conjunto de dados tipado existente usando o `/r` alternar em Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="fd2c4-311">Se você tentar usar um Svcutil.exe sem o `/r` alternar de um serviço que usa um conjunto de dados tipado, um serializador alternativo (XmlSerializer) é selecionado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="fd2c4-312">Se você deve utilizar o DataContractSerializer e deve gerar conjuntos de dados do esquema, você pode usar o procedimento a seguir: gerar os tipos de conjunto de dados tipados (usando a ferramenta Xsd.exe com o `/d` alternar do serviço), os tipos de compilação e, em seguida, aponte para -los usando o `/r` alternar em Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="fd2c4-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fd2c4-313">Consulte também</span><span class="sxs-lookup"><span data-stu-id="fd2c4-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="fd2c4-314">Usando contratos de dados</span><span class="sxs-lookup"><span data-stu-id="fd2c4-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="fd2c4-315">Tipos com suporte pelo serializador de contrato de dados</span><span class="sxs-lookup"><span data-stu-id="fd2c4-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
