---
title: Usando a classe XmlSerializer
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
caps.latest.revision: "26"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 6d47add27fb1170ae1bc14b99342ea0222be3549
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/02/2017
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="8cdda-102">Usando a classe XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8cdda-102">Using the XmlSerializer Class</span></span>
[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="8cdda-103">pode usar duas tecnologias diferentes de serialização para transformar os dados em seu aplicativo em XML que é transmitido entre clientes e serviços, um processo chamado de serialização.</span><span class="sxs-lookup"><span data-stu-id="8cdda-103"> can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>  
  
## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="8cdda-104">DataContractSerializer como padrão</span><span class="sxs-lookup"><span data-stu-id="8cdda-104">DataContractSerializer as the Default</span></span>  
 <span data-ttu-id="8cdda-105">Por padrão [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] usa o <xref:System.Runtime.Serialization.DataContractSerializer> classe para serializar os tipos de dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-105">By default [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="8cdda-106">Este serializador suporta os seguintes tipos:</span><span class="sxs-lookup"><span data-stu-id="8cdda-106">This serializer supports the following types:</span></span>  
  
-   <span data-ttu-id="8cdda-107">Tipos primitivos (por exemplo, inteiros, cadeias de caracteres e bytes matrizes), bem como alguns tipos especiais, como <xref:System.Xml.XmlElement> e <xref:System.DateTime>, que é tratado como primitivos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>  
  
-   <span data-ttu-id="8cdda-108">Tipos de contrato de dados (tipos marcados com o <xref:System.Runtime.Serialization.DataContractAttribute> atributo).</span><span class="sxs-lookup"><span data-stu-id="8cdda-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>  
  
-   <span data-ttu-id="8cdda-109">Tipos marcados com o <xref:System.SerializableAttribute> atributo, que incluem os tipos que implementam o <xref:System.Runtime.Serialization.ISerializable> interface.</span><span class="sxs-lookup"><span data-stu-id="8cdda-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
-   <span data-ttu-id="8cdda-110">Tipos que implementam o <xref:System.Xml.Serialization.IXmlSerializable> interface.</span><span class="sxs-lookup"><span data-stu-id="8cdda-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="8cdda-111">Muitos comuns tipos de coleção, que incluem vários tipos de coleção genérica.</span><span class="sxs-lookup"><span data-stu-id="8cdda-111">Many common collection types, which include many generic collection types.</span></span>  
  
 <span data-ttu-id="8cdda-112">Muitos [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] tipos se enquadram em duas categorias a última e, portanto, são serializáveis.</span><span class="sxs-lookup"><span data-stu-id="8cdda-112">Many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="8cdda-113">Matrizes de tipos serializáveis também são serializáveis.</span><span class="sxs-lookup"><span data-stu-id="8cdda-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="8cdda-114">Para obter uma lista completa, consulte [especificando a transferência de dados em contratos de serviço](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-114">For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
 <span data-ttu-id="8cdda-115">O <xref:System.Runtime.Serialization.DataContractSerializer>, usado junto com dados de tipos de contrato, é a maneira recomendada para escrever novos [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serviços.</span><span class="sxs-lookup"><span data-stu-id="8cdda-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="8cdda-116">[Usando contratos de dados](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-116"> [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="8cdda-117">Quando usar a classe XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8cdda-117">When to Use the XmlSerializer Class</span></span>  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="8cdda-118">também oferece suporte a <xref:System.Xml.Serialization.XmlSerializer> classe.</span><span class="sxs-lookup"><span data-stu-id="8cdda-118"> also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="8cdda-119">O <xref:System.Xml.Serialization.XmlSerializer> a classe não é exclusivo para [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8cdda-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span> <span data-ttu-id="8cdda-120">É a serialização mesmo mecanismo que [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] uso de serviços da Web.</span><span class="sxs-lookup"><span data-stu-id="8cdda-120">It is the same serialization engine that [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services use.</span></span> <span data-ttu-id="8cdda-121">O <xref:System.Xml.Serialization.XmlSerializer> classe oferece suporte a um conjunto muito mais estreito de tipos que o <xref:System.Runtime.Serialization.DataContractSerializer> de classe, mas permite muito mais controle sobre o XML resultante e dá suporte a muito mais do que a linguagem de definição de esquema XML (XSD) padrão.</span><span class="sxs-lookup"><span data-stu-id="8cdda-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="8cdda-122">Ele também não requer qualquer atributos declarativos nos tipos serializáveis.</span><span class="sxs-lookup"><span data-stu-id="8cdda-122">It also does not require any declarative attributes on the serializable types.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="8cdda-123">o tópico de serialização de XML de [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] documentação.</span><span class="sxs-lookup"><span data-stu-id="8cdda-123"> the XML Serialization topic in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] documentation.</span></span> <span data-ttu-id="8cdda-124">O <xref:System.Xml.Serialization.XmlSerializer> classe não oferece suporte a tipos de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>  
  
 <span data-ttu-id="8cdda-125">Ao usar o Svcutil.exe ou o **adicionar referência de serviço** recurso no [!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)] para gerar o código do cliente para um serviço de terceiros ou para acessar um esquema de terceiros, um serializador adequado é selecionado automaticamente para você.</span><span class="sxs-lookup"><span data-stu-id="8cdda-125">When using Svcutil.exe or the **Add Service Reference** feature in [!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)] to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="8cdda-126">Se o esquema não é compatível com o <xref:System.Runtime.Serialization.DataContractSerializer>, o <xref:System.Xml.Serialization.XmlSerializer> está selecionado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>  
  
## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="8cdda-127">Alternar manualmente para o XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8cdda-127">Manually Switching to the XmlSerializer</span></span>  
 <span data-ttu-id="8cdda-128">Às vezes, talvez você precise alternar manualmente para o <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="8cdda-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="8cdda-129">Isso acontece, por exemplo, nos seguintes casos:</span><span class="sxs-lookup"><span data-stu-id="8cdda-129">This happens, for example, in the following cases:</span></span>  
  
-   <span data-ttu-id="8cdda-130">Ao migrar um aplicativo de [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] serviços Web [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], talvez você queira reutilizar os existentes, <xref:System.Xml.Serialization.XmlSerializer>-tipos de contrato de tipos compatíveis em vez de criar novos dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-130">When migrating an application from [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>  
  
-   <span data-ttu-id="8cdda-131">Quando um controle preciso sobre o XML que é exibido em mensagens é importante, mas um documento WSDL Web Services Description Language () não está disponível, por exemplo, ao criar um serviço com tipos que têm para conformidade com determinadas padronizados e esquema publicado que é não é compatível com o DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="8cdda-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>  
  
-   <span data-ttu-id="8cdda-132">Ao criar serviços que seguem o padrão de codificação SOAP herdado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>  
  
 <span data-ttu-id="8cdda-133">Esses e outros casos, você pode alternar manualmente para o <xref:System.Xml.Serialization.XmlSerializer> classe aplicando o `XmlSerializerFormatAttribute` atributo para seu serviço, conforme mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="8cdda-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
 [!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]  
  
## <a name="security-considerations"></a><span data-ttu-id="8cdda-134">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="8cdda-134">Security Considerations</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8cdda-135">É importante ter cuidado ao alternar os mecanismos de serialização.</span><span class="sxs-lookup"><span data-stu-id="8cdda-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="8cdda-136">O mesmo tipo pode serializar XML diferente dependendo do serializador está sendo usado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="8cdda-137">Se você usar acidentalmente o serializador errado, você poderá ser divulgação de informações do tipo que você não pretendia divulgar.</span><span class="sxs-lookup"><span data-stu-id="8cdda-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>  
  
 <span data-ttu-id="8cdda-138">Por exemplo, o <xref:System.Runtime.Serialization.DataContractSerializer> classe serializa somente os membros marcados com o <xref:System.Runtime.Serialization.DataMemberAttribute> ao serializar os tipos de contrato de dados de atributo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="8cdda-139">O <xref:System.Xml.Serialization.XmlSerializer> classe serializa nenhum membro público.</span><span class="sxs-lookup"><span data-stu-id="8cdda-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="8cdda-140">Consulte o tipo no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="8cdda-140">See the type in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
 [!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]  
  
 <span data-ttu-id="8cdda-141">Se o tipo inadvertidamente é usado em um contrato de serviço onde o <xref:System.Xml.Serialization.XmlSerializer> classe for selecionada, o `creditCardNumber` membro é serializado, que provavelmente não se destina.</span><span class="sxs-lookup"><span data-stu-id="8cdda-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>  
  
 <span data-ttu-id="8cdda-142">Embora o <xref:System.Runtime.Serialization.DataContractSerializer> classe é o padrão, você pode explicitamente selecioná-lo para seu serviço (embora isso nunca deve ser necessário), aplicando o <xref:System.ServiceModel.DataContractFormatAttribute> de atributo para o tipo de contrato de serviço.</span><span class="sxs-lookup"><span data-stu-id="8cdda-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>  
  
 <span data-ttu-id="8cdda-143">O serializador usado para o serviço é parte integrante do contrato e não pode ser alterado selecionando uma associação diferente ou alterar outras configurações.</span><span class="sxs-lookup"><span data-stu-id="8cdda-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>  
  
 <span data-ttu-id="8cdda-144">Aplicam outras considerações de segurança importantes para o <xref:System.Xml.Serialization.XmlSerializer> classe.</span><span class="sxs-lookup"><span data-stu-id="8cdda-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="8cdda-145">Primeiro, é altamente recomendável que qualquer [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] aplicativo que usa o <xref:System.Xml.Serialization.XmlSerializer> classe está assinada com uma chave que está protegida contra a divulgação de informações.</span><span class="sxs-lookup"><span data-stu-id="8cdda-145">First, it is strongly recommended that any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="8cdda-146">Essa recomendação se aplica quando um comutador manual para o <xref:System.Xml.Serialization.XmlSerializer> é executada e quando um comutador automática é executado (por Svcutil.exe, adicionar referência de serviço ou uma ferramenta semelhante).</span><span class="sxs-lookup"><span data-stu-id="8cdda-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="8cdda-147">Isso ocorre porque o <xref:System.Xml.Serialization.XmlSerializer> mecanismo de serialização suporta o carregamento de *gerados previamente assemblies de serialização* , desde que sejam assinados com a mesma chave que o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="8cdda-148">Um aplicativo não assinado é completamente protegido contra a possibilidade de um assembly mal-intencionado correspondente ao nome esperado do assembly de serialização gerado que está sendo colocado na pasta do aplicativo ou o cache de assembly global.</span><span class="sxs-lookup"><span data-stu-id="8cdda-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="8cdda-149">Obviamente, um invasor deve primeiro obter acesso de gravação a um desses dois locais para tentar esta ação.</span><span class="sxs-lookup"><span data-stu-id="8cdda-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>  
  
 <span data-ttu-id="8cdda-150">Outra ameaça que existe sempre que você usar <xref:System.Xml.Serialization.XmlSerializer> está relacionado ao acesso de gravação para a pasta temporária do sistema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="8cdda-151">O <xref:System.Xml.Serialization.XmlSerializer> mecanismo de serialização cria e usa temporário *assemblies de serialização* nessa pasta.</span><span class="sxs-lookup"><span data-stu-id="8cdda-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="8cdda-152">Você deve estar ciente de que qualquer processo com acesso de gravação para a pasta temporária pode substituir esses assemblies de serialização com um código mal-intencionado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>  
  
## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="8cdda-153">Regras de suporte de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8cdda-153">Rules for XmlSerializer support</span></span>  
 <span data-ttu-id="8cdda-154">Você não pode aplicar diretamente <xref:System.Xml.Serialization.XmlSerializer>-atributos compatíveis para parâmetros de operação do contrato ou valores de retorno.</span><span class="sxs-lookup"><span data-stu-id="8cdda-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="8cdda-155">No entanto, podem ser aplicadas a mensagens digitadas (partes de corpo de contrato de mensagem,) conforme mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="8cdda-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
 [!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="8cdda-156">Quando aplicado a membros de tipo de mensagem, esses atributos substituem propriedades que estão em conflito nos atributos de tipo de mensagem.</span><span class="sxs-lookup"><span data-stu-id="8cdda-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="8cdda-157">Por exemplo, no código a seguir, `ElementName` substitui `Name`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>  
  
 [!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
 [!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]  
  
 <span data-ttu-id="8cdda-158">O <xref:System.ServiceModel.MessageHeaderArrayAttribute> atributo não é suportado ao usar o <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="8cdda-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8cdda-159">Nesse caso, o <xref:System.Xml.Serialization.XmlSerializer> gera a seguinte exceção for lançada antes [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "não pode ter um elemento declarado no nível superior de um esquema `maxOccurs` > 1.</span><span class="sxs-lookup"><span data-stu-id="8cdda-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="8cdda-160">Forneça um elemento wrapper para mais usando `XmlArray` ou `XmlArrayItem` em vez de `XmlElementAttribute`, ou usando o estilo de parâmetro Wrapped. "</span><span class="sxs-lookup"><span data-stu-id="8cdda-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>  
>   
>  <span data-ttu-id="8cdda-161">Se você receber essa exceção, investigue se esta situação se aplica.</span><span class="sxs-lookup"><span data-stu-id="8cdda-161">If you receive such an exception, investigate whether this situation applies.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="8cdda-162">não oferece suporte a <xref:System.Xml.Serialization.SoapIncludeAttribute> e <xref:System.Xml.Serialization.XmlIncludeAttribute> atributos em contratos de mensagem e a operação de contratos; use o <xref:System.Runtime.Serialization.KnownTypeAttribute> atributo em vez disso.</span><span class="sxs-lookup"><span data-stu-id="8cdda-162"> does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>  
  
## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="8cdda-163">Tipos que implementam a Interface IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="8cdda-163">Types that Implement the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="8cdda-164">Tipos que implementam o `IXmlSerializable` interface têm suporte total a `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="8cdda-165">O <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atributo sempre deve ser aplicado a esses tipos para controlar seu esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="8cdda-166">Se a serialização de tipos polimórficos que você deve aplicar o <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> para o tipo para garantir que o tipo correto é serializado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>  
  
 <span data-ttu-id="8cdda-167">Há três tipos de tipos que implementam `IXmlSerializable`: tipos que representam os tipos de conteúdo, arbitrários que representam um único elemento e herdado <xref:System.Data.DataSet> tipos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="8cdda-168">Tipos de conteúdo usam um método de provedor de esquema especificado pelo `XmlSchemaProviderAttribute` atributo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="8cdda-169">O método não retornar `null` e <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> propriedade no atributo for deixada em seu valor padrão de `false`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="8cdda-170">Este é o uso mais comum de `IXmlSerializable` tipos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-170">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="8cdda-171">Tipos de elemento são usados quando um `IXmlSerializable` tipo deve controlar seu próprio nome de elemento raiz.</span><span class="sxs-lookup"><span data-stu-id="8cdda-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="8cdda-172">Para marcar um tipo como um tipo de elemento, ou defina o <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> propriedade o <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atributo `true` ou retornar `null` do método do provedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="8cdda-173">Ter um método de provedor de esquema é opcional para tipos de elemento – você pode especificar `null` em vez do nome do método no `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="8cdda-174">No entanto, se `IsAny` é `true` e um método de provedor de esquema for especificado, o método deve retornar `null`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>  
  
-   <span data-ttu-id="8cdda-175">Herdado <xref:System.Data.DataSet> tipos são `IXmlSerializable` tipos que não são marcados com o `XmlSchemaProviderAttribute` atributo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="8cdda-176">Em vez disso, eles usam o <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> método para geração de esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="8cdda-177">Esse padrão é usado para o `DataSet` tipo e seu conjunto de dados tipado deriva de uma classe em versões anteriores do .NET Framework, mas agora está obsoletos e tem suporte apenas por motivos de herança.</span><span class="sxs-lookup"><span data-stu-id="8cdda-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="8cdda-178">Não contam com esse padrão e sempre se aplicam a `XmlSchemaProviderAttribute` para sua `IXmlSerializable` tipos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="8cdda-179">Tipos de conteúdo IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="8cdda-179">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="8cdda-180">Ao serializar um membro de dados de um tipo que implementa `IXmlSerializable` e é um tipo de conteúdo, conforme definido anteriormente, o serializador grava o elemento para o membro de dados e passa o controle para o <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="8cdda-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="8cdda-181">O <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementação pode gravar qualquer XML, que inclui a adição de atributos para o elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="8cdda-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="8cdda-182">Depois de `WriteXml` é feito, o serializador fecha o elemento.</span><span class="sxs-lookup"><span data-stu-id="8cdda-182">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="8cdda-183">Durante a desserialização de um membro de dados de um tipo que implementa `IXmlSerializable` e é um tipo de conteúdo, conforme definido anteriormente, o desserializador posiciona o leitor de XML no elemento wrapper para o membro de dados e passa o controle para o <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="8cdda-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="8cdda-184">O método deve ler todo o elemento, incluindo as marcas de início e término.</span><span class="sxs-lookup"><span data-stu-id="8cdda-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="8cdda-185">Certifique-se de sua `ReadXml` código trata do caso em que o elemento está vazio.</span><span class="sxs-lookup"><span data-stu-id="8cdda-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="8cdda-186">Além disso, sua `ReadXml` implementação não deve depender o elemento que está sendo nomeado de uma maneira específica.</span><span class="sxs-lookup"><span data-stu-id="8cdda-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="8cdda-187">O nome é escolhido pelo serializador pode variar.</span><span class="sxs-lookup"><span data-stu-id="8cdda-187">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="8cdda-188">É permitido atribuir `IXmlSerializable` tipos de conteúdo polimorficamente, por exemplo, para dados de membros de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="8cdda-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="8cdda-189">Também é permitido para as instâncias de tipo pode ser nulo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="8cdda-190">Por fim, é possível usar `IXmlSerializable` tipos com preservação de gráfico de objeto habilitado e o <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="8cdda-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="8cdda-191">Todos esses recursos exigem o [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializador anexar determinados atributos no elemento wrapper ("nulo" e "type" no namespace da instância do esquema XML e "Id", "Ref", "Tipo" e "Assembly" em um [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-namespace específico).</span><span class="sxs-lookup"><span data-stu-id="8cdda-191">All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="8cdda-192">Atributos a serem ignoradas ao implementar ReadXml</span><span class="sxs-lookup"><span data-stu-id="8cdda-192">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="8cdda-193">Antes de passar o controle para o `ReadXml` código, o desserializador examina o elemento XML, detecta desses atributos especiais de XML e age sobre eles.</span><span class="sxs-lookup"><span data-stu-id="8cdda-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="8cdda-194">Por exemplo, se for "nulo" `true`, um valor nulo é desserializado e `ReadXml` não for chamado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="8cdda-195">Se polimorfismo for detectado, o conteúdo do elemento desserializado como se fosse um tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="8cdda-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="8cdda-196">A implementação do tipo polimorficamente atribuído de `ReadXml` é chamado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="8cdda-197">Em qualquer caso, um `ReadXml` implementação deve ignorar desses atributos especiais porque eles são tratados pelo desserializador.</span><span class="sxs-lookup"><span data-stu-id="8cdda-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="8cdda-198">Considerações sobre o esquema para tipos de conteúdo IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="8cdda-198">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="8cdda-199">Ao exportar o esquema e um `IXmlSerializable` tipo de conteúdo, o método de provedor de esquema é chamado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="8cdda-200">Um <xref:System.Xml.Schema.XmlSchemaSet> é passado para o método de provedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="8cdda-201">O método pode adicionar qualquer esquema válido para o conjunto de esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="8cdda-202">O conjunto de esquema contém o esquema que já é conhecido no momento quando ocorre a exportação de esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="8cdda-203">Quando o método de provedor de esquema deve adicionar um item ao conjunto de esquema, ele deve determinar se um <xref:System.Xml.Schema.XmlSchema> com o namespace apropriado já existe no conjunto.</span><span class="sxs-lookup"><span data-stu-id="8cdda-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="8cdda-204">Em caso afirmativo, o método de provedor de esquema deve adicionar o novo item ao existente `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="8cdda-205">Caso contrário, ele deve criar um novo `XmlSchema` instância.</span><span class="sxs-lookup"><span data-stu-id="8cdda-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="8cdda-206">Isso é importante se matrizes de `IXmlSerializable` tipos estão sendo usados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="8cdda-207">Por exemplo, se você tiver um `IXmlSerializable` tipo que é exportado como tipo "A" no namespace "B", é possível que, no momento em que o método de provedor de esquema é chamado o esquema definido já contém o esquema para "B" manter o tipo de "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="8cdda-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="8cdda-208">Além de adicionar tipos para o <xref:System.Xml.Schema.XmlSchemaSet>, o método de provedor de esquema para tipos de conteúdo deve retornar um valor não nulo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="8cdda-209">Ele pode retornar um <xref:System.Xml.XmlQualifiedName> que especifica o nome do tipo de esquema a ser usado para o determinado `IXmlSerializable` tipo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="8cdda-210">Esse nome qualificado também serve como os dados de nome e namespace para o tipo de contrato.</span><span class="sxs-lookup"><span data-stu-id="8cdda-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="8cdda-211">Ele tem permissão para retornar um tipo que não existe no esquema definido imediatamente quando o método de provedor de esquema retorna.</span><span class="sxs-lookup"><span data-stu-id="8cdda-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="8cdda-212">No entanto, é esperado que no momento em todos os relacionados tipos são exportados (o <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> método é chamado para todos os tipos relevantes no <xref:System.Runtime.Serialization.XsdDataContractExporter> e <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> propriedade for acessada), o tipo existe no conjunto de esquema.</span><span class="sxs-lookup"><span data-stu-id="8cdda-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="8cdda-213">Acessando o `Schemas` propriedade antes de todos os relevantes `Export` chamadas feitas pode resultar em um <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="8cdda-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="8cdda-214">o processo de exportação, consulte [exportando esquemas de Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-214"> the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="8cdda-215">O método de provedor de esquema também pode retornar o <xref:System.Xml.Schema.XmlSchemaType> para usar.</span><span class="sxs-lookup"><span data-stu-id="8cdda-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="8cdda-216">O tipo pode ou não ser anônimo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="8cdda-217">Se for anônima, o esquema para o `IXmlSerializable` tipo é exportado como um tipo anônimo sempre o `IXmlSerializable` tipo é usado como um membro de dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="8cdda-218">O `IXmlSerializable` tipo ainda tem um nome de contrato de dados e um namespace.</span><span class="sxs-lookup"><span data-stu-id="8cdda-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="8cdda-219">(Isso é determinado conforme descrito em [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md) exceto que o <xref:System.Runtime.Serialization.DataContractAttribute> atributo não pode ser usado para personalizar o nome.) Se não for anônimo, ele deve ser um dos tipos de `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-219">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="8cdda-220">Nesse caso é equivalente ao retornar o `XmlQualifiedName` do tipo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="8cdda-221">Além disso, uma declaração de elemento global é exportada para o tipo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="8cdda-222">Se o tipo não tem o <xref:System.Xml.Serialization.XmlRootAttribute> atributo aplicado a ele, o elemento tem o mesmo nome e namespace do contrato de dados e sua propriedade "anulável" é `true`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="8cdda-223">A única exceção a isso é o namespace do esquema ("http://www.w3.org/2001/XMLSchema") – se é de contrato de dados do tipo neste namespace, o elemento global correspondente está no namespace em branco porque é proibido adicionar novos elementos no esquema namespace.</span><span class="sxs-lookup"><span data-stu-id="8cdda-223">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="8cdda-224">Se o tipo tiver o `XmlRootAttribute` atributo aplicado a ele, a declaração do elemento global é exportado usando o seguinte: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> e <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="8cdda-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="8cdda-225">Os padrões com `XmlRootAttribute` aplicadas são o nome do contrato de dados, um namespace em branco e "anulável" sendo `true`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>  
  
 <span data-ttu-id="8cdda-226">As mesmas regras de declaração de elemento global se aplicam a tipos de conjunto de dados herdados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="8cdda-227">Observe que o `XmlRootAttribute` não é possível substituir declarações de elemento global adicionadas por meio de código personalizado, adicionado para o `XmlSchemaSet` usando o método de provedor de esquema ou por meio `GetSchema` para tipos de conjunto de dados herdados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="8cdda-228">Tipos de elemento IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="8cdda-228">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="8cdda-229">`IXmlSerializable`tipos de elemento tem o `IsAny` propriedade definida como `true` ou ter seu método de provedor de esquema retornar `null`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="8cdda-230">Serialização e desserialização de um tipo de elemento é muito semelhante a serialização e desserialização de um tipo de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="8cdda-231">No entanto, há algumas diferenças importantes:</span><span class="sxs-lookup"><span data-stu-id="8cdda-231">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="8cdda-232">O `WriteXml` implementação deve gravar exatamente um elemento (o que naturalmente pode conter vários elementos filho).</span><span class="sxs-lookup"><span data-stu-id="8cdda-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="8cdda-233">Ele não deve ser gravar os atributos fora desse elemento único, vários elementos irmãos ou conteúdo misto.</span><span class="sxs-lookup"><span data-stu-id="8cdda-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="8cdda-234">O elemento pode estar vazio.</span><span class="sxs-lookup"><span data-stu-id="8cdda-234">The element may be empty.</span></span>  
  
-   <span data-ttu-id="8cdda-235">O `ReadXml` implementação não deve ler o elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="8cdda-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="8cdda-236">É esperado ao ler um elemento que `WriteXml` produz.</span><span class="sxs-lookup"><span data-stu-id="8cdda-236">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="8cdda-237">Ao serializar um tipo de elemento regularmente (por exemplo, como um membro de dados em um contrato de dados), o serializador gera um elemento wrapper antes de chamar `WriteXml`, assim como acontece com os tipos de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="8cdda-238">No entanto, ao serializar um tipo de elemento no nível superior, o serializador não normalmente de saída de um elemento wrapper em todos os ao redor do elemento que `WriteXml` grava, a menos que um nome de raiz e o namespace explicitamente especificados durante a criação do serializador em o `DataContractSerializer` ou `NetDataContractSerializer` construtores.</span><span class="sxs-lookup"><span data-stu-id="8cdda-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="8cdda-239">[Serialização e desserialização](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-239"> [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="8cdda-240">Ao serializar um tipo de elemento no nível superior, sem especificar o nome raiz e o namespace em tempo de construção, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essencialmente não fazer nada e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> chamadas `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="8cdda-241">Nesse modo, o objeto que está sendo serializado não pode ser `null` e não pode ser atribuído polimorficamente.</span><span class="sxs-lookup"><span data-stu-id="8cdda-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="8cdda-242">Além disso, preservação de gráfico de objeto não pode ser habilitado e o `NetDataContractSerializer` não pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="8cdda-243">Durante a desserialização de um tipo de elemento no nível superior, sem especificar o nome raiz e o namespace em tempo de construção, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> retorna `true` se conseguir encontrar o início de qualquer elemento.</span><span class="sxs-lookup"><span data-stu-id="8cdda-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="8cdda-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A>com o `verifyObjectName` parâmetro definido como `true` se comporta da mesma maneira como `IsStartObject` antes de realmente ler o objeto.</span><span class="sxs-lookup"><span data-stu-id="8cdda-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="8cdda-245">`ReadObject`em seguida, passa o controle para `ReadXml` método.</span><span class="sxs-lookup"><span data-stu-id="8cdda-245">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="8cdda-246">O esquema exportado para tipos de elementos é o mesmo que para o `XmlElement` digite conforme descrito em uma seção anterior, exceto que o método de provedor de esquema pode adicionar qualquer esquema adicional para o <xref:System.Xml.Schema.XmlSchemaSet> assim como acontece com os tipos de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="8cdda-247">Usando o `XmlRootAttribute` atributo com tipos de elemento não é permitido e declarações de elemento global nunca são emitidas para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="8cdda-248">Diferenças de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8cdda-248">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="8cdda-249">O `IXmlSerializable` interface e o `XmlSchemaProviderAttribute` e `XmlRootAttribute` atributos também são entendidos pelo <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="8cdda-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="8cdda-250">No entanto, há algumas diferenças na maneira como elas são tratadas no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="8cdda-251">As diferenças importantes são resumidas na lista a seguir:</span><span class="sxs-lookup"><span data-stu-id="8cdda-251">The important differences are summarized in the following list:</span></span>  
  
-   <span data-ttu-id="8cdda-252">O método de provedor de esquema deve ser público para ser usado no `XmlSerializer`, mas não precisa ser público a ser usado no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>  
  
-   <span data-ttu-id="8cdda-253">O método de provedor de esquema é chamado quando `IsAny` é `true` no modelo de contrato de dados, mas não com o `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="8cdda-254">Quando o `XmlRootAttribute` atributo não estiver presente para conteúdo, ou tipos de conjunto de dados herdados, o `XmlSerializer` exporta uma declaração de elemento global no namespace em branco.</span><span class="sxs-lookup"><span data-stu-id="8cdda-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="8cdda-255">No modelo de contrato de dados, o namespace usado normalmente é o namespace de contrato de dados conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="8cdda-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="8cdda-256">Lembre-se dessas diferenças ao criar tipos que são usados com ambas as tecnologias de serialização.</span><span class="sxs-lookup"><span data-stu-id="8cdda-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="8cdda-257">Importando esquema IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="8cdda-257">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="8cdda-258">Ao importar um esquema gerado a partir de `IXmlSerializable` tipos, há algumas possibilidades:</span><span class="sxs-lookup"><span data-stu-id="8cdda-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="8cdda-259">O esquema gerado pode ser um esquema de contrato de dados válido, conforme descrito em [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="8cdda-260">Nesse caso, o esquema pode ser importado como de costume e tipos de contrato de dados regulares são gerados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="8cdda-261">O esquema gerado não pode ser um esquema de contrato de dados válido.</span><span class="sxs-lookup"><span data-stu-id="8cdda-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="8cdda-262">Por exemplo, o método de provedor de esquema pode gerar o esquema que envolve os atributos XML que não são suportados no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="8cdda-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="8cdda-263">Nesse caso, você pode importar o esquema como `IXmlSerializable` tipos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="8cdda-264">Este modo de importação não é ativado por padrão, mas podem facilmente ser habilitado – por exemplo, com o `/importXmlTypes` opção de linha de comando para o [Ferramenta Utilitária de metadados ServiceModel (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="8cdda-265">Isso é descrito detalhadamente o [Importando esquema para gerar Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="8cdda-265">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="8cdda-266">Observe que você deve trabalhar diretamente com o XML para suas instâncias de tipo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="8cdda-267">Você também pode considerar o uso de uma tecnologia de serialização que dá suporte a uma maior variedade de esquema – Consulte o tópico sobre como usar o `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="8cdda-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="8cdda-268">Talvez você queira reutilizar existente `IXmlSerializable` tipos no proxy em vez de gerar novos.</span><span class="sxs-lookup"><span data-stu-id="8cdda-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="8cdda-269">Nesse caso, o recurso de tipos referenciados descrito no esquema de importação para o tópico gerar tipos pode ser usado para indicar o tipo para reutilização.</span><span class="sxs-lookup"><span data-stu-id="8cdda-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="8cdda-270">Isso corresponde ao usar o `/reference` alternar svcutil.exe, que especifica o assembly que contém os tipos de reutilizar.</span><span class="sxs-lookup"><span data-stu-id="8cdda-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="8cdda-271">Comportamento de XmlSerializer herdado</span><span class="sxs-lookup"><span data-stu-id="8cdda-271">XmlSerializer Legacy Behavior</span></span>  
 <span data-ttu-id="8cdda-272">No .NET Framework 4.0 e versões anteriores, o XmlSerializer gerado assemblies de serialização temporário, escrevendo código c# em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="8cdda-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="8cdda-273">O arquivo foi compilado em um assembly.</span><span class="sxs-lookup"><span data-stu-id="8cdda-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="8cdda-274">Esse comportamento tinha alguns consequências indesejáveis como diminuindo o tempo de inicialização para o serializador.</span><span class="sxs-lookup"><span data-stu-id="8cdda-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="8cdda-275">No .NET Framework 4.5, esse comportamento foi alterado para gerar os assemblies sem exigir o uso do compilador.</span><span class="sxs-lookup"><span data-stu-id="8cdda-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="8cdda-276">Alguns desenvolvedores podem desejar ver o código c# gerado.</span><span class="sxs-lookup"><span data-stu-id="8cdda-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="8cdda-277">Você pode especificar para usar esse comportamento herdado, a seguinte configuração:</span><span class="sxs-lookup"><span data-stu-id="8cdda-277">You can specify to use this legacy behavior by the following configuration:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <system.xml.serialization>  
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />  
  </system.xml.serialization>  
  <system.diagnostics>  
    <switches>  
      <add name="XmlSerialization.Compilation" value="1" />  
    </switches>  
  </system.diagnostics>  
</configuration>  
```  
  
 <span data-ttu-id="8cdda-278">Se você tiver problemas de compatibilidade, como o `XmlSerializer` Falha ao serializar uma classe derivada com uma nova substituição de não-públicos, você poderá alternar novamente para o `XMLSerializer` comportamento herdado usando a seguinte configuração:</span><span class="sxs-lookup"><span data-stu-id="8cdda-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>  
  
```xml  
<configuration>  
<appSettings>   
<add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />  
               </appSettings>  
</configuration>  
```  
  
 <span data-ttu-id="8cdda-279">Como alternativa para a configuração acima, você pode usar a configuração a seguir em um computador executando o .NET Framework 4.5 ou posterior:</span><span class="sxs-lookup"><span data-stu-id="8cdda-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>  
  
```xml  
<configuration>  
<system.xml.serialization>  
<xmlSerializer useLegacySerializerGeneration="true"/>  
</system.xml.serialization>  
</configuration>  
```  
  
> [!NOTE]
>  <span data-ttu-id="8cdda-280">O `<xmlSerializer useLegacySerializerGeneration="true"/>` switch só funciona em uma máquina que executa o .NET Framework 4.5 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="8cdda-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="8cdda-281">As opções acima `appSettings` abordagem funciona em todas as versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="8cdda-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8cdda-282">Consulte também</span><span class="sxs-lookup"><span data-stu-id="8cdda-282">See Also</span></span>  
 <xref:System.ServiceModel.DataContractFormatAttribute>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.XmlSerializer>  
 <xref:System.ServiceModel.MessageHeaderArrayAttribute>  
 [<span data-ttu-id="8cdda-283">Especificando transferência de dados em contratos de serviço</span><span class="sxs-lookup"><span data-stu-id="8cdda-283">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)  
 [<span data-ttu-id="8cdda-284">Usando contratos de dados</span><span class="sxs-lookup"><span data-stu-id="8cdda-284">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="8cdda-285">Como: melhorar a inicialização do tempo de WCF aplicativos cliente que usam o XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="8cdda-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
