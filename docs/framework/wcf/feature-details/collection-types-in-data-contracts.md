---
title: Tipos de coleção em contratos de dados
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: e7c7dd72c733036031fcf28d0dd2c1bc023d6552
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59106737"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="c699c-102">Tipos de coleção em contratos de dados</span><span class="sxs-lookup"><span data-stu-id="c699c-102">Collection Types in Data Contracts</span></span>
<span data-ttu-id="c699c-103">Um *coleção* é uma lista de itens de um determinado tipo.</span><span class="sxs-lookup"><span data-stu-id="c699c-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="c699c-104">No [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], essas listas podem ser representadas usando matrizes ou uma variedade de outros tipos (lista genérico, genéricos <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, ou <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="c699c-104">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="c699c-105">Por exemplo, uma coleção pode conter uma lista de endereços para um determinado cliente.</span><span class="sxs-lookup"><span data-stu-id="c699c-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="c699c-106">Essas coleções são chamadas *listar coleções*, independentemente de seu tipo real.</span><span class="sxs-lookup"><span data-stu-id="c699c-106">These collections are called *list collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="c699c-107">Uma forma especial de coleção existe que representa uma associação entre um item (a "chave") e outro (o "valor").</span><span class="sxs-lookup"><span data-stu-id="c699c-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="c699c-108">No [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], esses são representados por tipos como <xref:System.Collections.Hashtable> e o dicionário genérico.</span><span class="sxs-lookup"><span data-stu-id="c699c-108">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="c699c-109">Por exemplo, uma coleção de associação pode mapear uma cidade ("chave") para sua população ("valor").</span><span class="sxs-lookup"><span data-stu-id="c699c-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="c699c-110">Essas coleções são chamadas *coleções de dicionário*, independentemente de seu tipo real.</span><span class="sxs-lookup"><span data-stu-id="c699c-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="c699c-111">Coleções recebem o tratamento especial no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="c699c-111">Collections receive special treatment in the data contract model.</span></span>  
  
 <span data-ttu-id="c699c-112">Tipos que implementam o <xref:System.Collections.IEnumerable> reconhecido interface, inclusive matrizes e coleções genéricas, como coleções.</span><span class="sxs-lookup"><span data-stu-id="c699c-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="c699c-113">Desses, tipos que implementam o <xref:System.Collections.IDictionary> genérico ou <xref:System.Collections.Generic.IDictionary%602> interfaces são coleções de dicionário; todos os outros são coleções de lista.</span><span class="sxs-lookup"><span data-stu-id="c699c-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>  
  
 <span data-ttu-id="c699c-114">Requisitos adicionais em tipos de coleção, como ter um método chamado `Add` e um construtor padrão, são discutidos em detalhes nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="c699c-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="c699c-115">Isso garante que os tipos de coleção podem ser serializados e desserializados.</span><span class="sxs-lookup"><span data-stu-id="c699c-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="c699c-116">Isso significa que algumas coleções não são diretamente suportadas, como o genérico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (porque ele não tem nenhum construtor padrão).</span><span class="sxs-lookup"><span data-stu-id="c699c-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="c699c-117">No entanto, para obter informações sobre como contornar essas restrições, consulte a seção "Usando coleção Interface tipos e coleções somente leitura", mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c699c-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>  
  
 <span data-ttu-id="c699c-118">Os tipos contidos em coleções devem ser tipos de contrato de dados ou caso contrário, ser serializáveis.</span><span class="sxs-lookup"><span data-stu-id="c699c-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="c699c-119">Para obter mais informações, consulte [tipos com suporte pelo serializador de contrato de dados](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="c699c-119">For more information, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>  
  
 <span data-ttu-id="c699c-120">Para obter mais informações sobre o que é e o que não é considerado uma coleção válida, bem como sobre como as coleções são serializadas, consulte as informações sobre como serializar coleções na seção "Regras de coleção avançada" deste tópico.</span><span class="sxs-lookup"><span data-stu-id="c699c-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>  
  
## <a name="interchangeable-collections"></a><span data-ttu-id="c699c-121">Coleções intercambiáveis</span><span class="sxs-lookup"><span data-stu-id="c699c-121">Interchangeable Collections</span></span>  
 <span data-ttu-id="c699c-122">Todas as coleções de lista do mesmo tipo são consideradas como tendo os mesmos dados de contrato (a menos que elas são personalizadas usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo, como discutido posteriormente neste tópico).</span><span class="sxs-lookup"><span data-stu-id="c699c-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="c699c-123">Assim, por exemplo, os contratos de dados a seguir são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="c699c-123">Thus, for example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
 [!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]  
  
 <span data-ttu-id="c699c-124">Ambos os contratos de dados resultam em XML semelhante ao código a seguir.</span><span class="sxs-lookup"><span data-stu-id="c699c-124">Both data contracts result in XML similar to the following code.</span></span>  
  
```xml  
<PurchaseOrder>  
    <customerName>...</customerName>  
    <items>  
        <Item>...</Item>  
        <Item>...</Item>  
        <Item>...</Item>  
        ...  
    </items>  
    <comments>  
        <string>...</string>  
        <string>...</string>  
        <string>...</string>  
        ...  
    </comments>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="c699c-125">Intercâmbio de coleção permite que você use, por exemplo, um tipo de coleção otimizado para desempenho do servidor e um tipo de coleção projetado para ser associado a componentes de interface do usuário no cliente.</span><span class="sxs-lookup"><span data-stu-id="c699c-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>  
  
 <span data-ttu-id="c699c-126">Semelhante às coleções de lista, todas as coleções de dicionário que têm os mesmos tipos de chave e valor são consideradas como tendo os mesmos dados de contrato (a menos que personalizado com o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo).</span><span class="sxs-lookup"><span data-stu-id="c699c-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>  
  
 <span data-ttu-id="c699c-127">Somente os assuntos de tipo de contrato de dados muito diz respeito a equivalência de coleção, não tipos do .NET.</span><span class="sxs-lookup"><span data-stu-id="c699c-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="c699c-128">Ou seja, uma coleção de Type1 é considerada equivalente a uma coleção de Type2 se Type1 e Type2 tiverem contratos de dados equivalente.</span><span class="sxs-lookup"><span data-stu-id="c699c-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>  
  
 <span data-ttu-id="c699c-129">Coleções não genéricas são consideradas como tendo os mesmos dados como coleções genéricas do tipo de contrato de `Object`.</span><span class="sxs-lookup"><span data-stu-id="c699c-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="c699c-130">(Por exemplo, contratos de dados para <xref:System.Collections.ArrayList> e genéricos <xref:System.Collections.Generic.List%601> de `Object` são os mesmos.)</span><span class="sxs-lookup"><span data-stu-id="c699c-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>  
  
## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="c699c-131">Usando coleções somente leitura e os tipos de Interface de coleção</span><span class="sxs-lookup"><span data-stu-id="c699c-131">Using Collection Interface Types and Read-Only Collections</span></span>  
 <span data-ttu-id="c699c-132">Tipos de interface de coleção (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>genérica <xref:System.Collections.Generic.IDictionary%602>, ou interfaces derivadas dessas interfaces) também são consideradas como tendo os contratos de dados de coleção, equivalente a coleção de contratos de dados para tipos de coleção real.</span><span class="sxs-lookup"><span data-stu-id="c699c-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="c699c-133">Portanto, é possível declarar o tipo sendo serializado como um tipo de interface de coleção e os resultados são os mesmos, como se tivesse sido usado um tipo de coleção real.</span><span class="sxs-lookup"><span data-stu-id="c699c-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="c699c-134">Por exemplo, os contratos de dados a seguir são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="c699c-134">For example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
 [!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]  
  
 <span data-ttu-id="c699c-135">Durante a serialização, quando o tipo declarado é uma interface, o tipo de instância real usado pode ser qualquer tipo que implementa essa interface.</span><span class="sxs-lookup"><span data-stu-id="c699c-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="c699c-136">Restrições discutido anteriormente (ter um construtor padrão e um `Add` método) não se aplicam.</span><span class="sxs-lookup"><span data-stu-id="c699c-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="c699c-137">Por exemplo, você pode definir os endereços no Customer2 a uma instância de genérico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> do endereço, mesmo que diretamente, você não pode declarar um membro de dados de tipo genérico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="c699c-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 <span data-ttu-id="c699c-138">Durante a desserialização, quando o tipo declarado é uma interface, o mecanismo de serialização escolhe um tipo que implementa a interface declarada, e o tipo é instanciado.</span><span class="sxs-lookup"><span data-stu-id="c699c-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="c699c-139">Mecanismo de tipos conhecidos (descrito na [tipos conhecidos de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) não tem nenhum efeito aqui; a escolha do tipo é desenvolvida no WCF.</span><span class="sxs-lookup"><span data-stu-id="c699c-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>  
  
## <a name="customizing-collection-types"></a><span data-ttu-id="c699c-140">Personalizando tipos de coleção</span><span class="sxs-lookup"><span data-stu-id="c699c-140">Customizing Collection Types</span></span>  
 <span data-ttu-id="c699c-141">Você pode personalizar tipos de coleção usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo, que tem vários usos.</span><span class="sxs-lookup"><span data-stu-id="c699c-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>  
  
 <span data-ttu-id="c699c-142">Observe que personalizando coleta tipos comprometimentos coleção obrigatórios, portanto, geralmente é recomendável para evitar a aplicação desse atributo sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="c699c-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="c699c-143">Para obter mais informações sobre esse problema, consulte a seção "Regras de coleção avançada" mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c699c-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="collection-data-contract-naming"></a><span data-ttu-id="c699c-144">Contrato de dados de coleção de nomenclatura</span><span class="sxs-lookup"><span data-stu-id="c699c-144">Collection Data Contract Naming</span></span>  
 <span data-ttu-id="c699c-145">As regras de nomeação de tipos de coleção são semelhantes àquelas para nomear tipos de contrato de dados regulares, conforme descrito em [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md), embora existam algumas diferenças importantes:</span><span class="sxs-lookup"><span data-stu-id="c699c-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>  
  
-   <span data-ttu-id="c699c-146">O <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo é usado para personalizar o nome, em vez do <xref:System.Runtime.Serialization.DataContractAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="c699c-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="c699c-147">O <xref:System.Runtime.Serialization.CollectionDataContractAttribute> também tem um atributo `Name` e `Namespace` propriedades.</span><span class="sxs-lookup"><span data-stu-id="c699c-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>  
  
-   <span data-ttu-id="c699c-148">Quando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo não for aplicado, o nome padrão e o namespace para tipos de coleção dependem de nomes e namespaces de tipos contidos na coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="c699c-149">Eles não são afetados pelo nome e namespace do tipo de coleção em si.</span><span class="sxs-lookup"><span data-stu-id="c699c-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="c699c-150">Para obter um exemplo, consulte os seguintes tipos.</span><span class="sxs-lookup"><span data-stu-id="c699c-150">For an example, see the following types.</span></span>  
  
    ```csharp  
    public CustomerList1 : Collection<string> {}  
    public StringList1 : Collection<string> {}  
    ```  
  
 <span data-ttu-id="c699c-151">Nome do contrato de dados dos ambos os tipos é "ArrayOfstring" e não "CustomerList1" ou "StringList1".</span><span class="sxs-lookup"><span data-stu-id="c699c-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="c699c-152">Isso significa que a serialização de qualquer um desses tipos no nível raiz gera XML semelhante ao código a seguir.</span><span class="sxs-lookup"><span data-stu-id="c699c-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>  
  
```xml  
<ArrayOfstring>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</ArrayOfstring>  
```  
  
 <span data-ttu-id="c699c-153">Essa regra de nomenclatura foi escolhida para garantir que qualquer tipo não personalizado que representa uma lista de cadeias de caracteres tem o mesmo contrato de dados e a representação XML.</span><span class="sxs-lookup"><span data-stu-id="c699c-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="c699c-154">Isso torna possível obrigatórios da coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="c699c-155">Neste exemplo, CustomerList1 e StringList1 são completamente intercambiáveis.</span><span class="sxs-lookup"><span data-stu-id="c699c-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>  
  
 <span data-ttu-id="c699c-156">No entanto, quando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo é aplicado, a coleção se tornará um contrato de dados de coleção personalizada, mesmo se nenhuma propriedade estiver definida no atributo.</span><span class="sxs-lookup"><span data-stu-id="c699c-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="c699c-157">O nome e namespace dos dados de coleção de contrato e dependem do tipo de coleção em si.</span><span class="sxs-lookup"><span data-stu-id="c699c-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="c699c-158">Para obter um exemplo, consulte o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="c699c-158">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
 [!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]  
  
 <span data-ttu-id="c699c-159">Quando serializada, o XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="c699c-159">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList2>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</CustomerList2>  
```  
  
 <span data-ttu-id="c699c-160">Observe que isso não é equivalente a representação XML dos tipos não personalizado.</span><span class="sxs-lookup"><span data-stu-id="c699c-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>  
  
-   <span data-ttu-id="c699c-161">Você pode usar o `Name` e `Namespace` propriedades ainda mais personalizar a nomenclatura.</span><span class="sxs-lookup"><span data-stu-id="c699c-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="c699c-162">Consulte a classe a seguir.</span><span class="sxs-lookup"><span data-stu-id="c699c-162">See the following class.</span></span>  
  
     [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
     [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]  
  
 <span data-ttu-id="c699c-163">O XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="c699c-163">The resulting XML is similar to the following.</span></span>  
  
```xml  
<cust_list>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</cust_list>  
```  
  
 <span data-ttu-id="c699c-164">Para obter mais informações, consulte a seção "Regras de coleção avançada" mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c699c-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="c699c-165">Personalizar o nome de elemento de repetição em coleções de lista</span><span class="sxs-lookup"><span data-stu-id="c699c-165">Customizing the Repeating Element Name in List Collections</span></span>  
 <span data-ttu-id="c699c-166">As coleções de lista contêm entradas de repetição.</span><span class="sxs-lookup"><span data-stu-id="c699c-166">List collections contain repeating entries.</span></span> <span data-ttu-id="c699c-167">Normalmente, cada entrada de repetição é representada como um elemento nomeado de acordo com o nome do contrato de dados do tipo contido na coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>  
  
 <span data-ttu-id="c699c-168">No `CustomerList` exemplos, as cadeias de caracteres de coleções contidas.</span><span class="sxs-lookup"><span data-stu-id="c699c-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="c699c-169">O nome do contrato de dados para o tipo primitivo de cadeia de caracteres é "string", portanto, o elemento de repetição foi "\<cadeia de caracteres >".</span><span class="sxs-lookup"><span data-stu-id="c699c-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>  
  
 <span data-ttu-id="c699c-170">No entanto, usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> propriedade no <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo, essa repetição nome de elemento pode ser personalizado.</span><span class="sxs-lookup"><span data-stu-id="c699c-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="c699c-171">Para obter um exemplo, consulte o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="c699c-171">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
 [!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]  
  
 <span data-ttu-id="c699c-172">O XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="c699c-172">The resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList4>  
    <customer>...</customer>  
    <customer>...</customer>  
    <customer>...</customer>  
    ...  
</CustomerList4>  
```  
  
 <span data-ttu-id="c699c-173">O namespace do elemento de repetição é sempre o mesmo que o namespace do contrato de dados de coleção, que pode ser personalizado usando o `Namespace` propriedade, conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="c699c-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>  
  
### <a name="customizing-dictionary-collections"></a><span data-ttu-id="c699c-174">Personalizando coleções de dicionário</span><span class="sxs-lookup"><span data-stu-id="c699c-174">Customizing Dictionary Collections</span></span>  
 <span data-ttu-id="c699c-175">Coleções de dicionário são essencialmente listas de entradas, onde cada entrada tem uma chave seguida por um valor.</span><span class="sxs-lookup"><span data-stu-id="c699c-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="c699c-176">Assim como com listas regulares, você pode alterar o nome do elemento que corresponde ao elemento de repetição usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="c699c-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>  
  
 <span data-ttu-id="c699c-177">Além disso, você pode alterar os nomes dos elementos que representam a chave e o valor usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> e <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="c699c-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="c699c-178">Os namespaces para esses elementos são o mesmo que o namespace do contrato de dados de coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>  
  
 <span data-ttu-id="c699c-179">Para obter um exemplo, consulte o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="c699c-179">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
 [!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]  
  
 <span data-ttu-id="c699c-180">Quando serializada, o XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="c699c-180">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CountriesOrRegionsWithCapitals>  
    <entry>  
        <countryorregion>USA</countryorregion>  
        <capital>Washington</capital>  
    </entry>  
    <entry>  
        <countryorregion>France</countryorregion>  
        <capital>Paris</capital>  
    </entry>  
    ...  
</CountriesOrRegionsWithCapitals>  
```  
  
 <span data-ttu-id="c699c-181">Para obter mais informações sobre coleções de dicionários, consulte a seção "Regras de coleção avançada" mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="c699c-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
## <a name="collections-and-known-types"></a><span data-ttu-id="c699c-182">Coleções e tipos conhecidos</span><span class="sxs-lookup"><span data-stu-id="c699c-182">Collections and Known Types</span></span>  
 <span data-ttu-id="c699c-183">Você não precisará adicionar tipos de coleção de tipos conhecidos quando polimorficamente usado no lugar de outras coleções ou interfaces de coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="c699c-184">Por exemplo, se você declarar um membro de dados do tipo <xref:System.Collections.IEnumerable> e usá-lo para enviar uma instância do <xref:System.Collections.ArrayList>, você não precisará adicionar <xref:System.Collections.ArrayList> para tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="c699c-185">Quando você usa coleções polimorficamente no lugar de tipos não seja de coleção, eles devem ser adicionados aos tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="c699c-186">Por exemplo, se você declarar um membro de dados do tipo `Object` e usá-lo para enviar uma instância do <xref:System.Collections.ArrayList>, adicione <xref:System.Collections.ArrayList> para tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="c699c-187">Isso não permite a serialização de qualquer coleção equivalente polimorficamente.</span><span class="sxs-lookup"><span data-stu-id="c699c-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="c699c-188">Por exemplo, quando você adiciona <xref:System.Collections.ArrayList> à lista de tipos conhecidos no exemplo anterior, isso não permite que você atribuir o `Array of Object` de classe, mesmo que ela tenha um contrato de dados equivalente.</span><span class="sxs-lookup"><span data-stu-id="c699c-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="c699c-189">Isso não é diferente do comportamento de tipos conhecidos regular na serialização para tipos de não coleção, mas é especialmente importante entender no caso de coleções, porque ele é muito comum para coleções a serem equivalentes.</span><span class="sxs-lookup"><span data-stu-id="c699c-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>  
  
 <span data-ttu-id="c699c-190">Durante a serialização, apenas um tipo pode ser conhecido em qualquer determinado escopo para um contrato de dados fornecido e equivalentes coleções todos têm os mesmos contratos de dados.</span><span class="sxs-lookup"><span data-stu-id="c699c-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="c699c-191">Isso significa que, no exemplo anterior, você não pode adicionar ambos <xref:System.Collections.ArrayList> e `Array of Object` para tipos conhecidos no mesmo escopo.</span><span class="sxs-lookup"><span data-stu-id="c699c-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="c699c-192">Novamente, isso equivale ao comportamento de tipos conhecidos para tipos de não coleção, mas é especialmente importante entender para coleções.</span><span class="sxs-lookup"><span data-stu-id="c699c-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>  
  
 <span data-ttu-id="c699c-193">Tipos conhecidos também podem ser necessários para o conteúdo das coleções.</span><span class="sxs-lookup"><span data-stu-id="c699c-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="c699c-194">Por exemplo, se um <xref:System.Collections.ArrayList> realmente contém instâncias do `Type1` e `Type2`, ambos os tipos devem ser adicionados aos tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>  
  
 <span data-ttu-id="c699c-195">O exemplo a seguir mostra um gráfico de objeto construído corretamente usando as coleções e tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="c699c-196">O exemplo é um pouco artificial, como em um aplicativo real, você normalmente não deve definir os seguintes membros de dados como `Object`e, portanto, não têm problemas conhecidos de tipo/polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="c699c-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
 [!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]  
  
 <span data-ttu-id="c699c-197">Na desserialização, se o tipo declarado é um tipo de coleção, o tipo declarado é instanciado, independentemente do tipo que foi realmente enviado.</span><span class="sxs-lookup"><span data-stu-id="c699c-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="c699c-198">Se o tipo declarado é uma interface de coleção, o desserializador escolhe um tipo a ser instanciado sem considerar a tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>  
  
 <span data-ttu-id="c699c-199">Também na desserialização, se o tipo declarado não é um tipo de coleção, mas está sendo enviado a um tipo de coleção, um tipo de coleção correspondente é escolhido na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="c699c-200">É possível adicionar tipos de interface de coleção para a lista de tipos conhecidos na desserialização.</span><span class="sxs-lookup"><span data-stu-id="c699c-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="c699c-201">Nesse caso, o mecanismo de desserialização novamente escolhe um tipo a ser instanciado.</span><span class="sxs-lookup"><span data-stu-id="c699c-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>  
  
## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="c699c-202">Coleções e a classe de NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="c699c-202">Collections and the NetDataContractSerializer Class</span></span>  
 <span data-ttu-id="c699c-203">Quando o <xref:System.Runtime.Serialization.NetDataContractSerializer> classe está em uso, tipos de coleção não personalizado (sem o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo) que são matrizes não perca seu significado especial.</span><span class="sxs-lookup"><span data-stu-id="c699c-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>  
  
 <span data-ttu-id="c699c-204">Tipos de coleção personalizada não são marcados com o <xref:System.SerializableAttribute> atributo ainda pode ser serializado pela <xref:System.Runtime.Serialization.NetDataContractSerializer> classe de acordo com o <xref:System.SerializableAttribute> atributo ou o <xref:System.Runtime.Serialization.ISerializable> regras de interface.</span><span class="sxs-lookup"><span data-stu-id="c699c-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>  
  
 <span data-ttu-id="c699c-205">Tipos de coleção personalizada, interfaces de coleção e matrizes ainda são tratados como coleções, mesmo quando o <xref:System.Runtime.Serialization.NetDataContractSerializer> classe está em uso.</span><span class="sxs-lookup"><span data-stu-id="c699c-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>  
  
## <a name="collections-and-schema"></a><span data-ttu-id="c699c-206">Coleções e esquema</span><span class="sxs-lookup"><span data-stu-id="c699c-206">Collections and Schema</span></span>  
 <span data-ttu-id="c699c-207">Todas as coleções equivalentes têm a mesma representação em XML (XSD) esquema da linguagem.</span><span class="sxs-lookup"><span data-stu-id="c699c-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="c699c-208">Por isso, você normalmente não obtém o mesmo tipo de coleção no código do cliente gerado como aquele no servidor.</span><span class="sxs-lookup"><span data-stu-id="c699c-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="c699c-209">Por exemplo, o servidor pode usar um contrato de dados com um genérico <xref:System.Collections.Generic.List%601> de membro de dados inteiro, mas no código do cliente gerado mesmo membro de dados pode se tornar uma matriz de inteiros.</span><span class="sxs-lookup"><span data-stu-id="c699c-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>  
  
 <span data-ttu-id="c699c-210">Coleções de dicionário são marcadas com uma anotação de esquema específicas do WCF que indicam que eles são dicionários; Caso contrário, eles são difíceis de diferenciar de simples listas que contêm entradas com uma chave e um valor.</span><span class="sxs-lookup"><span data-stu-id="c699c-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="c699c-211">Para obter uma descrição exata de como as coleções são representadas no esquema de contrato de dados, consulte [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="c699c-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="c699c-212">Por padrão, os tipos não são gerados para coleções não personalizada no código importado.</span><span class="sxs-lookup"><span data-stu-id="c699c-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="c699c-213">Membros de dados de lista de tipos de coleção são importados como matrizes e membros de tipos de coleção de dicionário de dados são importados como dicionário genérico.</span><span class="sxs-lookup"><span data-stu-id="c699c-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>  
  
 <span data-ttu-id="c699c-214">No entanto, para coleções personalizadas, tipos separados são gerados, marcado com o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="c699c-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="c699c-215">(Um tipo de coleção personalizada no esquema é aquele que não usa o namespace padrão, nome, repetição nome do elemento ou chave/valor nomes de elemento.) Esses tipos são tipos vazios que derivam de genérico <xref:System.Collections.Generic.List%601> para tipos de lista e dicionário genérico para tipos de dicionário.</span><span class="sxs-lookup"><span data-stu-id="c699c-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>  
  
 <span data-ttu-id="c699c-216">Por exemplo, você pode ter os seguintes tipos no servidor.</span><span class="sxs-lookup"><span data-stu-id="c699c-216">For example, you may have the following types on the server.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
 [!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]  
  
 <span data-ttu-id="c699c-217">Quando o esquema é exportado e importado novamente novamente, o código de cliente gerado é semelhante à seguinte (os campos são exibidos em vez de propriedades para facilitar a leitura).</span><span class="sxs-lookup"><span data-stu-id="c699c-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
 [!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]  
  
 <span data-ttu-id="c699c-218">Talvez você queira usar tipos diferentes no código gerado que os valores padrão.</span><span class="sxs-lookup"><span data-stu-id="c699c-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="c699c-219">Por exemplo, você talvez queira usar genéricos <xref:System.ComponentModel.BindingList%601> em vez de matrizes regulares de seus membros de dados facilitar a associá-las a componentes de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="c699c-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>  
  
 <span data-ttu-id="c699c-220">Para escolher os tipos de coleção para gerar, passar uma lista dos tipos de coleção que você deseja usar para o <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> propriedade do <xref:System.Runtime.Serialization.ImportOptions> durante a importação de esquema do objeto.</span><span class="sxs-lookup"><span data-stu-id="c699c-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="c699c-221">Esses tipos são chamados *tipos de coleção referenciados*.</span><span class="sxs-lookup"><span data-stu-id="c699c-221">These types are called *referenced collection types*.</span></span>  
  
 <span data-ttu-id="c699c-222">Quando tipos genéricos estão sendo referenciados, eles devem ser totalmente aberto genéricos ou genéricos totalmente fechada.</span><span class="sxs-lookup"><span data-stu-id="c699c-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c699c-223">Ao usar a ferramenta de Svcutil.exe, essa referência pode ser feita usando o **/collectionType** opção de linha de comando (forma abreviada: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="c699c-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="c699c-224">Lembre-se de que você também deve especificar o assembly para os tipos de coleção referenciada usando a **/Reference** alternar (forma abreviada: **/r**).</span><span class="sxs-lookup"><span data-stu-id="c699c-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="c699c-225">Se o tipo for genérico, ele deve ser seguido por um acento e o número de parâmetros genéricos.</span><span class="sxs-lookup"><span data-stu-id="c699c-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="c699c-226">O acento (\`) não deve ser confundido com o caractere de aspas simples (').</span><span class="sxs-lookup"><span data-stu-id="c699c-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="c699c-227">Você pode especificar vários tipos de coleção referenciada usando a **/collectionType** alternar mais de uma vez.</span><span class="sxs-lookup"><span data-stu-id="c699c-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>  
  
 <span data-ttu-id="c699c-228">Por exemplo, para fazer com que todas as listas a serem importados como genérico <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="c699c-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
```console  
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1  
```  
  
 <span data-ttu-id="c699c-229">Ao importar qualquer coleção, essa lista de tipos de coleção referenciado é verificada e a coleção de fallback de melhor correspondência é usada se um for encontrado, como um tipo de membro de dados (para coleções não personalizado) ou como um tipo base para derivar de (para coleções personalizadas).</span><span class="sxs-lookup"><span data-stu-id="c699c-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="c699c-230">Dicionários somente serão comparados aos dicionários, enquanto as listas são comparadas com listas.</span><span class="sxs-lookup"><span data-stu-id="c699c-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>  
  
 <span data-ttu-id="c699c-231">Por exemplo, se você adicionar o genérico <xref:System.ComponentModel.BindingList%601> e <xref:System.Collections.Hashtable> à lista de tipos referenciados, o código de cliente gerado para o exemplo anterior é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="c699c-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
 [!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]  
  
 <span data-ttu-id="c699c-232">Você pode especificar os tipos de interface de coleção como parte de seus tipos de coleção referenciada, mas não é possível especificar os tipos de coleção inválido (como aqueles sem nenhum `Add` método ou construtor público).</span><span class="sxs-lookup"><span data-stu-id="c699c-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>  
  
 <span data-ttu-id="c699c-233">Um genérico fechado é considerado a melhor correspondência.</span><span class="sxs-lookup"><span data-stu-id="c699c-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="c699c-234">(Tipos genéricos não são considerados equivalentes aos genéricos fechados de `Object`).</span><span class="sxs-lookup"><span data-stu-id="c699c-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="c699c-235">Por exemplo, se os tipos genéricos <xref:System.Collections.Generic.List%601> dos <xref:System.DateTime>genérica <xref:System.ComponentModel.BindingList%601> (genérica aberta), e <xref:System.Collections.ArrayList> são os tipos de coleção referenciada, o seguinte é gerado.</span><span class="sxs-lookup"><span data-stu-id="c699c-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
 [!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]  
  
 <span data-ttu-id="c699c-236">Para coleções de lista, somente os casos na tabela a seguir têm suporte.</span><span class="sxs-lookup"><span data-stu-id="c699c-236">For list collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="c699c-237">Tipo de referência</span><span class="sxs-lookup"><span data-stu-id="c699c-237">Referenced type</span></span>|<span data-ttu-id="c699c-238">Interface implementada pelo tipo referenciado</span><span class="sxs-lookup"><span data-stu-id="c699c-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="c699c-239">Exemplo</span><span class="sxs-lookup"><span data-stu-id="c699c-239">Example</span></span>|<span data-ttu-id="c699c-240">Tipo é tratado como:</span><span class="sxs-lookup"><span data-stu-id="c699c-240">Type treated as:</span></span>|  
|---------------------|----------------------------------------------|-------------|----------------------|  
|<span data-ttu-id="c699c-241">Genérico não genéricas ou fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="c699c-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="c699c-242">Não genéricas</span><span class="sxs-lookup"><span data-stu-id="c699c-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="c699c-243">ou</span><span class="sxs-lookup"><span data-stu-id="c699c-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="c699c-244">em que T =</span><span class="sxs-lookup"><span data-stu-id="c699c-244">where T=</span></span> `int`|<span data-ttu-id="c699c-245">Fechado genérico de `Object` (por exemplo, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|  
|<span data-ttu-id="c699c-246">Genérico não genéricas ou fechado (qualquer número de parâmetros que não correspondem necessariamente o tipo de coleção)</span><span class="sxs-lookup"><span data-stu-id="c699c-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="c699c-247">Fechado genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="c699c-248">ou</span><span class="sxs-lookup"><span data-stu-id="c699c-248">or</span></span><br /><br /> `MyType<T> : IList<string>` <span data-ttu-id="c699c-249">em que T =</span><span class="sxs-lookup"><span data-stu-id="c699c-249">where T=</span></span>`int`|<span data-ttu-id="c699c-250">Genérico fechado (por exemplo, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-250">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="c699c-251">Fechado genérico com qualquer número de parâmetros</span><span class="sxs-lookup"><span data-stu-id="c699c-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="c699c-252">Genérica aberta usando qualquer um dos parâmetros do tipo</span><span class="sxs-lookup"><span data-stu-id="c699c-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="c699c-253">em que T =`int`, U =`string`, V =</span><span class="sxs-lookup"><span data-stu-id="c699c-253">where T=`int`, U=`string`, V=</span></span>`bool`|<span data-ttu-id="c699c-254">Genérico fechado (por exemplo, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-254">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="c699c-255">Genérica aberta com um parâmetro</span><span class="sxs-lookup"><span data-stu-id="c699c-255">Open generic with one parameter</span></span>|<span data-ttu-id="c699c-256">Usando o parâmetro do tipo de genérico aberto</span><span class="sxs-lookup"><span data-stu-id="c699c-256">Open generic using the type’s parameter</span></span>|`MyType<T> : IList<T>`<span data-ttu-id="c699c-257">, T está aberto</span><span class="sxs-lookup"><span data-stu-id="c699c-257">, T is open</span></span>|<span data-ttu-id="c699c-258">Genérica aberta (por exemplo, `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-258">Open generic (for example, `IList<T>`)</span></span>|  
  
 <span data-ttu-id="c699c-259">Se um tipo implementa mais de uma interface de coleção de lista, as seguintes restrições se aplicam:</span><span class="sxs-lookup"><span data-stu-id="c699c-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="c699c-260">Se o tipo implementa genérico <xref:System.Collections.Generic.IEnumerable%601> (ou suas interfaces derivadas) várias vezes para tipos diferentes, o tipo não é considerado um tipo de coleção referenciado válido e será ignorado.</span><span class="sxs-lookup"><span data-stu-id="c699c-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="c699c-261">Isso é verdadeiro mesmo se algumas implementações são inválidas ou usam abertos genéricos.</span><span class="sxs-lookup"><span data-stu-id="c699c-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="c699c-262">Por exemplo, um tipo que implementa <xref:System.Collections.Generic.IEnumerable%601> de `int` e genérica <xref:System.Collections.Generic.IEnumerable%601> de T nunca seria usado como uma coleção referenciada da `int` ou qualquer outro tipo, independentemente de ter o tipo de um `Add` aceitação de método `int` ou um `Add` método aceita um parâmetro do tipo T, ou ambos.</span><span class="sxs-lookup"><span data-stu-id="c699c-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>  
  
-   <span data-ttu-id="c699c-263">Se o tipo implementa uma interface de coleção genérica, bem como <xref:System.Collections.IList>, o tipo nunca é usado como um tipo de coleção referenciada, a menos que a interface de coleção genérica é do tipo genérico fechado <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c699c-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="c699c-264">Para coleções de dicionários, somente os casos na tabela a seguir têm suporte.</span><span class="sxs-lookup"><span data-stu-id="c699c-264">For dictionary collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="c699c-265">Tipo de referência</span><span class="sxs-lookup"><span data-stu-id="c699c-265">Referenced type</span></span>|<span data-ttu-id="c699c-266">Interface implementada pelo tipo referenciado</span><span class="sxs-lookup"><span data-stu-id="c699c-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="c699c-267">Exemplo</span><span class="sxs-lookup"><span data-stu-id="c699c-267">Example</span></span>|<span data-ttu-id="c699c-268">Tipo tratado como</span><span class="sxs-lookup"><span data-stu-id="c699c-268">Type treated as</span></span>|  
|---------------------|----------------------------------------------|-------------|---------------------|  
|<span data-ttu-id="c699c-269">Genérico não genéricas ou fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="c699c-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="c699c-270">ou</span><span class="sxs-lookup"><span data-stu-id="c699c-270">or</span></span><br /><br /> `MyType<T> : IDictionary` <span data-ttu-id="c699c-271">em que T =</span><span class="sxs-lookup"><span data-stu-id="c699c-271">where T=</span></span>`int`|<span data-ttu-id="c699c-272">Fechado genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-272">Closed generic</span></span> `IDictionary<object,object>`|  
|<span data-ttu-id="c699c-273">Genérico fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="c699c-273">Closed generic (any number of parameters)</span></span>|<xref:System.Collections.Generic.IDictionary%602><span data-ttu-id="c699c-274">, fechado</span><span class="sxs-lookup"><span data-stu-id="c699c-274">, closed</span></span>|`MyType<T> : IDictionary<string, bool>` <span data-ttu-id="c699c-275">em que T =</span><span class="sxs-lookup"><span data-stu-id="c699c-275">where T=</span></span>`int`|<span data-ttu-id="c699c-276">Genérico fechado (por exemplo, `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|  
|<span data-ttu-id="c699c-277">Genérico fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="c699c-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c699c-278">Genérico <xref:System.Collections.Generic.IDictionary%602>, uma chave ou valor é fechada, o outro está aberto e usa um dos parâmetros do tipo</span><span class="sxs-lookup"><span data-stu-id="c699c-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|`MyType<T,U,V> : IDictionary<string,V>` <span data-ttu-id="c699c-279">em que T =`int`, U =`float`, V =</span><span class="sxs-lookup"><span data-stu-id="c699c-279">where T=`int`, U=`float`,V=</span></span>`bool`<br /><br /> <span data-ttu-id="c699c-280">ou</span><span class="sxs-lookup"><span data-stu-id="c699c-280">or</span></span><br /><br /> `MyType<Z> : IDictionary<Z,bool>` <span data-ttu-id="c699c-281">em que Z =</span><span class="sxs-lookup"><span data-stu-id="c699c-281">where Z=</span></span>`string`|<span data-ttu-id="c699c-282">Genérico fechado (por exemplo, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="c699c-283">Genérico fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="c699c-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c699c-284">Genérico <xref:System.Collections.Generic.IDictionary%602>, chave e valor são abertos e cada uma usa um dos parâmetros do tipo</span><span class="sxs-lookup"><span data-stu-id="c699c-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|`MyType<T,U,V> : IDictionary<V,U>` <span data-ttu-id="c699c-285">em que T =`int`, U =`bool`, V =</span><span class="sxs-lookup"><span data-stu-id="c699c-285">where T=`int`, U=`bool`, V=</span></span>`string`|<span data-ttu-id="c699c-286">Genérico fechado (por exemplo, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="c699c-287">Genérica aberta (dois parâmetros)</span><span class="sxs-lookup"><span data-stu-id="c699c-287">Open generic (two parameters)</span></span>|<span data-ttu-id="c699c-288">Genérico <xref:System.Collections.Generic.IDictionary%602>, abrir, que usa dois parâmetros genéricos do tipo na ordem em que aparecem</span><span class="sxs-lookup"><span data-stu-id="c699c-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|`MyType<K,V> : IDictionary<K,V>`<span data-ttu-id="c699c-289">, K e V abertos</span><span class="sxs-lookup"><span data-stu-id="c699c-289">, K and V both open</span></span>|<span data-ttu-id="c699c-290">Genérica aberta (por exemplo, `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="c699c-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|  
  
 <span data-ttu-id="c699c-291">Se o tipo implementa ambos <xref:System.Collections.IDictionary> e genéricos <xref:System.Collections.Generic.IDictionary%602>genérica somente <xref:System.Collections.Generic.IDictionary%602> é considerado.</span><span class="sxs-lookup"><span data-stu-id="c699c-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>  
  
 <span data-ttu-id="c699c-292">Não há suporte para referenciar tipos genéricos parciais.</span><span class="sxs-lookup"><span data-stu-id="c699c-292">Referencing partial generic types is not supported.</span></span>  
  
 <span data-ttu-id="c699c-293">Não são permitidas duplicatas, por exemplo, você não pode adicionar a genérica <xref:System.Collections.Generic.List%601> dos `Integer` e a coleção genérica de `Integer` para <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, porque isso torna impossível determinar qual deles usar quando uma lista de inteiros é encontrado no esquema.</span><span class="sxs-lookup"><span data-stu-id="c699c-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="c699c-294">As duplicatas são detectadas somente se houver um tipo no esquema que expõe o problema de duplicatas.</span><span class="sxs-lookup"><span data-stu-id="c699c-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="c699c-295">Por exemplo, se o esquema que está sendo importado não contém listas de números inteiros, ele tem permissão para ter ambas as genérica <xref:System.Collections.Generic.List%601> de `Integer` e a coleção genérica de `Integer` no <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, mas não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="c699c-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>  
  
## <a name="advanced-collection-rules"></a><span data-ttu-id="c699c-296">Regras de coleta avançados</span><span class="sxs-lookup"><span data-stu-id="c699c-296">Advanced Collection Rules</span></span>  
  
### <a name="serializing-collections"></a><span data-ttu-id="c699c-297">Serializando coleções</span><span class="sxs-lookup"><span data-stu-id="c699c-297">Serializing Collections</span></span>  
 <span data-ttu-id="c699c-298">A seguir está uma lista de regras de coleção para a serialização:</span><span class="sxs-lookup"><span data-stu-id="c699c-298">The following is a list of collection rules for serialization:</span></span>  
  
-   <span data-ttu-id="c699c-299">Combinando tipos de coleção (com coleções de coleções) é permitido.</span><span class="sxs-lookup"><span data-stu-id="c699c-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="c699c-300">Matrizes denteadas são tratados como coleções de coleções.</span><span class="sxs-lookup"><span data-stu-id="c699c-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="c699c-301">Não há suporte para matrizes multidimensionais.</span><span class="sxs-lookup"><span data-stu-id="c699c-301">Multidimensional arrays are not supported.</span></span>  
  
-   <span data-ttu-id="c699c-302">Matrizes de bytes e matrizes de <xref:System.Xml.XmlNode> são tipos especiais de matriz que são tratados como primitivos, coleções não.</span><span class="sxs-lookup"><span data-stu-id="c699c-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="c699c-303">Serializando uma matriz de bytes resulta em um único elemento XML que contém um bloco de dados codificados em Base64, em vez de um elemento separado para cada byte.</span><span class="sxs-lookup"><span data-stu-id="c699c-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="c699c-304">Para obter mais informações sobre como uma matriz de <xref:System.Xml.XmlNode> é tratado, consulte [XML e tipos ADO.NET em contratos de dados](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="c699c-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="c699c-305">É claro, esses tipos especiais podem próprios participar de coleções: uma matriz de matriz de bytes resulta em vários elementos XML, com cada um contendo um bloco de dados codificados em Base64.</span><span class="sxs-lookup"><span data-stu-id="c699c-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>  
  
-   <span data-ttu-id="c699c-306">Se o <xref:System.Runtime.Serialization.DataContractAttribute> atributo é aplicado a um tipo de coleção, o tipo é tratado como um tipo de contrato de dados regulares, não como uma coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>  
  
-   <span data-ttu-id="c699c-307">Se um tipo de coleção implementa a <xref:System.Xml.Serialization.IXmlSerializable> interface, as seguintes regras se aplicam, dado um tipo `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="c699c-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>  
  
    -   <span data-ttu-id="c699c-308">Se o tipo declarado é `IList<string>`, o tipo é serializado como uma lista.</span><span class="sxs-lookup"><span data-stu-id="c699c-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>  
  
    -   <span data-ttu-id="c699c-309">Se for o tipo declarado `myType`, ele é serializado como `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="c699c-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>  
  
    -   <span data-ttu-id="c699c-310">Se for o tipo declarado `IXmlSerializable`, ele é serializado como `IXmlSerializable`, mas apenas se você adicionar `myType` à lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>  
  
-   <span data-ttu-id="c699c-311">Coleções são serializadas e desserializados usando os métodos mostrados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="c699c-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>  
  
|<span data-ttu-id="c699c-312">Tipo de coleção implementa</span><span class="sxs-lookup"><span data-stu-id="c699c-312">Collection type implements</span></span>|<span data-ttu-id="c699c-313">Chamada de método (s) na serialização</span><span class="sxs-lookup"><span data-stu-id="c699c-313">Method(s) called on serialization</span></span>|<span data-ttu-id="c699c-314">Chamada de método (s) na desserialização</span><span class="sxs-lookup"><span data-stu-id="c699c-314">Method(s) called on deserialization</span></span>|  
|--------------------------------|-----------------------------------------|-------------------------------------------|  
|<span data-ttu-id="c699c-315">Genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-315">Generic</span></span> <xref:System.Collections.Generic.IDictionary%602>|`get_Keys`<span data-ttu-id="c699c-316">,</span><span class="sxs-lookup"><span data-stu-id="c699c-316">,</span></span> `get_Values`|<span data-ttu-id="c699c-317">Adicionar genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-317">Generic Add</span></span>|  
|<xref:System.Collections.IDictionary>|`get_Keys`<span data-ttu-id="c699c-318">,</span><span class="sxs-lookup"><span data-stu-id="c699c-318">,</span></span> `get_Values`|`Add`|  
|<span data-ttu-id="c699c-319">Genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-319">Generic</span></span> <xref:System.Collections.Generic.IList%601>|<span data-ttu-id="c699c-320">Genérico <xref:System.Collections.Generic.IList%601> indexador</span><span class="sxs-lookup"><span data-stu-id="c699c-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="c699c-321">Adicionar genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-321">Generic Add</span></span>|  
|<span data-ttu-id="c699c-322">Genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-322">Generic</span></span> <xref:System.Collections.Generic.ICollection%601>|<span data-ttu-id="c699c-323">Enumerador</span><span class="sxs-lookup"><span data-stu-id="c699c-323">Enumerator</span></span>|<span data-ttu-id="c699c-324">Adicionar genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-324">Generic Add</span></span>|  
|<xref:System.Collections.IList>|<xref:System.Collections.IList> <span data-ttu-id="c699c-325">Indexador</span><span class="sxs-lookup"><span data-stu-id="c699c-325">Indexer</span></span>|`Add`|  
|<span data-ttu-id="c699c-326">Genérico</span><span class="sxs-lookup"><span data-stu-id="c699c-326">Generic</span></span> <xref:System.Collections.Generic.IEnumerable%601>|`GetEnumerator`|<span data-ttu-id="c699c-327">Um método não estático chamado `Add` que recebe um parâmetro do tipo apropriado (o tipo do parâmetro genérico) ou um de seus tipos base.</span><span class="sxs-lookup"><span data-stu-id="c699c-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="c699c-328">Esse tipo de método deve existir para o serializador tratar um tipo de coleção como uma coleção durante a serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="c699c-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
|<xref:System.Collections.IEnumerable> <span data-ttu-id="c699c-329">(e, portanto, <xref:System.Collections.ICollection>, que é derivada dele)</span><span class="sxs-lookup"><span data-stu-id="c699c-329">(and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="c699c-330">Um método não estático chamado `Add` que recebe um parâmetro de tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="c699c-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="c699c-331">Esse tipo de método deve existir para o serializador tratar um tipo de coleção como uma coleção durante a serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="c699c-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
  
 <span data-ttu-id="c699c-332">A tabela anterior lista as interfaces de coleção em ordem decrescente de precedência.</span><span class="sxs-lookup"><span data-stu-id="c699c-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="c699c-333">Isso significa, por exemplo, que se um tipo implementa ambos <xref:System.Collections.IList> e genéricos <xref:System.Collections.Generic.IEnumerable%601>, a coleção é serializada e desserializada de acordo com o <xref:System.Collections.IList> regras:</span><span class="sxs-lookup"><span data-stu-id="c699c-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>  
  
-   <span data-ttu-id="c699c-334">A desserialização, todas as coleções são desserializadas, primeiro criando uma instância do tipo chamando o construtor padrão, que deve estar presente para o serializador tratar um tipo de coleção como uma coleção durante a serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="c699c-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>  
  
-   <span data-ttu-id="c699c-335">Se a mesma interface de coleção genérica é implementada mais de uma vez (por exemplo, se um tipo implementa genérica <xref:System.Collections.Generic.ICollection%601> dos `Integer` e genérica <xref:System.Collections.Generic.ICollection%601> de <xref:System.String>) e nenhuma interface de precedência mais alta for encontrado, a coleção é não é tratado como uma coleção válida.</span><span class="sxs-lookup"><span data-stu-id="c699c-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>  
  
-   <span data-ttu-id="c699c-336">Tipos de coleção podem ter o <xref:System.SerializableAttribute> atributo aplicado a eles e pode implementar o <xref:System.Runtime.Serialization.ISerializable> interface.</span><span class="sxs-lookup"><span data-stu-id="c699c-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="c699c-337">Ambos são ignorados.</span><span class="sxs-lookup"><span data-stu-id="c699c-337">Both of these are ignored.</span></span> <span data-ttu-id="c699c-338">No entanto, se o tipo não totalmente atende aos requisitos de tipo de coleção (por exemplo, o `Add` método está ausente), o tipo não é considerado um tipo de coleção e, portanto, o <xref:System.SerializableAttribute> atributo e o <xref:System.Runtime.Serialization.ISerializable> interface são usados para determinar o tipo pode ser serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>  
  
-   <span data-ttu-id="c699c-339">Aplicando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo a uma coleção para personalizá-lo remove o <xref:System.SerializableAttribute> precede o mecanismo de fallback.</span><span class="sxs-lookup"><span data-stu-id="c699c-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="c699c-340">Em vez disso, se uma coleção personalizada coleção não atendam aos requisitos de tipo, um <xref:System.Runtime.Serialization.InvalidDataContractException> exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="c699c-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="c699c-341">A cadeia de caracteres de exceção geralmente contém informações que explicam por que um determinado tipo não é considerado uma coleção válida (nenhum `Add` método, nenhum construtor padrão e assim por diante), portanto, geralmente é útil aplicar o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo para fins de depuração.</span><span class="sxs-lookup"><span data-stu-id="c699c-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>  
  
### <a name="collection-naming"></a><span data-ttu-id="c699c-342">Coleção de nomenclatura</span><span class="sxs-lookup"><span data-stu-id="c699c-342">Collection Naming</span></span>  
 <span data-ttu-id="c699c-343">A seguir está uma lista de regras de nomenclatura de coleção:</span><span class="sxs-lookup"><span data-stu-id="c699c-343">The following is a list of collection naming rules:</span></span>  
  
-   <span data-ttu-id="c699c-344">O namespace padrão para todos os contratos de dados de coleção de dicionário, bem como para contratos de dados de coleção de lista que contêm tipos primitivos, é `http://schemas.microsoft.com/2003/10/Serialization/Arrays` , a menos que substituído usando o Namespace.</span><span class="sxs-lookup"><span data-stu-id="c699c-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="c699c-345">Tipos que são mapeados para tipos XSD internos, bem como `char`, `Timespan`, e `Guid` tipos, são considerados primitivos para essa finalidade.</span><span class="sxs-lookup"><span data-stu-id="c699c-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>  
  
-   <span data-ttu-id="c699c-346">O namespace padrão para tipos de coleção que contêm tipos de não primitivo, a menos que ele seja substituído usando o Namespace, é o mesmo que o namespace de contrato de dados do tipo contido na coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>  
  
-   <span data-ttu-id="c699c-347">O nome padrão para contratos de dados de coleção de lista, a menos que substituído usando o nome, é a cadeia de caracteres "ArrayOf" combinado com o nome do contrato de dados do tipo contido na coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="c699c-348">Por exemplo, o nome do contrato de dados para uma lista genérica de inteiros é "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="c699c-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="c699c-349">Tenha em mente que os dados de nome do contrato `Object` é "anyType", como o nome do contrato de dados de listas de não-genérica <xref:System.Collections.ArrayList> é "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="c699c-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>  
  
 <span data-ttu-id="c699c-350">O nome padrão para dados de coleção de dicionário de contratos, a menos que substituído usando `Name`, é a cadeia de caracteres "ArrayOfKeyValueOf" combinado com o nome do contrato de dados de tipo de chave, seguido do nome do contrato de dados do tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="c699c-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="c699c-351">Por exemplo, os dados de nome do contrato para um dicionário de cadeia de caracteres genérica e inteiro é "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="c699c-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="c699c-352">Além disso, se a chave ou os tipos de valor não são tipos primitivos, um hash de namespace dos namespaces de contrato de dados dos tipos de chave e o valor é acrescentado ao nome.</span><span class="sxs-lookup"><span data-stu-id="c699c-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="c699c-353">Para obter mais informações sobre os hashes de namespace, consulte [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="c699c-353">For more information about namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
 <span data-ttu-id="c699c-354">Cada contrato de dados de coleção de dicionário tem um contrato de dados complementar que representa uma entrada no dicionário.</span><span class="sxs-lookup"><span data-stu-id="c699c-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="c699c-355">Seu nome é o mesmo para o contrato de dados do dicionário, exceto para o prefixo "ArrayOf", e seu namespace é o mesmo para o contrato de dados do dicionário.</span><span class="sxs-lookup"><span data-stu-id="c699c-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="c699c-356">Por exemplo, para o contrato de dados do dicionário "ArrayOfKeyValueOfstringint", o contrato de dados "KeyValueofstringint" representa uma entrada no dicionário.</span><span class="sxs-lookup"><span data-stu-id="c699c-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="c699c-357">Você pode personalizar o nome do contrato de dados usando o `ItemName` propriedade, conforme descrito na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="c699c-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>  
  
 <span data-ttu-id="c699c-358">As regras de nomenclatura de tipo genérico conforme descrito em [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md), totalmente se aplicam a tipos de coleção; o que é, você pode usar chaves dentro do nome para indicar parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="c699c-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="c699c-359">No entanto, os números dentro dos colchetes consultem parâmetros genéricos e não os tipos contidos na coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>  
  
## <a name="collection-customization"></a><span data-ttu-id="c699c-360">Personalização de coleção</span><span class="sxs-lookup"><span data-stu-id="c699c-360">Collection Customization</span></span>  
 <span data-ttu-id="c699c-361">A seguir usa do <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo são proibidos e resultar em um <xref:System.Runtime.Serialization.InvalidDataContractException> exceção:</span><span class="sxs-lookup"><span data-stu-id="c699c-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>  
  
-   <span data-ttu-id="c699c-362">Aplicando o <xref:System.Runtime.Serialization.DataContractAttribute> de atributo para um tipo para o qual o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo foi aplicado, ou para um de seus tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="c699c-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>  
  
-   <span data-ttu-id="c699c-363">Aplicando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo para um tipo que implementa o <xref:System.Xml.Serialization.IXmlSerializable> interface.</span><span class="sxs-lookup"><span data-stu-id="c699c-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="c699c-364">Aplicando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo para um tipo não seja de coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>  
  
-   <span data-ttu-id="c699c-365">Tentativa de definir <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> ou <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> em um <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo aplicado a um tipo não existentes no dicionário.</span><span class="sxs-lookup"><span data-stu-id="c699c-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>  
  
### <a name="polymorphism-rules"></a><span data-ttu-id="c699c-366">Regras de polimorfismo</span><span class="sxs-lookup"><span data-stu-id="c699c-366">Polymorphism Rules</span></span>  
 <span data-ttu-id="c699c-367">Como mencionado anteriormente, personalizando coleções usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo pode interferir com obrigatórios da coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="c699c-368">Dois tipos de coleção personalizado só podem ser considerados equivalentes se correspondem a seu nome, namespace, nome do item, bem como nomes de chave e valor (se elas são coleções de dicionário).</span><span class="sxs-lookup"><span data-stu-id="c699c-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>  
  
 <span data-ttu-id="c699c-369">Devido a personalizações, é possível inadvertidamente usar contrato de dados de uma coleção em que outra é esperada.</span><span class="sxs-lookup"><span data-stu-id="c699c-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="c699c-370">Isso deve ser evitado.</span><span class="sxs-lookup"><span data-stu-id="c699c-370">This should be avoided.</span></span> <span data-ttu-id="c699c-371">Consulte os seguintes tipos.</span><span class="sxs-lookup"><span data-stu-id="c699c-371">See the following types.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
 [!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]  
  
 <span data-ttu-id="c699c-372">No caso, uma instância do `Marks1` podem ser atribuídos a `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="c699c-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="c699c-373">No entanto, `Marks2` não deve ser usado porque não é considerado equivalente ao seu contrato de dados a `IList<int>` contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="c699c-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="c699c-374">O nome do contrato de dados é "Marks2" e não "ArrayOfint", e o nome de elemento de repetição é "\<marcar >" e não "\<int >".</span><span class="sxs-lookup"><span data-stu-id="c699c-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>  
  
 <span data-ttu-id="c699c-375">As regras na tabela a seguir se aplicam a atribuição polimórfica de coleções.</span><span class="sxs-lookup"><span data-stu-id="c699c-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>  
  
|<span data-ttu-id="c699c-376">Tipo declarado</span><span class="sxs-lookup"><span data-stu-id="c699c-376">Declared type</span></span>|<span data-ttu-id="c699c-377">Atribuindo uma coleção não personalizado</span><span class="sxs-lookup"><span data-stu-id="c699c-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="c699c-378">Atribuindo uma coleção personalizada</span><span class="sxs-lookup"><span data-stu-id="c699c-378">Assigning a customized collection</span></span>|  
|-------------------|--------------------------------------------|---------------------------------------|  
|<span data-ttu-id="c699c-379">Objeto</span><span class="sxs-lookup"><span data-stu-id="c699c-379">Object</span></span>|<span data-ttu-id="c699c-380">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-380">Contract name is serialized.</span></span>|<span data-ttu-id="c699c-381">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c699c-382">Personalização é usada.</span><span class="sxs-lookup"><span data-stu-id="c699c-382">Customization is used.</span></span>|  
|<span data-ttu-id="c699c-383">Interface de coleção</span><span class="sxs-lookup"><span data-stu-id="c699c-383">Collection interface</span></span>|<span data-ttu-id="c699c-384">Nome do contrato não é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-384">Contract name is not serialized.</span></span>|<span data-ttu-id="c699c-385">Nome do contrato não é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="c699c-386">A personalização não é used.\*</span><span class="sxs-lookup"><span data-stu-id="c699c-386">Customization is not used.\*</span></span>|  
|<span data-ttu-id="c699c-387">Coleção não personalizado</span><span class="sxs-lookup"><span data-stu-id="c699c-387">Non-customized collection</span></span>|<span data-ttu-id="c699c-388">Nome do contrato não é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-388">Contract name is not serialized.</span></span>|<span data-ttu-id="c699c-389">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c699c-390">A personalização é used.\* \*</span><span class="sxs-lookup"><span data-stu-id="c699c-390">Customization is used.\*\*</span></span>|  
|<span data-ttu-id="c699c-391">Coleção personalizada</span><span class="sxs-lookup"><span data-stu-id="c699c-391">Customized collection</span></span>|<span data-ttu-id="c699c-392">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-392">Contract name is serialized.</span></span> <span data-ttu-id="c699c-393">A personalização não é used.\* \*</span><span class="sxs-lookup"><span data-stu-id="c699c-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="c699c-394">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="c699c-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c699c-395">Personalização do tipo atribuído é used.\* \*</span><span class="sxs-lookup"><span data-stu-id="c699c-395">Customization of the assigned type is used.\*\*</span></span>|  
  
 <span data-ttu-id="c699c-396">\* Com a <xref:System.Runtime.Serialization.NetDataContractSerializer> classe, personalização é usada nesse caso.</span><span class="sxs-lookup"><span data-stu-id="c699c-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="c699c-397">O <xref:System.Runtime.Serialization.NetDataContractSerializer> classe também serializa o nome do tipo real nesse caso, então, de desserialização funciona conforme o esperado.</span><span class="sxs-lookup"><span data-stu-id="c699c-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>  
  
 <span data-ttu-id="c699c-398">\* \* Esses casos resultam em instâncias de esquema inválido e, portanto, devem ser evitados.</span><span class="sxs-lookup"><span data-stu-id="c699c-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>  
  
 <span data-ttu-id="c699c-399">Nos casos em que o nome do contrato é serializado, o tipo de coleção atribuída deve ser na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="c699c-400">O oposto também é verdadeiro: nos casos em que o nome não é serializado, adicionar o tipo de lista de tipos conhecidos não é necessária.</span><span class="sxs-lookup"><span data-stu-id="c699c-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>  
  
 <span data-ttu-id="c699c-401">Uma matriz de um tipo derivado pode ser atribuída a uma matriz de um tipo base.</span><span class="sxs-lookup"><span data-stu-id="c699c-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="c699c-402">Nesse caso, o nome do contrato para o tipo derivado é serializado para cada elemento de repetição.</span><span class="sxs-lookup"><span data-stu-id="c699c-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="c699c-403">Por exemplo, se um tipo `Book` deriva do tipo `LibraryItem`, você pode atribuir uma matriz de `Book` para uma matriz de `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="c699c-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="c699c-404">Isso não se aplica a outros tipos de coleção.</span><span class="sxs-lookup"><span data-stu-id="c699c-404">This does not apply to other collection types.</span></span> <span data-ttu-id="c699c-405">Por exemplo, você não pode atribuir uma `Generic List of Book` para um `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="c699c-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="c699c-406">No entanto, você pode atribuir uma `Generic List of LibraryItem` que contém `Book` instâncias.</span><span class="sxs-lookup"><span data-stu-id="c699c-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="c699c-407">No caso não sejam de matriz e a matriz `Book` deve estar na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="c699c-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>  
  
## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="c699c-408">Coleções e preservação de referência de objeto</span><span class="sxs-lookup"><span data-stu-id="c699c-408">Collections and Object Reference Preservation</span></span>  
 <span data-ttu-id="c699c-409">Quando funções um serializador em um modo em que preserva as referências de objeto, preservação de referência de objeto também se aplica às coleções.</span><span class="sxs-lookup"><span data-stu-id="c699c-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="c699c-410">Especificamente, a identidade do objeto é preservada por coleções inteiras e contidos em coleções de itens individuais.</span><span class="sxs-lookup"><span data-stu-id="c699c-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="c699c-411">Para dicionários, a identidade do objeto é preservada para os objetos de par chave/valor e os objetos individuais de chave e valor.</span><span class="sxs-lookup"><span data-stu-id="c699c-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c699c-412">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c699c-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
