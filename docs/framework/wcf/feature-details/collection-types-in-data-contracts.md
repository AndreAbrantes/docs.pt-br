---
title: "Tipos de coleção em contratos de dados"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
caps.latest.revision: "19"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: ca3bbb4b88bf4355d3c487196672636e6b77d419
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/18/2017
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="243d3-102">Tipos de coleção em contratos de dados</span><span class="sxs-lookup"><span data-stu-id="243d3-102">Collection Types in Data Contracts</span></span>
<span data-ttu-id="243d3-103">Um *coleção* é uma lista de itens de um determinado tipo.</span><span class="sxs-lookup"><span data-stu-id="243d3-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="243d3-104">No [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], essas listas podem ser representadas usando matrizes ou em uma variedade de outros tipos (lista genérica, genérico <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, ou <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="243d3-104">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="243d3-105">Por exemplo, uma coleção pode conter uma lista de endereços para um cliente específico.</span><span class="sxs-lookup"><span data-stu-id="243d3-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="243d3-106">Essas coleções são chamadas *liste coleções*, independentemente de seu tipo real.</span><span class="sxs-lookup"><span data-stu-id="243d3-106">These collections are called *list collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="243d3-107">Uma forma especial de coleção existe que representa uma associação entre um item (a "chave") e outro (o "valor").</span><span class="sxs-lookup"><span data-stu-id="243d3-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="243d3-108">No [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], esses são representados pelos tipos como <xref:System.Collections.Hashtable> e o dicionário genérico.</span><span class="sxs-lookup"><span data-stu-id="243d3-108">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="243d3-109">Por exemplo, uma coleção de associação pode mapear uma cidade ("chave") para a população ("valor").</span><span class="sxs-lookup"><span data-stu-id="243d3-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="243d3-110">Essas coleções são chamadas *coleções de dicionário*, independentemente de seu tipo real.</span><span class="sxs-lookup"><span data-stu-id="243d3-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="243d3-111">Coleções recebem tratamento especial no modelo de contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="243d3-111">Collections receive special treatment in the data contract model.</span></span>  
  
 <span data-ttu-id="243d3-112">Tipos que implementam o <xref:System.Collections.IEnumerable> reconhecido interface, inclusive matrizes e coleções genéricas, como coleções.</span><span class="sxs-lookup"><span data-stu-id="243d3-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="243d3-113">Desses, tipos que implementam o <xref:System.Collections.IDictionary> ou genérico <xref:System.Collections.Generic.IDictionary%602> interfaces são coleções de dicionário; todos os outros são coleções de lista.</span><span class="sxs-lookup"><span data-stu-id="243d3-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>  
  
 <span data-ttu-id="243d3-114">Requisitos adicionais em tipos de coleção, como ter um método chamado `Add` e um construtor padrão, são discutidos em detalhes nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="243d3-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="243d3-115">Isso garante que os tipos de coleção podem ser serializados e desserializados.</span><span class="sxs-lookup"><span data-stu-id="243d3-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="243d3-116">Isso significa que algumas coleções não são diretamente suportadas, como genérica <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (porque ele não possui construtor padrão).</span><span class="sxs-lookup"><span data-stu-id="243d3-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="243d3-117">No entanto, para obter informações sobre como contornar essas restrições, consulte a seção "Usando coleção Interface tipos e coleções somente leitura", mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="243d3-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>  
  
 <span data-ttu-id="243d3-118">Os tipos contidos em coleções devem ser tipos de contrato de dados ou ser serializável.</span><span class="sxs-lookup"><span data-stu-id="243d3-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="243d3-119">[Tipos com suporte pelo serializador de contrato de dados](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="243d3-119"> [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="243d3-120">o que é e o que não é considerado uma coleção válida, bem como sobre como as coleções são serializadas, consulte as informações sobre serializando coleções na seção "Regras de coleta avançados" deste tópico.</span><span class="sxs-lookup"><span data-stu-id="243d3-120"> what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>  
  
## <a name="interchangeable-collections"></a><span data-ttu-id="243d3-121">Coleções intercambiáveis</span><span class="sxs-lookup"><span data-stu-id="243d3-121">Interchangeable Collections</span></span>  
 <span data-ttu-id="243d3-122">Todas as coleções de lista do mesmo tipo são consideradas como tendo os mesmos dados contrato (a menos que eles estão personalizados usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo, conforme discutido posteriormente neste tópico).</span><span class="sxs-lookup"><span data-stu-id="243d3-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="243d3-123">Assim, por exemplo, os contratos de dados a seguir são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="243d3-123">Thus, for example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
 [!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]  
  
 <span data-ttu-id="243d3-124">Ambos os contratos de dados resultam em XML semelhante ao seguinte código.</span><span class="sxs-lookup"><span data-stu-id="243d3-124">Both data contracts result in XML similar to the following code.</span></span>  
  
```xml  
<PurchaseOrder>  
    <customerName>...</customerName>  
    <items>  
        <Item>...</Item>  
        <Item>...</Item>  
        <Item>...</Item>  
        ...  
    </items>  
    <comments>  
        <string>...</string>  
        <string>...</string>  
        <string>...</string>  
        ...  
    </comments>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="243d3-125">Intercâmbio de coleção permite que você use, por exemplo, um tipo de coleção otimizado para desempenho do servidor e um tipo de coleção a ser associado a componentes de interface do usuário no cliente.</span><span class="sxs-lookup"><span data-stu-id="243d3-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>  
  
 <span data-ttu-id="243d3-126">Semelhante a coleções de lista, todas as coleções de dicionário que têm os mesmos tipos de chave e valor são consideradas como tendo os mesmos dados contrato (a menos que personalizado com o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo).</span><span class="sxs-lookup"><span data-stu-id="243d3-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>  
  
 <span data-ttu-id="243d3-127">Somente o assuntos de tipo de contrato de dados agora está preocupada equivalência de coleção, não os tipos de .NET.</span><span class="sxs-lookup"><span data-stu-id="243d3-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="243d3-128">Ou seja, uma coleção de Type1 é considerada equivalente a uma coleção de Type2 se Type1 e Type2 têm contratos de dados equivalentes.</span><span class="sxs-lookup"><span data-stu-id="243d3-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>  
  
 <span data-ttu-id="243d3-129">Coleções genéricas não são consideradas como tendo os mesmos dados contrato como coleções genéricas do tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="243d3-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="243d3-130">(Por exemplo, os dados de contratos para <xref:System.Collections.ArrayList> e genérica <xref:System.Collections.Generic.List%601> de `Object` são as mesmas.)</span><span class="sxs-lookup"><span data-stu-id="243d3-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>  
  
## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="243d3-131">Usando coleções somente leitura e os tipos de Interface de coleção</span><span class="sxs-lookup"><span data-stu-id="243d3-131">Using Collection Interface Types and Read-Only Collections</span></span>  
 <span data-ttu-id="243d3-132">Tipos de interface de coleção (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>genérica <xref:System.Collections.Generic.IDictionary%602>, ou interfaces derivam essas interfaces) também são considerados como tendo contratos de dados de coleção, equivalente a coleção de contratos de dados para tipos de coleção real.</span><span class="sxs-lookup"><span data-stu-id="243d3-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="243d3-133">Portanto, é possível declarar o tipo que está sendo serializado como um tipo de interface de coleção e os resultados são os mesmos, como se tivesse sido usado um tipo de coleção real.</span><span class="sxs-lookup"><span data-stu-id="243d3-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="243d3-134">Por exemplo, os contratos de dados a seguir são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="243d3-134">For example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
 [!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]  
  
 <span data-ttu-id="243d3-135">Durante a serialização, quando o tipo declarado é uma interface, o tipo de instância real usado pode ser qualquer tipo que implementa essa interface.</span><span class="sxs-lookup"><span data-stu-id="243d3-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="243d3-136">Restrições discutidos anteriormente (ter um construtor padrão e um `Add` método) não se aplicam.</span><span class="sxs-lookup"><span data-stu-id="243d3-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="243d3-137">Por exemplo, você pode definir endereços em Customer2 a uma instância do genérico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> do endereço, embora diretamente, você não pode declarar um membro de dados de tipo genérico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="243d3-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 <span data-ttu-id="243d3-138">Durante a desserialização, quando o tipo declarado é uma interface, o mecanismo de serialização escolhe um tipo que implementa a interface declarada e o tipo é instanciado.</span><span class="sxs-lookup"><span data-stu-id="243d3-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="243d3-139">De tipos conhecidos mecanismo (descrito na [tipos conhecidos de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) não tem nenhum efeito aqui; a escolha do tipo é criada em [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="243d3-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="customizing-collection-types"></a><span data-ttu-id="243d3-140">Personalizando tipos de coleção</span><span class="sxs-lookup"><span data-stu-id="243d3-140">Customizing Collection Types</span></span>  
 <span data-ttu-id="243d3-141">Você pode personalizar os tipos de coleção usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo, que tem vários usos.</span><span class="sxs-lookup"><span data-stu-id="243d3-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>  
  
 <span data-ttu-id="243d3-142">Observe que personalizando coleta tipos comprometimentos coleção obrigatórios, portanto, geralmente é recomendável para evitar aplicar esse atributo sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="243d3-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="243d3-143">Esse problema, consulte a seção "Regras de coleta avançados" mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="243d3-143"> this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="collection-data-contract-naming"></a><span data-ttu-id="243d3-144">Contrato de dados de coleção de nomenclatura</span><span class="sxs-lookup"><span data-stu-id="243d3-144">Collection Data Contract Naming</span></span>  
 <span data-ttu-id="243d3-145">As regras de nomeação de tipos de coleção são semelhantes às para nomear tipos de contrato de dados regulares, conforme descrito em [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md), embora existam algumas diferenças importantes:</span><span class="sxs-lookup"><span data-stu-id="243d3-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>  
  
-   <span data-ttu-id="243d3-146">O <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo é usado para personalizar o nome, em vez do <xref:System.Runtime.Serialization.DataContractAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="243d3-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="243d3-147">O <xref:System.Runtime.Serialization.CollectionDataContractAttribute> também tem um atributo `Name` e `Namespace` propriedades.</span><span class="sxs-lookup"><span data-stu-id="243d3-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>  
  
-   <span data-ttu-id="243d3-148">Quando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo não é aplicado, o nome padrão e o namespace para tipos de coleção dependem se os nomes e os namespaces de tipos contidos na coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="243d3-149">Eles não são afetados pelo nome e o namespace do tipo de coleção em si.</span><span class="sxs-lookup"><span data-stu-id="243d3-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="243d3-150">Para obter um exemplo, consulte os seguintes tipos.</span><span class="sxs-lookup"><span data-stu-id="243d3-150">For an example, see the following types.</span></span>  
  
    ```  
    public CustomerList1 : Collection<string> {}  
    public StringList1 : Collection<string> {}  
    ```  
  
 <span data-ttu-id="243d3-151">Nome de contrato de dados de ambos os tipos é "ArrayOfstring" e não "CustomerList1" ou "StringList1".</span><span class="sxs-lookup"><span data-stu-id="243d3-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="243d3-152">Isso significa que a serialização de qualquer um desses tipos no nível raiz gera XML semelhante ao seguinte código.</span><span class="sxs-lookup"><span data-stu-id="243d3-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>  
  
```xml  
<ArrayOfstring>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</ArrayOfstring>  
```  
  
 <span data-ttu-id="243d3-153">Essa regra de nomenclatura foi escolhida para garantir que qualquer tipo não personalizada que representa uma lista de cadeias de caracteres tem o mesmo contrato de dados e a representação XML.</span><span class="sxs-lookup"><span data-stu-id="243d3-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="243d3-154">Isso possibilita o intercâmbio de coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="243d3-155">Neste exemplo, CustomerList1 e StringList1 são intercambiáveis completamente.</span><span class="sxs-lookup"><span data-stu-id="243d3-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>  
  
 <span data-ttu-id="243d3-156">No entanto, quando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo é aplicado, a coleção se torna um contrato de dados de coleta personalizado, mesmo se nenhuma propriedade estiver definida no atributo.</span><span class="sxs-lookup"><span data-stu-id="243d3-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="243d3-157">O nome e o namespace dos dados de coleção de contrato e dependem do tipo de coleção em si.</span><span class="sxs-lookup"><span data-stu-id="243d3-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="243d3-158">Para obter um exemplo, consulte o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="243d3-158">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
 [!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]  
  
 <span data-ttu-id="243d3-159">Quando serializado, o XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="243d3-159">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList2>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</CustomerList2>  
```  
  
 <span data-ttu-id="243d3-160">Observe que isso não é equivalente a representação XML dos tipos não personalizada.</span><span class="sxs-lookup"><span data-stu-id="243d3-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>  
  
-   <span data-ttu-id="243d3-161">Você pode usar o `Name` e `Namespace` propriedades para obter mais personalizar a nomeação.</span><span class="sxs-lookup"><span data-stu-id="243d3-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="243d3-162">Consulte a seguinte classe.</span><span class="sxs-lookup"><span data-stu-id="243d3-162">See the following class.</span></span>  
  
     [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
     [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]  
  
 <span data-ttu-id="243d3-163">O XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="243d3-163">The resulting XML is similar to the following.</span></span>  
  
```xml  
<cust_list>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</cust_list>  
```  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="243d3-164">a seção "Regras de coleta avançada" neste tópico.</span><span class="sxs-lookup"><span data-stu-id="243d3-164"> the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="243d3-165">Personalizando o nome de elemento de repetição em coleções de lista</span><span class="sxs-lookup"><span data-stu-id="243d3-165">Customizing the Repeating Element Name in List Collections</span></span>  
 <span data-ttu-id="243d3-166">Lista de coleções contêm as entradas repetidas.</span><span class="sxs-lookup"><span data-stu-id="243d3-166">List collections contain repeating entries.</span></span> <span data-ttu-id="243d3-167">Normalmente, cada entrada de repetição é representada como um elemento nomeado de acordo com o nome do contrato de dados do tipo contido na coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>  
  
 <span data-ttu-id="243d3-168">No `CustomerList` exemplos, as cadeias de caracteres de coleções contidas.</span><span class="sxs-lookup"><span data-stu-id="243d3-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="243d3-169">O nome de contrato de dados para o tipo primitivo de cadeia de caracteres é "string", para o elemento de repetição foi "\<cadeia de caracteres >".</span><span class="sxs-lookup"><span data-stu-id="243d3-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>  
  
 <span data-ttu-id="243d3-170">No entanto, usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> propriedade o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo, essa repetição nome de elemento pode ser personalizado.</span><span class="sxs-lookup"><span data-stu-id="243d3-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="243d3-171">Para obter um exemplo, consulte o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="243d3-171">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
 [!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]  
  
 <span data-ttu-id="243d3-172">O XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="243d3-172">The resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList4>  
    <customer>...</ customer>  
    <customer>...</customer>  
    <customer>...</customer>  
    ...  
</CustomerList4>  
```  
  
 <span data-ttu-id="243d3-173">O namespace do elemento de repetição é sempre o mesmo que o namespace do contrato de dados de coleção, que pode ser personalizado usando o `Namespace` propriedade, conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="243d3-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>  
  
### <a name="customizing-dictionary-collections"></a><span data-ttu-id="243d3-174">Personalizando a coleções de dicionário</span><span class="sxs-lookup"><span data-stu-id="243d3-174">Customizing Dictionary Collections</span></span>  
 <span data-ttu-id="243d3-175">Coleções do dicionário são essencialmente listas de entradas, onde cada entrada tem uma chave seguida por um valor.</span><span class="sxs-lookup"><span data-stu-id="243d3-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="243d3-176">Assim como com listas regulares, você pode alterar o nome do elemento que corresponde ao elemento de repetição usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="243d3-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>  
  
 <span data-ttu-id="243d3-177">Além disso, você pode alterar os nomes dos elementos que representam a chave e o valor usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> e <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="243d3-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="243d3-178">Os namespaces para esses elementos são o mesmo que o namespace do contrato de dados de coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>  
  
 <span data-ttu-id="243d3-179">Para obter um exemplo, consulte o seguinte tipo.</span><span class="sxs-lookup"><span data-stu-id="243d3-179">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
 [!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]  
  
 <span data-ttu-id="243d3-180">Quando serializado, o XML resultante é semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="243d3-180">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CountriesOrRegionsWithCapitals>  
    <entry>  
        <countryorregion>USA</countryorregion>  
        <capital>Washington</capital>  
    </entry>  
    <entry>  
        <countryorregion>France</countryorregion>  
        <capital>Paris</capital>  
    </entry>  
    ...  
</CountriesOrRegionsWithCapitals>  
```  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="243d3-181">coleções de dicionário, consulte a seção "Regras de coleta avançados" mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="243d3-181"> dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
## <a name="collections-and-known-types"></a><span data-ttu-id="243d3-182">Coleções e tipos conhecidos</span><span class="sxs-lookup"><span data-stu-id="243d3-182">Collections and Known Types</span></span>  
 <span data-ttu-id="243d3-183">Você não precisa adicionar tipos de coleção de tipos conhecidos quando polimorficamente usado no lugar de outras coleções ou interfaces de coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="243d3-184">Por exemplo, se você declarar um membro de dados do tipo <xref:System.Collections.IEnumerable> e usá-lo para enviar uma instância do <xref:System.Collections.ArrayList>, você não precisa adicionar <xref:System.Collections.ArrayList> para tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="243d3-185">Quando você usa coleções polimorficamente no lugar de tipos de coleção não, eles devem ser adicionados aos tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="243d3-186">Por exemplo, se você declarar um membro de dados do tipo `Object` e usá-lo para enviar uma instância do <xref:System.Collections.ArrayList>, adicionar <xref:System.Collections.ArrayList> para tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="243d3-187">Isso não permite a serialização de qualquer coleção equivalente polimorficamente.</span><span class="sxs-lookup"><span data-stu-id="243d3-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="243d3-188">Por exemplo, quando você adiciona <xref:System.Collections.ArrayList> à lista de tipos conhecidos no exemplo anterior, isso não permite que você atribua a `Array of Object` classe, embora tenha um contrato de dados equivalente.</span><span class="sxs-lookup"><span data-stu-id="243d3-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="243d3-189">Isso não é diferente do comportamento de tipos conhecidos regular na serialização de tipos de coleção não, mas é especialmente importante entender no caso de coleções porque é muito comum a ser equivalente para coleções.</span><span class="sxs-lookup"><span data-stu-id="243d3-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>  
  
 <span data-ttu-id="243d3-190">Durante a serialização, apenas um tipo pode ser conhecido no escopo especificado para um contrato de dados e equivalentes coleções de todos os tem os mesmos contratos de dados.</span><span class="sxs-lookup"><span data-stu-id="243d3-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="243d3-191">Isso significa que, no exemplo anterior, você não pode adicionar ambos <xref:System.Collections.ArrayList> e `Array of Object` para tipos conhecidos no mesmo escopo.</span><span class="sxs-lookup"><span data-stu-id="243d3-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="243d3-192">Novamente, isso é equivalente ao comportamento de tipos conhecidos para tipos de coleção não, mas é especialmente importante entender para coleções.</span><span class="sxs-lookup"><span data-stu-id="243d3-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>  
  
 <span data-ttu-id="243d3-193">Também podem ser necessários para conteúdo de coleções de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="243d3-194">Por exemplo, se um <xref:System.Collections.ArrayList> realmente contém instâncias de `Type1` e `Type2`, ambos os tipos devem ser adicionados aos tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>  
  
 <span data-ttu-id="243d3-195">O exemplo a seguir mostra um gráfico de objeto construído corretamente usando coleções e tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="243d3-196">O exemplo é um pouco contrived porque em um aplicativo real, você normalmente não deve definir os seguintes membros de dados como `Object`e, portanto, não terão problemas conhecidos de tipo/polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="243d3-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
 [!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]  
  
 <span data-ttu-id="243d3-197">Na desserialização, se o tipo declarado é um tipo de coleção, o tipo declarado é instanciado, independentemente do tipo que foi enviado.</span><span class="sxs-lookup"><span data-stu-id="243d3-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="243d3-198">Se o tipo declarado é uma interface de coleção, o desserializador escolhe um tipo a ser instanciado com nenhuma relação para tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>  
  
 <span data-ttu-id="243d3-199">Também na desserialização, se o tipo declarado não é um tipo de coleção, mas um tipo de coleção está sendo enviado, um tipo de coleção correspondente é escolhido fora da lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="243d3-200">É possível adicionar tipos de interface de coleção para a lista de tipos conhecidos na desserialização.</span><span class="sxs-lookup"><span data-stu-id="243d3-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="243d3-201">Nesse caso, o mecanismo de desserialização novamente escolhe um tipo a ser instanciado.</span><span class="sxs-lookup"><span data-stu-id="243d3-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>  
  
## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="243d3-202">A classe NetDataContractSerializer e coleções</span><span class="sxs-lookup"><span data-stu-id="243d3-202">Collections and the NetDataContractSerializer Class</span></span>  
 <span data-ttu-id="243d3-203">Quando o <xref:System.Runtime.Serialization.NetDataContractSerializer> classe está em uso, tipos de coleção não personalizada (sem o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo) que são matrizes não perca seu significado especial.</span><span class="sxs-lookup"><span data-stu-id="243d3-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>  
  
 <span data-ttu-id="243d3-204">Tipos de coleção personalizados não marcado com o <xref:System.SerializableAttribute> ainda pode ser serializado com atributo pelo <xref:System.Runtime.Serialization.NetDataContractSerializer> classe de acordo com o <xref:System.SerializableAttribute> atributo ou o <xref:System.Runtime.Serialization.ISerializable> regras de interface.</span><span class="sxs-lookup"><span data-stu-id="243d3-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>  
  
 <span data-ttu-id="243d3-205">Tipos de coleção personalizados, interfaces de coleção e matrizes ainda são tratados como coleções, mesmo quando o <xref:System.Runtime.Serialization.NetDataContractSerializer> classe está em uso.</span><span class="sxs-lookup"><span data-stu-id="243d3-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>  
  
## <a name="collections-and-schema"></a><span data-ttu-id="243d3-206">Coleções e esquema</span><span class="sxs-lookup"><span data-stu-id="243d3-206">Collections and Schema</span></span>  
 <span data-ttu-id="243d3-207">Todas as coleções equivalentes possuem a mesma representação no esquema de linguagem XSD de definição de esquema XML.</span><span class="sxs-lookup"><span data-stu-id="243d3-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="243d3-208">Por isso, você normalmente não obtém o mesmo tipo de coleção no código do cliente gerado como um no servidor.</span><span class="sxs-lookup"><span data-stu-id="243d3-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="243d3-209">Por exemplo, o servidor pode usar um contrato de dados com um genérico <xref:System.Collections.Generic.List%601> de membro de dados inteiro, mas no código do cliente gerado do mesmo membro de dados pode se tornar uma matriz de inteiros.</span><span class="sxs-lookup"><span data-stu-id="243d3-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>  
  
 <span data-ttu-id="243d3-210">Coleções do dicionário são marcadas com um [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-anotação de esquema específico que indicar que eles são dicionários; caso contrário, eles são indistinguíveis de listas simples que contém entradas com uma chave e um valor.</span><span class="sxs-lookup"><span data-stu-id="243d3-210">Dictionary collections are marked with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="243d3-211">Para obter uma descrição exata de como as coleções são representadas no esquema de contrato de dados, consulte [referência de esquema de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="243d3-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="243d3-212">Por padrão, os tipos não são gerados para coleções não personalizada em código importado.</span><span class="sxs-lookup"><span data-stu-id="243d3-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="243d3-213">Membros de dados de lista de tipos de coleção são importados como matrizes e membros de dados de dicionário de tipos de coleção são importados como um dicionário genérico.</span><span class="sxs-lookup"><span data-stu-id="243d3-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>  
  
 <span data-ttu-id="243d3-214">No entanto, para coleções personalizadas, tipos separados são gerados, marcado com o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="243d3-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="243d3-215">(Um tipo de coleção personalizada no esquema é aquele que não usa o namespace padrão, nome, repetição elemento nome ou chave/valor nomes de elemento.) Esses tipos são vazios tipos que derivam genérico <xref:System.Collections.Generic.List%601> para tipos de lista e um dicionário genérico para tipos de dicionário.</span><span class="sxs-lookup"><span data-stu-id="243d3-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>  
  
 <span data-ttu-id="243d3-216">Por exemplo, você pode ter os seguintes tipos no servidor.</span><span class="sxs-lookup"><span data-stu-id="243d3-216">For example, you may have the following types on the server.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
 [!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]  
  
 <span data-ttu-id="243d3-217">Quando o esquema é exportado e importados novamente, o código de cliente gerado é semelhante à seguinte (os campos são exibidos em vez de propriedades para facilitar a leitura).</span><span class="sxs-lookup"><span data-stu-id="243d3-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
 [!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]  
  
 <span data-ttu-id="243d3-218">Você talvez queira usar tipos diferentes no código gerado que as definições padrão.</span><span class="sxs-lookup"><span data-stu-id="243d3-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="243d3-219">Por exemplo, você talvez queira usar genéricos <xref:System.ComponentModel.BindingList%601> em vez de matrizes regulares para os membros de dados facilitar a associá-las a componentes de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="243d3-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>  
  
 <span data-ttu-id="243d3-220">Para escolher os tipos de coleção para gerar, passar uma lista de tipos de coleção que você deseja usar para o <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> propriedade o <xref:System.Runtime.Serialization.ImportOptions> ao importar o esquema do objeto.</span><span class="sxs-lookup"><span data-stu-id="243d3-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="243d3-221">Esses tipos são chamados *referenciado tipos de coleção*.</span><span class="sxs-lookup"><span data-stu-id="243d3-221">These types are called *referenced collection types*.</span></span>  
  
 <span data-ttu-id="243d3-222">Quando estão sendo referenciados tipos genéricos, eles devem ser genéricos totalmente aberto ou fechado totalmente genéricos.</span><span class="sxs-lookup"><span data-stu-id="243d3-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="243d3-223">Ao usar a ferramenta Svcutil.exe, essa referência pode ser feita usando o **/collectionType** opção de linha de comando (forma abreviada: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="243d3-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="243d3-224">Tenha em mente que você também deve especificar o assembly para os tipos de coleção referenciada usando o **/Reference** alternar (forma abreviada: **/r**).</span><span class="sxs-lookup"><span data-stu-id="243d3-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="243d3-225">Se o tipo é genérico, ele deve ser seguido uma cotação voltar e o número de parâmetros genéricos.</span><span class="sxs-lookup"><span data-stu-id="243d3-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="243d3-226">É a back aspas (') não deve ser confundido com o caractere de aspas simples (').</span><span class="sxs-lookup"><span data-stu-id="243d3-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="243d3-227">Você pode especificar vários tipos de coleção referenciada usando o **/collectionType** alternar mais de uma vez.</span><span class="sxs-lookup"><span data-stu-id="243d3-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>  
  
 <span data-ttu-id="243d3-228">Por exemplo, para fazer com que todas as listas são importados como genérica <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="243d3-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
```  
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1  
```  
  
 <span data-ttu-id="243d3-229">Ao importar qualquer coleção, esta lista de tipos de coleção referenciado é examinada e a coleção de melhor correspondência é usada se uma for encontrada, como um tipo de membro de dados (para coleções não personalizada) ou como um tipo base para derivar de (para coleções personalizadas).</span><span class="sxs-lookup"><span data-stu-id="243d3-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="243d3-230">Dicionários só são comparados com dicionários, enquanto as listas são comparadas com listas.</span><span class="sxs-lookup"><span data-stu-id="243d3-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>  
  
 <span data-ttu-id="243d3-231">Por exemplo, se você adicionar genérica <xref:System.ComponentModel.BindingList%601> e <xref:System.Collections.Hashtable> à lista de tipos referenciados, o código de cliente gerada para o exemplo anterior é semelhante à seguinte.</span><span class="sxs-lookup"><span data-stu-id="243d3-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
 [!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]  
  
 <span data-ttu-id="243d3-232">Você pode especificar os tipos de interface de coleção como parte de seus tipos de coleção referenciada, mas você não pode especificar os tipos de coleção inválido (como aqueles sem nenhum `Add` método ou construtor público).</span><span class="sxs-lookup"><span data-stu-id="243d3-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>  
  
 <span data-ttu-id="243d3-233">Um genérico fechado é considerado a melhor correspondência.</span><span class="sxs-lookup"><span data-stu-id="243d3-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="243d3-234">(Tipos genéricos não são considerados equivalentes aos genéricos fechados de `Object`).</span><span class="sxs-lookup"><span data-stu-id="243d3-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="243d3-235">Por exemplo, se os tipos genéricos <xref:System.Collections.Generic.List%601> de <xref:System.DateTime>genérica <xref:System.ComponentModel.BindingList%601> (genérico aberto), e <xref:System.Collections.ArrayList> são os tipos de coleção referenciada, o seguinte é gerado.</span><span class="sxs-lookup"><span data-stu-id="243d3-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
 [!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]  
  
 <span data-ttu-id="243d3-236">Para coleções de lista, somente os casos na tabela a seguir têm suporte.</span><span class="sxs-lookup"><span data-stu-id="243d3-236">For list collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="243d3-237">Tipo referenciado</span><span class="sxs-lookup"><span data-stu-id="243d3-237">Referenced type</span></span>|<span data-ttu-id="243d3-238">Interface implementada pelo tipo referenciado</span><span class="sxs-lookup"><span data-stu-id="243d3-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="243d3-239">Exemplo</span><span class="sxs-lookup"><span data-stu-id="243d3-239">Example</span></span>|<span data-ttu-id="243d3-240">Tipo é tratado como:</span><span class="sxs-lookup"><span data-stu-id="243d3-240">Type treated as:</span></span>|  
|---------------------|----------------------------------------------|-------------|----------------------|  
|<span data-ttu-id="243d3-241">Não genérico ou fechado genérico (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="243d3-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="243d3-242">Não genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="243d3-243">ou</span><span class="sxs-lookup"><span data-stu-id="243d3-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="243d3-244">onde T =`int`</span><span class="sxs-lookup"><span data-stu-id="243d3-244">where T= `int`</span></span>|<span data-ttu-id="243d3-245">Fechado genérico de `Object` (por exemplo, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|  
|<span data-ttu-id="243d3-246">Não genérico ou fechado genérico (qualquer número de parâmetros que não necessariamente correspondem ao tipo de coleção)</span><span class="sxs-lookup"><span data-stu-id="243d3-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="243d3-247">Fechado genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="243d3-248">ou</span><span class="sxs-lookup"><span data-stu-id="243d3-248">or</span></span><br /><br /> <span data-ttu-id="243d3-249">`MyType<T> : IList<string>`onde T =`int`</span><span class="sxs-lookup"><span data-stu-id="243d3-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="243d3-250">Genérico fechado (por exemplo, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-250">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="243d3-251">Fechado genérico com qualquer número de parâmetros</span><span class="sxs-lookup"><span data-stu-id="243d3-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="243d3-252">Abra genérico usando qualquer um dos parâmetros do tipo</span><span class="sxs-lookup"><span data-stu-id="243d3-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="243d3-253">onde T =`int`, U =`string`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="243d3-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="243d3-254">Genérico fechado (por exemplo, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-254">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="243d3-255">Genérico aberto com um parâmetro</span><span class="sxs-lookup"><span data-stu-id="243d3-255">Open generic with one parameter</span></span>|<span data-ttu-id="243d3-256">Genérico aberto usando o parâmetro do tipo</span><span class="sxs-lookup"><span data-stu-id="243d3-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="243d3-257">`MyType<T> : IList<T>`, T é aberto</span><span class="sxs-lookup"><span data-stu-id="243d3-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="243d3-258">Genérico aberto (por exemplo, `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-258">Open generic (for example, `IList<T>`)</span></span>|  
  
 <span data-ttu-id="243d3-259">Se um tipo implementa mais de uma interface de coleção da lista, as seguintes restrições se aplicam:</span><span class="sxs-lookup"><span data-stu-id="243d3-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="243d3-260">Se o tipo implementa genérico <xref:System.Collections.Generic.IEnumerable%601> (ou suas interfaces derivadas) várias vezes para tipos diferentes, o tipo não é considerado um tipo de coleção referenciado válido e será ignorado.</span><span class="sxs-lookup"><span data-stu-id="243d3-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="243d3-261">Isso é verdadeiro mesmo se algumas implementações são inválidas ou usam genéricos abertos.</span><span class="sxs-lookup"><span data-stu-id="243d3-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="243d3-262">Por exemplo, um tipo que implementa genérico <xref:System.Collections.Generic.IEnumerable%601> de `int` e genérica <xref:System.Collections.Generic.IEnumerable%601> de T nunca serão usadas como uma coleção referenciada de `int` ou qualquer outro tipo, independentemente se o tipo tem um `Add` método aceitar `int` ou um `Add` método aceita um parâmetro de tipo T, ou ambos.</span><span class="sxs-lookup"><span data-stu-id="243d3-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>  
  
-   <span data-ttu-id="243d3-263">Se o tipo implementa uma interface de coleção genérica, bem como <xref:System.Collections.IList>, o tipo nunca é usado como um tipo de coleção referenciada, a menos que a interface de coleção genérica é fechado genérico do tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="243d3-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="243d3-264">Para coleções de dicionário, somente os casos na tabela a seguir têm suporte.</span><span class="sxs-lookup"><span data-stu-id="243d3-264">For dictionary collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="243d3-265">Tipo referenciado</span><span class="sxs-lookup"><span data-stu-id="243d3-265">Referenced type</span></span>|<span data-ttu-id="243d3-266">Interface implementada pelo tipo referenciado</span><span class="sxs-lookup"><span data-stu-id="243d3-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="243d3-267">Exemplo</span><span class="sxs-lookup"><span data-stu-id="243d3-267">Example</span></span>|<span data-ttu-id="243d3-268">Tipo tratado como</span><span class="sxs-lookup"><span data-stu-id="243d3-268">Type treated as</span></span>|  
|---------------------|----------------------------------------------|-------------|---------------------|  
|<span data-ttu-id="243d3-269">Não genérico ou fechado genérico (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="243d3-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="243d3-270">ou</span><span class="sxs-lookup"><span data-stu-id="243d3-270">or</span></span><br /><br /> <span data-ttu-id="243d3-271">`MyType<T> : IDictionary`onde T =`int`</span><span class="sxs-lookup"><span data-stu-id="243d3-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="243d3-272">Fechado genérico`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="243d3-272">Closed generic `IDictionary<object,object>`</span></span>|  
|<span data-ttu-id="243d3-273">Genérico fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="243d3-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="243d3-274"><xref:System.Collections.Generic.IDictionary%602>, fechado</span><span class="sxs-lookup"><span data-stu-id="243d3-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="243d3-275">`MyType<T> : IDictionary\<string, bool>`onde T =`int`</span><span class="sxs-lookup"><span data-stu-id="243d3-275">`MyType<T> : IDictionary\<string, bool>` where T=`int`</span></span>|<span data-ttu-id="243d3-276">Genérico fechado (por exemplo, `IDIctionary\<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-276">Closed generic (for example, `IDIctionary\<string,bool>`)</span></span>|  
|<span data-ttu-id="243d3-277">Genérico fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="243d3-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="243d3-278">Genérica <xref:System.Collections.Generic.IDictionary%602>, chave ou valor é fechado, o outro está aberto e usa um dos parâmetros do tipo</span><span class="sxs-lookup"><span data-stu-id="243d3-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="243d3-279">`MyType\<T,U,V> : IDictionary\<string,V>`onde T =`int`, U =`float`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="243d3-279">`MyType\<T,U,V> : IDictionary\<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="243d3-280">ou</span><span class="sxs-lookup"><span data-stu-id="243d3-280">or</span></span><br /><br /> <span data-ttu-id="243d3-281">`MyType<Z> : IDictionary\<Z,bool>`onde Z =`string`</span><span class="sxs-lookup"><span data-stu-id="243d3-281">`MyType<Z> : IDictionary\<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="243d3-282">Genérico fechado (por exemplo, `IDictionary\<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-282">Closed generic (For example, `IDictionary\<string,bool>`)</span></span>|  
|<span data-ttu-id="243d3-283">Genérico fechado (qualquer número de parâmetros)</span><span class="sxs-lookup"><span data-stu-id="243d3-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="243d3-284">Genérica <xref:System.Collections.Generic.IDictionary%602>, chave e valor são abertos e cada uma usa um dos parâmetros do tipo</span><span class="sxs-lookup"><span data-stu-id="243d3-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="243d3-285">`MyType\<T,U,V> : IDictionary\<V,U>`onde T =`int`, U =`bool`, V =`string`</span><span class="sxs-lookup"><span data-stu-id="243d3-285">`MyType\<T,U,V> : IDictionary\<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="243d3-286">Genérico fechado (por exemplo, `IDictionary\<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-286">Closed generic (for example, `IDictionary\<string,bool>`)</span></span>|  
|<span data-ttu-id="243d3-287">Abra genérico (dois parâmetros)</span><span class="sxs-lookup"><span data-stu-id="243d3-287">Open generic (two parameters)</span></span>|<span data-ttu-id="243d3-288">Genérica <xref:System.Collections.Generic.IDictionary%602>, abrir, que usa dois parâmetros genéricos do tipo na ordem em que aparecem</span><span class="sxs-lookup"><span data-stu-id="243d3-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="243d3-289">`MyType\<K,V> : IDictionary\<K,V>`, K e V abertos</span><span class="sxs-lookup"><span data-stu-id="243d3-289">`MyType\<K,V> : IDictionary\<K,V>`, K and V both open</span></span>|<span data-ttu-id="243d3-290">Genérico aberto (por exemplo, `IDictionary\<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="243d3-290">Open generic (for example, `IDictionary\<K,V>`)</span></span>|  
  
 <span data-ttu-id="243d3-291">Se o tipo implementa ambos <xref:System.Collections.IDictionary> e genérica <xref:System.Collections.Generic.IDictionary%602>somente genérica <xref:System.Collections.Generic.IDictionary%602> é considerada.</span><span class="sxs-lookup"><span data-stu-id="243d3-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>  
  
 <span data-ttu-id="243d3-292">Não há suporte para referenciar tipos genéricos parciais.</span><span class="sxs-lookup"><span data-stu-id="243d3-292">Referencing partial generic types is not supported.</span></span>  
  
 <span data-ttu-id="243d3-293">Não são permitidas duplicatas, por exemplo, você não pode adicionar os dois genérica <xref:System.Collections.Generic.List%601> de `Integer` e a coleção genérica de `Integer` para <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, pois isso torna impossível determinar qual delas usar quando uma lista de inteiros foi encontrado no esquema.</span><span class="sxs-lookup"><span data-stu-id="243d3-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="243d3-294">Duplicatas são detectadas somente se houver um tipo no esquema que expõe o problema de duplicatas.</span><span class="sxs-lookup"><span data-stu-id="243d3-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="243d3-295">Por exemplo, se o esquema que está sendo importado não contém listas de números inteiros, ele é permitido ter ambos genérica <xref:System.Collections.Generic.List%601> de `Integer` e a coleção genérica de `Integer` no <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, mas não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="243d3-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>  
  
## <a name="advanced-collection-rules"></a><span data-ttu-id="243d3-296">Regras de coleta avançados</span><span class="sxs-lookup"><span data-stu-id="243d3-296">Advanced Collection Rules</span></span>  
  
### <a name="serializing-collections"></a><span data-ttu-id="243d3-297">Serializando coleções</span><span class="sxs-lookup"><span data-stu-id="243d3-297">Serializing Collections</span></span>  
 <span data-ttu-id="243d3-298">A seguir está uma lista de regras de coleção para a serialização:</span><span class="sxs-lookup"><span data-stu-id="243d3-298">The following is a list of collection rules for serialization:</span></span>  
  
-   <span data-ttu-id="243d3-299">A combinação de tipos de coleção (com coleções de coleções) é permitida.</span><span class="sxs-lookup"><span data-stu-id="243d3-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="243d3-300">Matrizes denteadas são tratados como coleções de coleções.</span><span class="sxs-lookup"><span data-stu-id="243d3-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="243d3-301">Não há suporte para matrizes multidimensionais.</span><span class="sxs-lookup"><span data-stu-id="243d3-301">Multidimensional arrays are not supported.</span></span>  
  
-   <span data-ttu-id="243d3-302">Matrizes de bytes e matrizes de <xref:System.Xml.XmlNode> são tipos especiais de matriz são tratados como tipos primitivos, coleções não.</span><span class="sxs-lookup"><span data-stu-id="243d3-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="243d3-303">Serialização de uma matriz de bytes de resultados em um único elemento XML que contém um bloco de dados codificados na Base64, em vez de um elemento separado para cada byte.</span><span class="sxs-lookup"><span data-stu-id="243d3-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="243d3-304">como uma matriz de <xref:System.Xml.XmlNode> é tratado, consulte [XML e tipos de ADO.NET em contratos de dados](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="243d3-304"> how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="243d3-305">Obviamente, esses tipos especiais próprios participem de coleções: uma matriz de conjunto de resultados de bytes em vários elementos XML, com cada um contendo uma parte dos dados codificados na Base64.</span><span class="sxs-lookup"><span data-stu-id="243d3-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>  
  
-   <span data-ttu-id="243d3-306">Se o <xref:System.Runtime.Serialization.DataContractAttribute> atributo é aplicado a um tipo de coleção, o tipo é tratado como um tipo de contrato de dados regular, não como uma coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>  
  
-   <span data-ttu-id="243d3-307">Se um tipo de coleção implementa o <xref:System.Xml.Serialization.IXmlSerializable> interface, as seguintes regras se aplicam, considerando um tipo `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="243d3-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>  
  
    -   <span data-ttu-id="243d3-308">Se o tipo declarado é `IList<string>`, o tipo é serializado como uma lista.</span><span class="sxs-lookup"><span data-stu-id="243d3-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>  
  
    -   <span data-ttu-id="243d3-309">Se o tipo declarado é `myType`, ele é serializado como `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="243d3-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>  
  
    -   <span data-ttu-id="243d3-310">Se o tipo declarado é `IXmlSerializable`, ele é serializado como `IXmlSerializable`, mas somente se você adicionar `myType` à lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>  
  
-   <span data-ttu-id="243d3-311">Coleções são serializadas e desserializados usando os métodos mostrados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="243d3-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>  
  
|<span data-ttu-id="243d3-312">Implementa o tipo de coleção</span><span class="sxs-lookup"><span data-stu-id="243d3-312">Collection type implements</span></span>|<span data-ttu-id="243d3-313">Método chamado em serialização</span><span class="sxs-lookup"><span data-stu-id="243d3-313">Method(s) called on serialization</span></span>|<span data-ttu-id="243d3-314">Chamada de método (s) na desserialização</span><span class="sxs-lookup"><span data-stu-id="243d3-314">Method(s) called on deserialization</span></span>|  
|--------------------------------|-----------------------------------------|-------------------------------------------|  
|<span data-ttu-id="243d3-315"><xref:System.Collections.Generic.IDictionary%602>genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="243d3-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="243d3-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="243d3-317">Adicionar genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-317">Generic Add</span></span>|  
|<xref:System.Collections.IDictionary>|<span data-ttu-id="243d3-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="243d3-318">`get_Keys`, `get_Values`</span></span>|`Add`|  
|<span data-ttu-id="243d3-319"><xref:System.Collections.Generic.IList%601>genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="243d3-320">Genérica <xref:System.Collections.Generic.IList%601> indexador</span><span class="sxs-lookup"><span data-stu-id="243d3-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="243d3-321">Adicionar genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-321">Generic Add</span></span>|  
|<span data-ttu-id="243d3-322"><xref:System.Collections.Generic.ICollection%601>genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="243d3-323">Enumerador</span><span class="sxs-lookup"><span data-stu-id="243d3-323">Enumerator</span></span>|<span data-ttu-id="243d3-324">Adicionar genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-324">Generic Add</span></span>|  
|<xref:System.Collections.IList>|<span data-ttu-id="243d3-325"><xref:System.Collections.IList>Indexador</span><span class="sxs-lookup"><span data-stu-id="243d3-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|  
|<span data-ttu-id="243d3-326"><xref:System.Collections.Generic.IEnumerable%601>genérico</span><span class="sxs-lookup"><span data-stu-id="243d3-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="243d3-327">Um método não estático chamado `Add` que recebe um parâmetro do tipo apropriado (o tipo do parâmetro genérico) ou um de seus tipos base.</span><span class="sxs-lookup"><span data-stu-id="243d3-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="243d3-328">Esse método um deve existir para o serializador tratar um tipo de coleção como uma coleção durante a serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="243d3-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
|<span data-ttu-id="243d3-329"><xref:System.Collections.IEnumerable>(e, portanto, <xref:System.Collections.ICollection>, que é derivado dele)</span><span class="sxs-lookup"><span data-stu-id="243d3-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="243d3-330">Um método não estático chamado `Add` que recebe um parâmetro do tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="243d3-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="243d3-331">Esse método um deve existir para o serializador tratar um tipo de coleção como uma coleção durante a serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="243d3-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
  
 <span data-ttu-id="243d3-332">A tabela anterior lista interfaces de coleção em ordem decrescente de precedência.</span><span class="sxs-lookup"><span data-stu-id="243d3-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="243d3-333">Isso significa que, por exemplo, que se um tipo implementa ambos <xref:System.Collections.IList> e genérica <xref:System.Collections.Generic.IEnumerable%601>, a coleção é serializada e desserializada de acordo com o <xref:System.Collections.IList> regras:</span><span class="sxs-lookup"><span data-stu-id="243d3-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>  
  
-   <span data-ttu-id="243d3-334">A desserialização, todas as coleções são desserializadas pelo primeiro criar uma instância do tipo chamando o construtor padrão, que deve estar presente para o serializador tratar um tipo de coleção como uma coleção durante a serialização e desserialização.</span><span class="sxs-lookup"><span data-stu-id="243d3-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>  
  
-   <span data-ttu-id="243d3-335">Se a mesma interface de coleção genérica é implementada mais de uma vez (por exemplo, se um tipo implementa tanto do genérico <xref:System.Collections.Generic.ICollection%601> de `Integer` e genérica <xref:System.Collections.Generic.ICollection%601> de <xref:System.String>) e nenhuma interface de precedência mais alta for encontrado, a coleção é não é tratado como uma coleção válida.</span><span class="sxs-lookup"><span data-stu-id="243d3-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>  
  
-   <span data-ttu-id="243d3-336">Tipos de coleção podem ter o <xref:System.SerializableAttribute> atributo aplicado a eles e pode implementar o <xref:System.Runtime.Serialization.ISerializable> interface.</span><span class="sxs-lookup"><span data-stu-id="243d3-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="243d3-337">Ambos são ignorados.</span><span class="sxs-lookup"><span data-stu-id="243d3-337">Both of these are ignored.</span></span> <span data-ttu-id="243d3-338">No entanto, se o tipo não totalmente atende aos requisitos de tipo de coleção (por exemplo, o `Add` método está ausente), o tipo não é considerado um tipo de coleção e, portanto, o <xref:System.SerializableAttribute> atributo e o <xref:System.Runtime.Serialization.ISerializable> interface são usados para determinar o tipo pode ser serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>  
  
-   <span data-ttu-id="243d3-339">Aplicar o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo a uma coleção para personalizá-la remove o <xref:System.SerializableAttribute> precede o mecanismo de fallback.</span><span class="sxs-lookup"><span data-stu-id="243d3-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="243d3-340">Em vez disso, se uma coleção personalizada coleção não atender aos requisitos de tipos, um <xref:System.Runtime.Serialization.InvalidDataContractException> exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="243d3-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="243d3-341">A cadeia de caracteres de exceção geralmente contém informações que explicam por que um determinado tipo não é considerado uma coleção válida (nenhum `Add` método, nenhum construtor padrão e assim por diante), portanto, geralmente é útil aplicar o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo para fins de depuração.</span><span class="sxs-lookup"><span data-stu-id="243d3-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>  
  
### <a name="collection-naming"></a><span data-ttu-id="243d3-342">Coleção de nomenclatura</span><span class="sxs-lookup"><span data-stu-id="243d3-342">Collection Naming</span></span>  
 <span data-ttu-id="243d3-343">A seguir está uma lista das regras de nomenclatura de coleção:</span><span class="sxs-lookup"><span data-stu-id="243d3-343">The following is a list of collection naming rules:</span></span>  
  
-   <span data-ttu-id="243d3-344">O namespace padrão para todos os contratos de dados de coleção de dicionário, bem como para contratos de dados de coleção de lista que contém os tipos primitivos, é http://schemas.microsoft.com/2003/10/Serialization/Arrays a menos que substituído usando o Namespace.</span><span class="sxs-lookup"><span data-stu-id="243d3-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is http://schemas.microsoft.com/2003/10/Serialization/Arrays unless overridden using Namespace.</span></span> <span data-ttu-id="243d3-345">Tipos que são mapeados para tipos XSD internos, bem como `char`, `Timespan`, e `Guid` tipos, são consideradas primitivos para essa finalidade.</span><span class="sxs-lookup"><span data-stu-id="243d3-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>  
  
-   <span data-ttu-id="243d3-346">O namespace padrão para tipos de coleção que contém os tipos de não primitivo, a menos que ele seja substituído usando o Namespace, é o mesmo que o namespace de contrato de dados do tipo contido na coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>  
  
-   <span data-ttu-id="243d3-347">O nome padrão para contratos de dados de coleção de lista, a menos que substituído usando o nome, é a cadeia de caracteres "ArrayOf" combinado com o nome de contrato de dados do tipo contido na coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="243d3-348">Por exemplo, o nome de contrato de dados para uma lista de inteiros genérico é "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="243d3-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="243d3-349">Tenha em mente que o contrato de dados nome do `Object` é "anyType", portanto, como o nome de contrato de dados de listas não genérico <xref:System.Collections.ArrayList> é "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="243d3-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>  
  
 <span data-ttu-id="243d3-350">O nome padrão para dados de coleção de dicionário de contratos, a menos que substituído usando `Name`, é a cadeia de caracteres "ArrayOfKeyValueOf" combinado com o nome de contrato de dados do tipo de chave, seguido do nome de contrato de dados do tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="243d3-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="243d3-351">Por exemplo, os dados de nome de contrato para um dicionário de cadeia de caracteres genérica e inteiro é "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="243d3-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="243d3-352">Além disso, se os tipos de valor ou a chave não são tipos primitivos, um hash de namespace dos namespaces de contrato de dados dos tipos de chave e o valor é anexado ao nome.</span><span class="sxs-lookup"><span data-stu-id="243d3-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="243d3-353">hashes de namespace, consulte [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="243d3-353"> namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
 <span data-ttu-id="243d3-354">Cada contrato de dados de coleção de dicionário tem um contrato de dados complementares que representa uma entrada no dicionário.</span><span class="sxs-lookup"><span data-stu-id="243d3-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="243d3-355">Seu nome é o mesmo para o contrato de dados do dicionário, exceto para o prefixo "ArrayOf", e seu namespace é o mesmo contrato de dados de dicionário.</span><span class="sxs-lookup"><span data-stu-id="243d3-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="243d3-356">Por exemplo, para o contrato de dados de dicionário "ArrayOfKeyValueOfstringint", o contrato de dados "KeyValueofstringint" representa uma entrada no dicionário.</span><span class="sxs-lookup"><span data-stu-id="243d3-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="243d3-357">Você pode personalizar o nome do contrato de dados usando o `ItemName` propriedade, conforme descrito na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="243d3-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>  
  
 <span data-ttu-id="243d3-358">Regras de nomenclatura de tipo genérico conforme descrito em [nomes de contrato de dados](../../../../docs/framework/wcf/feature-details/data-contract-names.md), totalmente se aplicam a tipos de coleção; o que é, você pode usar as chaves no nome para indicar parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="243d3-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="243d3-359">No entanto, os números dentro dos colchetes consultem parâmetros genéricos e não os tipos contidos na coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>  
  
## <a name="collection-customization"></a><span data-ttu-id="243d3-360">Personalização de coleção</span><span class="sxs-lookup"><span data-stu-id="243d3-360">Collection Customization</span></span>  
 <span data-ttu-id="243d3-361">Os seguintes usos da <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo são proibidos e resultar em um <xref:System.Runtime.Serialization.InvalidDataContractException> exceção:</span><span class="sxs-lookup"><span data-stu-id="243d3-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>  
  
-   <span data-ttu-id="243d3-362">Aplicar o <xref:System.Runtime.Serialization.DataContractAttribute> de atributo para um tipo para o qual o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo foi aplicado, ou para um de seus tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="243d3-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>  
  
-   <span data-ttu-id="243d3-363">Aplicar o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo para um tipo que implementa o <xref:System.Xml.Serialization.IXmlSerializable> interface.</span><span class="sxs-lookup"><span data-stu-id="243d3-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="243d3-364">Aplicar o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> de atributo para um tipo de coleção não.</span><span class="sxs-lookup"><span data-stu-id="243d3-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>  
  
-   <span data-ttu-id="243d3-365">Tentativa de definir <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> ou <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> em um <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo aplicado a um tipo de dicionário não.</span><span class="sxs-lookup"><span data-stu-id="243d3-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>  
  
### <a name="polymorphism-rules"></a><span data-ttu-id="243d3-366">Polimorfismo regras</span><span class="sxs-lookup"><span data-stu-id="243d3-366">Polymorphism Rules</span></span>  
 <span data-ttu-id="243d3-367">Como mencionado anteriormente, personalizando coleções usando o <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo pode interferir com obrigatórios da coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="243d3-368">Dois tipos de coleção personalizados somente podem ser considerados equivalentes quando seu nome, namespace, nome do item, bem como nomes de chave e valor (se eles são coleções de dicionário) correspondem.</span><span class="sxs-lookup"><span data-stu-id="243d3-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>  
  
 <span data-ttu-id="243d3-369">Devido a personalizações, é possível inadvertidamente use contrato de dados de uma coleção em que outra é esperada.</span><span class="sxs-lookup"><span data-stu-id="243d3-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="243d3-370">Isso deve ser evitado.</span><span class="sxs-lookup"><span data-stu-id="243d3-370">This should be avoided.</span></span> <span data-ttu-id="243d3-371">Consulte os seguintes tipos.</span><span class="sxs-lookup"><span data-stu-id="243d3-371">See the following types.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
 [!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]  
  
 <span data-ttu-id="243d3-372">Nesse caso, uma instância do `Marks1` podem ser atribuídos a `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="243d3-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="243d3-373">No entanto, `Marks2` não deve ser usado porque seu contrato de dados não é equivalente a `IList<int>` contrato de dados.</span><span class="sxs-lookup"><span data-stu-id="243d3-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="243d3-374">O nome de contrato de dados é "Marks2" e não "ArrayOfint" e o nome de elemento de repetição é "\<marcar >" e não "\<int >".</span><span class="sxs-lookup"><span data-stu-id="243d3-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>  
  
 <span data-ttu-id="243d3-375">As regras na tabela a seguir se aplicam a atribuição polimórfica de coleções.</span><span class="sxs-lookup"><span data-stu-id="243d3-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>  
  
|<span data-ttu-id="243d3-376">Tipo declarado</span><span class="sxs-lookup"><span data-stu-id="243d3-376">Declared type</span></span>|<span data-ttu-id="243d3-377">Atribuir uma coleção não personalizada</span><span class="sxs-lookup"><span data-stu-id="243d3-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="243d3-378">Atribuir uma coleção personalizada</span><span class="sxs-lookup"><span data-stu-id="243d3-378">Assigning a customized collection</span></span>|  
|-------------------|--------------------------------------------|---------------------------------------|  
|<span data-ttu-id="243d3-379">Objeto</span><span class="sxs-lookup"><span data-stu-id="243d3-379">Object</span></span>|<span data-ttu-id="243d3-380">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-380">Contract name is serialized.</span></span>|<span data-ttu-id="243d3-381">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="243d3-382">Personalização é usada.</span><span class="sxs-lookup"><span data-stu-id="243d3-382">Customization is used.</span></span>|  
|<span data-ttu-id="243d3-383">Interface de coleção</span><span class="sxs-lookup"><span data-stu-id="243d3-383">Collection interface</span></span>|<span data-ttu-id="243d3-384">Nome do contrato não é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-384">Contract name is not serialized.</span></span>|<span data-ttu-id="243d3-385">Nome do contrato não é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="243d3-386">A personalização não é used.*</span><span class="sxs-lookup"><span data-stu-id="243d3-386">Customization is not used.*</span></span>|  
|<span data-ttu-id="243d3-387">Coleção não personalizada</span><span class="sxs-lookup"><span data-stu-id="243d3-387">Non-customized collection</span></span>|<span data-ttu-id="243d3-388">Nome do contrato não é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-388">Contract name is not serialized.</span></span>|<span data-ttu-id="243d3-389">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="243d3-390">A personalização é used.* *</span><span class="sxs-lookup"><span data-stu-id="243d3-390">Customization is used.**</span></span>|  
|<span data-ttu-id="243d3-391">Coleção personalizada</span><span class="sxs-lookup"><span data-stu-id="243d3-391">Customized collection</span></span>|<span data-ttu-id="243d3-392">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-392">Contract name is serialized.</span></span> <span data-ttu-id="243d3-393">Não é de personalização used.* *</span><span class="sxs-lookup"><span data-stu-id="243d3-393">Customization is not used.**</span></span>|<span data-ttu-id="243d3-394">Nome do contrato é serializado.</span><span class="sxs-lookup"><span data-stu-id="243d3-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="243d3-395">Personalização do tipo atribuído é used.* *</span><span class="sxs-lookup"><span data-stu-id="243d3-395">Customization of the assigned type is used.**</span></span>|  
  
 <span data-ttu-id="243d3-396">* Com o <xref:System.Runtime.Serialization.NetDataContractSerializer> classe, personalização é usada neste caso.</span><span class="sxs-lookup"><span data-stu-id="243d3-396">*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="243d3-397">O <xref:System.Runtime.Serialization.NetDataContractSerializer> classe serializa também o nome do tipo real nesse caso, portanto a desserialização funciona conforme o esperado.</span><span class="sxs-lookup"><span data-stu-id="243d3-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>  
  
 <span data-ttu-id="243d3-398">* * Nesses casos resultam em instâncias de esquema inválida e, portanto, devem ser evitados.</span><span class="sxs-lookup"><span data-stu-id="243d3-398">**These cases result in schema-invalid instances and thus should be avoided.</span></span>  
  
 <span data-ttu-id="243d3-399">Nos casos em que o nome do contrato é serializado, deve ser o tipo de coleção atribuída na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="243d3-400">O oposto também é verdadeiro: nos casos em que o nome não é serializado, adicionando o tipo à lista de tipos conhecidos não é necessária.</span><span class="sxs-lookup"><span data-stu-id="243d3-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>  
  
 <span data-ttu-id="243d3-401">Uma matriz de um tipo derivado pode ser atribuída a uma matriz de um tipo base.</span><span class="sxs-lookup"><span data-stu-id="243d3-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="243d3-402">Nesse caso, o nome do contrato para o tipo derivado é serializado para cada elemento de repetição.</span><span class="sxs-lookup"><span data-stu-id="243d3-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="243d3-403">Por exemplo, se um tipo `Book` deriva do tipo `LibraryItem`, você pode atribuir uma matriz de `Book` para uma matriz de `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="243d3-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="243d3-404">Isso não se aplica a outros tipos de coleção.</span><span class="sxs-lookup"><span data-stu-id="243d3-404">This does not apply to other collection types.</span></span> <span data-ttu-id="243d3-405">Por exemplo, você não pode atribuir um `Generic List of Book` para um `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="243d3-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="243d3-406">No entanto, você pode atribuir um `Generic List of LibraryItem` que contém `Book` instâncias.</span><span class="sxs-lookup"><span data-stu-id="243d3-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="243d3-407">A matriz e o caso não sejam de matriz, `Book` devem estar na lista de tipos conhecidos.</span><span class="sxs-lookup"><span data-stu-id="243d3-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>  
  
## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="243d3-408">Coleções e preservação de referência de objeto</span><span class="sxs-lookup"><span data-stu-id="243d3-408">Collections and Object Reference Preservation</span></span>  
 <span data-ttu-id="243d3-409">Quando funções um serializador em um modo em que preserva as referências de objeto, preservação de referência de objeto também se aplica às coleções.</span><span class="sxs-lookup"><span data-stu-id="243d3-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="243d3-410">Especificamente, a identidade do objeto é preservada para coleções inteiras e contidos em coleções de itens individuais.</span><span class="sxs-lookup"><span data-stu-id="243d3-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="243d3-411">Para dicionários, a identidade do objeto é preservada para os objetos de par chave/valor e os objetos individuais de chave e valor.</span><span class="sxs-lookup"><span data-stu-id="243d3-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="243d3-412">Consulte também</span><span class="sxs-lookup"><span data-stu-id="243d3-412">See Also</span></span>  
 <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
