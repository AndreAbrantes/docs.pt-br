---
title: Mapeamento entre JSON e XML
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: 55812ad15d1f38bb0c295e6895dfff329035206d
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/16/2020
ms.locfileid: "81464062"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="51de0-102">Mapeamento entre JSON e XML</span><span class="sxs-lookup"><span data-stu-id="51de0-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="51de0-103">Os leitores e <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> escritores produzidos pelo fornecer uma API XML sobre o conteúdo de Notação de Objeto JavaScript (JSON).</span><span class="sxs-lookup"><span data-stu-id="51de0-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="51de0-104">JSON codifica dados usando um subconjunto dos literais do objeto javaScript.</span><span class="sxs-lookup"><span data-stu-id="51de0-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="51de0-105">Os leitores e escritores produzidos por esta fábrica também são usados quando o conteúdo JSON está sendo enviado ou recebido por aplicativos da Windows Communication Foundation (WCF) usando o <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> ou o <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="51de0-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>

<span data-ttu-id="51de0-106">Quando inicializado com conteúdo JSON, o leitor JSON se comporta da mesma forma que um leitor XML textual faz sobre uma instância de XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="51de0-107">O escritor JSON, quando dada uma seqüência de chamadas que em um leitor XML textual produz uma certa instância XML, escreve o conteúdo JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="51de0-108">O mapeamento entre esta instância de XML e o conteúdo JSON é descrito neste tópico para uso em cenários avançados.</span><span class="sxs-lookup"><span data-stu-id="51de0-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>

<span data-ttu-id="51de0-109">Internamente, o JSON é representado como um infoset XML quando processado pelo WCF.</span><span class="sxs-lookup"><span data-stu-id="51de0-109">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="51de0-110">Normalmente você não precisa se preocupar com essa representação interna, pois o mapeamento é apenas lógico: JSON normalmente não é convertido fisicamente para XML na memória ou convertido para JSON do XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="51de0-111">O mapeamento significa que as APIs XML são usadas para acessar o conteúdo JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-111">The mapping means that XML APIs are used to access JSON content.</span></span>

<span data-ttu-id="51de0-112">Quando o WCF usa JSON, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> o cenário usual é <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> que o é <xref:System.ServiceModel.Description.WebHttpBehavior> automaticamente conectado pelo comportamento, ou pelo comportamento quando apropriado.</span><span class="sxs-lookup"><span data-stu-id="51de0-112">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="51de0-113">O <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset e age como se estivesse lidando diretamente com JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="51de0-114">(É possível usar <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> o com qualquer leitor ou escritor XML, com a compreensão de que o XML está de acordo com o seguinte mapeamento.)</span><span class="sxs-lookup"><span data-stu-id="51de0-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>

<span data-ttu-id="51de0-115">Em cenários avançados, pode se tornar necessário acessar diretamente o seguinte mapeamento.</span><span class="sxs-lookup"><span data-stu-id="51de0-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="51de0-116">Esses cenários ocorrem quando você deseja serializar e desserializar o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>JSON de <xref:System.ServiceModel.Channels.Message> maneiras personalizadas, sem depender do , ou ao lidar com o tipo diretamente para mensagens que contêm JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="51de0-117">O mapeamento JSON-XML também é usado para registro de mensagens.</span><span class="sxs-lookup"><span data-stu-id="51de0-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="51de0-118">Ao usar o recurso de registro de mensagens no WCF, as mensagens JSON são registradas como XML de acordo com o mapeamento descrito na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="51de0-118">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>

<span data-ttu-id="51de0-119">Para esclarecer o conceito de um mapeamento, o exemplo a seguir é de um documento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>

```json
{"product":"pencil","price":12}
```

<span data-ttu-id="51de0-120">Para ler este documento JSON usando um dos leitores <xref:System.Xml.XmlDictionaryReader> mencionados anteriormente, use a mesma seqüência de chamadas que você faria para ler o seguinte documento XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>

```xml
<root type="object">
    <product type="string">pencil</product>
    <price type="number">12</price>
</root>
```

<span data-ttu-id="51de0-121">Além disso, se a mensagem JSON no exemplo for recebida pelo WCF e registrada, você verá o fragmento XML no registro anterior.</span><span class="sxs-lookup"><span data-stu-id="51de0-121">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>

## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="51de0-122">Mapeamento entre JSON e o Infoset XML</span><span class="sxs-lookup"><span data-stu-id="51de0-122">Mapping Between JSON and the XML Infoset</span></span>

<span data-ttu-id="51de0-123">Formalmente, o mapeamento é entre JSON conforme descrito no [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (exceto com certas restrições relaxadas e certas outras restrições adicionadas) e o infoset XML (e não xml textual) conforme descrito no [Conjunto de Informações XML](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span><span class="sxs-lookup"><span data-stu-id="51de0-123">Formally, the mapping is between JSON as described in [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span></span> <span data-ttu-id="51de0-124">Consulte este tópico para as definições de itens de *informação* e campos em [colchetes quadrados].</span><span class="sxs-lookup"><span data-stu-id="51de0-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>

<span data-ttu-id="51de0-125">Um documento JSON em branco mapeia um documento XML em branco e um documento XML em branco mapeia um documento JSON em branco.</span><span class="sxs-lookup"><span data-stu-id="51de0-125">A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="51de0-126">No mapeamento XML para JSON, não são permitidos o espaço em branco que precede o espaço em branco e o espaço em branco após o documento.</span><span class="sxs-lookup"><span data-stu-id="51de0-126">On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.</span></span>

<span data-ttu-id="51de0-127">O mapeamento é definido entre um Item de Informações de Documentos (DII) ou um Item de Informações de Elemento (EII) e JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="51de0-128">A propriedade EII, ou dii [elemento de documento], é referida como o Elemento JSON Raiz.</span><span class="sxs-lookup"><span data-stu-id="51de0-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="51de0-129">Observe que fragmentos de documento (XML com múltiplos elementos de raiz) não são suportados neste mapeamento.</span><span class="sxs-lookup"><span data-stu-id="51de0-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>

<span data-ttu-id="51de0-130">Exemplo: O seguinte documento:</span><span class="sxs-lookup"><span data-stu-id="51de0-130">Example: The following document:</span></span>

```xml
<?xml version="1.0"?>
<root type="number">42</root>
```

<span data-ttu-id="51de0-131">E o seguinte elemento:</span><span class="sxs-lookup"><span data-stu-id="51de0-131">And the following element:</span></span>

```xml
<root type="number">42</root>
```

<span data-ttu-id="51de0-132">Ambos têm um mapeamento para JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="51de0-133">O `root` elemento> <é o Elemento JSON Raiz em ambos os casos.</span><span class="sxs-lookup"><span data-stu-id="51de0-133">The <`root`> element is the Root JSON Element in both cases.</span></span>

<span data-ttu-id="51de0-134">Além disso, no caso de um DII, deve-se considerar o seguinte:</span><span class="sxs-lookup"><span data-stu-id="51de0-134">Furthermore, in the case of a DII, the following should be considered:</span></span>

- <span data-ttu-id="51de0-135">Alguns itens da lista [de crianças] não devem estar presentes.</span><span class="sxs-lookup"><span data-stu-id="51de0-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="51de0-136">Não confie nesse fato ao ler XML mapeado de JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>

- <span data-ttu-id="51de0-137">A lista [de crianças] não contém itens de informação de comentários.</span><span class="sxs-lookup"><span data-stu-id="51de0-137">The [children] list holds no comment information items.</span></span>

- <span data-ttu-id="51de0-138">A lista [crianças] não contém itens de informação DTD.</span><span class="sxs-lookup"><span data-stu-id="51de0-138">The [children] list holds no DTD information items.</span></span>

- <span data-ttu-id="51de0-139">A lista [crianças] não contém itens de informações `<?xml…>` pessoais (PI) (a declaração não é considerada um item de informações de PI)</span><span class="sxs-lookup"><span data-stu-id="51de0-139">The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)</span></span>

- <span data-ttu-id="51de0-140">O conjunto [notações] está vazio.</span><span class="sxs-lookup"><span data-stu-id="51de0-140">The [notations] set is empty.</span></span>

- <span data-ttu-id="51de0-141">O conjunto [entidades não parsed] está vazio.</span><span class="sxs-lookup"><span data-stu-id="51de0-141">The [unparsed entities] set is empty.</span></span>

<span data-ttu-id="51de0-142">Exemplo: O documento a seguir não tem mapeamento para JSON porque [crianças] possui um PI e um comentário.</span><span class="sxs-lookup"><span data-stu-id="51de0-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>

```xml
<?xml version="1.0"?>
<!--comment--><?pi?>
<root type="number">42</root>
```

<span data-ttu-id="51de0-143">O EII para o Elemento JSON Raiz tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="51de0-143">The EII for the Root JSON Element has the following characteristics:</span></span>

- <span data-ttu-id="51de0-144">[nome local] tem o valor "raiz".</span><span class="sxs-lookup"><span data-stu-id="51de0-144">[local name] has the value "root".</span></span>

- <span data-ttu-id="51de0-145">[nome do namespace] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-145">[namespace name] has no value.</span></span>

- <span data-ttu-id="51de0-146">[prefixo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-146">[prefix] has no value.</span></span>

- <span data-ttu-id="51de0-147">[crianças] podem conter EIIs (que representam elementos internos como descritos posteriormente) ou CIIs (Items de Informação de Caracteres como descrito anteriormente) ou nenhum deles, mas não ambos.</span><span class="sxs-lookup"><span data-stu-id="51de0-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>

- <span data-ttu-id="51de0-148">[atributos] podem conter os seguintes itens de informações de atributos opcionais (AIIs)</span><span class="sxs-lookup"><span data-stu-id="51de0-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>

- <span data-ttu-id="51de0-149">O Atributo tipo JSON ("tipo") conforme descrito mais adiante.</span><span class="sxs-lookup"><span data-stu-id="51de0-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="51de0-150">Este atributo é usado para preservar o tipo JSON (string, number, booleano, object, array ou null) no XML mapeado.</span><span class="sxs-lookup"><span data-stu-id="51de0-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>

- <span data-ttu-id="51de0-151">O Atributo nome\_\_do contrato de dados (" tipo") conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="51de0-151">The Data Contract Name Attribute ("\_\_type") as described further.</span></span> <span data-ttu-id="51de0-152">Este atributo só pode estar presente se o atributo do tipo JSON também estiver presente e seu valor [normalizado] for "objeto".</span><span class="sxs-lookup"><span data-stu-id="51de0-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="51de0-153">Este atributo é `DataContractJsonSerializer` usado para preservar informações do tipo de contrato de dados - por exemplo, em casos polimórficos em que um tipo derivado é serializado e onde um tipo de base é esperado.</span><span class="sxs-lookup"><span data-stu-id="51de0-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="51de0-154">Se você não está `DataContractJsonSerializer`trabalhando com o , na maioria dos casos, este atributo é ignorado.</span><span class="sxs-lookup"><span data-stu-id="51de0-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>

- <span data-ttu-id="51de0-155">[namespaces no escopo] contém a vinculação `http://www.w3.org/XML/1998/namespace` de "xml" a, conforme manda a especificação infoset.</span><span class="sxs-lookup"><span data-stu-id="51de0-155">[in-scope namespaces] contains the binding of "xml" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification.</span></span>

- <span data-ttu-id="51de0-156">[crianças], [atributos] e [namespaces no escopo] não devem ter nenhum item diferente do especificado anteriormente e [atributos de namespace] não devem ter membros, mas não confiam nesses fatos ao ler XML mapeado no JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>

<span data-ttu-id="51de0-157">Exemplo: O documento a seguir não tem mapeamento para JSON porque [atributos de namespace] não está vazio.</span><span class="sxs-lookup"><span data-stu-id="51de0-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>

```xml
<?xml version="1.0"?>
<root xmlns:a="myattributevalue">42</root>
```

<span data-ttu-id="51de0-158">A IA para o Atributo tipo JSON tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="51de0-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>

- <span data-ttu-id="51de0-159">[nome do namespace] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-159">[namespace name] has no value.</span></span>
- <span data-ttu-id="51de0-160">[prefixo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-160">[prefix] has no value.</span></span>
- <span data-ttu-id="51de0-161">[nome local] é "tipo".</span><span class="sxs-lookup"><span data-stu-id="51de0-161">[local name] is "type".</span></span>
- <span data-ttu-id="51de0-162">[valor normalizado] é um dos possíveis valores de tipo descritos na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="51de0-162">[normalized value] is one of the possible type values described in the following section.</span></span>
- <span data-ttu-id="51de0-163">[especificado] `true`é .</span><span class="sxs-lookup"><span data-stu-id="51de0-163">[specified] is `true`.</span></span>
- <span data-ttu-id="51de0-164">[tipo de atributo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-164">[attribute type] has no value.</span></span>
- <span data-ttu-id="51de0-165">[referências] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-165">[references] has no value.</span></span>

<span data-ttu-id="51de0-166">A IA para o atributo nome do contrato de dados tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="51de0-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>

- <span data-ttu-id="51de0-167">[nome do namespace] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-167">[namespace name] has no value.</span></span>
- <span data-ttu-id="51de0-168">[prefixo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-168">[prefix] has no value.</span></span>
- <span data-ttu-id="51de0-169">[nome local]\_\_é " tipo" (dois sublinhados e, em seguida, "digitar").</span><span class="sxs-lookup"><span data-stu-id="51de0-169">[local name] is "\_\_type" (two underscores and then "type").</span></span>
- <span data-ttu-id="51de0-170">[valor normalizado] é qualquer seqüência unicode válida – o mapeamento desta seqüência para JSON é descrito na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="51de0-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>
- <span data-ttu-id="51de0-171">[especificado] `true`é .</span><span class="sxs-lookup"><span data-stu-id="51de0-171">[specified] is `true`.</span></span>
- <span data-ttu-id="51de0-172">[tipo de atributo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-172">[attribute type] has no value.</span></span>
- <span data-ttu-id="51de0-173">[referências] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="51de0-173">[references] has no value.</span></span>

<span data-ttu-id="51de0-174">Os elementos internos contidos no Elemento Root JSON ou outros elementos internos têm as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="51de0-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>

- <span data-ttu-id="51de0-175">[nome local] pode ter qualquer valor como descrito mais adiante.</span><span class="sxs-lookup"><span data-stu-id="51de0-175">[local name] may have any value as described further.</span></span>
- <span data-ttu-id="51de0-176">[namespace name], [prefixo], [crianças], [atributos], [atributos de namespace], e [namespaces no escopo] estão sujeitos às mesmas regras do Elemento Root JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>

<span data-ttu-id="51de0-177">Tanto no Elemento JSON Raiz quanto nos elementos internos, o Atributo tipo JSON define o mapeamento para JSON e o possível [filhos] e sua interpretação.</span><span class="sxs-lookup"><span data-stu-id="51de0-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="51de0-178">O valor [normalizado] do atributo é sensível a maiúsculas e minúsculas e não pode conter espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="51de0-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.</span></span>

|<span data-ttu-id="51de0-179">[valor normalizado] da IA Do Atributo do Tipo JSON</span><span class="sxs-lookup"><span data-stu-id="51de0-179">[normalized value] of JSON Type Attribute’s AII</span></span>|<span data-ttu-id="51de0-180">Permitido [crianças] do EII correspondente</span><span class="sxs-lookup"><span data-stu-id="51de0-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="51de0-181">Mapeamento para JSON</span><span class="sxs-lookup"><span data-stu-id="51de0-181">Mapping to JSON</span></span>|
|---------------------------------------------------------|---------------------------------------------------|---------------------|
|<span data-ttu-id="51de0-182">`string`(ou ausência do tipo JSON AII)</span><span class="sxs-lookup"><span data-stu-id="51de0-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="51de0-183">A `string` e a ausência do Tipo JSON AII são os mesmos que tornam `string` o padrão.</span><span class="sxs-lookup"><span data-stu-id="51de0-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="51de0-184">Então, `<root> string1</root>` mapeia para `string` o JSON "string1".</span><span class="sxs-lookup"><span data-stu-id="51de0-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="51de0-185">0 ou mais CIIs</span><span class="sxs-lookup"><span data-stu-id="51de0-185">0 or more CIIs</span></span>|<span data-ttu-id="51de0-186">Um JSON `string` (JSON RFC, seção 2.5).</span><span class="sxs-lookup"><span data-stu-id="51de0-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="51de0-187">Cada `char` um é um caractere que corresponde ao [código de caractere] do CII.</span><span class="sxs-lookup"><span data-stu-id="51de0-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="51de0-188">Se não houver CIIs, ele mapeia para um JSON `string`vazio .</span><span class="sxs-lookup"><span data-stu-id="51de0-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="51de0-189">Exemplo: O elemento a seguir mapeia um fragmento JSON:</span><span class="sxs-lookup"><span data-stu-id="51de0-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="51de0-190">O fragmento json é "42".</span><span class="sxs-lookup"><span data-stu-id="51de0-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="51de0-191">No mapeamento XML para JSON, personagens que devem ser escapados mapa para personagens fugitivos, todos os outros mapeiam para personagens que não são escapados.</span><span class="sxs-lookup"><span data-stu-id="51de0-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="51de0-192">O personagem "/" é especial – ele escapa mesmo que não\\precise ser (escrito como " /").</span><span class="sxs-lookup"><span data-stu-id="51de0-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="51de0-193">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="51de0-194">O fragmento json \\é\\"o\\"da /ta".</span><span class="sxs-lookup"><span data-stu-id="51de0-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="51de0-195">No mapeamento JSON para XML, todos os caracteres e caracteres fugitivos que não são escapados mapeiam corretamente para o correspondente [código de caractere].</span><span class="sxs-lookup"><span data-stu-id="51de0-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="51de0-196">Exemplo: O fragmento JSON "\u0041BC", mapeia o seguinte elemento XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="51de0-197">A corda pode ser cercada por espaço branco ('ws' na seção 2 do JSON RFC) que não é mapeado para XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-197">The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="51de0-198">Exemplo: O fragmento JSON "ABC", (há espaços antes da primeira citação dupla), mapeia o seguinte elemento XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="51de0-199">Qualquer espaço em branco nos mapas XML para o espaço branco em JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-199">Any white space in XML maps to white space in JSON.</span></span><br /><br /> <span data-ttu-id="51de0-200">Exemplo: O elemento XML a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="51de0-201">O fragmento json é " A BC ".</span><span class="sxs-lookup"><span data-stu-id="51de0-201">The JSON fragment is " A BC ".</span></span>|
|`number`|<span data-ttu-id="51de0-202">1 ou mais CIIs</span><span class="sxs-lookup"><span data-stu-id="51de0-202">1 or more CIIs</span></span>|<span data-ttu-id="51de0-203">Um JSON `number` (JSON RFC, seção 2.4), possivelmente cercado por espaço branco.</span><span class="sxs-lookup"><span data-stu-id="51de0-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space.</span></span> <span data-ttu-id="51de0-204">Cada caractere na combinação de número/espaço branco é um caractere que corresponde ao [código de caractere] do CII.</span><span class="sxs-lookup"><span data-stu-id="51de0-204">Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="51de0-205">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="51de0-206">O fragmento JSON é 42</span><span class="sxs-lookup"><span data-stu-id="51de0-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="51de0-207">(O espaço branco está preservado).</span><span class="sxs-lookup"><span data-stu-id="51de0-207">(White space is preserved).</span></span>|
|`boolean`|<span data-ttu-id="51de0-208">4 ou 5 CIIs (que `false`corresponde ou `true` ), possivelmente cercado por CIIs adicionais de espaço branco.</span><span class="sxs-lookup"><span data-stu-id="51de0-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.</span></span>|<span data-ttu-id="51de0-209">Uma seqüência CII que corresponde à seqüência `true`"true" é mapeada para o literal , e `false`uma seqüência CII que corresponde à seqüência "falsa" é mapeada para o literal .</span><span class="sxs-lookup"><span data-stu-id="51de0-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="51de0-210">O espaço branco ao redor está preservado.</span><span class="sxs-lookup"><span data-stu-id="51de0-210">Surrounding white space is preserved.</span></span><br /><br /> <span data-ttu-id="51de0-211">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="51de0-212">O fragmento JSON é `false`.</span><span class="sxs-lookup"><span data-stu-id="51de0-212">The JSON fragment is `false`.</span></span>|
|`null`|<span data-ttu-id="51de0-213">Nada permitido.</span><span class="sxs-lookup"><span data-stu-id="51de0-213">None allowed.</span></span>|<span data-ttu-id="51de0-214">O `null`literal.</span><span class="sxs-lookup"><span data-stu-id="51de0-214">The literal `null`.</span></span> <span data-ttu-id="51de0-215">No mapeamento JSON para `null` XML, o pode ser cercado por espaço branco ('ws' na seção 2) que não é mapeado para XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-215">On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="51de0-216">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="51de0-217">ou</span><span class="sxs-lookup"><span data-stu-id="51de0-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="51de0-218">:</span><span class="sxs-lookup"><span data-stu-id="51de0-218">:</span></span><br /><br /> <span data-ttu-id="51de0-219">O fragmento JSON em `Null`ambos os casos é .</span><span class="sxs-lookup"><span data-stu-id="51de0-219">The JSON fragment in both cases is `Null`.</span></span>|
|`object`|<span data-ttu-id="51de0-220">0 ou mais EIIs.</span><span class="sxs-lookup"><span data-stu-id="51de0-220">0 or more EIIs.</span></span>|<span data-ttu-id="51de0-221">A `begin-object` (cinta encaracolada esquerda) como na seção 2.2 do JSON RFC, seguido de um registro de membro para cada EII conforme descrito posteriormente.</span><span class="sxs-lookup"><span data-stu-id="51de0-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="51de0-222">Se houver mais de um EII, há separadores de valor (commas) entre os registros de membros.</span><span class="sxs-lookup"><span data-stu-id="51de0-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="51de0-223">Tudo isso é seguido por um objeto final (cinta encaracolada direita).</span><span class="sxs-lookup"><span data-stu-id="51de0-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="51de0-224">Exemplo: O elemento a seguir mapeia o fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> `<root type="object">`<br /><br /> `<type1 type="string">aaa\</type1>`<br /><br /> `<type2 type="string">bbb\</type2>`<br /><br /> `</root >`<br /><br /> <span data-ttu-id="51de0-225">O fragmento JSON é `{"type1":"aaa","type2":"bbb"}`.</span><span class="sxs-lookup"><span data-stu-id="51de0-225">The JSON fragment is `{"type1":"aaa","type2":"bbb"}`.</span></span><br /><br /> <span data-ttu-id="51de0-226">Se o atributo tipo de contrato de dados estiver presente no mapeamento XML para JSON, então um registro adicional de membro será inserido no início.</span><span class="sxs-lookup"><span data-stu-id="51de0-226">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="51de0-227">Seu nome é o [nome local] do\_\_Atributo tipo de contrato de dados (" tipo"), e seu valor é o atributo [valor normalizado].</span><span class="sxs-lookup"><span data-stu-id="51de0-227">Its name is the [local name] of the Data Contract Type Attribute ("\_\_type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="51de0-228">Por outro lado, no mapeamento JSON para XML, se o nome do primeiro membro-registro for o\_\_[nome local] do Atributo tipo de contrato de dados (ou seja, " tipo"), um atributo de tipo de contrato de dados correspondente está presente no XML mapeado, mas um EII correspondente não está presente.</span><span class="sxs-lookup"><span data-stu-id="51de0-228">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\_\_type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="51de0-229">Observe que este registro de membro deve ocorrer primeiro no objeto JSON para que este mapeamento especial seja aplicado.</span><span class="sxs-lookup"><span data-stu-id="51de0-229">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="51de0-230">Isso representa uma saída do processamento json usual, onde a ordem dos registros de membros não é significativa.</span><span class="sxs-lookup"><span data-stu-id="51de0-230">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="51de0-231">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="51de0-231">Example:</span></span><br /><br /> <span data-ttu-id="51de0-232">Os seguintes mapas de fragmento json para XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-232">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="51de0-233">O XML é o seguinte código.</span><span class="sxs-lookup"><span data-stu-id="51de0-233">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="51de0-234">Observe que \_ \_o tipo AII está \_ \_presente, mas não há nenhum tipo EII.</span><span class="sxs-lookup"><span data-stu-id="51de0-234">Notice that the \_\_type AII is present, but there is no \_\_type EII.</span></span><br /><br /> <span data-ttu-id="51de0-235">No entanto, se a ordem no JSON for invertida como mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="51de0-235">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> `{"name":"John","\_\_type":"Person"}`<br /><br /> <span data-ttu-id="51de0-236">O XML correspondente é mostrado.</span><span class="sxs-lookup"><span data-stu-id="51de0-236">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="51de0-237">Ou seja, \__type deixa de ter um significado especial e mapeia para um EII como de costume, não para a IA.</span><span class="sxs-lookup"><span data-stu-id="51de0-237">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="51de0-238">As regras de fuga/descaptura para o valor normalizado da AII quando mapeadas para um valor JSON são as mesmas das strings JSON, especificadas na linha "string" desta tabela.</span><span class="sxs-lookup"><span data-stu-id="51de0-238">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="51de0-239">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="51de0-239">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="51de0-240">para o exemplo anterior pode ser mapeado para o JSON a seguir.</span><span class="sxs-lookup"><span data-stu-id="51de0-240">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="51de0-241">Em um mapeamento XML para JSON, o primeiro EII [nome local] não deve ser "tipo".\_\_</span><span class="sxs-lookup"><span data-stu-id="51de0-241">On an XML to JSON mapping, the first EII’s [local name] must not be "\_\_type".</span></span><br /><br /> <span data-ttu-id="51de0-242">O espaço`ws`branco ( ) nunca é gerado no mapeamento XML para JSON para objetos e é ignorado no mapeamento JSON para XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-242">White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="51de0-243">Exemplo: O fragmento JSON a seguir mapeia um elemento XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-243">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> `{ "ccc" : "aaa", "ddd" :"bbb"}`<br /><br /> <span data-ttu-id="51de0-244">O elemento XML é mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="51de0-244">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|
|<span data-ttu-id="51de0-245">matriz</span><span class="sxs-lookup"><span data-stu-id="51de0-245">array</span></span>|<span data-ttu-id="51de0-246">0 ou mais EIIs</span><span class="sxs-lookup"><span data-stu-id="51de0-246">0 or more EIIs</span></span>|<span data-ttu-id="51de0-247">Uma matriz de início (suporte quadrado esquerdo) como na seção 2.3 do JSON RFC, seguida por um registro de matriz para cada EII conforme descrito mais adiante.</span><span class="sxs-lookup"><span data-stu-id="51de0-247">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="51de0-248">Se houver mais de um EII, há separadores de valor (commas) entre os registros de matriz.</span><span class="sxs-lookup"><span data-stu-id="51de0-248">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="51de0-249">Tudo isso é seguido por uma matriz final.</span><span class="sxs-lookup"><span data-stu-id="51de0-249">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="51de0-250">Exemplo: O elemento XML a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-250">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="51de0-251">O fragmento JSON é`["aaa","bbb"]`</span><span class="sxs-lookup"><span data-stu-id="51de0-251">The JSON fragment is `["aaa","bbb"]`</span></span><br /><br /> <span data-ttu-id="51de0-252">O espaço`ws`branco ( ) nunca é gerado no mapeamento XML para JSON para arrays e é ignorado no mapeamento JSON para XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-252">White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="51de0-253">Exemplo: um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-253">Example: A JSON fragment.</span></span><br /><br />`["aaa", "bbb"]`<br /><br /> <span data-ttu-id="51de0-254">O elemento XML para o que ele mapeia.</span><span class="sxs-lookup"><span data-stu-id="51de0-254">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|

<span data-ttu-id="51de0-255">Os registros de membros funcionam da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="51de0-255">Member Records work as follows:</span></span>

- <span data-ttu-id="51de0-256">O elemento interno [nome local] `string` mapeia a parte do `member` como definido na seção 2.2 do JSON RFC.</span><span class="sxs-lookup"><span data-stu-id="51de0-256">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>

<span data-ttu-id="51de0-257">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-257">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName type="string">aaa</myLocalName>
</root>
```

<span data-ttu-id="51de0-258">O seguinte fragmento JSON é exibido.</span><span class="sxs-lookup"><span data-stu-id="51de0-258">The following JSON fragment is displayed.</span></span>

```json
{"myLocalName":"aaa"}
```

- <span data-ttu-id="51de0-259">No mapeamento XML para JSON, os personagens que devem ser escapados em JSON são escapados, e os outros não escapam.</span><span class="sxs-lookup"><span data-stu-id="51de0-259">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="51de0-260">O personagem "/", embora não seja um personagem que deve ser escapado, escapa no entanto (ele não precisa ser escapado no mapeamento JSON para XML).</span><span class="sxs-lookup"><span data-stu-id="51de0-260">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="51de0-261">Isso é necessário para suportar o `DateTime` formato AJAX ASP.NET para dados no JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-261">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>

- <span data-ttu-id="51de0-262">No mapeamento JSON para XML, todos os caracteres (incluindo os caracteres não escapados, se necessário) são levados para formar um `string` que produz um [nome local].</span><span class="sxs-lookup"><span data-stu-id="51de0-262">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>

- <span data-ttu-id="51de0-263">Elementos internos [crianças] mapeiam o valor `JSON Type Attribute` na seção `Root JSON Element`2.2, de acordo com o mesmo do .</span><span class="sxs-lookup"><span data-stu-id="51de0-263">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="51de0-264">Vários níveis de aninhamento de EIIs (incluindo aninhamento dentro de matrizes) são permitidos.</span><span class="sxs-lookup"><span data-stu-id="51de0-264">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>

<span data-ttu-id="51de0-265">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-265">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName1 type="string">myValue1</myLocalName1>
    <myLocalName2 type="number">2</myLocalName2>
    <myLocalName3 type="object">
        <myNestedName1 type="boolean">true</myNestedName1>
        <myNestedName2 type="null"/>
    </myLocalName3>
</root >
```

<span data-ttu-id="51de0-266">O seguinte fragmento JSON é o que ele mapeia para.</span><span class="sxs-lookup"><span data-stu-id="51de0-266">The following JSON fragment is what it maps to.</span></span>

```json
{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}
```

> [!NOTE]
> <span data-ttu-id="51de0-267">Não há etapa de codificação XML no mapeamento anterior.</span><span class="sxs-lookup"><span data-stu-id="51de0-267">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="51de0-268">Portanto, o WCF só suporta documentos JSON onde todos os caracteres em nomes-chave são caracteres válidos em nomes de elementos XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-268">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="51de0-269">Por exemplo, o documento JSON {"<":"a"} não é suportado porque < não é um nome válido para um elemento XML.</span><span class="sxs-lookup"><span data-stu-id="51de0-269">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>

<span data-ttu-id="51de0-270">A situação inversa (caracteres válidos em XML, mas não em JSON) não causa problemas porque o mapeamento anterior inclui etapas de fuga/fuga de JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-270">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>

<span data-ttu-id="51de0-271">Os registros de array funcionam da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="51de0-271">Array Records work as follows:</span></span>

- <span data-ttu-id="51de0-272">O [nome local] do elemento interno é "item".</span><span class="sxs-lookup"><span data-stu-id="51de0-272">Inner element’s [local name] is "item".</span></span>

- <span data-ttu-id="51de0-273">O mapa [crianças] do elemento interno para o valor na seção 2.3, de acordo com o Atributo do Tipo JSON, como é para o Elemento JSON raiz.</span><span class="sxs-lookup"><span data-stu-id="51de0-273">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="51de0-274">Vários níveis de aninhamento de EIIs (incluindo aninhamento dentro de objetos) são permitidos.</span><span class="sxs-lookup"><span data-stu-id="51de0-274">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>

<span data-ttu-id="51de0-275">Exemplo: O elemento a seguir mapeia um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-275">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="array">
    <item type="string">myValue1</item>
    <item type="number">2</item>
    <item type="array">
    <item type="boolean">true</item>
    <item type="null"/></item>
</root>
```

<span data-ttu-id="51de0-276">A seguir está o fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="51de0-276">The following is the JSON fragment.</span></span>

```json
["myValue1",2,[true,null]]
```

## <a name="see-also"></a><span data-ttu-id="51de0-277">Confira também</span><span class="sxs-lookup"><span data-stu-id="51de0-277">See also</span></span>

- <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>
- <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>
- [<span data-ttu-id="51de0-278">Serialização JSON autônoma</span><span class="sxs-lookup"><span data-stu-id="51de0-278">Stand-Alone JSON Serialization</span></span>](stand-alone-json-serialization.md)
