---
title: Mapeamento entre JSON e XML
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
caps.latest.revision: "10"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 9bf104af8c88413298412d3ec3a29cd934558e2d
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/02/2017
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="e0683-102">Mapeamento entre JSON e XML</span><span class="sxs-lookup"><span data-stu-id="e0683-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="e0683-103">Os leitores e gravadores produzido pelo <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> fornecem uma API XML sobre o conteúdo do objeto notação JSON (JavaScript).</span><span class="sxs-lookup"><span data-stu-id="e0683-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="e0683-104">JSON codifica dados usando um subconjunto de literais de objeto do JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e0683-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="e0683-105">Os leitores e gravadores produzidos por essa fábrica também são usados quando o conteúdo do JSON está sendo enviado ou recebido por [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] aplicativos usando o <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> ou <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="e0683-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>  
  
 <span data-ttu-id="e0683-106">Quando inicializados com conteúdo JSON, o leitor JSON se comporta da mesma maneira que um leitor XML textual faz em uma instância de XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="e0683-107">O gravador JSON, quando recebe uma sequência de chamadas em um leitor XML textual produz uma determinada instância XML, grava o conteúdo JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="e0683-108">O mapeamento entre esta instância de XML e o conteúdo do JSON é descrito neste tópico para uso em situações avançadas.</span><span class="sxs-lookup"><span data-stu-id="e0683-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>  
  
 <span data-ttu-id="e0683-109">Internamente, o JSON é representado como um XML infoset quando processado por [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e0683-109">Internally, JSON is represented as an XML infoset when processed by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span> <span data-ttu-id="e0683-110">Normalmente você não precisa se preocupar com essa representação interna, como o mapeamento é apenas uma lógica: JSON fisicamente normalmente não é convertido em XML na memória ou convertido em JSON do XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="e0683-111">O mapeamento significa que as APIs de XML são usadas para acessar conteúdo JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-111">The mapping means that XML APIs are used to access JSON content.</span></span>  
  
 <span data-ttu-id="e0683-112">Quando [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] usa JSON, o cenário comum é que o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> é automaticamente conectado pelo <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> comportamento, ou o <xref:System.ServiceModel.Description.WebHttpBehavior> comportamento quando apropriado.</span><span class="sxs-lookup"><span data-stu-id="e0683-112">When [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="e0683-113">O <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> entende o mapeamento entre JSON e XML infoset e age como se ela está lidando com JSON diretamente.</span><span class="sxs-lookup"><span data-stu-id="e0683-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="e0683-114">(É possível usar o <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> com o leitor de XML ou gravador, sabendo que o XML está de acordo com o seguinte mapeamento.)</span><span class="sxs-lookup"><span data-stu-id="e0683-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>  
  
 <span data-ttu-id="e0683-115">Em cenários avançados, talvez seja necessário acessar diretamente o seguinte mapeamento.</span><span class="sxs-lookup"><span data-stu-id="e0683-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="e0683-116">Essas situações ocorrer quando você deseja serializar e desserializar JSON formas personalizadas, sem depender de <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, ou ao lidar com o <xref:System.ServiceModel.Channels.Message> tipo diretamente para mensagens que contém JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="e0683-117">O mapeamento de XML JSON também é usado para o log de mensagem.</span><span class="sxs-lookup"><span data-stu-id="e0683-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="e0683-118">Ao usar o recurso de log de mensagens em [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], mensagens JSON é registrado como XML de acordo com o mapeamento descrito na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="e0683-118">When using the message logging feature in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], JSON messages is logged as XML according to the mapping described in the next section.</span></span>  
  
 <span data-ttu-id="e0683-119">Para esclarecer o conceito de um mapeamento, o exemplo a seguir é de um documento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>  
  
```json  
{"product":"pencil","price":12}  
```  
  
 <span data-ttu-id="e0683-120">Para ler este documento JSON usando um dos leitores mencionados anteriormente, use a mesma sequência de <xref:System.Xml.XmlDictionaryReader> chama como você faria para ler o documento XML a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>  
  
```xml  
<root type="object">  
    <product type="string">pencil</product>  
    <price type="number">12</price>  
</root>  
```  
  
 <span data-ttu-id="e0683-121">Além disso, se o JSON de mensagem no exemplo é recebido pelo [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] e conectado, você verá o fragmento XML no log anterior.</span><span class="sxs-lookup"><span data-stu-id="e0683-121">Furthermore, if the JSON message in the example is received by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and logged, you would see the XML fragment in the preceding log.</span></span>  
  
## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="e0683-122">Mapeamento entre JSON e XML Infoset</span><span class="sxs-lookup"><span data-stu-id="e0683-122">Mapping Between JSON and the XML Infoset</span></span>  
 <span data-ttu-id="e0683-123">Anteriormente, o mapeamento é feito entre JSON conforme descrito em [RFC 4627](http://go.microsoft.com/fwlink/?LinkId=98808) (exceto com algumas restrições reduzidas e determinadas outras restrições adicionadas) e o XML infoset (e não textual XML) como descrito em [informações XML Definir](http://go.microsoft.com/fwlink/?LinkId=98809) .</span><span class="sxs-lookup"><span data-stu-id="e0683-123">Formally, the mapping is between JSON as described in [RFC 4627](http://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](http://go.microsoft.com/fwlink/?LinkId=98809) .</span></span> <span data-ttu-id="e0683-124">Consulte este tópico para definições de *itens de informações* e campos colchetes [].</span><span class="sxs-lookup"><span data-stu-id="e0683-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>  
  
 <span data-ttu-id="e0683-125">Um documento JSON em branco é mapeado para o documento XML em branco e um documento XML em branco é mapeado para um documento JSON em branco.</span><span class="sxs-lookup"><span data-stu-id="e0683-125">A blank JSON document maps to blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="e0683-126">Em XML para o mapeamento de JSON, precedendo o espaço em branco e espaço em branco final do documento não são permitidas.</span><span class="sxs-lookup"><span data-stu-id="e0683-126">On the XML to JSON mapping, preceding whitespace and trailing whitespace after the document are not allowed.</span></span>  
  
 <span data-ttu-id="e0683-127">O mapeamento é definido entre um Item de informação de documento (DII) ou um Item de informação do elemento (EII) e JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="e0683-128">O EII ou propriedade de [elemento do documento] do DII, é conhecida como elemento raiz JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="e0683-129">Observe que os fragmentos de documento (XML com vários elementos raiz) não são suportados nesse mapeamento.</span><span class="sxs-lookup"><span data-stu-id="e0683-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>  
  
 <span data-ttu-id="e0683-130">Exemplo: O documento a seguir:</span><span class="sxs-lookup"><span data-stu-id="e0683-130">Example: The following document:</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e0683-131">E o seguinte elemento:</span><span class="sxs-lookup"><span data-stu-id="e0683-131">And the following element:</span></span>  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e0683-132">Ter um mapeamento para JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="e0683-133">O <`root`> é o elemento de JSON raiz em ambos os casos.</span><span class="sxs-lookup"><span data-stu-id="e0683-133">The <`root`> element is the Root JSON Element in both cases.</span></span>  
  
 <span data-ttu-id="e0683-134">Além disso, no caso de um DII, a seguir deve ser considerados:</span><span class="sxs-lookup"><span data-stu-id="e0683-134">Furthermore, in the case of a DII, the following should be considered:</span></span>  
  
-   <span data-ttu-id="e0683-135">Alguns itens da lista [filhos] não devem estar presentes.</span><span class="sxs-lookup"><span data-stu-id="e0683-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="e0683-136">Não confie neste fato durante a leitura de que XML mapeado do JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>  
  
-   <span data-ttu-id="e0683-137">A lista de [filhos] não contém nenhum comentário itens de informações.</span><span class="sxs-lookup"><span data-stu-id="e0683-137">The [children] list holds no comment information items.</span></span>  
  
-   <span data-ttu-id="e0683-138">A lista de [filhos] não contém nenhum item de informação de DTD.</span><span class="sxs-lookup"><span data-stu-id="e0683-138">The [children] list holds no DTD information items.</span></span>  
  
-   <span data-ttu-id="e0683-139">A lista de [filhos] não contém nenhum item de informações pessoais informações PI () (a \<? xml... > declaração não é considerada um item de informação de PI)</span><span class="sxs-lookup"><span data-stu-id="e0683-139">The [children] list holds no personal Information (PI) information items (the \<?xml…> declaration is not considered a PI information item)</span></span>  
  
-   <span data-ttu-id="e0683-140">O conjunto [notações] está vazio.</span><span class="sxs-lookup"><span data-stu-id="e0683-140">The [notations] set is empty.</span></span>  
  
-   <span data-ttu-id="e0683-141">O conjunto [entidades não analisado] está vazio.</span><span class="sxs-lookup"><span data-stu-id="e0683-141">The [unparsed entities] set is empty.</span></span>  
  
 <span data-ttu-id="e0683-142">Exemplo: O documento a seguir não tem a nenhum mapeamento para JSON porque [filhos] mantém um PI e um comentário.</span><span class="sxs-lookup"><span data-stu-id="e0683-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<!--comment--><?pi?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e0683-143">EII para o elemento raiz JSON tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="e0683-143">The EII for the Root JSON Element has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e0683-144">[nome do local] tem o valor "root".</span><span class="sxs-lookup"><span data-stu-id="e0683-144">[local name] has the value "root".</span></span>  
  
-   <span data-ttu-id="e0683-145">[nome do namespace] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-145">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-146">[prefixo] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-146">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-147">[filhos] podem conter EIIs (que representam os elementos internos conforme descrito mais) ou CIIs (caractere informações itens conforme descrito mais) ou nenhum desses, mas não ambos.</span><span class="sxs-lookup"><span data-stu-id="e0683-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>  
  
-   <span data-ttu-id="e0683-148">[atributos] podem conter os seguintes itens de informações de atributo opcional (AIIs)</span><span class="sxs-lookup"><span data-stu-id="e0683-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>  
  
-   <span data-ttu-id="e0683-149">O atributo de tipo de JSON ("type") conforme descrito mais.</span><span class="sxs-lookup"><span data-stu-id="e0683-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="e0683-150">Este atributo é usado para preservar o tipo JSON (cadeia de caracteres, número, booliano, objeto, matriz ou null) no XML mapeada.</span><span class="sxs-lookup"><span data-stu-id="e0683-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>  
  
-   <span data-ttu-id="e0683-151">( Type") conforme descrito mais dados de atributo ao nome de contrato.</span><span class="sxs-lookup"><span data-stu-id="e0683-151">The Data Contract Name Attribute ("__type") as described further.</span></span> <span data-ttu-id="e0683-152">Esse atributo pode estar presente apenas se o atributo de tipo JSON também está presente e seu [valor normalizado] é o "objeto".</span><span class="sxs-lookup"><span data-stu-id="e0683-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="e0683-153">Este atributo é usado pelo `DataContractJsonSerializer` para preservar a contrato de dados informações de tipo - por exemplo, em casos polimórficos onde um tipo derivado é serializado e um tipo base é esperado.</span><span class="sxs-lookup"><span data-stu-id="e0683-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="e0683-154">Se você não estiver trabalhando com o `DataContractJsonSerializer`, na maioria dos casos, esse atributo é ignorado.</span><span class="sxs-lookup"><span data-stu-id="e0683-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>  
  
-   <span data-ttu-id="e0683-155">[namespaces em escopo] contém a associação de "xml" para "http://www.w3.org/XML/1998/namespace" conforme exigido pela especificação do infoset.</span><span class="sxs-lookup"><span data-stu-id="e0683-155">[in-scope namespaces] contains the binding of "xml" to "http://www.w3.org/XML/1998/namespace" as mandated by the infoset specification.</span></span>  
  
-   <span data-ttu-id="e0683-156">[filhos], [atributos] e [namespaces em escopo] não devem ter todos os itens que conforme especificado anteriormente e [namespace atributos] não devem ter nenhum membro, mas não confiam nesses fatos durante a leitura de XML mapeado do JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>  
  
 <span data-ttu-id="e0683-157">Exemplo: O documento a seguir não tem a nenhum mapeamento para JSON porque [namespace atributos] não está vazio.</span><span class="sxs-lookup"><span data-stu-id="e0683-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root  xmlns:a="myattributevalue">42</root>`  
  
 <span data-ttu-id="e0683-158">O todos os para o atributo de tipo JSON tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="e0683-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e0683-159">[nome do namespace] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-159">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-160">[prefixo] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-160">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-161">[nome do local] é "type".</span><span class="sxs-lookup"><span data-stu-id="e0683-161">[local name] is "type".</span></span>  
  
-   <span data-ttu-id="e0683-162">[valor normalizado] é um dos valores possíveis do tipo descritos na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-162">[normalized value] is one of the possible type values described in the following section.</span></span>  
  
-   <span data-ttu-id="e0683-163">[especificado] é `true`.</span><span class="sxs-lookup"><span data-stu-id="e0683-163">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="e0683-164">[tipo de atributo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-164">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-165">[referências] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-165">[references] has no value.</span></span>  
  
 <span data-ttu-id="e0683-166">O todos os para o atributo de nome de contrato de dados tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="e0683-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e0683-167">[nome do namespace] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-167">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-168">[prefixo] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-168">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-169">[nome do local] é type"(dois sublinhados e, em seguida,"tipo").</span><span class="sxs-lookup"><span data-stu-id="e0683-169">[local name] is "__type" (two underscores and then "type").</span></span>  
  
-   <span data-ttu-id="e0683-170">[valor normalizado] é qualquer cadeia de caracteres Unicode válida: o mapeamento da cadeia de caracteres em JSON é descrito na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>  
  
-   <span data-ttu-id="e0683-171">[especificado] é `true`.</span><span class="sxs-lookup"><span data-stu-id="e0683-171">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="e0683-172">[tipo de atributo] não tem valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-172">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="e0683-173">[referências] não tem nenhum valor.</span><span class="sxs-lookup"><span data-stu-id="e0683-173">[references] has no value.</span></span>  
  
 <span data-ttu-id="e0683-174">Elementos internos contidos no elemento raiz JSON ou outros elementos internos têm as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="e0683-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>  
  
-   <span data-ttu-id="e0683-175">[nome do local] pode ter qualquer valor conforme descrito mais</span><span class="sxs-lookup"><span data-stu-id="e0683-175">[local name] may have any value as described further</span></span>  
  
-   <span data-ttu-id="e0683-176">[nome do namespace], [prefixo], [filhos], atributos, [atributos do namespace,] e [namespaces em escopo] estão sujeitos às mesmas regras que o elemento raiz JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>  
  
 <span data-ttu-id="e0683-177">No elemento raiz do JSON e os elementos internos, o atributo de tipo JSON define o mapeamento de JSON e os possíveis [filhos] e a interpretação.</span><span class="sxs-lookup"><span data-stu-id="e0683-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="e0683-178">O atributo [valor normalizado] diferencia maiusculas de minúsculas e deve estar em minúsculo e não pode conter espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="e0683-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain whitespace.</span></span>  
  
|<span data-ttu-id="e0683-179">[valor normalizado] de `JSON Type Attribute`de todos os</span><span class="sxs-lookup"><span data-stu-id="e0683-179">[normalized value] of `JSON Type Attribute`’s AII</span></span>|<span data-ttu-id="e0683-180">Permitido [filhos] o EII correspondente</span><span class="sxs-lookup"><span data-stu-id="e0683-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="e0683-181">Mapeamento de JSON</span><span class="sxs-lookup"><span data-stu-id="e0683-181">Mapping to JSON</span></span>|  
|---------------------------------------------------------|---------------------------------------------------|---------------------|  
|<span data-ttu-id="e0683-182">`string`(ou ausência do tipo JSON todos os)</span><span class="sxs-lookup"><span data-stu-id="e0683-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="e0683-183">Um `string` e a ausência do tipo JSON todos os são a mesma torna `string` o padrão.</span><span class="sxs-lookup"><span data-stu-id="e0683-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="e0683-184">Portanto, `<root> string1</root>` mapeia para o JSON `string` "string1".</span><span class="sxs-lookup"><span data-stu-id="e0683-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="e0683-185">0 ou mais CIIs</span><span class="sxs-lookup"><span data-stu-id="e0683-185">0 or more CIIs</span></span>|<span data-ttu-id="e0683-186">JSON `string` (RFC JSON, seção 2.5).</span><span class="sxs-lookup"><span data-stu-id="e0683-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="e0683-187">Cada `char` é um caractere que corresponde ao [código] na CII.</span><span class="sxs-lookup"><span data-stu-id="e0683-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="e0683-188">Se não houver nenhum CIIs, ele mapeia para um JSON vazio `string`.</span><span class="sxs-lookup"><span data-stu-id="e0683-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="e0683-189">Exemplo: O seguinte elemento mapeia para um fragmento JSON:</span><span class="sxs-lookup"><span data-stu-id="e0683-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="e0683-190">O fragmento JSON é "42".</span><span class="sxs-lookup"><span data-stu-id="e0683-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="e0683-191">Em XML para o mapeamento de JSON, caracteres que devem ser substituídos mapa de caracteres de escape, todos os outros usuários mapeiam para caracteres que não são ignoradas.</span><span class="sxs-lookup"><span data-stu-id="e0683-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="e0683-192">O caractere "/" é especial – mesmo que ele não precisa ser tenha escape (escrito out como "\\/").</span><span class="sxs-lookup"><span data-stu-id="e0683-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="e0683-193">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="e0683-194">O fragmento JSON é "o \\" das\\/ta\\"".</span><span class="sxs-lookup"><span data-stu-id="e0683-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="e0683-195">Em JSON para mapeamento de XML, quaisquer caracteres de escape e caracteres que não são substituídas mapa corretamente ao correspondente [código].</span><span class="sxs-lookup"><span data-stu-id="e0683-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="e0683-196">Exemplo: O fragmento JSON "\u0041BC" mapeia para o seguinte elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="e0683-197">A cadeia de caracteres pode ser cercada por espaços em branco ('ws' na seção 2 do RFC JSON) que não são mapeados para XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-197">The string can be surrounded by whitespace ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="e0683-198">Exemplo: O JSON fragmentar "ABC", (há espaços antes do primeiro aspas duplas), é mapeado para o seguinte elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="e0683-199">Qualquer espaço em branco no XML é mapeado para o espaço em branco em JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-199">Any whitespace in XML maps to whitespace in JSON.</span></span><br /><br /> <span data-ttu-id="e0683-200">Exemplo: O seguinte elemento XML é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="e0683-201">O fragmento JSON é "Um BC".</span><span class="sxs-lookup"><span data-stu-id="e0683-201">The JSON fragment is " A BC ".</span></span>|  
|`number`|<span data-ttu-id="e0683-202">1 ou mais CIIs</span><span class="sxs-lookup"><span data-stu-id="e0683-202">1 or more CIIs</span></span>|<span data-ttu-id="e0683-203">JSON `number` (RFC JSON, seção 2.4), possivelmente cercado por espaços em branco.</span><span class="sxs-lookup"><span data-stu-id="e0683-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by whitespace.</span></span> <span data-ttu-id="e0683-204">Cada caractere da combinação de número/espaço em branco é um caractere que corresponde ao [código] na CII.</span><span class="sxs-lookup"><span data-stu-id="e0683-204">Each character in the number/whitespace combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="e0683-205">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="e0683-206">O fragmento JSON é 42</span><span class="sxs-lookup"><span data-stu-id="e0683-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="e0683-207">(Espaço em branco é preservado).</span><span class="sxs-lookup"><span data-stu-id="e0683-207">(Whitespace is preserved).</span></span>|  
|`boolean`|<span data-ttu-id="e0683-208">4 ou 5 CIIs (que corresponde ao `true` ou `false`), possivelmente cercados por um espaço em branco CIIs adicional.</span><span class="sxs-lookup"><span data-stu-id="e0683-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional whitespace CIIs.</span></span>|<span data-ttu-id="e0683-209">Uma sequência CII que corresponde à cadeia de caracteres "true" é mapeada para o literal `true`, e uma sequência CII que corresponde à cadeia de caracteres "false" está mapeada para o literal `false`.</span><span class="sxs-lookup"><span data-stu-id="e0683-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="e0683-210">Ao redor de espaço em branco é preservado.</span><span class="sxs-lookup"><span data-stu-id="e0683-210">Surrounding whitespace is preserved.</span></span><br /><br /> <span data-ttu-id="e0683-211">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="e0683-212">O fragmento JSON é `false`.</span><span class="sxs-lookup"><span data-stu-id="e0683-212">The JSON fragment is `false`.</span></span>|  
|`null`|<span data-ttu-id="e0683-213">Nenhum é permitido.</span><span class="sxs-lookup"><span data-stu-id="e0683-213">None allowed.</span></span>|<span data-ttu-id="e0683-214">O literal `null`.</span><span class="sxs-lookup"><span data-stu-id="e0683-214">The literal `null`.</span></span> <span data-ttu-id="e0683-215">Em JSON para mapeamento de XML, o `null` pode estar cercado por espaços em branco ('ws' na seção 2) que não são mapeados para XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-215">On JSON to XML mapping, the `null` may be surrounded by whitespace (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="e0683-216">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="e0683-217">ou</span><span class="sxs-lookup"><span data-stu-id="e0683-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="e0683-218">:</span><span class="sxs-lookup"><span data-stu-id="e0683-218">:</span></span><br /><br /> <span data-ttu-id="e0683-219">O fragmento JSON em ambos os casos é `Null`.</span><span class="sxs-lookup"><span data-stu-id="e0683-219">The JSON fragment in both cases is `Null`.</span></span>|  
|`object`|<span data-ttu-id="e0683-220">0 ou mais EIIs.</span><span class="sxs-lookup"><span data-stu-id="e0683-220">0 or more EIIs.</span></span>|<span data-ttu-id="e0683-221">Um `begin-object` (chave de abertura da esquerda) como seção 2.2 da RFC JSON, seguido por um registro de membro para cada EII conforme descrito mais.</span><span class="sxs-lookup"><span data-stu-id="e0683-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="e0683-222">Se houver mais de um EII, há separadores de valor (vírgula) entre os registros de membro.</span><span class="sxs-lookup"><span data-stu-id="e0683-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="e0683-223">Tudo isso é seguido por um objeto de término (chave de fechamento).</span><span class="sxs-lookup"><span data-stu-id="e0683-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="e0683-224">Exemplo: O seguinte elemento mapeia para o fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> <span data-ttu-id="e0683-225">\<tipo de raiz = "objeto" ></span><span class="sxs-lookup"><span data-stu-id="e0683-225">\<root type="object"></span></span><br /><br /> <span data-ttu-id="e0683-226">\<tipo de type1 = "string" > aaa\</type1 ></span><span class="sxs-lookup"><span data-stu-id="e0683-226">\<type1 type="string">aaa\</type1></span></span><br /><br /> <span data-ttu-id="e0683-227">\<tipo de type2 = "string" > bbb\</type2 ></span><span class="sxs-lookup"><span data-stu-id="e0683-227">\<type2 type="string">bbb\</type2></span></span><br /><br /> <span data-ttu-id="e0683-228">\</ root ></span><span class="sxs-lookup"><span data-stu-id="e0683-228">\</root ></span></span><br /><br /> <span data-ttu-id="e0683-229">O fragmento JSON é {"type1": "aaa", "type2": "bbb"}.</span><span class="sxs-lookup"><span data-stu-id="e0683-229">The JSON fragment is {"type1":"aaa","type2":"bbb"}.</span></span><br /><br /> <span data-ttu-id="e0683-230">Se o atributo de tipo de contrato de dados está presente no XML para o mapeamento de JSON, um registro de membro adicional é inserido no início.</span><span class="sxs-lookup"><span data-stu-id="e0683-230">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="e0683-231">Seu nome é [nome local] do atributo de tipo de contrato de dados ( type"), e seu valor é o atributo [valor normalizado].</span><span class="sxs-lookup"><span data-stu-id="e0683-231">Its name is the [local name] of the Data Contract Type Attribute ("__type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="e0683-232">Por outro lado, em JSON para mapeamento de XML, se o nome do primeiro membro-Registro [nome local] o atributo de tipo de contrato de dados de (ou seja, "\_digitar"), um atributo de tipo de contrato de dados correspondente está presente no XML mapeada, mas um EII correspondente não é presente.</span><span class="sxs-lookup"><span data-stu-id="e0683-232">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\__type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="e0683-233">Observe que este registro de membro deve ocorrer primeiro no objeto JSON para que esse mapeamento especial aplicar.</span><span class="sxs-lookup"><span data-stu-id="e0683-233">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="e0683-234">Isso representa um desvio do processamento normal de JSON, onde a ordem dos registros de membro não é significativa.</span><span class="sxs-lookup"><span data-stu-id="e0683-234">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="e0683-235">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="e0683-235">Example:</span></span><br /><br /> <span data-ttu-id="e0683-236">O fragmento JSON a seguir mapeia para XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-236">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="e0683-237">O XML é o código a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-237">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="e0683-238">Observe que o \_digitar todos os está presente, mas não há nenhum \_digitar EII.</span><span class="sxs-lookup"><span data-stu-id="e0683-238">Notice that the \__type AII is present, but there is no \__type EII.</span></span><br /><br /> <span data-ttu-id="e0683-239">No entanto, se a ordem em JSON é invertida como mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-239">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> <span data-ttu-id="e0683-240">{"name": "John","\_digitar": "Pessoa"}</span><span class="sxs-lookup"><span data-stu-id="e0683-240">{"name":"John","\__type":"Person"}</span></span><br /><br /> <span data-ttu-id="e0683-241">O XML correspondente é mostrado.</span><span class="sxs-lookup"><span data-stu-id="e0683-241">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="e0683-242">Ou seja, \_interrompido digitar ter um significado especial e é mapeado para um EII como de costume, não todos os.</span><span class="sxs-lookup"><span data-stu-id="e0683-242">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="e0683-243">Substituição/unescape regras para a todos os [valor normalizado da] quando mapeado para um valor JSON são as mesmas para cadeias de caracteres JSON, especificadas na linha "string" desta tabela.</span><span class="sxs-lookup"><span data-stu-id="e0683-243">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="e0683-244">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="e0683-244">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="e0683-245">o exemplo anterior pode ser mapeado para o JSON a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-245">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="e0683-246">Em um XML para o mapeamento de JSON, o primeiro EII [nome do local] não deve ser "\_digitar".</span><span class="sxs-lookup"><span data-stu-id="e0683-246">On an XML to JSON mapping, the first EII’s [local name] must not be "\__type".</span></span><br /><br /> <span data-ttu-id="e0683-247">Espaço em branco (`ws`) nunca é gerado no XML para mapeamento de JSON para objetos e é ignorada em JSON para mapeamento de XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-247">Whitespace (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="e0683-248">Exemplo: O seguinte fragmento JSON é mapeado para um elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-248">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> <span data-ttu-id="e0683-249">{"ccc": "aaa", "ddd": "bbb"}</span><span class="sxs-lookup"><span data-stu-id="e0683-249">{   "ccc"   :  "aaa",   "ddd"    :"bbb"}</span></span><br /><br /> <span data-ttu-id="e0683-250">O elemento XML é mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="e0683-250">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|  
<span data-ttu-id="e0683-251">Ray'</span><span class="sxs-lookup"><span data-stu-id="e0683-251">ray\`</span></span>|<span data-ttu-id="e0683-252">0 ou mais EIIs</span><span class="sxs-lookup"><span data-stu-id="e0683-252">0 or more EIIs</span></span>|<span data-ttu-id="e0683-253">Um begin array (colchete esquerdo) como seção 2.3 da RFC JSON, seguido por um registro de matriz para cada EII conforme descrito mais.</span><span class="sxs-lookup"><span data-stu-id="e0683-253">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="e0683-254">Se houver mais de um EII, há separadores de valor (vírgula) entre os registros de matriz.</span><span class="sxs-lookup"><span data-stu-id="e0683-254">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="e0683-255">Tudo isso é seguido por uma matriz de término.</span><span class="sxs-lookup"><span data-stu-id="e0683-255">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="e0683-256">Exemplo: O seguinte elemento XML é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-256">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="e0683-257">O fragmento JSON é ["aaa", "bbb"]</span><span class="sxs-lookup"><span data-stu-id="e0683-257">The JSON fragment is ["aaa","bbb"]</span></span><br /><br /> <span data-ttu-id="e0683-258">Espaço em branco (`ws`) nunca é gerado no XML para o mapeamento de JSON para matrizes e é ignorada em JSON para mapeamento de XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-258">Whitespace (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="e0683-259">Exemplo: Fragmento AJSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-259">Example: AJSON fragment.</span></span><br /><br /> <span data-ttu-id="e0683-260">["aaa", "bbb"]</span><span class="sxs-lookup"><span data-stu-id="e0683-260">[     "aaa",     "bbb"]</span></span><br /><br /> <span data-ttu-id="e0683-261">O elemento XML que ele é mapeado.</span><span class="sxs-lookup"><span data-stu-id="e0683-261">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|  
  
 <span data-ttu-id="e0683-262">Registros de membro trabalhar da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="e0683-262">Member Records work as follows:</span></span>  
  
-   <span data-ttu-id="e0683-263">Elemento interno [nome do local] mapeia para o `string` parte do `member` conforme definido na seção 2.2 da RFC JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-263">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>  
  
 <span data-ttu-id="e0683-264">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-264">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object"/>`  
  
 `<myLocalName type="string">aaa</myLocalName>`  
  
 `</root >`  
  
 <span data-ttu-id="e0683-265">O seguinte fragmento JSON é exibido.</span><span class="sxs-lookup"><span data-stu-id="e0683-265">The following JSON fragment is displayed.</span></span>  
  
 `{"myLocalName":"aaa"}`  
  
-   <span data-ttu-id="e0683-266">Em XML para o mapeamento de JSON, os caracteres que devem ser substituídos no JSON são ignorados e não os outros são ignorados.</span><span class="sxs-lookup"><span data-stu-id="e0683-266">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="e0683-267">O caractere "/", embora não seja um caractere que deve ser substituído, é ignorado, não obstante, (ele não precisa de escape para mapeamento de XML em JSON).</span><span class="sxs-lookup"><span data-stu-id="e0683-267">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="e0683-268">Isso é necessário para oferecer suporte ao formato do ASP.NET AJAX para `DateTime` dados em JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-268">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>  
  
-   <span data-ttu-id="e0683-269">Em JSON para mapeamento de XML, todos os caracteres (incluindo os caracteres de escapados não, se necessário) são obtidos para formar um `string` que produz um [nome local].</span><span class="sxs-lookup"><span data-stu-id="e0683-269">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>  
  
-   <span data-ttu-id="e0683-270">Mapeiam elementos internos [filhos] para o valor na seção 2.2, de acordo com o `JSON Type Attribute` assim como para o `Root JSON Element`.</span><span class="sxs-lookup"><span data-stu-id="e0683-270">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="e0683-271">Vários níveis de aninhamento de EIIs (incluindo aninhamento em matrizes) são permitidos.</span><span class="sxs-lookup"><span data-stu-id="e0683-271">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>  
  
 <span data-ttu-id="e0683-272">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-272">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object">`  
  
 `<myLocalName1 type="string">myValue1</myLocalName1>`  
  
 `<myLocalName2 type="number">2</myLocalName2>`  
  
 `<myLocalName3 type="object">`  
  
 `<myNestedName1 type="boolean">true</myNestedName1>`  
  
 `<myNestedName2 type="null"/>`  
  
 `</myLocalName3>`  
  
 `</root >`  
  
 <span data-ttu-id="e0683-273">O seguinte fragmento JSON é que ele é mapeado.</span><span class="sxs-lookup"><span data-stu-id="e0683-273">The following JSON fragment is what it maps to.</span></span>  
  
 `{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}`  
  
> [!NOTE]
>  <span data-ttu-id="e0683-274">Não há nenhuma etapa de codificação XML no mapeamento anterior.</span><span class="sxs-lookup"><span data-stu-id="e0683-274">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="e0683-275">Portanto, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] só dá suporte a documentos JSON, onde todos os caracteres em nomes de chave são caracteres válidos em nomes de elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-275">Therefore, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="e0683-276">Por exemplo, o documento JSON {"<": "a"} não é suportado porque < não é um nome válido para um elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e0683-276">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>  
  
 <span data-ttu-id="e0683-277">A situação inversa (caracteres válido em XML, mas não em JSON) não causa problemas, pois o mapeamento anterior inclui etapas unescape/saída JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-277">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>  
  
 <span data-ttu-id="e0683-278">Matriz de registros de trabalho da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="e0683-278">Array Records work as follows:</span></span>  
  
-   <span data-ttu-id="e0683-279">Elemento interno [nome do local] é "item".</span><span class="sxs-lookup"><span data-stu-id="e0683-279">Inner element’s [local name] is "item".</span></span>  
  
-   <span data-ttu-id="e0683-280">Elemento interno [filhos] mapear para o valor na seção 2.3, de acordo com o atributo de tipo de JSON como faz para o elemento raiz JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-280">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="e0683-281">Vários níveis de aninhamento de EIIs (incluindo aninhamento dentro de objetos) são permitidos.</span><span class="sxs-lookup"><span data-stu-id="e0683-281">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>  
  
 <span data-ttu-id="e0683-282">Exemplo: O seguinte elemento é mapeado para um fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-282">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="array"/>`  
  
 `<item type="string">myValue1</item>`  
  
 `<item type="number">2</item>`  
  
 `<item type="array">`  
  
 `<item type="boolean">true</item>`  
  
 `<item type="null"/>`  
  
 `</item>`  
  
 `</root >`  
  
 <span data-ttu-id="e0683-283">A seguir está o fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="e0683-283">The following is the JSON fragment.</span></span>  
  
 `["myValue1",2,[true,null]]`  
  
## <a name="see-also"></a><span data-ttu-id="e0683-284">Consulte também</span><span class="sxs-lookup"><span data-stu-id="e0683-284">See Also</span></span>  
 <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>  
 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>  
 [<span data-ttu-id="e0683-285">Serialização JSON autônoma</span><span class="sxs-lookup"><span data-stu-id="e0683-285">Stand-Alone JSON Serialization</span></span>](../../../../docs/framework/wcf/feature-details/stand-alone-json-serialization.md)
