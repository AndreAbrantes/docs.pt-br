---
title: Escolhendo um padrão de troca de mensagens
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: 22c720beaa8dc70d2916a5b1d38819ad3d333a0f
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96275652"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="2562d-102">Escolhendo um padrão de troca de mensagens</span><span class="sxs-lookup"><span data-stu-id="2562d-102">Choosing a Message Exchange Pattern</span></span>

<span data-ttu-id="2562d-103">A primeira etapa na gravação de um transporte personalizado é decidir quais *padrões de troca de mensagens* (ou MEPS) são necessários para o canal que você está desenvolvendo.</span><span class="sxs-lookup"><span data-stu-id="2562d-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="2562d-104">Este tópico descreve as opções disponíveis e discute os vários requisitos.</span><span class="sxs-lookup"><span data-stu-id="2562d-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="2562d-105">Esta é a primeira tarefa na lista de tarefas de desenvolvimento de canal descrita em [desenvolvimento de canais](developing-channels.md).</span><span class="sxs-lookup"><span data-stu-id="2562d-105">This is the first task in the channel development task list described in [Developing Channels](developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="2562d-106">Seis padrões de troca de mensagens</span><span class="sxs-lookup"><span data-stu-id="2562d-106">Six Message Exchange Patterns</span></span>  

 <span data-ttu-id="2562d-107">Há três MEPs de escolha:</span><span class="sxs-lookup"><span data-stu-id="2562d-107">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="2562d-108">Datagrama ( <xref:System.ServiceModel.Channels.IInputChannel> e <xref:System.ServiceModel.Channels.IOutputChannel> )</span><span class="sxs-lookup"><span data-stu-id="2562d-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="2562d-109">Ao usar um dataMEP de datagrama, um cliente envia uma mensagem usando um *incêndio e esquece* o Exchange.</span><span class="sxs-lookup"><span data-stu-id="2562d-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="2562d-110">Um incêndio e esquecido o Exchange é um que requer a confirmação fora de banda da entrega bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="2562d-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="2562d-111">A mensagem pode ser perdida em trânsito e nunca alcançar o serviço.</span><span class="sxs-lookup"><span data-stu-id="2562d-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="2562d-112">Se a operação de envio for concluída com êxito na extremidade do cliente, ela não garante que o ponto de extremidade remoto tenha recebido a mensagem.</span><span class="sxs-lookup"><span data-stu-id="2562d-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="2562d-113">O datagrama é um bloco de construção fundamental para mensagens, pois você pode criar seus próprios protocolos sobre ele, incluindo protocolos confiáveis e protocolos seguros.</span><span class="sxs-lookup"><span data-stu-id="2562d-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="2562d-114">Canais de datagrama de cliente implementam a <xref:System.ServiceModel.Channels.IOutputChannel> interface e os canais de datagrama de serviço implementam a <xref:System.ServiceModel.Channels.IInputChannel> interface.</span><span class="sxs-lookup"><span data-stu-id="2562d-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="2562d-115">Request-Response ( <xref:System.ServiceModel.Channels.IRequestChannel> e <xref:System.ServiceModel.Channels.IReplyChannel> )</span><span class="sxs-lookup"><span data-stu-id="2562d-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="2562d-116">Neste MEP, uma mensagem é enviada e uma resposta é recebida.</span><span class="sxs-lookup"><span data-stu-id="2562d-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="2562d-117">O padrão consiste em pares de solicitação-resposta.</span><span class="sxs-lookup"><span data-stu-id="2562d-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="2562d-118">Exemplos de chamadas de solicitação-resposta são RPC (chamadas de procedimento remoto) e solicitações GET de navegador.</span><span class="sxs-lookup"><span data-stu-id="2562d-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="2562d-119">Esse padrão também é conhecido como Half-duplex.</span><span class="sxs-lookup"><span data-stu-id="2562d-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="2562d-120">Neste MEP, os canais de cliente implementam o <xref:System.ServiceModel.Channels.IRequestChannel> e os canais de serviço implementam <xref:System.ServiceModel.Channels.IReplyChannel> .</span><span class="sxs-lookup"><span data-stu-id="2562d-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="2562d-121">Duplex ( <xref:System.ServiceModel.Channels.IDuplexChannel> )</span><span class="sxs-lookup"><span data-stu-id="2562d-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="2562d-122">O MEP duplex permite que um número arbitrário de mensagens seja enviado por um cliente e recebido em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="2562d-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="2562d-123">O duplex MEP é como uma conversa telefônica, onde cada palavra que está sendo falada é uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="2562d-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="2562d-124">Como ambos os lados podem enviar e receber neste MEP, a interface implementada pelos canais de cliente e de serviço é <xref:System.ServiceModel.Channels.IDuplexChannel> .</span><span class="sxs-lookup"><span data-stu-id="2562d-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="2562d-125">![Escolhendo um padrão de troca de mensagens](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="2562d-125">![Choosing a message exchange pattern](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="2562d-126">Os três padrões básicos de troca de mensagens.</span><span class="sxs-lookup"><span data-stu-id="2562d-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="2562d-127">De cima para baixo: datagrama, solicitação-resposta e duplex.</span><span class="sxs-lookup"><span data-stu-id="2562d-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="2562d-128">Cada um desses MEPs também pode dar suporte a *sessões*.</span><span class="sxs-lookup"><span data-stu-id="2562d-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="2562d-129">Uma sessão (e implementação do <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> tipo <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType> ) correlaciona todas as mensagens enviadas e recebidas em um canal.</span><span class="sxs-lookup"><span data-stu-id="2562d-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="2562d-130">O padrão de solicitação-resposta é uma sessão autônoma de duas mensagens, pois a solicitação e a resposta são correlacionadas.</span><span class="sxs-lookup"><span data-stu-id="2562d-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="2562d-131">Por outro lado, o padrão de solicitação-resposta que dá suporte a sessões implica que todos os pares de solicitação/resposta nesse canal estão correlacionados entre si.</span><span class="sxs-lookup"><span data-stu-id="2562d-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="2562d-132">Isso lhe dá um total de seis MEPs para escolher:</span><span class="sxs-lookup"><span data-stu-id="2562d-132">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="2562d-133">Datagrama</span><span class="sxs-lookup"><span data-stu-id="2562d-133">Datagram</span></span>  
  
- <span data-ttu-id="2562d-134">Solicitação-resposta</span><span class="sxs-lookup"><span data-stu-id="2562d-134">Request-response</span></span>  
  
- <span data-ttu-id="2562d-135">Duplex</span><span class="sxs-lookup"><span data-stu-id="2562d-135">Duplex</span></span>  
  
- <span data-ttu-id="2562d-136">Datagrama com sessões</span><span class="sxs-lookup"><span data-stu-id="2562d-136">Datagram with sessions</span></span>  
  
- <span data-ttu-id="2562d-137">Solicitação-resposta com sessões</span><span class="sxs-lookup"><span data-stu-id="2562d-137">Request-response with sessions</span></span>  
  
- <span data-ttu-id="2562d-138">Duplex com sessões</span><span class="sxs-lookup"><span data-stu-id="2562d-138">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2562d-139">Para o transporte UDP, o único MEP com suporte é datagrama, pois o UDP é inerentemente a um protocolo Fire e esqueça.</span><span class="sxs-lookup"><span data-stu-id="2562d-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="2562d-140">Sessões e canais de sessão</span><span class="sxs-lookup"><span data-stu-id="2562d-140">Sessions and Sessionful Channels</span></span>  

 <span data-ttu-id="2562d-141">No mundo de rede, há protocolos orientados a conexões (por exemplo, TCP) e protocolos sem conexão (por exemplo, UDP).</span><span class="sxs-lookup"><span data-stu-id="2562d-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="2562d-142">O WCF usa a sessão de termo para significar uma abstração lógica como uma conexão.</span><span class="sxs-lookup"><span data-stu-id="2562d-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="2562d-143">Os protocolos WCF de sessão são semelhantes aos protocolos de rede orientados a conexões e os protocolos WCF sem sessão são semelhantes aos protocolos de rede com menos conexão.</span><span class="sxs-lookup"><span data-stu-id="2562d-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="2562d-144">No modelo de objeto do canal, cada sessão lógica é manifestada como uma instância de um canal de sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="2562d-145">Portanto, todas as novas sessões criadas pelo cliente e aceitas no serviço correspondem a um novo canal de sessão em cada lado.</span><span class="sxs-lookup"><span data-stu-id="2562d-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="2562d-146">O diagrama a seguir mostra, na parte superior, a estrutura de canais de sessão e, na parte inferior, a estrutura de canais de sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="2562d-147">![Escolhendo um padrão de troca de mensagens](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="2562d-147">![Choosing a message exchange pattern](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="2562d-148">Um cliente cria um novo canal de sessão e envia uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="2562d-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="2562d-149">No lado do serviço, o ouvinte do canal recebe essa mensagem e detecta que ela pertence a uma nova sessão, de modo que cria um novo canal de sessão e a passa para o aplicativo (em resposta ao aplicativo que chama AcceptChannel no ouvinte do canal).</span><span class="sxs-lookup"><span data-stu-id="2562d-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="2562d-150">O aplicativo recebe essa mensagem e todas as mensagens subsequentes enviadas na mesma sessão por meio do mesmo canal de sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="2562d-151">Outro cliente (ou o mesmo cliente) cria uma nova sessão e envia uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="2562d-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="2562d-152">O ouvinte de canal detecta que essa mensagem está em uma nova sessão e cria um novo canal de sessão e o processo se repete.</span><span class="sxs-lookup"><span data-stu-id="2562d-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="2562d-153">Sem sessões, não há nenhuma correlação entre canais e sessões.</span><span class="sxs-lookup"><span data-stu-id="2562d-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="2562d-154">Portanto, um ouvinte de canal cria apenas um canal pelo qual todas as mensagens recebidas são entregues ao aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2562d-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="2562d-155">Também não há nenhuma solicitação de mensagem porque não há nenhuma sessão dentro da qual manter a ordem da mensagem.</span><span class="sxs-lookup"><span data-stu-id="2562d-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="2562d-156">A parte superior do gráfico anterior ilustra uma troca de mensagens por sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="2562d-157">Iniciando e terminando sessões</span><span class="sxs-lookup"><span data-stu-id="2562d-157">Starting and Terminating Sessions</span></span>  

 <span data-ttu-id="2562d-158">As sessões são iniciadas no cliente simplesmente criando um novo canal de sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="2562d-159">Eles são iniciados no serviço quando o serviço recebe uma mensagem que foi enviada em uma nova sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="2562d-160">Da mesma forma, as sessões são encerradas fechando ou anulando um canal de sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="2562d-161">A exceção é <xref:System.ServiceModel.Channels.IDuplexSessionChannel> que é usada para enviar e receber mensagens em um padrão de comunicação duplex e de sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="2562d-162">É possível que um lado queira parar de enviar mensagens, mas continuar recebendo mensagens, portanto, ao usar <xref:System.ServiceModel.Channels.IDuplexSessionChannel> há um mecanismo que permite fechar a sessão de saída, indicando que você não enviará mais mensagens, mas manterá a sessão de entrada aberta, permitindo que você continue a receber mensagens.</span><span class="sxs-lookup"><span data-stu-id="2562d-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="2562d-163">Em geral, as sessões são fechadas no lado de saída e não no lado de entrada.</span><span class="sxs-lookup"><span data-stu-id="2562d-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="2562d-164">Ou seja, os canais de saída de sessão podem ser fechados, encerrando assim a sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="2562d-165">Fechar um canal de saída de sessão faz com que o canal de entrada da sessão correspondente retorne nulo para a chamada do aplicativo <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> no <xref:System.ServiceModel.Channels.IDuplexSessionChannel> .</span><span class="sxs-lookup"><span data-stu-id="2562d-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="2562d-166">No entanto, os canais de entrada de sessão não devem ser fechados, a menos que <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> em <xref:System.ServiceModel.Channels.IDuplexSessionChannel> retorna NULL, indicando que a sessão já está fechada.</span><span class="sxs-lookup"><span data-stu-id="2562d-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="2562d-167">Se <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> em <xref:System.ServiceModel.Channels.IDuplexSessionChannel> não tiver retornado NULL, o fechamento de um canal de entrada de sessão poderá gerar uma exceção, pois poderá receber mensagens inesperadas durante o fechamento.</span><span class="sxs-lookup"><span data-stu-id="2562d-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="2562d-168">Se um receptor quiser encerrar uma sessão antes do remetente, ele deverá chamar <xref:System.ServiceModel.ICommunicationObject.Abort%2A> no canal de entrada, que finalizará abruptamente a sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="2562d-169">Gravando canais de sessão</span><span class="sxs-lookup"><span data-stu-id="2562d-169">Writing Sessionful Channels</span></span>  

 <span data-ttu-id="2562d-170">Como um autor de canal de sessão, há algumas coisas que seu canal deve fazer para fornecer sessões.</span><span class="sxs-lookup"><span data-stu-id="2562d-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="2562d-171">No lado do envio, seu canal precisa:</span><span class="sxs-lookup"><span data-stu-id="2562d-171">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="2562d-172">Para cada novo canal, crie uma nova sessão e associe-a a uma nova ID de sessão, que é uma cadeia de caracteres exclusiva.</span><span class="sxs-lookup"><span data-stu-id="2562d-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="2562d-173">Ou obtenha uma nova sessão do canal de sessão abaixo da pilha.</span><span class="sxs-lookup"><span data-stu-id="2562d-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="2562d-174">Para cada mensagem enviada usando esse canal, se o canal tiver criado a sessão (em vez de obtê-la da camada abaixo), você precisará associar a mensagem à sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="2562d-175">Para canais de protocolo, isso normalmente é feito adicionando um cabeçalho SOAP.</span><span class="sxs-lookup"><span data-stu-id="2562d-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="2562d-176">Para canais de transporte, isso normalmente é feito criando uma nova conexão de transporte ou adicionando informações de sessão ao protocolo de enquadramento.</span><span class="sxs-lookup"><span data-stu-id="2562d-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="2562d-177">Para cada mensagem enviada usando esse canal, você precisa fornecer as garantias de entrega mencionadas acima.</span><span class="sxs-lookup"><span data-stu-id="2562d-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="2562d-178">Se você estiver contando com o canal abaixo de fornecer a sessão, esse canal também fornecerá as garantias de entrega.</span><span class="sxs-lookup"><span data-stu-id="2562d-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="2562d-179">Se você estiver fornecendo a sessão por conta própria, precisará implementar essas garantias como parte do seu protocolo.</span><span class="sxs-lookup"><span data-stu-id="2562d-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="2562d-180">Em geral, se você estiver escrevendo um canal de protocolo que assume o WCF em ambos os lados, poderá exigir o transporte TCP ou o canal de mensagens confiáveis e confiar em qualquer um para fornecer uma sessão.</span><span class="sxs-lookup"><span data-stu-id="2562d-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="2562d-181">Quando o <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> for chamado em seu canal, execute o trabalho necessário para fechar a sessão usando o tempo limite especificado ou o padrão.</span><span class="sxs-lookup"><span data-stu-id="2562d-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="2562d-182">Isso pode ser tão simples quanto chamar <xref:System.ServiceModel.ICommunicationObject.Close%2A> no canal abaixo de você (se você acabou de obter a sessão a partir dele) ou enviar uma mensagem SOAP especial ou fechar uma conexão de transporte.</span><span class="sxs-lookup"><span data-stu-id="2562d-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="2562d-183">Quando <xref:System.ServiceModel.ICommunicationObject.Abort%2A> é chamado em seu canal, encerre a sessão abruptamente sem executar e/s.</span><span class="sxs-lookup"><span data-stu-id="2562d-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="2562d-184">Isso pode significar não fazer nada ou pode envolver a anulação de uma conexão de rede ou de algum outro recurso.</span><span class="sxs-lookup"><span data-stu-id="2562d-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="2562d-185">No lado do recebimento, seu canal precisa:</span><span class="sxs-lookup"><span data-stu-id="2562d-185">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="2562d-186">Para cada mensagem de entrada, o ouvinte do canal deve detectar a sessão à qual pertence.</span><span class="sxs-lookup"><span data-stu-id="2562d-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="2562d-187">Se esta for a primeira mensagem na sessão, o ouvinte do canal deverá criar um novo canal e retorná-lo da chamada para <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2562d-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2562d-188">Caso contrário, o ouvinte do canal deve encontrar o canal existente que corresponde à sessão e entregar a mensagem por meio desse canal.</span><span class="sxs-lookup"><span data-stu-id="2562d-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="2562d-189">Se o canal estiver fornecendo a sessão (juntamente com as garantias de entrega necessárias), o lado de recebimento poderá ser necessário para executar algumas ações, como reordenar mensagens ou enviar confirmações.</span><span class="sxs-lookup"><span data-stu-id="2562d-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="2562d-190">Quando o <xref:System.ServiceModel.ICommunicationObject.Close%2A> for chamado em seu canal, execute o trabalho necessário para fechar a sessão com o tempo limite especificado ou o padrão.</span><span class="sxs-lookup"><span data-stu-id="2562d-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="2562d-191">Isso pode resultar em exceções se o canal receber uma mensagem enquanto aguarda o tempo limite de fechamento expirar.</span><span class="sxs-lookup"><span data-stu-id="2562d-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="2562d-192">Isso ocorre porque o canal estará no estado de fechamento quando receber uma mensagem para que ele seja gerado.</span><span class="sxs-lookup"><span data-stu-id="2562d-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="2562d-193">Quando <xref:System.ServiceModel.ICommunicationObject.Abort%2A> é chamado em seu canal, encerre a sessão abruptamente sem executar e/s.</span><span class="sxs-lookup"><span data-stu-id="2562d-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="2562d-194">Novamente, isso pode significar não fazer nada ou pode envolver a anulação de uma conexão de rede ou de algum outro recurso.</span><span class="sxs-lookup"><span data-stu-id="2562d-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2562d-195">Veja também</span><span class="sxs-lookup"><span data-stu-id="2562d-195">See also</span></span>

- [<span data-ttu-id="2562d-196">Visão geral de modelo de canal</span><span class="sxs-lookup"><span data-stu-id="2562d-196">Channel Model Overview</span></span>](channel-model-overview.md)
