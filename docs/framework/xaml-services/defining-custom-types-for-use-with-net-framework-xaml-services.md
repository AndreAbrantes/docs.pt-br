---
title: "Definindo tipos personalizados para uso com serviços XAML do .NET Framework"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: "11"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.openlocfilehash: 0b35c35be7351fdf45157153ce6ca55fc763c3ed
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/21/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="36c34-102">Definindo tipos personalizados para uso com serviços XAML do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="36c34-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="36c34-103">Quando você define tipos personalizados que são objetos de negócios ou tipos que não têm uma dependência em estruturas específicas, há algumas melhores práticas para XAML, você pode seguir.</span><span class="sxs-lookup"><span data-stu-id="36c34-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="36c34-104">Se você seguir essas práticas recomendadas, serviços XAML do .NET Framework e seus leitores XAML e gravadores XAML podem descobrir as características XAML de seu tipo e dê a ele representação apropriada em um fluxo do nó XAML usando o sistema de tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="36c34-105">Este tópico descreve as práticas recomendadas para definições de tipo, definições de membro e atribuição de CLR de tipos ou membros.</span><span class="sxs-lookup"><span data-stu-id="36c34-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="36c34-106">Construtor padrões e definições de tipo para XAML</span><span class="sxs-lookup"><span data-stu-id="36c34-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="36c34-107">Para ser instanciado como um elemento de objeto em XAML, uma classe personalizada deve atender aos seguintes requisitos:</span><span class="sxs-lookup"><span data-stu-id="36c34-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="36c34-108">A classe personalizada deve ser pública e deve expor um construtor público (sem parâmetros) do padrão.</span><span class="sxs-lookup"><span data-stu-id="36c34-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="36c34-109">(Consulte a seção a seguir para ver as observações sobre estruturas.)</span><span class="sxs-lookup"><span data-stu-id="36c34-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="36c34-110">A classe personalizada não deve ser uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="36c34-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="36c34-111">Adicionais "ponto" no caminho do nome completo torna a divisão do namespace da classe ambígua e interferem com outros recursos XAML, como propriedades anexadas.</span><span class="sxs-lookup"><span data-stu-id="36c34-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="36c34-112">Se um objeto pode ser instanciado como um elemento de objeto, o objeto criado pode preencher o formulário de elemento de propriedade de todas as propriedades que usam o objeto como seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="36c34-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="36c34-113">Você ainda pode fornecer valores de objeto para tipos que não atendem a esses critérios, se você habilitar um conversor de valor.</span><span class="sxs-lookup"><span data-stu-id="36c34-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="36c34-114">Para obter mais informações, consulte [conversores de tipo e extensões de marcação para XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="36c34-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="36c34-115">Estruturas</span><span class="sxs-lookup"><span data-stu-id="36c34-115">Structures</span></span>  
 <span data-ttu-id="36c34-116">Estruturas sempre são capazes de ser construído em XAML, por definição de CLR.</span><span class="sxs-lookup"><span data-stu-id="36c34-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="36c34-117">Isso ocorre porque um compilador CLR cria implicitamente um construtor padrão para uma estrutura.</span><span class="sxs-lookup"><span data-stu-id="36c34-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="36c34-118">Este construtor inicializa todos os valores de propriedade para seus padrões.</span><span class="sxs-lookup"><span data-stu-id="36c34-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="36c34-119">Em alguns casos, o comportamento de construção padrão para uma estrutura não é desejável.</span><span class="sxs-lookup"><span data-stu-id="36c34-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="36c34-120">Isso pode ser porque a estrutura é destinada para preencher valores e função conceitualmente como uma união.</span><span class="sxs-lookup"><span data-stu-id="36c34-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="36c34-121">Como uma união, os valores contidos podem ter interpretações mutuamente exclusivas e, portanto, nenhuma de suas propriedades são configuráveis.</span><span class="sxs-lookup"><span data-stu-id="36c34-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="36c34-122">Um exemplo de tal uma estrutura de vocabulário do WPF é <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="36c34-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="36c34-123">Essas estruturas devem implementar um conversor de tipo para que os valores podem ser expressos na forma de atributo usando convenções de cadeia de caracteres que cria a interpretações diferentes ou modos dos valores de estrutura.</span><span class="sxs-lookup"><span data-stu-id="36c34-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="36c34-124">A estrutura também deve expor um comportamento semelhante para a construção de código por meio de um construtor não padrão.</span><span class="sxs-lookup"><span data-stu-id="36c34-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="36c34-125">Interfaces</span><span class="sxs-lookup"><span data-stu-id="36c34-125">Interfaces</span></span>  
 <span data-ttu-id="36c34-126">Interfaces podem ser usadas como tipos base de membros.</span><span class="sxs-lookup"><span data-stu-id="36c34-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="36c34-127">O sistema de tipo XAML verifica a lista pode ser atribuída e espera que o objeto que é fornecido como o valor pode ser atribuído à interface.</span><span class="sxs-lookup"><span data-stu-id="36c34-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="36c34-128">Não há nenhum conceito de como a interface deve ser apresentada como um tipo XAML, como um tipo atribuível relevante suporte os requisitos de construção de XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="36c34-129">Métodos de fábrica</span><span class="sxs-lookup"><span data-stu-id="36c34-129">Factory Methods</span></span>  
 <span data-ttu-id="36c34-130">Métodos de fábrica são um recurso de XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="36c34-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="36c34-131">Eles modificar o princípio XAML que objetos devem ter construtores padrão.</span><span class="sxs-lookup"><span data-stu-id="36c34-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="36c34-132">Métodos de fábrica não são documentados neste tópico.</span><span class="sxs-lookup"><span data-stu-id="36c34-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="36c34-133">Consulte [diretiva X:factorymethod](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="36c34-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="36c34-134">Enumerações</span><span class="sxs-lookup"><span data-stu-id="36c34-134">Enumerations</span></span>  
 <span data-ttu-id="36c34-135">Enumerações tem comportamento de conversão de tipo nativo do XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="36c34-136">Nomes de constantes de enumeração especificados em XAML são resolvidos em relação ao tipo de enumeração subjacente e retornam o valor de enumeração para o gravador de objeto XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="36c34-137">XAML dá suporte ao uso de um estilo de sinalizadores para enumerações com <xref:System.FlagsAttribute> aplicado.</span><span class="sxs-lookup"><span data-stu-id="36c34-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="36c34-138">Para obter mais informações, consulte [XAML sintaxe em detalhes](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="36c34-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="36c34-139">([XAML sintaxe em detalhes](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) é gravado para o público do WPF, mas a maioria das informações do tópico é relevante para XAML que não é específico para uma estrutura específica de implementação.)</span><span class="sxs-lookup"><span data-stu-id="36c34-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="36c34-140">Definições de membro</span><span class="sxs-lookup"><span data-stu-id="36c34-140">Member Definitions</span></span>  
 <span data-ttu-id="36c34-141">Tipos podem definir membros para uso em XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="36c34-142">É possível para os tipos que definem os membros que são utilizáveis de XAML, mesmo se esse tipo específico não é utilizável de XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="36c34-143">Isso é possível devido a herança de CLR.</span><span class="sxs-lookup"><span data-stu-id="36c34-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="36c34-144">Desde que algum tipo que herda o membro oferece suporte ao uso XAML, como um tipo e o membro oferece suporte ao uso do XAML para seu tipo subjacente ou possui uma sintaxe XAML nativo disponível, esse membro é XAML utilizável.</span><span class="sxs-lookup"><span data-stu-id="36c34-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="36c34-145">Propriedades</span><span class="sxs-lookup"><span data-stu-id="36c34-145">Properties</span></span>  
 <span data-ttu-id="36c34-146">Se você definir propriedades como uma propriedade pública de CLR usando o CLR típico `get` e `set` padrões de acessador e palavras-chave apropriada ao idioma, o sistema de tipo XAML pode relatar a propriedade como um membro com informações apropriadas fornecida para <xref:System.Xaml.XamlMember> propriedades, como <xref:System.Xaml.XamlMember.IsReadPublic%2A> e <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="36c34-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="36c34-147">Propriedades específicas podem habilitar uma sintaxe de texto aplicando <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="36c34-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="36c34-148">Para obter mais informações, consulte [conversores de tipo e extensões de marcação para XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="36c34-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="36c34-149">Na ausência de uma sintaxe de texto ou de conversão de XAML nativo e na ausência de indireção adicional, como um uso de extensão de marcação, o tipo de uma propriedade (<xref:System.Xaml.XamlMember.TargetType%2A> no XAML sistema de tipos) deve ser capaz de retornar uma instância de um gravador de objeto XAML tratando o t tipo de destino como um tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="36c34-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="36c34-150">Se usando XAML 2009, [extensão de marcação X:Reference](../../../docs/framework/xaml-services/x-reference-markup-extension.md) pode ser usado para fornecer valores se as considerações anteriores não forem atendidas; no entanto, que é mais um problema de uso de um problema de definição de tipo.</span><span class="sxs-lookup"><span data-stu-id="36c34-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="36c34-151">Eventos</span><span class="sxs-lookup"><span data-stu-id="36c34-151">Events</span></span>  
 <span data-ttu-id="36c34-152">Se você definir eventos como um evento público do CLR, o sistema de tipo XAML pode relatar o evento como um membro com <xref:System.Xaml.XamlMember.IsEvent%2A> como `true`.</span><span class="sxs-lookup"><span data-stu-id="36c34-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="36c34-153">Os manipuladores de eventos de circuito não está dentro do escopo de recursos de serviços XAML do .NET Framework; Isso é da esquerda para implementações e estruturas específicas.</span><span class="sxs-lookup"><span data-stu-id="36c34-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="36c34-154">Métodos</span><span class="sxs-lookup"><span data-stu-id="36c34-154">Methods</span></span>  
 <span data-ttu-id="36c34-155">O código embutido para métodos não é um recurso XAML padrão.</span><span class="sxs-lookup"><span data-stu-id="36c34-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="36c34-156">Na maioria dos casos você não faça referência diretamente membros de método do XAML, e a função dos métodos em XAML é apenas fornecer suporte para padrões específicos de XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="36c34-157">[Diretiva X:factorymethod](../../../docs/framework/xaml-services/x-factorymethod-directive.md) é uma exceção.</span><span class="sxs-lookup"><span data-stu-id="36c34-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="36c34-158">Campos</span><span class="sxs-lookup"><span data-stu-id="36c34-158">Fields</span></span>  
 <span data-ttu-id="36c34-159">Diretrizes de design do CLR evitar campos não estáticos.</span><span class="sxs-lookup"><span data-stu-id="36c34-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="36c34-160">Para campos estáticos, você pode acessar os valores de campo estático somente com [extensão de marcação X:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md); nesse caso você não fazem nada especial na definição do CLR para expor um campo para [X:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usos.</span><span class="sxs-lookup"><span data-stu-id="36c34-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="36c34-161">Membros anexáveis</span><span class="sxs-lookup"><span data-stu-id="36c34-161">Attachable Members</span></span>  
 <span data-ttu-id="36c34-162">Membros anexáveis são expostos para XAML por meio de um padrão de método de acessador em uma definição de tipo.</span><span class="sxs-lookup"><span data-stu-id="36c34-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="36c34-163">A definição de tipo em si não precisa ser XAML usado como um objeto.</span><span class="sxs-lookup"><span data-stu-id="36c34-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="36c34-164">Na verdade, um padrão comum é declarar uma classe de serviço cuja função é possuir o membro anexável e implementar os comportamentos relacionados, mas não servem nenhuma outra função, como uma representação da interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="36c34-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="36c34-165">Para as seções a seguir, o espaço reservado *PropertyName* representa o nome de seu membro anexável.</span><span class="sxs-lookup"><span data-stu-id="36c34-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="36c34-166">Esse nome deve ser válido no [gramática XamlName](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="36c34-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="36c34-167">Tenha cuidado de conflitos de nome entre esses padrões e outros métodos de um tipo.</span><span class="sxs-lookup"><span data-stu-id="36c34-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="36c34-168">Se existe um membro que corresponda a um dos padrões, ele pode ser interpretado como um caminho de uso anexável por um processador XAML mesmo que não era a intenção.</span><span class="sxs-lookup"><span data-stu-id="36c34-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="36c34-169">O acessador de GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="36c34-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="36c34-170">A assinatura para o acessador `Get`*PropertyName* deve ser:</span><span class="sxs-lookup"><span data-stu-id="36c34-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="36c34-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="36c34-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="36c34-172">O objeto `target` pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="36c34-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="36c34-173">Você pode usar isso para definir o escopo de uso de anexável; usos de fora de seu escopo pretendido lançarão exceções de conversão inválida que, em seguida, são apresentadas por um erro de análise XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="36c34-174">O nome do parâmetro `target` não é um requisito, mas é denominado `target` por convenção, na maioria das implementações.</span><span class="sxs-lookup"><span data-stu-id="36c34-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="36c34-175">O valor retornado pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="36c34-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="36c34-176">Para dar suporte a um <xref:System.ComponentModel.TypeConverter> sintaxe de texto habilitado para uso do atributo do membro anexável, aplicar <xref:System.ComponentModel.TypeConverterAttribute> para o `Get` *PropertyName* acessador.</span><span class="sxs-lookup"><span data-stu-id="36c34-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="36c34-177">Aplicação para o `get` em vez do `set` pode parecer (nada óbvio); no entanto, essa convenção pode dar suporte o conceito de somente leitura anexáveis membros serializáveis, que é útil em cenários de designer.</span><span class="sxs-lookup"><span data-stu-id="36c34-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="36c34-178">O acessador de SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="36c34-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="36c34-179">A assinatura para o conjunto de*PropertyName* acessador deve ser:</span><span class="sxs-lookup"><span data-stu-id="36c34-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="36c34-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="36c34-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="36c34-181">O `target` objeto pode ser especificado como um tipo mais específico na sua implementação, com a mesma lógica e consequências, conforme descrito na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="36c34-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="36c34-182">O objeto `value` pode ser especificado como um tipo mais específico na sua implementação.</span><span class="sxs-lookup"><span data-stu-id="36c34-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="36c34-183">Lembre-se de que o valor para este método é a entrada proveniente do uso de XAML, normalmente na forma de atributo.</span><span class="sxs-lookup"><span data-stu-id="36c34-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="36c34-184">De forma de atributo deve haver suporte de conversor de valor para uma sintaxe de texto e atributo no `Get` *PropertyName* acessador.</span><span class="sxs-lookup"><span data-stu-id="36c34-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="36c34-185">Repositórios de membro anexável</span><span class="sxs-lookup"><span data-stu-id="36c34-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="36c34-186">Os métodos acessadores normalmente não são suficientes para fornecer um meio para inserir os valores de membro anexável em um gráfico de objeto, ou para recuperar valores fora do gráfico do objeto e serializá-los corretamente.</span><span class="sxs-lookup"><span data-stu-id="36c34-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="36c34-187">Para fornecer essa funcionalidade, o `target` objetos nas assinaturas acessador anterior devem ser capazes de armazenar valores.</span><span class="sxs-lookup"><span data-stu-id="36c34-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="36c34-188">O mecanismo de armazenamento deve ser consistente com o princípio de anexável que o membro anexável para destinos de onde o membro anexável não está na lista de membros.</span><span class="sxs-lookup"><span data-stu-id="36c34-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="36c34-189">Serviços XAML do .NET framework fornece uma técnica de implementação para o membro anexável armazena através das APIs <xref:System.Xaml.IAttachedPropertyStore> e <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="36c34-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="36c34-190"><xref:System.Xaml.IAttachedPropertyStore>é usado pelos autores XAML para descobrir a implementação de armazenamento e deve ser implementado no tipo que é o `target` de acessadores.</span><span class="sxs-lookup"><span data-stu-id="36c34-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="36c34-191">Estático <xref:System.Xaml.AttachablePropertyServices> APIs são usados dentro do corpo de acessadores e consulte o membro anexável por seu <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="36c34-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="36c34-192">Atributos CLR relacionados a XAML</span><span class="sxs-lookup"><span data-stu-id="36c34-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="36c34-193">Atribuição corretamente os tipos, membros e assemblies é importante na ordem para o relatório de informações do sistema de tipo XAML para serviços XAML do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="36c34-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="36c34-194">Isso é relevante se você pretende seus tipos para uso com os sistemas XAML diretamente com base em leitores de XAML de serviços XAML do .NET Framework e gravadores XAML, ou se você define ou usa uma estrutura utilizando XAML com base nesses leitores XAML e gravadores XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="36c34-195">Para obter uma lista de cada atributo relacionados a XAML que é relevante para suporte XAML de seus tipos personalizados, consulte [XAML-Related CLR atributos para tipos personalizados e bibliotecas](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="36c34-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="36c34-196">Uso</span><span class="sxs-lookup"><span data-stu-id="36c34-196">Usage</span></span>  
 <span data-ttu-id="36c34-197">Uso de tipos personalizados requer que o autor de marcação deve mapear um prefixo para o assembly e o namespace CLR que contém o tipo personalizado.</span><span class="sxs-lookup"><span data-stu-id="36c34-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="36c34-198">Esse procedimento não está documentado neste tópico.</span><span class="sxs-lookup"><span data-stu-id="36c34-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="36c34-199">Nível de acesso</span><span class="sxs-lookup"><span data-stu-id="36c34-199">Access Level</span></span>  
 <span data-ttu-id="36c34-200">XAML fornece um meio para carregar e instanciar tipos que têm um `internal` nível de acesso.</span><span class="sxs-lookup"><span data-stu-id="36c34-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="36c34-201">Essa funcionalidade é fornecida para que o código do usuário pode definir seus próprios tipos e, em seguida, criar uma instância dessas classes de marcação que também faz parte do mesmo escopo de código do usuário.</span><span class="sxs-lookup"><span data-stu-id="36c34-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="36c34-202">Um exemplo do WPF é sempre que o código de usuário define uma <xref:System.Windows.Controls.UserControl> que destina-se como uma maneira para refatorar um comportamento de interface do usuário, mas não como parte de qualquer mecanismo de extensão possíveis que pode ser implícitas declarando a classe de suporte com `public` nível de acesso.</span><span class="sxs-lookup"><span data-stu-id="36c34-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="36c34-203">Tal uma <xref:System.Windows.Controls.UserControl> pode ser declarado com `internal` acesso se o código é compilado para o mesmo assembly do qual ele é referenciado como um tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="36c34-204">Para um aplicativo que carrega o XAML em confiança total e usa <xref:System.Xaml.XamlObjectWriter>, carregando classes com `internal` nível de acesso está sempre habilitado.</span><span class="sxs-lookup"><span data-stu-id="36c34-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="36c34-205">Para um aplicativo que carrega o XAML em confiança parcial, você pode controlar as características de nível de acesso usando o <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="36c34-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="36c34-206">Além disso, mecanismos de adiamento (como o sistema de modelo do WPF) devem ser capazes de propagar quaisquer permissões de nível de acesso e preservá-los para as avaliações de tempo de execução eventual; Isso é manipulado internamente, passando o <xref:System.Xaml.Permissions.XamlAccessLevel> informações.</span><span class="sxs-lookup"><span data-stu-id="36c34-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="36c34-207">Implementação do WPF</span><span class="sxs-lookup"><span data-stu-id="36c34-207">WPF Implementation</span></span>  
 <span data-ttu-id="36c34-208">WPF XAML usa um modelo de acesso de confiança parcial onde se BAML é carregado sob confiança parcial, o acesso é restrito a <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> para o assembly que é a origem BAML.</span><span class="sxs-lookup"><span data-stu-id="36c34-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="36c34-209">Para o adiamento, WPF usa <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> como um mecanismo para passar as informações de nível de acesso.</span><span class="sxs-lookup"><span data-stu-id="36c34-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="36c34-210">Na terminologia do WPF XAML, uma *tipo interno* é um tipo definido pelo mesmo assembly que também inclui o XAML de referência.</span><span class="sxs-lookup"><span data-stu-id="36c34-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="36c34-211">Desse tipo pode ser mapeado por meio de um namespace XAML que deliberadamente omite o assembly = parte de um mapeamento, por exemplo, `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="36c34-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="36c34-212">Se BAML faz referência a um tipo interno e que tenha tipo `internal` acessar nível, isso gera um `GeneratedInternalTypeHelper` classe para o assembly.</span><span class="sxs-lookup"><span data-stu-id="36c34-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="36c34-213">Se você quiser evitar `GeneratedInternalTypeHelper`, você deve use `public` nível, de acesso ou deve influenciar a classe relevante um assembly separado e tornar esse assembly dependente.</span><span class="sxs-lookup"><span data-stu-id="36c34-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="36c34-214">Consulte também</span><span class="sxs-lookup"><span data-stu-id="36c34-214">See Also</span></span>  
 [<span data-ttu-id="36c34-215">Atributos CLR relacionados a XAML para tipos personalizados e bibliotecas</span><span class="sxs-lookup"><span data-stu-id="36c34-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="36c34-216">Serviços XAML</span><span class="sxs-lookup"><span data-stu-id="36c34-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
