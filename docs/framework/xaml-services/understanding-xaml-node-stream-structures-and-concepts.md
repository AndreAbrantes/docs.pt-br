---
title: Noções básicas sobre estruturas e conceitos do fluxo de nó XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: 100de0a897538527b76b1a53cf40d59a8804d3ae
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/04/2018
ms.locfileid: "43519441"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="2011b-102">Noções básicas sobre estruturas e conceitos do fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-102">Understanding XAML Node Stream Structures and Concepts</span></span>
<span data-ttu-id="2011b-103">Leitores XAML e gravadores XAML como implementado no serviços de XAML do .NET Framework baseiam-se no conceito de design de um fluxo de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="2011b-104">O fluxo do nó XAML é uma conceitualização de um conjunto de nós XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="2011b-105">Este conceitualização, um processador XAML conduz através da estrutura das relações em que o XAML em um nó por vez.</span><span class="sxs-lookup"><span data-stu-id="2011b-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="2011b-106">A qualquer momento, somente um registro atual ou a posição atual existe em um fluxo de nó XAML aberto e muitos aspectos da API de relatório apenas as informações disponíveis de posição.</span><span class="sxs-lookup"><span data-stu-id="2011b-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="2011b-107">O nó atual em um fluxo de nó XAML pode ser descrito como sendo um objeto, um membro ou um valor.</span><span class="sxs-lookup"><span data-stu-id="2011b-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="2011b-108">Tratando o XAML como um fluxo do nó XAML, os leitores XAML podem se comunicar com gravadores XAML e habilitar um programa exibir, interagir com ou alterar o conteúdo de um fluxo de nó XAML durante um caminho de carga ou salvar operação de caminho que envolve a XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="2011b-109">Design de API de leitor e gravador XAML e o conceito de fluxo do nó XAML são semelhantes ao anterior leitor relacionado e designs de gravador e conceitos, como o [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] e o <xref:System.Xml.XmlReader> e <xref:System.Xml.XmlWriter> classes.</span><span class="sxs-lookup"><span data-stu-id="2011b-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="2011b-110">Este tópico aborda os conceitos de fluxo de nó XAML e descreve como você pode escrever rotinas que interagem com representações de XAML no nível do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>  
  
<a name="loading_into_a_xaml_reader"></a>   
## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="2011b-111">Carregamento de XAML em um leitor XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-111">Loading XAML into a XAML Reader</span></span>  
 <span data-ttu-id="2011b-112">A base de <xref:System.Xaml.XamlReader> classe declara uma técnica específica para carregar o XAML inicial em um leitor XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="2011b-113">Em vez disso, uma classe derivada declara e implementa a técnica de carregamento, incluindo as características gerais e restrições de sua fonte de entrada para XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="2011b-114">Por exemplo, um <xref:System.Xaml.XamlObjectReader> lê um grafo de objeto, começando da fonte de entrada de um único objeto que representa a raiz ou base.</span><span class="sxs-lookup"><span data-stu-id="2011b-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="2011b-115">O <xref:System.Xaml.XamlObjectReader> , em seguida, produz um fluxo do nó XAML do grafo de objetos.</span><span class="sxs-lookup"><span data-stu-id="2011b-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>  
  
 <span data-ttu-id="2011b-116">O mais proeminente definidos para serviços de XAML do .NET Framework <xref:System.Xaml.XamlReader> subclasse é <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="2011b-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="2011b-117"><xref:System.Xaml.XamlXmlReader> carrega a XAML inicial, seja ao carregar um arquivo de texto diretamente por meio de um caminho de arquivo ou fluxo ou indiretamente por meio de uma classe de leitor relacionados, como <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="2011b-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="2011b-118">O <xref:System.Xaml.XamlReader> pode ser pensado como contendo a totalidade da fonte de entrada de XAML depois de ele ter sido carregado.</span><span class="sxs-lookup"><span data-stu-id="2011b-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="2011b-119">No entanto, o <xref:System.Xaml.XamlReader> API base foi projetado para que o leitor está interagindo com um único nó da XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="2011b-120">Quando carregado pela primeira vez, o primeiro nó único que você encontrar é a raiz de seu objeto de início e o XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>  
  
### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="2011b-121">O conceito de Stream do nó XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-121">The XAML Node Stream Concept</span></span>  
 <span data-ttu-id="2011b-122">Se você estiver mais familiarizado com um DOM, a metáfora da árvore ou a abordagem baseada em consulta para acessar tecnologias baseadas em XML, uma maneira útil de conceitualizar um fluxo do nó XAML é da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="2011b-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="2011b-123">Imagine que o XAML carregado é um DOM ou uma árvore onde cada nó possíveis é expandida totalmente e, em seguida, apresentado linearmente.</span><span class="sxs-lookup"><span data-stu-id="2011b-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="2011b-124">Conforme você avança através de nós, você pode percorrer "in" ou "out" de níveis que seriam relevantes para um DOM, mas o fluxo do nó XAML não explicitamente manter controle porque esses conceitos de nível não são relevantes para um fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="2011b-125">O fluxo do nó tem uma posição "atual", mas a menos que você tenha armazenado outras partes do fluxo por conta própria como referências, todos os aspectos do fluxo de nó que não seja a posição do nó atual estão fora do modo de exibição.</span><span class="sxs-lookup"><span data-stu-id="2011b-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>  
  
 <span data-ttu-id="2011b-126">O conceito de fluxo do nó XAML tem a vantagem notável que se você percorrer o fluxo de todo o nó, você terá certeza que você processou a representação inteira do XAML; Você não precisa se preocupar que uma consulta, uma operação de DOM ou qualquer outra abordagem para informações de processamento não linear perdeu alguma parte da representação completa do XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="2011b-127">Por esse motivo, a representação de fluxo do nó XAML é ideal para conectar-se a leitores XAML e gravadores XAML e para fornecer um sistema em que você pode inserir seu próprio processo que funciona entre as fases de leitura e gravação de uma operação de processamento de XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="2011b-128">Em muitos casos, a ordenação de nós em que o fluxo do nó XAML é deliberadamente otimizada ou reordenada por leitores XAML versus como a ordem pode aparecer no texto de origem, binário ou grafo de objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="2011b-129">Esse comportamento destina-se para impor uma arquitetura de processamento de XAML, no qual os gravadores XAML são nunca em uma posição em que eles têm para "retornar" no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="2011b-130">Idealmente, XAML de todas as operações de gravação deve ser capaz de agir com base no contexto de esquema além da posição atual do fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>  
  
<a name="a_basic_reading_node_loop"></a>   
## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="2011b-131">Um Loop de nó de leitura básicas</span><span class="sxs-lookup"><span data-stu-id="2011b-131">A Basic Reading Node Loop</span></span>  
 <span data-ttu-id="2011b-132">Um básico lendo o loop de nó para examinar um fluxo do nó XAML consiste em conceitos a seguir.</span><span class="sxs-lookup"><span data-stu-id="2011b-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="2011b-133">Para fins de loops conforme discutido neste tópico, supõem que você está lendo um XAML baseado em texto e humanamente legível do nó de arquivos usando o <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="2011b-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="2011b-134">Os links nesta seção se referem ao loop de nó XAML específico API implementado pelo <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="2011b-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>  
  
-   <span data-ttu-id="2011b-135">Certifique-se de que você não está no final do fluxo de nó XAML (Verifique <xref:System.Xaml.XamlXmlReader.IsEof%2A>, ou usar o <xref:System.Xaml.XamlXmlReader.Read%2A> retornar valor).</span><span class="sxs-lookup"><span data-stu-id="2011b-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="2011b-136">Se você estiver no final do fluxo, não há nenhum nó atual e você deve sair.</span><span class="sxs-lookup"><span data-stu-id="2011b-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>  
  
-   <span data-ttu-id="2011b-137">Verificar que tipo de nó, atualmente, expõe o fluxo do nó XAML chamando <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>  
  
-   <span data-ttu-id="2011b-138">Se você tiver um gravador de objeto XAML associado que está conectado diretamente, você geralmente chama <xref:System.Xaml.XamlWriter.WriteNode%2A> neste momento.</span><span class="sxs-lookup"><span data-stu-id="2011b-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>  
  
-   <span data-ttu-id="2011b-139">Com base no qual <xref:System.Xaml.XamlNodeType> é relatada como o nó atual ou o registro atual, chame um dos procedimentos a seguir para obter informações sobre o conteúdo do nó:</span><span class="sxs-lookup"><span data-stu-id="2011b-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>  
  
    -   <span data-ttu-id="2011b-140">Para um <xref:System.Xaml.XamlXmlReader.NodeType%2A> dos <xref:System.Xaml.XamlNodeType.StartMember> ou <xref:System.Xaml.XamlNodeType.EndMember>, chame <xref:System.Xaml.XamlXmlReader.Member%2A> obter <xref:System.Xaml.XamlMember> informações sobre um membro.</span><span class="sxs-lookup"><span data-stu-id="2011b-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="2011b-141">Observe que o membro pode ser um <xref:System.Xaml.XamlDirective>, e, portanto, pode não ser necessariamente um membro de tipo definido convencional do objeto anterior.</span><span class="sxs-lookup"><span data-stu-id="2011b-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="2011b-142">Por exemplo, `x:Name` aplicado a um objeto aparece como um membro XAML em que <xref:System.Xaml.XamlMember.IsDirective%2A> é verdadeiro e o <xref:System.Xaml.XamlMember.Name%2A> do membro é `Name`, com outras propriedades que indica que essa diretiva está sob o namespace XAML de linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>  
  
    -   <span data-ttu-id="2011b-143">Para um <xref:System.Xaml.XamlXmlReader.NodeType%2A> dos <xref:System.Xaml.XamlNodeType.StartObject> ou <xref:System.Xaml.XamlNodeType.EndObject>, chame <xref:System.Xaml.XamlXmlReader.Type%2A> obter <xref:System.Xaml.XamlType> informações sobre um objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>  
  
    -   <span data-ttu-id="2011b-144">Para um <xref:System.Xaml.XamlXmlReader.NodeType%2A> dos <xref:System.Xaml.XamlNodeType.Value>, chame <xref:System.Xaml.XamlXmlReader.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="2011b-145">Um nó é um valor somente se ele é a expressão mais simples de um valor para um membro ou o texto de inicialização para um objeto (no entanto, você deve estar ciente do comportamento de conversão de tipo, conforme documentado em uma seção posterior deste tópico).</span><span class="sxs-lookup"><span data-stu-id="2011b-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>  
  
    -   <span data-ttu-id="2011b-146">Para um <xref:System.Xaml.XamlXmlReader.NodeType%2A> dos <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, chame <xref:System.Xaml.XamlXmlReader.Namespace%2A> para obter informações de namespace para um nó de namespace.</span><span class="sxs-lookup"><span data-stu-id="2011b-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>  
  
-   <span data-ttu-id="2011b-147">Chamar <xref:System.Xaml.XamlXmlReader.Read%2A> para avança o leitor XAML para o próximo nó no fluxo de nó XAML e repita as etapas novamente.</span><span class="sxs-lookup"><span data-stu-id="2011b-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>  
  
 <span data-ttu-id="2011b-148">O fluxo do nó XAML fornecido pelos leitores de XAML de serviços de XAML do .NET Framework sempre fornece uma passagem completa, detalhada de todos os nós possíveis.</span><span class="sxs-lookup"><span data-stu-id="2011b-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="2011b-149">Técnicas de controle de fluxo típico para um loop de nó XAML incluem a definição de corpo dentro de um `while (reader.Read())`e a alternância <xref:System.Xaml.XamlXmlReader.NodeType%2A> em cada nó do ponto no loop de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>  
  
 <span data-ttu-id="2011b-150">Se o fluxo do nó estiver no final do arquivo, o nó atual é nulo.</span><span class="sxs-lookup"><span data-stu-id="2011b-150">If the node stream is at end of file, the current node is null.</span></span>  
  
 <span data-ttu-id="2011b-151">O loop mais simples que usa um leitor e gravador é semelhante ao exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="2011b-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>  
  
```  
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));  
//where xamlStringToLoad is a string of well formed XAML  
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);  
while (xxr.Read()) {  
  xow.WriteNode(xxr);  
}  
```  
  
 <span data-ttu-id="2011b-152">Este exemplo básico de um loop de nó XAML carga caminho conecta de maneira transparente o leitor XAML e o gravador XAML, sem fazer nada diferente se você tivesse usado <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2011b-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2011b-153">Mas essa estrutura básica, em seguida, é expandida para aplicar ao seu cenário de gravação ou leitura.</span><span class="sxs-lookup"><span data-stu-id="2011b-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="2011b-154">Alguns cenários possíveis são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="2011b-154">Some possible scenarios are as follows:</span></span>  
  
-   <span data-ttu-id="2011b-155">Ative o <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="2011b-156">Execute ações diferentes dependendo de qual nó o tipo está sendo lido.</span><span class="sxs-lookup"><span data-stu-id="2011b-156">Perform different actions depending on which node type is being read.</span></span>  
  
-   <span data-ttu-id="2011b-157">Não chame <xref:System.Xaml.XamlWriter.WriteNode%2A> em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="2011b-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="2011b-158">Apenas chame <xref:System.Xaml.XamlWriter.WriteNode%2A> em alguns <xref:System.Xaml.XamlXmlReader.NodeType%2A> casos.</span><span class="sxs-lookup"><span data-stu-id="2011b-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>  
  
-   <span data-ttu-id="2011b-159">Na lógica para um tipo de nó específico, analisamos as especificações do nó e agir sobre eles.</span><span class="sxs-lookup"><span data-stu-id="2011b-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="2011b-160">Por exemplo, você poderia escrever apenas objetos que vêm de um namespace XAML específico e, em seguida, remover ou adiar quaisquer objetos não do namespace XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="2011b-161">Ou você pode remover ou reprocessar caso contrário, as diretivas XAML que não dão suporte a seu sistema XAML como parte de seu membro de processamento.</span><span class="sxs-lookup"><span data-stu-id="2011b-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>  
  
-   <span data-ttu-id="2011b-162">Definir um personalizado <xref:System.Xaml.XamlObjectWriter> que substitui `Write*` métodos, possivelmente executando o mapeamento de tipo que ignora o contexto de esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>  
  
-   <span data-ttu-id="2011b-163">Construir o <xref:System.Xaml.XamlXmlReader> usar um contexto de esquema XAML não padrão, para que personalizado diferenças no comportamento XAML são usadas pelo leitor e gravador.</span><span class="sxs-lookup"><span data-stu-id="2011b-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>  
  
### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="2011b-164">Acessando o XAML além do conceito de Loop de nó</span><span class="sxs-lookup"><span data-stu-id="2011b-164">Accessing XAML Beyond the Node Loop Concept</span></span>  
 <span data-ttu-id="2011b-165">Há potencialmente outras maneiras de trabalhar com uma representação de XAML diferente de como um loop de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="2011b-166">Por exemplo, pode existir um leitor XAML que pode ler um nó indexado, ou em particular acessa nós diretamente pelo `x:Name`, por `x:Uid`, ou por meio de outros identificadores.</span><span class="sxs-lookup"><span data-stu-id="2011b-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="2011b-167">Serviços de XAML do .NET framework não fornece uma implementação completa, mas fornece um padrão sugerido por meio de tipos de serviços e suporte.</span><span class="sxs-lookup"><span data-stu-id="2011b-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="2011b-168">Para obter mais informações, consulte <xref:System.Xaml.IXamlIndexingReader> e <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="2011b-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="2011b-169">Microsoft também produz uma versão de out-of-band conhecida como o Kit de ferramentas do Microsoft XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-169">Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit.</span></span> <span data-ttu-id="2011b-170">Esta versão do out-of-band ainda está em seus estágios de pré-lançamento.</span><span class="sxs-lookup"><span data-stu-id="2011b-170">This out-of-band release is still in its pre-release stages.</span></span> <span data-ttu-id="2011b-171">No entanto, se você estiver disposto a trabalhar com componentes de pré-lançamento, o Kit de ferramentas do Microsoft XAML fornece alguns recursos interessantes para ferramentas XAML e análise estática do XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-171">However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML.</span></span> <span data-ttu-id="2011b-172">O Kit de ferramentas do Microsoft XAML inclui uma API do DOM XAML, suporte para análise do FxCop e um contexto de esquema XAML para Silverlight.</span><span class="sxs-lookup"><span data-stu-id="2011b-172">The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight.</span></span> <span data-ttu-id="2011b-173">Para obter mais informações, consulte [Kit de ferramentas do Microsoft XAML](https://code.msdn.microsoft.com/XAML).</span><span class="sxs-lookup"><span data-stu-id="2011b-173">For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).</span></span>  
  
<a name="working_with_the_current_node"></a>   
## <a name="working-with-the-current-node"></a><span data-ttu-id="2011b-174">Trabalhando com o nó atual</span><span class="sxs-lookup"><span data-stu-id="2011b-174">Working with the Current Node</span></span>  
 <span data-ttu-id="2011b-175">A maioria dos cenários que usam um loop de nó XAML não ler apenas os nós.</span><span class="sxs-lookup"><span data-stu-id="2011b-175">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="2011b-176">A maioria dos cenários processar nós atuais e passar cada nó de um por vez para uma implementação de <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="2011b-176">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>  
  
 <span data-ttu-id="2011b-177">No cenário de carga típica de caminho, uma <xref:System.Xaml.XamlXmlReader> produz um fluxo de nó XAML; os nós XAML serão processados segundo sua lógica e o contexto de esquema XAML; e os nós são passados para um <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="2011b-177">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="2011b-178">Você, em seguida, integrar o grafo de objeto resultante em seu aplicativo ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="2011b-178">You then integrate the resulting object graph into your application or framework.</span></span>  
  
 <span data-ttu-id="2011b-179">Em um típico cenário de caminho de salvar uma <xref:System.Xaml.XamlObjectReader> lê o grafo de objeto, nós individuais do XAML são processados e um <xref:System.Xaml.XamlXmlWriter> gera o resultado serializado como um arquivo de texto XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-179">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="2011b-180">A chave é que os caminhos e cenários envolvem trabalhar com exatamente um nó XAML por vez e os nós XAML estão disponíveis para tratamento de uma maneira padronizada que é definida pelo sistema de tipo XAML e o.NET Framework as APIs dos serviços de XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-180">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>  
  
### <a name="frames-and-scope"></a><span data-ttu-id="2011b-181">Quadros e escopo</span><span class="sxs-lookup"><span data-stu-id="2011b-181">Frames and Scope</span></span>  
 <span data-ttu-id="2011b-182">Um loop de nó XAML orienta por meio de um fluxo do nó XAML de forma linear.</span><span class="sxs-lookup"><span data-stu-id="2011b-182">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="2011b-183">Percorre o fluxo do nó em objetos em membros que contêm outros objetos e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="2011b-183">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="2011b-184">Geralmente é útil manter o controle de escopo dentro do fluxo de nó XAML com a implementação de um conceito de quadro e a pilha.</span><span class="sxs-lookup"><span data-stu-id="2011b-184">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="2011b-185">Isso é especialmente verdadeiro se você estiver ajustando ativamente o fluxo do nó enquanto estiver nele.</span><span class="sxs-lookup"><span data-stu-id="2011b-185">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="2011b-186">O quadro e a pilha de suportam que você implemente como parte de sua lógica de loop de nó pode contar `StartObject` (ou `GetObject`) e `EndObject` escopos conforme você descer para uma estrutura de nó XAML se a estrutura é considerada de uma perspectiva de DOM.</span><span class="sxs-lookup"><span data-stu-id="2011b-186">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>  
  
<a name="traversing_and_entering_object_nodes"></a>   
## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="2011b-187">Percorrer e inserindo nós de objeto</span><span class="sxs-lookup"><span data-stu-id="2011b-187">Traversing and Entering Object Nodes</span></span>  
 <span data-ttu-id="2011b-188">O primeiro nó em um fluxo de nó quando ele é aberto por um leitor XAML é o nó de objeto inicial do objeto raiz.</span><span class="sxs-lookup"><span data-stu-id="2011b-188">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="2011b-189">Por definição, esse objeto é sempre um único nó de objeto e não tem nenhum par.</span><span class="sxs-lookup"><span data-stu-id="2011b-189">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="2011b-190">Em qualquer exemplo XAML do mundo real, o objeto raiz é definido para ter uma ou mais propriedades que contêm mais objetos e essas propriedades têm nós membro.</span><span class="sxs-lookup"><span data-stu-id="2011b-190">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="2011b-191">Os nós de membro tem um ou mais nós de objeto ou também podem terminar em um nó de valor em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2011b-191">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="2011b-192">O objeto raiz normalmente define namescopes XAML, que são atribuídos sintaticamente como atributos na marcação de texto XAML, mas mapear para um `Namescope` tipo de nó na representação de fluxo do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-192">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>  
  
 <span data-ttu-id="2011b-193">Considere o seguinte exemplo XAML (esse é o XAML arbitrário, não tem relação com os tipos existentes no .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="2011b-193">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="2011b-194">Suponha que nesse modelo de objeto, `FavorCollection` está `List<T>` dos `Favor`, `Balloon` e `NoiseMaker` podem ser atribuídos a `Favor`, o `Balloon.Color` propriedade é feita por um `Color` objeto semelhante à forma como o WPF define cores como nomes de cor conhecida e `Color` dá suporte a um conversor de tipo para a sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="2011b-194">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>  
  
|<span data-ttu-id="2011b-195">Marcação XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-195">XAML markup</span></span>|<span data-ttu-id="2011b-196">Fluxo de nó XAML resultante</span><span class="sxs-lookup"><span data-stu-id="2011b-196">Resulting XAML node stream</span></span>|  
|-----------------|--------------------------------|  
|`<Party`|<span data-ttu-id="2011b-197">`Namespace` nó para `Party`</span><span class="sxs-lookup"><span data-stu-id="2011b-197">`Namespace` node for `Party`</span></span>|  
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="2011b-198">`StartObject` nó para `Party`</span><span class="sxs-lookup"><span data-stu-id="2011b-198">`StartObject` node for `Party`</span></span>|  
|`<Party.Favors>`|<span data-ttu-id="2011b-199">`StartMember` nó para `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="2011b-199">`StartMember` node for `Party.Favors`</span></span>|  
||<span data-ttu-id="2011b-200">`StartObject` nó para implícita `FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="2011b-200">`StartObject` node for implicit `FavorCollection`</span></span>|  
||<span data-ttu-id="2011b-201">`StartMember` nó para implícita `FavorCollection` itens de propriedade.</span><span class="sxs-lookup"><span data-stu-id="2011b-201">`StartMember` node for implicit `FavorCollection` items property.</span></span>|  
|`<Balloon`|<span data-ttu-id="2011b-202">`StartObject` nó para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="2011b-202">`StartObject` node for `Balloon`</span></span>|  
|`Color="Red"`|<span data-ttu-id="2011b-203">`StartMember` nó para `Color`</span><span class="sxs-lookup"><span data-stu-id="2011b-203">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="2011b-204">`Value` nó da cadeia de caracteres do valor de atributo `"Red"`</span><span class="sxs-lookup"><span data-stu-id="2011b-204">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="2011b-205">`EndMember` para `Color`</span><span class="sxs-lookup"><span data-stu-id="2011b-205">`EndMember` for `Color`</span></span>|  
|`HasHelium="True"`|<span data-ttu-id="2011b-206">`StartMember` nó para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="2011b-206">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="2011b-207">`Value` nó da cadeia de caracteres do valor de atributo `"True"`</span><span class="sxs-lookup"><span data-stu-id="2011b-207">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="2011b-208">`EndMember` para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="2011b-208">`EndMember` for `HasHelium`</span></span>|  
|`>`|<span data-ttu-id="2011b-209">`EndObject` para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="2011b-209">`EndObject` for `Balloon`</span></span>|  
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="2011b-210">`StartObject` nó para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="2011b-210">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="2011b-211">`StartMember` nó para `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="2011b-211">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="2011b-212">`Value` nó da cadeia de caracteres do valor de inicialização `"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="2011b-212">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="2011b-213">`EndMember` nó para `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="2011b-213">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="2011b-214">`EndObject` para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="2011b-214">`EndObject` for `NoiseMaker`</span></span>|  
||<span data-ttu-id="2011b-215">`EndMember` nó para implícita `FavorCollection` itens de propriedade.</span><span class="sxs-lookup"><span data-stu-id="2011b-215">`EndMember` node for implicit `FavorCollection` items property.</span></span>|  
||<span data-ttu-id="2011b-216">`EndObject` nó para implícita `FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="2011b-216">`EndObject` node for implicit `FavorCollection`</span></span>|  
|`</Party.Favors>`|<span data-ttu-id="2011b-217">`EndMember` para `Favors`</span><span class="sxs-lookup"><span data-stu-id="2011b-217">`EndMember` for `Favors`</span></span>|  
|`</Party>`|<span data-ttu-id="2011b-218">`EndObject` para `Party`</span><span class="sxs-lookup"><span data-stu-id="2011b-218">`EndObject` for `Party`</span></span>|  
  
 <span data-ttu-id="2011b-219">O fluxo do nó XAML, você pode contar o seguinte comportamento:</span><span class="sxs-lookup"><span data-stu-id="2011b-219">In the XAML node stream, you can rely on the following behavior:</span></span>  
  
-   <span data-ttu-id="2011b-220">Se um `Namespace` nó existe, ele é adicionado para o fluxo imediatamente antes de `StartObject` que declarado o namespace XAML com `xmlns`.</span><span class="sxs-lookup"><span data-stu-id="2011b-220">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="2011b-221">Examinar a tabela anterior com o fluxo do nó XAML e o exemplo novamente.</span><span class="sxs-lookup"><span data-stu-id="2011b-221">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="2011b-222">Observe como o `StartObject` e `Namespace` nós parecem ser modificados em comparação com as posições de declaração na marcação de texto.</span><span class="sxs-lookup"><span data-stu-id="2011b-222">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="2011b-223">Isso é representativa do comportamento em que os nós de namespace aparecem sempre à frente o nó se aplicam a no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-223">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="2011b-224">O objetivo deste design é que as informações de namespace são vitais para gravadores de objeto e devem ser conhecidas antes que as tentativas de gravador de objeto para executar o tipo de mapeamento ou caso contrário, processam o objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-224">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="2011b-225">Colocar as informações do namespace XAML à frente do seu escopo de aplicativo no fluxo torna mais simples para sempre processar o fluxo do nó em sua ordem apresentada.</span><span class="sxs-lookup"><span data-stu-id="2011b-225">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>  
  
-   <span data-ttu-id="2011b-226">Por causa de consideração acima, é um ou mais `Namespace` nós que você leia primeiro na maioria dos casos de marcação do mundo real ao percorrer nós desde o início, não o `StartObject` da raiz.</span><span class="sxs-lookup"><span data-stu-id="2011b-226">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>  
  
-   <span data-ttu-id="2011b-227">Um `StartObject` nó pode ser seguido por `StartMember`, `Value`, ou imediato `EndObject`.</span><span class="sxs-lookup"><span data-stu-id="2011b-227">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="2011b-228">Ele nunca será seguido imediatamente por outro `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="2011b-228">It is never followed immediately by another `StartObject`.</span></span>  
  
-   <span data-ttu-id="2011b-229">Um `StartMember` pode ser seguido por um `StartObject`, `Value`, ou imediato `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="2011b-229">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="2011b-230">Ele pode ser seguido por `GetObject`, para membros em que o valor deve vir de um valor existente do objeto pai em vez de um `StartObject` que poderia instanciar um novo valor.</span><span class="sxs-lookup"><span data-stu-id="2011b-230">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="2011b-231">Ele também pode ser seguido por um `Namespace` nó, que se aplica a uma futura `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="2011b-231">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="2011b-232">Ele nunca será seguido imediatamente por outro `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="2011b-232">It is never followed immediately by another `StartMember`.</span></span>  
  
-   <span data-ttu-id="2011b-233">Um `Value` nó representa o valor em si; não há nenhum "EndValue".</span><span class="sxs-lookup"><span data-stu-id="2011b-233">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="2011b-234">Ele pode ser seguido apenas por um `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="2011b-234">It can be followed only by an `EndMember`.</span></span>  
  
    -   <span data-ttu-id="2011b-235">Texto de inicialização do XAML do objeto, como pode ser usado pela construção não resulta em uma estrutura de valor do objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-235">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="2011b-236">Em vez disso, um nó de membro dedicado para um membro chamado `_Initialization` é criado.</span><span class="sxs-lookup"><span data-stu-id="2011b-236">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="2011b-237">e esse nó de membro contém a cadeia de caracteres do valor de inicialização.</span><span class="sxs-lookup"><span data-stu-id="2011b-237">and that member node contains the initialization value string.</span></span> <span data-ttu-id="2011b-238">Se ele existir, `_Initialization` sempre é a primeira `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="2011b-238">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="2011b-239">`_Initialization` pode ser qualificado em algumas representações de serviços XAML com o namescope XAML de linguagem XAML, para esclarecer que `_Initialization` não é uma propriedade definida em tipos de suporte.</span><span class="sxs-lookup"><span data-stu-id="2011b-239">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>  
  
    -   <span data-ttu-id="2011b-240">Uma combinação do valor do membro representa uma definição de atributo do valor.</span><span class="sxs-lookup"><span data-stu-id="2011b-240">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="2011b-241">Eventualmente, talvez existam um conversor de valor envolvidos no processamento esse valor e o valor é uma cadeia de caracteres simples.</span><span class="sxs-lookup"><span data-stu-id="2011b-241">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="2011b-242">No entanto, que não é avaliada até que um gravador de objeto XAML processa esse fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-242">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="2011b-243">O gravador de objeto XAML possui o contexto de esquema XAML necessário, mapeamento de tipo de sistema e outros tipos de suporte necessários para conversões de valor.</span><span class="sxs-lookup"><span data-stu-id="2011b-243">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>  
  
-   <span data-ttu-id="2011b-244">Uma `EndMember` nó pode ser seguido por um `StartMember` nó para um membro subsequente, ou por um `EndObject` nó do proprietário do membro.</span><span class="sxs-lookup"><span data-stu-id="2011b-244">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>  
  
-   <span data-ttu-id="2011b-245">Uma `EndObject` nó pode ser seguido por um `EndMember` nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-245">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="2011b-246">Ele também pode ser seguido por um `StartObject` nó para casos em que os objetos são correspondentes nos itens da coleção.</span><span class="sxs-lookup"><span data-stu-id="2011b-246">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="2011b-247">Ou ele pode ser seguido por um `Namespace` nó, que se aplica a uma futura `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="2011b-247">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>  
  
    -   <span data-ttu-id="2011b-248">Para o caso exclusivo de fechar o fluxo de todo o nó, o `EndObject` de raiz não é seguida por nada; o leitor agora é o fim do arquivo, e <xref:System.Xaml.XamlReader.Read%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="2011b-248">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>  
  
<a name="value_converters_and_the_xaml_node_stream"></a>   
## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="2011b-249">Conversores de valor e o Stream de nó XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-249">Value Converters and the XAML Node Stream</span></span>  
 <span data-ttu-id="2011b-250">Um conversor de valor é um termo geral para uma extensão de marcação, um conversor de tipo (incluindo os serializadores de valor) ou outra classe dedicado que é relatado como um conversor de valor por meio do sistema de tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-250">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="2011b-251">No fluxo de nó XAML, um uso de conversor de tipo e um uso de extensão de marcação têm representações muito diferentes.</span><span class="sxs-lookup"><span data-stu-id="2011b-251">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>  
  
### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="2011b-252">Conversores de tipo em que o Stream de nó XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-252">Type Converters in the XAML Node Stream</span></span>  
 <span data-ttu-id="2011b-253">Um atributo definido que eventualmente resulta em um uso de conversor de tipo é relatado no fluxo de nó XAML como um valor de um membro.</span><span class="sxs-lookup"><span data-stu-id="2011b-253">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="2011b-254">O fluxo do nó XAML não tenta produzir um objeto de instância do conversor de tipo e passar o valor para ele.</span><span class="sxs-lookup"><span data-stu-id="2011b-254">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="2011b-255">Usando a implementação de conversão de um conversor de tipo requer invocando o contexto do esquema XAML e usá-lo para o mapeamento de tipo.</span><span class="sxs-lookup"><span data-stu-id="2011b-255">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="2011b-256">Até mesmo determina qual classe de conversor de tipo deve ser usado para processar o valor requer indiretamente o contexto do esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-256">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="2011b-257">Quando você usa o contexto do esquema XAML padrão, essa informação está disponível do sistema de tipo de XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-257">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="2011b-258">Se você precisar que as informações de classe de conversor de tipo no nível do fluxo de nó XAML antes da conexão para um gravador XAML, você pode obtê-lo do <xref:System.Xaml.XamlMember> informações do membro que está sendo definido.</span><span class="sxs-lookup"><span data-stu-id="2011b-258">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="2011b-259">Mas, caso contrário, entrada do conversor de tipo deve ser preservada no fluxo de nó XAML como um valor simples até que o restante das operações que exigem o sistema de mapeamento de tipo e contexto de esquema XAML é executado, por exemplo, a criação do objeto por um XAML objeto gravador.</span><span class="sxs-lookup"><span data-stu-id="2011b-259">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>  
  
 <span data-ttu-id="2011b-260">Por exemplo, considere a seguinte estrutura de tópicos de definição de classe e o uso do XAML para ele:</span><span class="sxs-lookup"><span data-stu-id="2011b-260">For example, consider the following class definition outline and XAML usage for it:</span></span>  
  
```  
public class BoardSizeConverter : TypeConverter {  
  //converts from string to an int[2] by splitting on an "x" char  
}  
public class GameBoard {  
  [TypeConverter(typeof(BoardSizeConverter))]  
  public int[] BoardSize; //2x2 array, initialization not shown  
}  
```  
  
```xaml  
<GameBoard BoardSize="8x8"/>  
```  
  
 <span data-ttu-id="2011b-261">Uma representação de texto do fluxo de nó XAML para esse uso pode ser expresso da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="2011b-261">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>  
  
 <span data-ttu-id="2011b-262">`StartObject` com <xref:System.Xaml.XamlType> representando `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="2011b-262">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>  
  
 <span data-ttu-id="2011b-263">`StartMember` com <xref:System.Xaml.XamlMember> representando `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="2011b-263">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>  
  
 <span data-ttu-id="2011b-264">`Value` nó, com a cadeia de caracteres de texto "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="2011b-264">`Value` node, with text string "`8x8`"</span></span>  
  
 <span data-ttu-id="2011b-265">`EndMember` Correspondências `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="2011b-265">`EndMember` matches `BoardSize`</span></span>  
  
 <span data-ttu-id="2011b-266">`EndObject` Correspondências `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="2011b-266">`EndObject` matches `GameBoard`</span></span>  
  
 <span data-ttu-id="2011b-267">Observe que não há nenhuma instância do conversor de tipo nesse fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-267">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="2011b-268">Mas você pode obter informações de conversor de tipo, chamando <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> sobre o <xref:System.Xaml.XamlMember> para `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="2011b-268">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="2011b-269">Se você tiver um contexto de esquema XAML válido, você também pode chamar os métodos de conversor, obtendo uma instância de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-269">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>  
  
### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="2011b-270">Extensões de marcação no Stream de nó de XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-270">Markup Extensions in the XAML Node Stream</span></span>  
 <span data-ttu-id="2011b-271">Um uso de extensão de marcação é relatado no fluxo de nó XAML como um nó de objeto dentro de um membro, em que o objeto representa uma instância de extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="2011b-271">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="2011b-272">Portanto, um uso de extensão de marcação é apresentado mais explicitamente a representação de fluxo do nó que é um uso de conversor de tipo e carrega mais informações.</span><span class="sxs-lookup"><span data-stu-id="2011b-272">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="2011b-273"><xref:System.Xaml.XamlMember> informações poderiam não ter dissemos nada sobre a extensão de marcação, porque o uso é situacional e varia em cada caso de marcação possíveis; não é implícita por tipo ou membro e dedicada como é o caso com conversores de tipo.</span><span class="sxs-lookup"><span data-stu-id="2011b-273"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>  
  
 <span data-ttu-id="2011b-274">A representação de fluxo do nó de extensões de marcação como nós de objeto é o caso mesmo se o uso de extensão de marcação foi feito na forma de atributo na marcação de texto XAML (que é geralmente o caso).</span><span class="sxs-lookup"><span data-stu-id="2011b-274">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="2011b-275">Usos de extensão de marcação que é usado um formulário de elemento de objeto explícitas são tratados da mesma maneira.</span><span class="sxs-lookup"><span data-stu-id="2011b-275">Markup extension usages that used an explicit object element form are treated the same way.</span></span>  
  
 <span data-ttu-id="2011b-276">Dentro de um nó de objeto de extensão de marcação, podem ser membros dessa extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="2011b-276">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="2011b-277">A representação de fluxo do nó XAML preserva o uso da extensão de marcação, seja um uso do parâmetro posicional ou um uso de parâmetros nomeados explícitos.</span><span class="sxs-lookup"><span data-stu-id="2011b-277">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>  
  
 <span data-ttu-id="2011b-278">Para o uso de um parâmetro posicional, o fluxo do nó XAML contém uma propriedade de definido em linguagem XAML `_PositionalParameters` que registra o uso.</span><span class="sxs-lookup"><span data-stu-id="2011b-278">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="2011b-279">Esta propriedade é um genérico <xref:System.Collections.Generic.List%601> com <xref:System.Object> restrição.</span><span class="sxs-lookup"><span data-stu-id="2011b-279">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="2011b-280">A restrição é object e string não porque perfeitamente um uso do parâmetro posicional pode conter os usos de extensão de marcação aninhadas dentro dele.</span><span class="sxs-lookup"><span data-stu-id="2011b-280">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="2011b-281">Para acessar os parâmetros posicionais com o uso, você pode iterar na lista e usar indexadores para valores de lista individual.</span><span class="sxs-lookup"><span data-stu-id="2011b-281">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>  
  
 <span data-ttu-id="2011b-282">Para o uso de um parâmetro nomeado, cada parâmetro nomeado é representado como um nó de membro esse nome no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-282">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="2011b-283">Os valores do membro não são necessariamente cadeias de caracteres, porque pode haver um uso de extensão de marcação aninhadas.</span><span class="sxs-lookup"><span data-stu-id="2011b-283">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>  
  
 <span data-ttu-id="2011b-284">`ProvideValue` da marcação extensão não é ainda invocada.</span><span class="sxs-lookup"><span data-stu-id="2011b-284">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="2011b-285">No entanto, ele é invocado se você se conectar a um leitor XAML e o gravador XAML, de modo que `WriteEndObject` é invocado no nó de extensão de marcação, quando você examiná-lo no fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-285">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="2011b-286">Por esse motivo, você geralmente precisa mesmo contexto de esquema XAML disponível que seriam usadas para formar o grafo de objeto no caminho de carga.</span><span class="sxs-lookup"><span data-stu-id="2011b-286">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="2011b-287">Caso contrário, `ProvideValue` de qualquer marcação extensão pode lançar exceções aqui, porque ele não tem serviços esperados disponíveis.</span><span class="sxs-lookup"><span data-stu-id="2011b-287">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>  
  
<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>   
## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="2011b-288">XAML e XML membros de idioma definido no Stream de nó XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-288">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>  
 <span data-ttu-id="2011b-289">Determinados membros são introduzidos em um fluxo de nó XAML devido a interpretações e convenções de um leitor de XAML, em vez de por meio de um explícito <xref:System.Xaml.XamlMember> construção ou pesquisa.</span><span class="sxs-lookup"><span data-stu-id="2011b-289">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="2011b-290">Geralmente, esses membros são diretivas XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-290">Often, these members are XAML directives.</span></span> <span data-ttu-id="2011b-291">Em alguns casos, ele é o ato de ler o XAML que apresenta a diretiva para o fluxo do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-291">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="2011b-292">Em outras palavras, o texto XAML de entrada original não travado especificou a diretiva de membro, mas o leitor XAML insere a diretiva para satisfazer uma estruturais XAML convenção e relatar informações no fluxo de nó XAML antes que essas informações serão perdidas.</span><span class="sxs-lookup"><span data-stu-id="2011b-292">In other words, the original input XAML text did not explictly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>  
  
 <span data-ttu-id="2011b-293">As seguintes observações de lista todos os casos em que um leitor XAML é esperado para introduzir um nó de membro XAML diretiva e como esse nó de membro é identificado em implementações de serviços de XAML do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="2011b-293">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>  
  
-   <span data-ttu-id="2011b-294">**Texto de inicialização para um nó de objeto:** é o nome deste nó de membro `_Initialization`, ele representa uma diretiva XAML, e ele é definido no namespace XAML de linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-294">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="2011b-295">Você pode obter uma entidade de estática para ela da <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-295">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>  
  
-   <span data-ttu-id="2011b-296">**Parâmetros posicionais para uma extensão de marcação:** é o nome deste nó de membro `_PositionalParameters`, e ele é definido no namespace XAML de linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-296">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="2011b-297">Ele sempre contém uma lista genérica de objetos, cada um deles é um parâmetro posicional previamente separado pela divisão do `,` caractere delimitador como fornecidos na entrada de XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-297">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="2011b-298">Você pode obter uma entidade de estática para a diretiva de parâmetros posicionais de <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-298">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>  
  
-   <span data-ttu-id="2011b-299">**Conteúdo desconhecido:** é o nome deste nó de membro `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="2011b-299">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="2011b-300">Estritamente falando, é um <xref:System.Xaml.XamlDirective>, e ele é definido no namespace XAML de linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-300">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="2011b-301">Essa diretiva é usada como uma Sentinela casos em que um elemento de objeto XAML contém o conteúdo na fonte de XAML, mas nenhuma propriedade de conteúdo pode ser determinada sob o contexto de esquema XAML disponível no momento.</span><span class="sxs-lookup"><span data-stu-id="2011b-301">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="2011b-302">Você pode detectar esse caso em um fluxo do nó XAML através da verificação de membros nomeados `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="2011b-302">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="2011b-303">Se nenhuma outra ação é executada em um fluxo de nó XAML do caminho de carga, o padrão <xref:System.Xaml.XamlObjectWriter> gera na tentativa `WriteEndObject` quando ele encontra o `_UnknownContent` membro em qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-303">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="2011b-304">O padrão <xref:System.Xaml.XamlXmlWriter> não gerará e tratará o membro como implícita.</span><span class="sxs-lookup"><span data-stu-id="2011b-304">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="2011b-305">Você pode obter uma entidade de estática para `_UnknownContent` de <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-305">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>  
  
-   <span data-ttu-id="2011b-306">**Propriedade de coleção de uma coleção:** Embora o tipo de CLR de apoio de uma classe de coleção que é usado normalmente para XAML tem dedicada chamada de propriedade que contém os itens da coleção, essa propriedade não é conhecida para um sistema de tipo XAML antes do tipo subjacente resolução.</span><span class="sxs-lookup"><span data-stu-id="2011b-306">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="2011b-307">Em vez disso, o fluxo do nó XAML apresenta um `Items` espaço reservado como um membro da coleção de tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="2011b-307">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="2011b-308">Na implementação de serviços de XAML do .NET Framework o nome dessa diretiva / membro no fluxo de nó é `_Items`.</span><span class="sxs-lookup"><span data-stu-id="2011b-308">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="2011b-309">Uma constante para essa diretiva pode ser obtida em <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="2011b-309">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>  
  
     <span data-ttu-id="2011b-310">Observe que um fluxo do nó XAML pode conter uma propriedade de itens com os itens que se tornar não pode ser analisado com base no contexto do esquema XAML e resolução de tipo de backup.</span><span class="sxs-lookup"><span data-stu-id="2011b-310">Note that a XAML node stream might contain an Items property with items that turn out to not be parseable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="2011b-311">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="2011b-311">For example,</span></span>  
  
-   <span data-ttu-id="2011b-312">**Membros definidos pelo XML:** definidas para o XML `xml:base`, `xml:lang` e `xml:space` membros são relatados como diretivas XAML nomeadas `base`, `lang`, e `space` nos serviços de XAML do .NET Framework implementações.</span><span class="sxs-lookup"><span data-stu-id="2011b-312">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="2011b-313">O namespace para eles é o namespace de XML `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="2011b-313">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="2011b-314">Constantes para cada um deles podem ser obtidas em <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="2011b-314">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>  
  
## <a name="node-order"></a><span data-ttu-id="2011b-315">Ordem de nó</span><span class="sxs-lookup"><span data-stu-id="2011b-315">Node Order</span></span>  
 <span data-ttu-id="2011b-316">Em alguns casos, <xref:System.Xaml.XamlXmlReader> altera a ordem de nós do XAML no fluxo de nó XAML, em comparação com a ordem em que os nós exibidos se exibido na marcação ou se processados como XML.</span><span class="sxs-lookup"><span data-stu-id="2011b-316">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="2011b-317">Isso é feito para ordenar os nós de tal forma que um <xref:System.Xaml.XamlObjectWriter> pode processar o fluxo do nó de uma maneira de somente avanço.</span><span class="sxs-lookup"><span data-stu-id="2011b-317">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="2011b-318">Nos serviços de XAML do .NET Framework, o leitor XAML reordena nós em vez de deixar essa tarefa para o gravador XAML, como uma otimização de desempenho para os consumidores de gravador de objeto XAML do fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="2011b-318">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>  
  
 <span data-ttu-id="2011b-319">Determinadas diretivas destinam-se especificamente para fornecer mais informações para a criação de um objeto de um elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-319">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="2011b-320">Essas diretivas são: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="2011b-320">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="2011b-321">Os leitores de XAML de serviços de XAML do .NET Framework tentam colocar essas diretivas como primeiros membros no fluxo de nó após um objeto `StartObject`, por razões que são explicados na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="2011b-321">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>  
  
### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="2011b-322">Comportamento de XamlObjectWriter e a ordem de nó</span><span class="sxs-lookup"><span data-stu-id="2011b-322">XamlObjectWriter Behavior and Node Order</span></span>  
 <span data-ttu-id="2011b-323">`StartObject` para um <xref:System.Xaml.XamlObjectWriter> não é necessariamente um sinal para o gravador de objeto XAML para construir imediatamente a instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-323">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="2011b-324">XAML inclui vários recursos de linguagem que tornam possível inicializar um objeto com uma entrada adicional e não contar totalmente invocar um construtor padrão para produzir o objeto inicial e, em seguida, somente propriedades de configuração.</span><span class="sxs-lookup"><span data-stu-id="2011b-324">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a default constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="2011b-325">Esses recursos incluem: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; o texto de inicialização; [X:TypeArguments](../../../docs/framework/xaml-services/x-typearguments-directive.md); posicionais os parâmetros de uma extensão de marcação; métodos de fábrica e respectivos [x: argumentos](../../../docs/framework/xaml-services/x-arguments-directive.md) nós (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="2011b-325">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](../../../docs/framework/xaml-services/x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](../../../docs/framework/xaml-services/x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="2011b-326">Cada um desses casos atrasar a construção do objeto real, e porque o fluxo do nó é reordenado, o gravador de objeto XAML pode contar com um comportamento que não seja especificamente uma construção de realmente construir a instância sempre que um membro inicial é encontrado diretiva para esse tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="2011b-326">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>  
  
### <a name="getobject"></a><span data-ttu-id="2011b-327">GetObject</span><span class="sxs-lookup"><span data-stu-id="2011b-327">GetObject</span></span>  
 <span data-ttu-id="2011b-328">`GetObject` representa um nó XAML em que, em vez de construir um novo objeto, um gravador de objeto XAML deve em vez disso, obter o valor da propriedade do objeto contentor.</span><span class="sxs-lookup"><span data-stu-id="2011b-328">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="2011b-329">Um caso típico onde um `GetObject` nó é encontrado em um nó XAML fluxo é para um objeto de coleção ou um objeto de dicionário, quando a propriedade recipiente é deliberadamente somente leitura no modelo de objeto do tipo de backup.</span><span class="sxs-lookup"><span data-stu-id="2011b-329">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="2011b-330">Nesse cenário, a coleção ou dicionário geralmente é criado e inicializado (geralmente vazio) pela lógica de inicialização de um tipo de proprietário.</span><span class="sxs-lookup"><span data-stu-id="2011b-330">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2011b-331">Consulte também</span><span class="sxs-lookup"><span data-stu-id="2011b-331">See Also</span></span>  
 <xref:System.Xaml.XamlObjectReader>  
 [<span data-ttu-id="2011b-332">Serviços XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-332">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)  
 [<span data-ttu-id="2011b-333">Namespaces XAML</span><span class="sxs-lookup"><span data-stu-id="2011b-333">XAML Namespaces</span></span>](../../../docs/framework/xaml-services/xaml-namespaces-for-net-framework-xaml-services.md)
