---
title: Noções básicas sobre estruturas e conceitos do fluxo de nó XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: 2c8093c3ef497bd836427f71098e62626f228e24
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/07/2019
ms.locfileid: "73733382"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="93296-102">Noções básicas sobre estruturas e conceitos do fluxo de nó XAML</span><span class="sxs-lookup"><span data-stu-id="93296-102">Understanding XAML Node Stream Structures and Concepts</span></span>

<span data-ttu-id="93296-103">Os leitores XAML e os gravadores XAML, conforme implementados em .NET Framework serviços XAML, são baseados no conceito de design de um fluxo de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="93296-104">O fluxo do nó XAML é uma conceituação de um conjunto de nós XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="93296-105">Nessa conceituação, um processador XAML percorre a estrutura das relações de nó no XAML um de cada vez.</span><span class="sxs-lookup"><span data-stu-id="93296-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="93296-106">A qualquer momento, apenas um registro atual ou uma posição atual existe em um fluxo de nó XAML aberto, e muitos aspectos da API relatam apenas as informações disponíveis nessa posição.</span><span class="sxs-lookup"><span data-stu-id="93296-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="93296-107">O nó atual em um fluxo de nó XAML pode ser descrito como sendo um objeto, um membro ou um valor.</span><span class="sxs-lookup"><span data-stu-id="93296-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="93296-108">Tratando o XAML como um fluxo de nó XAML, os leitores XAML podem se comunicar com os gravadores XAML e permitir que um programa exiba, interaja ou altere o conteúdo de um fluxo de nó XAML durante um caminho de carga ou uma operação de salvar caminho que envolva XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="93296-109">O design de API do gravador e leitor XAML e o conceito de fluxo do nó XAML são semelhantes aos designs e conceitos relacionados ao leitor e ao gravador anteriores, como o XML Modelo de Objeto do Documento (DOM) e as classes <xref:System.Xml.XmlReader> e <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="93296-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="93296-110">Este tópico discute os conceitos de fluxo do nó XAML e descreve como você pode escrever rotinas que interagem com representações XAML no nível do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

<a name="loading_into_a_xaml_reader"></a>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="93296-111">Carregando XAML em um leitor XAML</span><span class="sxs-lookup"><span data-stu-id="93296-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="93296-112">A classe base <xref:System.Xaml.XamlReader> não declara uma técnica específica para carregar o XAML inicial em um leitor XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="93296-113">Em vez disso, uma classe derivada declara e implementa a técnica de carregamento, incluindo as características gerais e restrições de sua fonte de entrada para XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="93296-114">Por exemplo, um <xref:System.Xaml.XamlObjectReader> lê um gráfico de objeto, a partir da fonte de entrada de um único objeto que representa a raiz ou base.</span><span class="sxs-lookup"><span data-stu-id="93296-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="93296-115">Em seguida, o <xref:System.Xaml.XamlObjectReader> produz um fluxo de nó XAML do grafo do objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="93296-116">O mais proeminente .NET Framework serviços XAML – definido <xref:System.Xaml.XamlReader> subclasse é <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="93296-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="93296-117"><xref:System.Xaml.XamlXmlReader> carrega o XAML inicial, carregando um arquivo de texto diretamente por meio de um fluxo ou caminho de arquivo, ou indiretamente por meio de uma classe de leitor relacionada, como <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="93296-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="93296-118">A <xref:System.Xaml.XamlReader> pode ser considerada como contendo a totalidade da fonte de entrada XAML depois que ela é carregada.</span><span class="sxs-lookup"><span data-stu-id="93296-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="93296-119">No entanto, a API base do <xref:System.Xaml.XamlReader> foi projetada para que o leitor interaja com um único nó do XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="93296-120">Quando carregado pela primeira vez, o primeiro nó único que você encontra é a raiz do XAML e seu objeto de início.</span><span class="sxs-lookup"><span data-stu-id="93296-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="93296-121">O conceito de fluxo do nó XAML</span><span class="sxs-lookup"><span data-stu-id="93296-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="93296-122">Se você geralmente está mais familiarizado com um DOM, metáfora de árvore ou uma abordagem baseada em consulta em relação ao acesso a tecnologias baseadas em XML, uma maneira útil de conceituar um fluxo de nó XAML é a seguinte.</span><span class="sxs-lookup"><span data-stu-id="93296-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="93296-123">Imagine que o XAML carregado é um DOM ou uma árvore onde cada nó possível é expandido o caminho e, em seguida, apresentado linearmente.</span><span class="sxs-lookup"><span data-stu-id="93296-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="93296-124">À medida que avança pelos nós, você pode estar atravessando "em" ou "fora" dos níveis que seriam relevantes para um DOM, mas o fluxo do nó XAML não mantém explicitamente o controle, pois esses conceitos de nível não são relevantes para um fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="93296-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="93296-125">O fluxo do nó tem uma posição "atual", mas, a menos que você tenha armazenado outras partes do fluxo por conta própria como referências, cada aspecto do fluxo do nó diferente da posição do nó atual está fora da exibição.</span><span class="sxs-lookup"><span data-stu-id="93296-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="93296-126">O conceito de fluxo do nó XAML tem a vantagem notável de que, se você percorrer todo o fluxo do nó, terá certeza de que você processou toda a representação XAML; Você não precisa se preocupar que uma consulta, uma operação DOM ou alguma outra abordagem não linear para processar informações perdeu alguma parte da representação XAML completa.</span><span class="sxs-lookup"><span data-stu-id="93296-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="93296-127">Por esse motivo, a representação de fluxo do nó XAML é ideal para conectar leitores XAML e gravadores XAML, além de fornecer um sistema no qual você pode inserir seu próprio processo que atue entre as fases de leitura e gravação de uma operação de processamento XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="93296-128">Em muitos casos, a ordenação de nós no fluxo do nó XAML é deliberadamente otimizada ou reordenada por leitores XAML em comparação com o modo como o pedido pode aparecer no gráfico de texto de origem, binário ou objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="93296-129">Esse comportamento destina-se a impor uma arquitetura de processamento XAML na qual os gravadores XAML nunca estão em uma posição em que eles precisam voltar "voltar" no fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="93296-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="93296-130">Idealmente, todas as operações de gravação XAML devem ser capazes de agir com base no contexto do esquema mais a posição atual do fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="93296-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

<a name="a_basic_reading_node_loop"></a>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="93296-131">Um loop de nó de leitura básico</span><span class="sxs-lookup"><span data-stu-id="93296-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="93296-132">Um loop de nó de leitura básico para examinar um fluxo de nó XAML consiste nos seguintes conceitos.</span><span class="sxs-lookup"><span data-stu-id="93296-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="93296-133">Para fins de loops de nó conforme discutido neste tópico, suponha que você esteja lendo um arquivo XAML com leitura humana e baseado em texto usando <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="93296-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="93296-134">Os links nesta seção referem-se à API de loop de nó XAML específica implementada por <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="93296-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="93296-135">Certifique-se de que você não está no final do fluxo do nó XAML (marque <xref:System.Xaml.XamlXmlReader.IsEof%2A>ou use o valor de retorno <xref:System.Xaml.XamlXmlReader.Read%2A>).</span><span class="sxs-lookup"><span data-stu-id="93296-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="93296-136">Se você estiver no final do fluxo, não haverá nenhum nó atual e você deverá sair.</span><span class="sxs-lookup"><span data-stu-id="93296-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="93296-137">Verifique o tipo de nó que o fluxo do nó XAML expõe atualmente chamando <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="93296-138">Se você tiver um gravador de objeto XAML associado que esteja conectado diretamente, geralmente você chamará <xref:System.Xaml.XamlWriter.WriteNode%2A> neste momento.</span><span class="sxs-lookup"><span data-stu-id="93296-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="93296-139">Com base em qual <xref:System.Xaml.XamlNodeType> é relatado como o nó atual ou o registro atual, chame um dos seguintes para obter informações sobre o conteúdo do nó:</span><span class="sxs-lookup"><span data-stu-id="93296-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="93296-140">Para obter uma <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.StartMember> ou <xref:System.Xaml.XamlNodeType.EndMember>, chame <xref:System.Xaml.XamlXmlReader.Member%2A> para obter informações de <xref:System.Xaml.XamlMember> sobre um membro.</span><span class="sxs-lookup"><span data-stu-id="93296-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="93296-141">Observe que o membro pode ser um <xref:System.Xaml.XamlDirective>e, portanto, pode não ser necessariamente um membro de tipo convencional definido do objeto anterior.</span><span class="sxs-lookup"><span data-stu-id="93296-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="93296-142">Por exemplo, `x:Name` aplicado a um objeto aparece como um membro XAML em que <xref:System.Xaml.XamlMember.IsDirective%2A> é true e o <xref:System.Xaml.XamlMember.Name%2A> do membro é `Name`, com outras propriedades indicando que essa diretiva está sob o namespace XAML da linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="93296-143">Para obter uma <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.StartObject> ou <xref:System.Xaml.XamlNodeType.EndObject>, chame <xref:System.Xaml.XamlXmlReader.Type%2A> para obter informações de <xref:System.Xaml.XamlType> sobre um objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="93296-144">Para obter uma <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.Value>, chame <xref:System.Xaml.XamlXmlReader.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="93296-145">Um nó é um valor somente se for a expressão mais simples de um valor para um membro ou o texto de inicialização de um objeto (no entanto, você deve estar ciente do comportamento de conversão de tipo, conforme documentado em uma próxima seção deste tópico).</span><span class="sxs-lookup"><span data-stu-id="93296-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="93296-146">Para obter uma <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, chame <xref:System.Xaml.XamlXmlReader.Namespace%2A> para obter informações de namespace para um nó de namespace.</span><span class="sxs-lookup"><span data-stu-id="93296-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="93296-147">Chame <xref:System.Xaml.XamlXmlReader.Read%2A> para avançar o leitor XAML para o próximo nó no fluxo do nó XAML e repita as etapas.</span><span class="sxs-lookup"><span data-stu-id="93296-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="93296-148">O fluxo do nó XAML fornecido por .NET Framework leitores XAML dos serviços XAML sempre fornece uma passagem completa e profunda de todos os nós possíveis.</span><span class="sxs-lookup"><span data-stu-id="93296-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="93296-149">As técnicas de controle de fluxo típicas para um loop de nó XAML incluem a definição de um corpo dentro de `while (reader.Read())`e a alternância de <xref:System.Xaml.XamlXmlReader.NodeType%2A> em cada ponto de nó no loop de nó.</span><span class="sxs-lookup"><span data-stu-id="93296-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="93296-150">Se o fluxo do nó estiver no final do arquivo, o nó atual será nulo.</span><span class="sxs-lookup"><span data-stu-id="93296-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="93296-151">O loop mais simples que usa um leitor e um gravador é semelhante ao exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="93296-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="93296-152">Este exemplo básico de um loop de nó XAML de caminho de carga conecta de forma transparente o leitor XAML e o gravador XAML, não fazendo nada diferente de se você tivesse usado <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="93296-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="93296-153">Mas essa estrutura básica é expandida para ser aplicada ao cenário de leitura ou gravação.</span><span class="sxs-lookup"><span data-stu-id="93296-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="93296-154">Alguns cenários possíveis são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="93296-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="93296-155">Ative <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="93296-156">Execute ações diferentes dependendo de qual tipo de nó está sendo lido.</span><span class="sxs-lookup"><span data-stu-id="93296-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="93296-157">Não chame <xref:System.Xaml.XamlWriter.WriteNode%2A> em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="93296-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="93296-158">Só chame <xref:System.Xaml.XamlWriter.WriteNode%2A> em alguns casos de <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="93296-159">Dentro da lógica de um tipo de nó específico, analise as especificidades desse nó e aja nelas.</span><span class="sxs-lookup"><span data-stu-id="93296-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="93296-160">Por exemplo, você pode gravar somente objetos provenientes de um namespace XAML específico e, em seguida, remover ou adiar quaisquer objetos que não sejam desse namespace XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="93296-161">Ou então, você pode remover ou reprocessar quaisquer diretivas XAML para as quais seu sistema XAML não dá suporte como parte do seu processamento de membro.</span><span class="sxs-lookup"><span data-stu-id="93296-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="93296-162">Defina um <xref:System.Xaml.XamlObjectWriter> personalizado que substitui `Write*` métodos, possivelmente executando o mapeamento de tipo que ignora o contexto do esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="93296-163">Construa o <xref:System.Xaml.XamlXmlReader> para usar um contexto de esquema XAML não padrão, de modo que as diferenças personalizadas no comportamento XAML sejam usadas pelo leitor e pelo gravador.</span><span class="sxs-lookup"><span data-stu-id="93296-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="93296-164">Acessando XAML além do conceito de loop de nó</span><span class="sxs-lookup"><span data-stu-id="93296-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="93296-165">Há potencialmente outras maneiras de trabalhar com uma representação XAML diferente de como um loop de nó XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="93296-166">Por exemplo, pode haver um leitor XAML que possa ler um nó indexado ou em determinados nós de acesso diretamente por `x:Name`, por `x:Uid`ou por meio de outros identificadores.</span><span class="sxs-lookup"><span data-stu-id="93296-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="93296-167">.NET Framework serviços XAML não fornecem uma implementação completa, mas fornece um padrão sugerido por meio de serviços e tipos de suporte.</span><span class="sxs-lookup"><span data-stu-id="93296-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="93296-168">Para obter mais informações, consulte <xref:System.Xaml.IXamlIndexingReader> e <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="93296-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

<a name="working_with_the_current_node"></a>

## <a name="working-with-the-current-node"></a><span data-ttu-id="93296-169">Trabalhando com o nó atual</span><span class="sxs-lookup"><span data-stu-id="93296-169">Working with the Current Node</span></span>

<span data-ttu-id="93296-170">A maioria dos cenários que usam um loop de nó XAML não apenas lê os nós.</span><span class="sxs-lookup"><span data-stu-id="93296-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="93296-171">A maioria dos cenários processa os nós atuais e passa cada nó um de cada vez para uma implementação de <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="93296-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="93296-172">No cenário de caminho de carga típico, um <xref:System.Xaml.XamlXmlReader> produz um fluxo de nó XAML; os nós XAML são processados de acordo com seu contexto de esquema de lógica e XAML; e os nós são passados para um <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="93296-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="93296-173">Em seguida, integre o grafo do objeto resultante em seu aplicativo ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="93296-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="93296-174">Em um cenário de salvar caminho típico, um <xref:System.Xaml.XamlObjectReader> lê o grafo do objeto, nós XAML individuais são processados e um <xref:System.Xaml.XamlXmlWriter> gera o resultado serializado como um arquivo de texto XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="93296-175">A chave é que ambos os caminhos e cenários envolvem trabalhar com exatamente um nó XAML por vez, e os nós XAML estão disponíveis para tratamento em uma maneira padronizada que é definida pelo sistema de tipos XAML e APIs de serviços XAML do the.NET Framework.</span><span class="sxs-lookup"><span data-stu-id="93296-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="93296-176">Quadros e escopo</span><span class="sxs-lookup"><span data-stu-id="93296-176">Frames and Scope</span></span>

<span data-ttu-id="93296-177">Um loop de nó XAML percorre um fluxo de nó XAML de forma linear.</span><span class="sxs-lookup"><span data-stu-id="93296-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="93296-178">O fluxo do nó percorre objetos, em membros que contêm outros objetos e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="93296-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="93296-179">Geralmente, é útil manter o controle do escopo dentro do fluxo do nó XAML implementando um conceito de quadro e pilha.</span><span class="sxs-lookup"><span data-stu-id="93296-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="93296-180">Isso é particularmente verdadeiro se você estiver ajustando ativamente o fluxo do nó enquanto estiver nele.</span><span class="sxs-lookup"><span data-stu-id="93296-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="93296-181">O suporte a quadros e pilhas que você implementa como parte da lógica do loop de nó pode contar `StartObject` (ou `GetObject`) e `EndObject` escopos à medida que você descende em uma estrutura de nó XAML se a estrutura é considerada de uma perspectiva DOM.</span><span class="sxs-lookup"><span data-stu-id="93296-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

<a name="traversing_and_entering_object_nodes"></a>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="93296-182">Atravessando e inserindo nós de objeto</span><span class="sxs-lookup"><span data-stu-id="93296-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="93296-183">O primeiro nó em um fluxo de nó quando ele é aberto por um leitor XAML é o nó Start-Object do objeto raiz.</span><span class="sxs-lookup"><span data-stu-id="93296-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="93296-184">Por definição, esse objeto é sempre um único nó de objeto e não tem nenhum par.</span><span class="sxs-lookup"><span data-stu-id="93296-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="93296-185">Em qualquer exemplo de XAML do mundo real, o objeto raiz é definido para ter uma ou mais propriedades que contenham mais objetos, e essas propriedades têm nós Membros.</span><span class="sxs-lookup"><span data-stu-id="93296-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="93296-186">Os nós de membro têm um ou mais nós de objeto ou também podem ser encerrados em um nó de valor.</span><span class="sxs-lookup"><span data-stu-id="93296-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="93296-187">O objeto raiz normalmente define os namescopes XAML, que são atribuídos sintaticamente como atributos na marcação de texto XAML, mas são mapeados para um `Namescope` tipo de nó na representação de fluxo do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="93296-188">Considere o seguinte exemplo XAML (é XAML arbitrário, não apoiado por tipos existentes no .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="93296-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="93296-189">Suponha que, nesse modelo de objeto, `FavorCollection` seja `List<T>` de `Favor`, `Balloon` e `NoiseMaker` sejam atribuíveis ao `Favor`, a propriedade `Balloon.Color` é apoiada por um objeto de `Color` semelhante a como o WPF define as cores como nomes de cores conhecidos e `Color` dá suporte a um conversor de tipo para sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="93296-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="93296-190">Marcação XAML</span><span class="sxs-lookup"><span data-stu-id="93296-190">XAML markup</span></span>|<span data-ttu-id="93296-191">Fluxo do nó XAML resultante</span><span class="sxs-lookup"><span data-stu-id="93296-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="93296-192">`Namespace` nó para `Party`</span><span class="sxs-lookup"><span data-stu-id="93296-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="93296-193">`StartObject` nó para `Party`</span><span class="sxs-lookup"><span data-stu-id="93296-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="93296-194">`StartMember` nó para `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="93296-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="93296-195">`StartObject` nó para `FavorCollection` implícitas</span><span class="sxs-lookup"><span data-stu-id="93296-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="93296-196">`StartMember` nó para a propriedade de itens de `FavorCollection` implícito.</span><span class="sxs-lookup"><span data-stu-id="93296-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="93296-197">`StartObject` nó para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="93296-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="93296-198">`StartMember` nó para `Color`</span><span class="sxs-lookup"><span data-stu-id="93296-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="93296-199">`Value` nó para a cadeia de caracteres de valor de atributo `"Red"`</span><span class="sxs-lookup"><span data-stu-id="93296-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="93296-200">`EndMember` para `Color`</span><span class="sxs-lookup"><span data-stu-id="93296-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="93296-201">`StartMember` nó para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="93296-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="93296-202">`Value` nó para a cadeia de caracteres de valor de atributo `"True"`</span><span class="sxs-lookup"><span data-stu-id="93296-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="93296-203">`EndMember` para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="93296-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="93296-204">`EndObject` para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="93296-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="93296-205">`StartObject` nó para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="93296-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="93296-206">`StartMember` nó para `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="93296-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="93296-207">`Value` nó para a cadeia de caracteres do valor de inicialização `"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="93296-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="93296-208">`EndMember` nó para `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="93296-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="93296-209">`EndObject` para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="93296-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="93296-210">`EndMember` nó para a propriedade de itens de `FavorCollection` implícito.</span><span class="sxs-lookup"><span data-stu-id="93296-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="93296-211">`EndObject` nó para `FavorCollection` implícitas</span><span class="sxs-lookup"><span data-stu-id="93296-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="93296-212">`EndMember` para `Favors`</span><span class="sxs-lookup"><span data-stu-id="93296-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="93296-213">`EndObject` para `Party`</span><span class="sxs-lookup"><span data-stu-id="93296-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="93296-214">No fluxo do nó XAML, você pode contar com o seguinte comportamento:</span><span class="sxs-lookup"><span data-stu-id="93296-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="93296-215">Se um nó de `Namespace` existir, ele será adicionado ao fluxo imediatamente antes da `StartObject` que declarou o namespace XAML com `xmlns`.</span><span class="sxs-lookup"><span data-stu-id="93296-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="93296-216">Examine novamente a tabela anterior com o fluxo de exemplo de XAML e de nó.</span><span class="sxs-lookup"><span data-stu-id="93296-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="93296-217">Observe como os nós `StartObject` e `Namespace` parecem ser transpostos versus suas posições de declaração na marcação de texto.</span><span class="sxs-lookup"><span data-stu-id="93296-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="93296-218">Isso representa o comportamento em que os nós de namespace sempre aparecem à frente do nó ao qual se aplicam no fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="93296-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="93296-219">A finalidade desse design é que as informações de namespace são vitais para os gravadores de objeto e devem ser conhecidas antes que o gravador de objeto tente executar o mapeamento de tipo ou processar o objeto de outra forma.</span><span class="sxs-lookup"><span data-stu-id="93296-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="93296-220">Colocar as informações do namespace XAML antes do escopo do aplicativo no fluxo torna mais simples sempre processar o fluxo do nó em sua ordem apresentada.</span><span class="sxs-lookup"><span data-stu-id="93296-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="93296-221">Devido à consideração acima, é um ou mais nós de `Namespace` que você lê primeiro na maioria dos casos de marcação do mundo real ao atravessar nós do início, não do `StartObject` da raiz.</span><span class="sxs-lookup"><span data-stu-id="93296-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="93296-222">Um nó `StartObject` pode ser seguido por `StartMember`, `Value`ou uma `EndObject`imediata.</span><span class="sxs-lookup"><span data-stu-id="93296-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="93296-223">Ele nunca é seguido imediatamente por outra `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="93296-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="93296-224">Um `StartMember` pode ser seguido por um `StartObject`, `Value`ou uma `EndMember`imediata.</span><span class="sxs-lookup"><span data-stu-id="93296-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="93296-225">Ele pode ser seguido por `GetObject`, para membros em que o valor deve vir de um valor existente do objeto pai em vez de um `StartObject` que instanciaria um novo valor.</span><span class="sxs-lookup"><span data-stu-id="93296-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="93296-226">Ele também pode ser seguido por um nó `Namespace`, que se aplica a um futuro `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="93296-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="93296-227">Ele nunca é seguido imediatamente por outra `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="93296-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="93296-228">Um nó `Value` representa o próprio valor; Não há "EndValue".</span><span class="sxs-lookup"><span data-stu-id="93296-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="93296-229">Ele pode ser seguido apenas por um `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="93296-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="93296-230">O texto de inicialização XAML do objeto como pode ser usado pela construção não resulta em uma estrutura de valor de objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="93296-231">Em vez disso, um nó de membro dedicado para um membro chamado `_Initialization` é criado.</span><span class="sxs-lookup"><span data-stu-id="93296-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="93296-232">e esse nó de membro contém a cadeia de caracteres de valor de inicialização.</span><span class="sxs-lookup"><span data-stu-id="93296-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="93296-233">Se existir, `_Initialization` sempre será a primeira `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="93296-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="93296-234">`_Initialization` pode ser qualificado em algumas representações de serviços XAML com o namescope XAML da linguagem XAML, para esclarecer que `_Initialization` não é uma propriedade definida nos tipos de suporte.</span><span class="sxs-lookup"><span data-stu-id="93296-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="93296-235">Uma combinação de valor de membro representa uma configuração de atributo do valor.</span><span class="sxs-lookup"><span data-stu-id="93296-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="93296-236">Eventualmente, pode haver um conversor de valor envolvido no processamento desse valor, e o valor é uma cadeia de caracteres simples.</span><span class="sxs-lookup"><span data-stu-id="93296-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="93296-237">No entanto, isso não é avaliado até que um gravador de objeto XAML processe esse fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="93296-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="93296-238">O gravador de objeto XAML possui o contexto de esquema XAML necessário, o mapeamento do sistema de tipo e outro suporte necessário para conversões de valor.</span><span class="sxs-lookup"><span data-stu-id="93296-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="93296-239">Um nó de `EndMember` pode ser seguido por um nó de `StartMember` para um membro subsequente ou por um nó de `EndObject` para o proprietário do membro.</span><span class="sxs-lookup"><span data-stu-id="93296-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="93296-240">Um nó de `EndObject` pode ser seguido por um nó de `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="93296-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="93296-241">Ele também pode ser seguido por um nó de `StartObject` para casos em que os objetos são pares em itens de uma coleção.</span><span class="sxs-lookup"><span data-stu-id="93296-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="93296-242">Ou pode ser seguido por um nó `Namespace`, que se aplica a uma `StartObject`futura.</span><span class="sxs-lookup"><span data-stu-id="93296-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="93296-243">Para o caso exclusivo de fechar o fluxo do nó inteiro, o `EndObject` da raiz não é seguido por nada; o leitor agora é o fim do arquivo e <xref:System.Xaml.XamlReader.Read%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="93296-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

<a name="value_converters_and_the_xaml_node_stream"></a>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="93296-244">Conversores de valor e o fluxo do nó XAML</span><span class="sxs-lookup"><span data-stu-id="93296-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="93296-245">Um conversor de valor é um termo geral para uma extensão de marcação, um conversor de tipo (incluindo serializadores de valor) ou outra classe dedicada que é relatada como um conversor de valor por meio do sistema de tipos XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="93296-246">No fluxo do nó XAML, um uso de conversor de tipo e um uso de extensão de marcação têm representações muito diferentes.</span><span class="sxs-lookup"><span data-stu-id="93296-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="93296-247">Conversores de tipo no fluxo do nó XAML</span><span class="sxs-lookup"><span data-stu-id="93296-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="93296-248">Um conjunto de atributos que eventualmente resulta em um uso de conversor de tipo é relatado no fluxo do nó XAML como um valor de um membro.</span><span class="sxs-lookup"><span data-stu-id="93296-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="93296-249">O fluxo do nó XAML não tenta produzir um objeto de instância de conversor de tipo e passa o valor para ele.</span><span class="sxs-lookup"><span data-stu-id="93296-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="93296-250">O uso de uma implementação de conversão do conversor de tipo requer invocar o contexto do esquema XAML e usá-lo para o mapeamento de tipo.</span><span class="sxs-lookup"><span data-stu-id="93296-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="93296-251">Mesmo determinando qual classe de conversor de tipo deve ser usada para processar o valor requer o contexto de esquema XAML indiretamente.</span><span class="sxs-lookup"><span data-stu-id="93296-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="93296-252">Quando você usa o contexto de esquema XAML padrão, essas informações estão disponíveis no sistema de tipos XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="93296-253">Se você precisar das informações de classe do conversor de tipo no nível de fluxo do nó XAML antes da conexão com um gravador XAML, você poderá obtê-lo do <xref:System.Xaml.XamlMember> informações do membro que está sendo definido.</span><span class="sxs-lookup"><span data-stu-id="93296-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="93296-254">Caso contrário, a entrada do conversor de tipo deve ser preservada no fluxo do nó XAML como um valor simples até que o restante das operações que exigem o sistema de mapeamento de tipos e o contexto de esquema XAML sejam executados, por exemplo, a criação do objeto por um gravador de objeto XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="93296-255">Por exemplo, considere a seguinte estrutura de tópicos de definição de classe e uso de XAML para ela:</span><span class="sxs-lookup"><span data-stu-id="93296-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="93296-256">Uma representação de texto do fluxo do nó XAML para esse uso pode ser expressa da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="93296-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="93296-257">`StartObject` com <xref:System.Xaml.XamlType> representando `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="93296-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="93296-258">`StartMember` com <xref:System.Xaml.XamlMember> representando `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="93296-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="93296-259">`Value` nó, com a cadeia de caracteres de texto "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="93296-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="93296-260">`EndMember` corresponde `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="93296-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="93296-261">`EndObject` corresponde `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="93296-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="93296-262">Observe que não há nenhuma instância de conversor de tipo neste fluxo de nó.</span><span class="sxs-lookup"><span data-stu-id="93296-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="93296-263">Mas você pode obter informações de conversor de tipo chamando <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> no <xref:System.Xaml.XamlMember> para `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="93296-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="93296-264">Se você tiver um contexto de esquema XAML válido, também poderá invocar os métodos do conversor obtendo uma instância do <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="93296-265">Extensões de marcação no fluxo do nó XAML</span><span class="sxs-lookup"><span data-stu-id="93296-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="93296-266">Um uso de extensão de marcação é relatado no fluxo do nó XAML como um nó de objeto dentro de um membro, em que o objeto representa uma instância de extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="93296-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="93296-267">Portanto, um uso de extensão de marcação é apresentado mais explicitamente na representação de fluxo do nó do que o uso do conversor de tipo e traz mais informações.</span><span class="sxs-lookup"><span data-stu-id="93296-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="93296-268"><xref:System.Xaml.XamlMember> informações não puderam ter dito nada sobre a extensão de marcação, porque o uso é situação e varia em cada caso de marcação possível; Ele não é dedicado e implícito por tipo ou membro, como é o caso com conversores de tipo.</span><span class="sxs-lookup"><span data-stu-id="93296-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="93296-269">A representação de fluxo de nó de extensões de marcação como nós de objeto é o caso, mesmo que o uso da extensão de marcação tenha sido feito no formato de atributo na marcação de texto XAML (que geralmente é o caso).</span><span class="sxs-lookup"><span data-stu-id="93296-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="93296-270">Usos de extensão de marcação que usaram um formulário de elemento de objeto explícito são tratados da mesma maneira.</span><span class="sxs-lookup"><span data-stu-id="93296-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="93296-271">Dentro de um nó de objeto de extensão de marcação, pode haver membros dessa extensão de marcação.</span><span class="sxs-lookup"><span data-stu-id="93296-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="93296-272">A representação de fluxo do nó XAML preserva o uso dessa extensão de marcação, seja ele um uso de parâmetro posicional ou um uso com parâmetros nomeados explícitos.</span><span class="sxs-lookup"><span data-stu-id="93296-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="93296-273">Para um uso de parâmetro posicional, o fluxo do nó XAML contém uma propriedade XAML definida pelo idioma `_PositionalParameters` que registra o uso.</span><span class="sxs-lookup"><span data-stu-id="93296-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="93296-274">Essa propriedade é uma <xref:System.Collections.Generic.List%601> genérica com restrição <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="93296-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="93296-275">A restrição é Object e not String porque, de fato, um uso de parâmetro posicional pode conter usos aninhados de extensão de marcação dentro dele.</span><span class="sxs-lookup"><span data-stu-id="93296-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="93296-276">Para acessar os parâmetros posicionais do uso, você pode iterar na lista e usar os indexadores para valores de lista individuais.</span><span class="sxs-lookup"><span data-stu-id="93296-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="93296-277">Para um uso de parâmetro nomeado, cada parâmetro nomeado é representado como um nó de membro desse nome no fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="93296-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="93296-278">Os valores de membro não são necessariamente cadeias de caracteres, pois pode haver um uso de extensão de marcação aninhada.</span><span class="sxs-lookup"><span data-stu-id="93296-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="93296-279">o `ProvideValue` da extensão de marcação ainda não foi invocado.</span><span class="sxs-lookup"><span data-stu-id="93296-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="93296-280">No entanto, ele será invocado se você conectar um leitor XAML e um gravador XAML para que `WriteEndObject` seja invocado no nó de extensão de marcação ao examiná-lo no fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="93296-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="93296-281">Por esse motivo, geralmente você precisa do mesmo contexto de esquema XAML disponível, pois seria usado para formar o grafo de objeto no caminho de carga.</span><span class="sxs-lookup"><span data-stu-id="93296-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="93296-282">Caso contrário, `ProvideValue` de qualquer extensão de marcação pode gerar exceções aqui, porque ele não tem os serviços esperados disponíveis.</span><span class="sxs-lookup"><span data-stu-id="93296-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="93296-283">Membros definidos por linguagem XML e XAML no fluxo do nó XAML</span><span class="sxs-lookup"><span data-stu-id="93296-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="93296-284">Determinados membros são introduzidos em um fluxo de nó XAML devido a interpretações e convenções de um leitor XAML, em vez de uma <xref:System.Xaml.XamlMember> de pesquisa ou construção explícita.</span><span class="sxs-lookup"><span data-stu-id="93296-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="93296-285">Geralmente, esses membros são diretivas XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="93296-286">Em alguns casos, é o ato de ler o XAML que apresenta a diretiva no fluxo do nó XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="93296-287">Em outras palavras, o texto XAML de entrada original não especificou explicitamente a diretiva member, mas o leitor XAML insere a diretiva para atender a uma convenção XAML estrutural e relatar informações no fluxo do nó XAML antes que essas informações sejam perdidas.</span><span class="sxs-lookup"><span data-stu-id="93296-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="93296-288">A lista a seguir observa todos os casos em que um leitor XAML deve introduzir um nó de membro XAML de diretiva e como esse nó de membro é identificado na .NET Framework implementações de serviços XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>

- <span data-ttu-id="93296-289">**Texto de inicialização para um nó de objeto:** O nome desse nó de membro é `_Initialization`, ele representa uma diretiva XAML e é definido no namespace XAML da linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="93296-290">Você pode obter uma entidade estática para ela de <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="93296-291">**Parâmetros posicionais para uma extensão de marcação:** O nome desse nó de membro é `_PositionalParameters`e é definido no namespace XAML da linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="93296-292">Ele sempre contém uma lista genérica de objetos, cada um dos quais é um parâmetro posicional separado por divisão no `,` caractere delimitador, conforme fornecido no XAML de entrada.</span><span class="sxs-lookup"><span data-stu-id="93296-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="93296-293">Você pode obter uma entidade estática para a diretiva de parâmetros posicionais de <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="93296-294">**Conteúdo desconhecido:** O nome deste nó de membro é `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="93296-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="93296-295">Estritamente falando, é um <xref:System.Xaml.XamlDirective>e é definido no namespace XAML da linguagem XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="93296-296">Essa diretiva é usada como uma sentinela para casos em que um elemento de objeto XAML contém conteúdo no XAML de origem, mas nenhuma propriedade de conteúdo pode ser determinada sob o contexto de esquema XAML disponível no momento.</span><span class="sxs-lookup"><span data-stu-id="93296-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="93296-297">Você pode detectar esse caso em um fluxo de nó XAML verificando os membros chamados `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="93296-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="93296-298">Se nenhuma outra ação for executada em um fluxo de nó XAML do caminho de carga, a <xref:System.Xaml.XamlObjectWriter> padrão será lançada na tentativa de `WriteEndObject` quando encontrar o membro `_UnknownContent` em qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="93296-299">O <xref:System.Xaml.XamlXmlWriter> padrão não gera e trata o membro como implícito.</span><span class="sxs-lookup"><span data-stu-id="93296-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="93296-300">Você pode obter uma entidade estática para `_UnknownContent` de <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="93296-301">**Propriedade de coleção de uma coleção:** Embora o tipo de CLR de backup de uma classe de coleção que é usado para XAML geralmente tenha uma propriedade nomeada dedicada que contém os itens de coleta, essa propriedade não é conhecida por um sistema de tipo XAML antes de fazer o backup da resolução de tipo.</span><span class="sxs-lookup"><span data-stu-id="93296-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="93296-302">Em vez disso, o fluxo do nó XAML introduz um espaço reservado `Items` como um membro do tipo XAML da coleção.</span><span class="sxs-lookup"><span data-stu-id="93296-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="93296-303">Na implementação de serviços XAML .NET Framework, o nome dessa diretiva/membro no fluxo do nó é `_Items`.</span><span class="sxs-lookup"><span data-stu-id="93296-303">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="93296-304">Uma constante para essa diretiva pode ser obtida em <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="93296-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="93296-305">Observe que um fluxo de nó XAML pode conter uma propriedade Items com itens que se desativam para não ser analisáveis com base na resolução de tipo de backup e no contexto de esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="93296-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="93296-306">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="93296-306">For example,</span></span>

- <span data-ttu-id="93296-307">**Membros definidos pelo XML:** Os membros definidos pelo XML `xml:base`, `xml:lang` e `xml:space` são relatados como diretivas XAML chamadas `base`, `lang`e `space` nas implementações dos serviços XAML .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="93296-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="93296-308">O namespace para esses é o namespace XML `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="93296-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="93296-309">As constantes para cada uma delas podem ser obtidas em <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="93296-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="93296-310">Ordem de nó</span><span class="sxs-lookup"><span data-stu-id="93296-310">Node Order</span></span>

<span data-ttu-id="93296-311">Em alguns casos, <xref:System.Xaml.XamlXmlReader> altera a ordem dos nós XAML no fluxo do nó XAML, em comparação com a ordem em que os nós aparecem se forem exibidos na marcação ou se forem processados como XML.</span><span class="sxs-lookup"><span data-stu-id="93296-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="93296-312">Isso é feito para ordenar os nós de forma que um <xref:System.Xaml.XamlObjectWriter> possa processar o fluxo do nó em um modo somente de avanço.</span><span class="sxs-lookup"><span data-stu-id="93296-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="93296-313">Em .NET Framework serviços XAML, o leitor XAML reordena os nós em vez de deixar essa tarefa para o gravador XAML, como uma otimização de desempenho para consumidores do gravador de objeto XAML do fluxo do nó.</span><span class="sxs-lookup"><span data-stu-id="93296-313">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="93296-314">Determinadas diretivas são destinadas especificamente para fornecer mais informações para a criação de um objeto a partir de um elemento Object.</span><span class="sxs-lookup"><span data-stu-id="93296-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="93296-315">Essas diretivas são: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="93296-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="93296-316">Os .NET Framework leitores XAML dos serviços XAML tentam posicionar essas diretivas como os primeiros membros no fluxo do nó seguindo a `StartObject`de um objeto, por motivos que são explicados na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="93296-316">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="93296-317">Comportamento de XamlObjectWriter e ordem de nó</span><span class="sxs-lookup"><span data-stu-id="93296-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="93296-318">`StartObject` a uma <xref:System.Xaml.XamlObjectWriter> não é necessariamente um sinal ao gravador de objeto XAML para construir imediatamente a instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="93296-319">O XAML inclui vários recursos de linguagem que possibilitam inicializar um objeto com entrada adicional e não depender inteiramente de invocar um construtor sem parâmetros para produzir o objeto inicial e, em seguida, definir propriedades.</span><span class="sxs-lookup"><span data-stu-id="93296-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="93296-320">Esses recursos incluem: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; texto de inicialização; [x:TypeArguments](x-typearguments-directive.md); parâmetros posicionais de uma extensão de marcação; métodos de fábrica e nós [x:Arguments](x-arguments-directive.md) associados (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="93296-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="93296-321">Cada um desses casos atrasa a construção real do objeto e, como o fluxo do nó é reordenado, o gravador do objeto XAML pode contar com um comportamento de realmente construir a instância sempre que um membro inicial é encontrado que não é especificamente uma construção diretiva para esse tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-321">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="93296-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="93296-322">GetObject</span></span>

<span data-ttu-id="93296-323">`GetObject` representa um nó XAML em que, em vez de construir um novo objeto, um gravador de objeto XAML deve obter o valor da propriedade que contém o objeto.</span><span class="sxs-lookup"><span data-stu-id="93296-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="93296-324">Um caso típico em que um nó `GetObject` é encontrado em um fluxo de nó XAML é para um objeto de coleção ou um objeto Dictionary, quando a propriedade contentora é deliberadamente somente leitura no modelo de objeto do tipo de backup.</span><span class="sxs-lookup"><span data-stu-id="93296-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="93296-325">Nesse cenário, a coleção ou o dicionário geralmente é criado e inicializado (geralmente vazio) pela lógica de inicialização de um tipo proprietário.</span><span class="sxs-lookup"><span data-stu-id="93296-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="93296-326">Consulte também</span><span class="sxs-lookup"><span data-stu-id="93296-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="93296-327">Serviços XAML</span><span class="sxs-lookup"><span data-stu-id="93296-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="93296-328">Namespaces XAML</span><span class="sxs-lookup"><span data-stu-id="93296-328">XAML Namespaces</span></span>](xaml-namespaces-for-net-framework-xaml-services.md)
