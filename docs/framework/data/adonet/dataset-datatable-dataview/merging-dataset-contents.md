---
title: Mesclando conteúdo do DataSet
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: abc9183666602a7ef369e690e3ae499f8c7b8b11
ms.sourcegitcommit: d2e1dfa7ef2d4e9ffae3d431cf6a4ffd9c8d378f
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/07/2019
ms.locfileid: "70784403"
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="c1af8-102">Mesclando conteúdo do DataSet</span><span class="sxs-lookup"><span data-stu-id="c1af8-102">Merging DataSet Contents</span></span>

<span data-ttu-id="c1af8-103">Você pode usar o método <xref:System.Data.DataSet.Merge%2A> para mesclar o conteúdo de uma matriz <xref:System.Data.DataSet>, <xref:System.Data.DataTable> ou <xref:System.Data.DataRow> em um `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="c1af8-104">Vários fatores e opções afetam a maneira como os novos dados são mesclados em um `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>

## <a name="primary-keys"></a><span data-ttu-id="c1af8-105">Chaves primárias</span><span class="sxs-lookup"><span data-stu-id="c1af8-105">Primary Keys</span></span>

<span data-ttu-id="c1af8-106">Se a tabela que recebe novos dados e esquemas de uma mesclagem tiver uma chave primária, as novas linhas de dados de entrada coincidirão com linhas existentes que tenham os mesmos valores de chave primária <xref:System.Data.DataRowVersion.Original> que nos dados de entrada.</span><span class="sxs-lookup"><span data-stu-id="c1af8-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="c1af8-107">Se as colunas do esquema de entrada coincidem com as do esquema existente, os dados nas linhas existentes são modificados.</span><span class="sxs-lookup"><span data-stu-id="c1af8-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="c1af8-108">As colunas que não correspondem ao esquema existente são ignoradas ou adicionadas com base no parâmetro <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>.</span><span class="sxs-lookup"><span data-stu-id="c1af8-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="c1af8-109">As novas linhas com valores de chave primária que não correspondem a linhas existentes são adicionadas à tabela existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>

<span data-ttu-id="c1af8-110">Se o estado de linha das linhas novas ou existentes for <xref:System.Data.DataRowState.Added>, seus valores de chave primária serão correspondidos usando o valor de chave primária <xref:System.Data.DataRowVersion.Current> da linha `Added` pois não existe versão da linha `Original`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>

<span data-ttu-id="c1af8-111">Se uma tabela de entrada e uma tabela existente contiverem uma coluna com o mesmo nome, mas tipos de dados diferentes, uma exceção será gerada e o evento <xref:System.Data.DataSet.MergeFailed> de `DataSet` será gerado.</span><span class="sxs-lookup"><span data-stu-id="c1af8-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="c1af8-112">Se uma tabela de entrada e uma tabela existente tiverem chaves definidas, mas as chaves primárias forem para colunas diferentes, uma exceção será gerada e o evento `MergeFailed` de `DataSet` será gerado.</span><span class="sxs-lookup"><span data-stu-id="c1af8-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>

<span data-ttu-id="c1af8-113">Se a tabela que recebe novos dados de uma mesclagem não tem uma chave primária, as novas linhas de dados de entrada não podem coincidir com linhas existentes na tabela e são adicionadas à tabela existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>

## <a name="table-names-and-namespaces"></a><span data-ttu-id="c1af8-114">Nomes de tabela e namespaces</span><span class="sxs-lookup"><span data-stu-id="c1af8-114">Table Names and Namespaces</span></span>

<span data-ttu-id="c1af8-115">Os objetos <xref:System.Data.DataTable> podem opcionalmente receber um valor de propriedade <xref:System.Data.DataTable.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="c1af8-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="c1af8-116">Quando os valores <xref:System.Data.DataTable.Namespace%2A> são atribuídos, um <xref:System.Data.DataSet> pode conter vários objetos <xref:System.Data.DataTable> com o mesmo valor <xref:System.Data.DataTable.TableName%2A>.</span><span class="sxs-lookup"><span data-stu-id="c1af8-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="c1af8-117">Durante operações de mesclagem, <xref:System.Data.DataTable.TableName%2A> e <xref:System.Data.DataTable.Namespace%2A> são usados para identificar o destino de uma mesclagem.</span><span class="sxs-lookup"><span data-stu-id="c1af8-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="c1af8-118">Se nenhum <xref:System.Data.DataTable.Namespace%2A> foi atribuído, somente <xref:System.Data.DataTable.TableName%2A> será usado para identificar o destino de uma mesclagem.</span><span class="sxs-lookup"><span data-stu-id="c1af8-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>

> [!NOTE]
> <span data-ttu-id="c1af8-119">Esse comportamento mudou no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="c1af8-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="c1af8-120">Na versão 1.1, namespaces tinham suporte, mas eram ignorados durante operações de mesclagem.</span><span class="sxs-lookup"><span data-stu-id="c1af8-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="c1af8-121">Por esse motivo, um <xref:System.Data.DataSet> que usa valores de propriedade <xref:System.Data.DataTable.Namespace%2A> terá comportamentos diferentes de acordo com a versão do .NET Framework executada.</span><span class="sxs-lookup"><span data-stu-id="c1af8-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="c1af8-122">Por exemplo, digamos que você tenha dois `DataSets` contendo `DataTables` com os mesmos valores de propriedade <xref:System.Data.DataTable.TableName%2A>, mas diferentes valores de propriedades <xref:System.Data.DataTable.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="c1af8-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="c1af8-123">No .NET Framework versão 1.1, os nomes diferentes de <xref:System.Data.DataTable.Namespace%2A> serão ignorados na mesclagem dos dois objetos <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="c1af8-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="c1af8-124">No entanto, a partir da versão 2.0, a mesclagem leva à criação de dois novos `DataTables` no <xref:System.Data.DataSet> de destino.</span><span class="sxs-lookup"><span data-stu-id="c1af8-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="c1af8-125">O `DataTables` original não será afetado pela mesclagem.</span><span class="sxs-lookup"><span data-stu-id="c1af8-125">The original `DataTables` will be unaffected by the merge.</span></span>

## <a name="preservechanges"></a><span data-ttu-id="c1af8-126">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="c1af8-126">PreserveChanges</span></span>

<span data-ttu-id="c1af8-127">Quando você passa uma matriz de `DataSet`, de `DataTable` ou de `DataRow` para o método `Merge`, pode incluir parâmetros opcionais que especificam se as alterações devem ou não ser preservadas no `DataSet` existente, e como tratar novos elementos de esquema encontrados nos dados de entrada.</span><span class="sxs-lookup"><span data-stu-id="c1af8-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="c1af8-128">O primeiro desses parâmetros após os dados de entrada é um sinalizador booliano, <xref:System.Data.LoadOption.PreserveChanges>, que especifica se as alterações devem ou não ser preservadas no `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="c1af8-129">Se o sinalizador `PreserveChanges` estiver definido como `true`, os valores de entrada não substituirão os valores existentes na versão de linha `Current` da linha existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="c1af8-130">Se o sinalizador `PreserveChanges` estiver definido como `false`, os valores de entrada substituirão os valores existentes na versão de linha `Current` da linha existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="c1af8-131">Se o sinalizador `PreserveChanges` não for especificado, ele será definido como `false` por padrão.</span><span class="sxs-lookup"><span data-stu-id="c1af8-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="c1af8-132">Para obter mais informações sobre versões de linha, consulte [Estados de linha e versões de linha](row-states-and-row-versions.md).</span><span class="sxs-lookup"><span data-stu-id="c1af8-132">For more information about row versions, see [Row States and Row Versions](row-states-and-row-versions.md).</span></span>

<span data-ttu-id="c1af8-133">Quando `PreserveChanges` é `true`, os dados da linha existente são mantidos na versão de linha <xref:System.Data.DataRowVersion.Current> da linha existente, enquanto os dados da versão de linha <xref:System.Data.DataRowVersion.Original> da linha existente são substituídos pelos dados da versão de linha `Original` da nova linha.</span><span class="sxs-lookup"><span data-stu-id="c1af8-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="c1af8-134">O <xref:System.Data.DataRow.RowState%2A> da linha existente é definido como <xref:System.Data.DataRowState.Modified>.</span><span class="sxs-lookup"><span data-stu-id="c1af8-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="c1af8-135">As seguintes exceções se aplicam:</span><span class="sxs-lookup"><span data-stu-id="c1af8-135">The following exceptions apply:</span></span>

- <span data-ttu-id="c1af8-136">Se a linha existente tem um `RowState` de `Deleted`, este `RowState` permanece `Deleted` e não é definido como `Modified`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="c1af8-137">Nesse caso, os dados da nova linha ainda serão armazenados na versão de linha `Original` da linha existente, substituindo a versão de linha `Original` da linha existente (a menos que a nova linha tenha um `RowState` de `Added`).</span><span class="sxs-lookup"><span data-stu-id="c1af8-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>

- <span data-ttu-id="c1af8-138">Se a nova linha tem `RowState` de `Added`, os dados da versão de linha `Original` da linha existente não serão substituídos pelos dados da nova linha, pois a nova linha não tem uma versão de linha `Original`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

<span data-ttu-id="c1af8-139">Quando `PreserveChanges` é `false`, as versões de linha `Current` e `Original` na linha existente são substituídas pelos dados da nova linha, e `RowState` da linha existente é definido como o `RowState` da nova linha.</span><span class="sxs-lookup"><span data-stu-id="c1af8-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="c1af8-140">As seguintes exceções se aplicam:</span><span class="sxs-lookup"><span data-stu-id="c1af8-140">The following exceptions apply:</span></span>

- <span data-ttu-id="c1af8-141">Se a nova linha tem um `RowState` de `Unchanged` e a linha existente tem um `RowState` de `Modified`, de `Deleted` ou de `Added`, o `RowState` da linha existente é definido como `Modified`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>

- <span data-ttu-id="c1af8-142">Se a nova linha tem um `RowState` de `Added` e a linha existente tem um `RowState` de `Unchanged`, de `Modified` ou de `Deleted`, o `RowState` da linha existente é definido como `Modified`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="c1af8-143">Além disso, os dados da versão de linha `Original` da linha existente não são substituídos pelos dados da nova linha, pois a nova linha não tem uma versão de linha `Original`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

## <a name="missingschemaaction"></a><span data-ttu-id="c1af8-144">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="c1af8-144">MissingSchemaAction</span></span>

<span data-ttu-id="c1af8-145">Você pode usar o parâmetro opcional <xref:System.Data.MissingSchemaAction> do método `Merge` para especificar como `Merge` tratará os elementos de esquema nos dados de entrada que não fazem parte do `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>

<span data-ttu-id="c1af8-146">A tabela a seguir descreve as opções de `MissingSchemaAction`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-146">The following table describes the options for `MissingSchemaAction`.</span></span>

|<span data-ttu-id="c1af8-147">Opção MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="c1af8-147">MissingSchemaAction option</span></span>|<span data-ttu-id="c1af8-148">Descrição</span><span class="sxs-lookup"><span data-stu-id="c1af8-148">Description</span></span>|
|--------------------------------|-----------------|
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="c1af8-149">Adicionar as novas informações de esquema ao `DataSet` e preencher as novas colunas com os valores de entrada.</span><span class="sxs-lookup"><span data-stu-id="c1af8-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="c1af8-150">Esse é o padrão.</span><span class="sxs-lookup"><span data-stu-id="c1af8-150">This is the default.</span></span>|
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="c1af8-151">Adicionar as novas informações de esquema e de chave primária ao `DataSet` e preencher as novas colunas com os valores de entrada.</span><span class="sxs-lookup"><span data-stu-id="c1af8-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="c1af8-152">Gere uma exceção se forem encontradas informações de esquema incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="c1af8-152">Throw an exception if mismatched schema information is encountered.</span></span>|
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="c1af8-153">Ignorar as novas informações do esquema.</span><span class="sxs-lookup"><span data-stu-id="c1af8-153">Ignore the new schema information.</span></span>|

## <a name="constraints"></a><span data-ttu-id="c1af8-154">Restrições</span><span class="sxs-lookup"><span data-stu-id="c1af8-154">Constraints</span></span>

<span data-ttu-id="c1af8-155">Com o método `Merge`, as restrições não são verificadas até que todos os novos dados sejam adicionados ao `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="c1af8-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="c1af8-156">Após a adição dos dados, as restrições são impostas nos valores atuais no `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="c1af8-157">Você deve garantir que seu código trate quaisquer exceções que possam ser geradas por causa de violações de restrição.</span><span class="sxs-lookup"><span data-stu-id="c1af8-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>

<span data-ttu-id="c1af8-158">Considere um caso onde uma linha existente em um `DataSet` seja uma linha `Unchanged` com um valor de chave primária de 1.</span><span class="sxs-lookup"><span data-stu-id="c1af8-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="c1af8-159">Durante uma operação de mesclagem com uma nova linha `Modified` com um valor de chave primária `Original` de 2 e um valor de chave primária `Current` de 1, a linha existente e a nova linha não são consideradas coincidentes porque os valores de chave primária `Original` diferem.</span><span class="sxs-lookup"><span data-stu-id="c1af8-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="c1af8-160">Entretanto, quando a mesclagem é concluída e restrições são verificadas, uma exceção é gerada pois os valores de chave primária `Current` violam a restrição exclusiva para a coluna de chave primária.</span><span class="sxs-lookup"><span data-stu-id="c1af8-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>

> [!NOTE]
> <span data-ttu-id="c1af8-161">Quando linhas são inseridas em uma tabela de banco de dados contendo uma coluna de incremento automático, como uma coluna de identidade, o valor da coluna de identidade retornado pela inserção talvez não corresponda ao valor no `DataSet`, causando as linhas retornados a serem adicionadas, e não mescladas.</span><span class="sxs-lookup"><span data-stu-id="c1af8-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="c1af8-162">Para obter mais informações, consulte [recuperando identidade ou valores de numeração automática](../retrieving-identity-or-autonumber-values.md).</span><span class="sxs-lookup"><span data-stu-id="c1af8-162">For more information, see [Retrieving Identity or Autonumber Values](../retrieving-identity-or-autonumber-values.md).</span></span>

<span data-ttu-id="c1af8-163">O exemplo de código a seguir mescla `DataSet` dois objetos com esquemas diferentes em um `DataSet` com os esquemas combinados dos dois objetos de entrada `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="c1af8-163">The following code example merges two `DataSet` objects with different schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>

[!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]

<span data-ttu-id="c1af8-164">O exemplo de código a seguir usa um `DataSet` existente com atualizações e passa essas atualizações para um `DataAdapter` a serem processadas na fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="c1af8-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="c1af8-165">Os resultados são mesclados no `DataSet` original.</span><span class="sxs-lookup"><span data-stu-id="c1af8-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="c1af8-166">Após a rejeição das alterações que resultaram em um erro, as alterações mescladas são confirmadas com `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="c1af8-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]

## <a name="see-also"></a><span data-ttu-id="c1af8-167">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c1af8-167">See also</span></span>

- <span data-ttu-id="c1af8-168">[DataSets, DataTables, and DataViews](index.md) (DataSets, DataTables e DataViews)</span><span class="sxs-lookup"><span data-stu-id="c1af8-168">[DataSets, DataTables, and DataViews](index.md)</span></span>
- [<span data-ttu-id="c1af8-169">Estados e versões de linha</span><span class="sxs-lookup"><span data-stu-id="c1af8-169">Row States and Row Versions</span></span>](row-states-and-row-versions.md)
- [<span data-ttu-id="c1af8-170">DataAdapters e DataReaders</span><span class="sxs-lookup"><span data-stu-id="c1af8-170">DataAdapters and DataReaders</span></span>](../dataadapters-and-datareaders.md)
- <span data-ttu-id="c1af8-171">[Retrieving and Modifying Data in ADO.NET](../retrieving-and-modifying-data.md) (Recuperando e modificando dados no ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="c1af8-171">[Retrieving and Modifying Data in ADO.NET](../retrieving-and-modifying-data.md)</span></span>
- [<span data-ttu-id="c1af8-172">Recuperando identidade ou valores de Autonumber</span><span class="sxs-lookup"><span data-stu-id="c1af8-172">Retrieving Identity or Autonumber Values</span></span>](../retrieving-identity-or-autonumber-values.md)
- <span data-ttu-id="c1af8-173">[ADO.NET Overview](../ado-net-overview.md) (Visão geral do ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="c1af8-173">[ADO.NET Overview](../ado-net-overview.md)</span></span>
