---
title: Populando um DataSet a partir de um DataAdapter
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: 5e86eb4c37d20be53d271aba9f4913f2eeccd923
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69928339"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="6e970-102">Populando um DataSet a partir de um DataAdapter</span><span class="sxs-lookup"><span data-stu-id="6e970-102">Populating a DataSet from a DataAdapter</span></span>
<span data-ttu-id="6e970-103">O ADO.NET <xref:System.Data.DataSet> é uma representação de dados residente na memória que fornece um modelo de programação relacional consistente independente da fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-103">The ADO.NET <xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="6e970-104">O `DataSet` representa um conjunto completo de dados, que inclui tabelas, restrições e relações entre as tabelas.</span><span class="sxs-lookup"><span data-stu-id="6e970-104">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="6e970-105">Como `DataSet` é independente da fonte de dados, um `DataSet` pode incluir o local de dados para o aplicativo, e os dados de várias fontes de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-105">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="6e970-106">A interação com fontes de dados existente é controlada com o `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="6e970-106">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="6e970-107">A propriedade `SelectCommand` do `DataAdapter` é um objeto `Command` que recupera dados da fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-107">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="6e970-108">As propriedades `InsertCommand`, `UpdateCommand`, e `DeleteCommand` do `DataAdapter` são objetos `Command` que gerenciam as atualizações aos dados na fonte de dados de acordo com as alterações feitas aos dados no `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-108">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="6e970-109">Essas propriedades são abordadas em mais detalhes na [atualização de fontes de dados com](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)DataAdapters.</span><span class="sxs-lookup"><span data-stu-id="6e970-109">These properties are covered in more detail in [Updating Data Sources with DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="6e970-110">O método `Fill` do `DataAdapter` é usado para preencher um `DataSet` com os resultados do `SelectCommand` do `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="6e970-110">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="6e970-111">`Fill` utiliza como seus argumentos um `DataSet` a ser preenchido, e um objeto `DataTable`, ou nome do `DataTable` a ser preenchido com as linhas retornadas do `SelectCommand`.</span><span class="sxs-lookup"><span data-stu-id="6e970-111">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6e970-112">Usar o `DataAdapter` para recuperar todas as tabelas leva tempo, especialmente se há várias linhas na tabela.</span><span class="sxs-lookup"><span data-stu-id="6e970-112">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="6e970-113">Isso ocorre porque acessar o banco de dados, localizar e processar os dados e, em seguida, transferir os dados para o cliente é demorado.</span><span class="sxs-lookup"><span data-stu-id="6e970-113">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="6e970-114">Receber todas as tabelas para o cliente também bloqueia todas as linhas no servidor.</span><span class="sxs-lookup"><span data-stu-id="6e970-114">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="6e970-115">Para melhorar o desempenho, você pode usar a cláusula `WHERE` para reduzir bastante o número de linhas retornadas para o cliente.</span><span class="sxs-lookup"><span data-stu-id="6e970-115">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="6e970-116">Você também pode reduzir a quantidade de dados retornados para o cliente somente listando explicitamente as colunas necessárias na instrução `SELECT`.</span><span class="sxs-lookup"><span data-stu-id="6e970-116">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="6e970-117">Outra boa solução alternativa é recuperar as linhas em lotes (como várias centenas de linhas de cada vez) e recuperar somente o próximo lote quando o cliente tiver terminado o lote atual.</span><span class="sxs-lookup"><span data-stu-id="6e970-117">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="6e970-118">O método `Fill` usa o objeto `DataReader` implicitamente para retornar os nomes de coluna e os tipos que são usados para criar as tabelas no `DataSet`, e os dados para preencher as linhas das tabelas no `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-118">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="6e970-119">As tabelas e as colunas são criadas somente se já não existirem; caso contrário, `Fill` usará o esquema existente do `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-119">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="6e970-120">Os tipos de coluna são criados como tipos de .NET Framework de acordo com as tabelas em mapeamentos de [tipo de dados no ADO.net](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md).</span><span class="sxs-lookup"><span data-stu-id="6e970-120">Column types are created as .NET Framework types according to the tables in [Data Type Mappings in ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="6e970-121">As chaves primárias não são criadas, a menos que elas existam na fonte de dados e `DataAdapter` **.** `MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="6e970-121">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="6e970-122">é definido como `MissingSchemaAction` **.** `AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="6e970-122">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="6e970-123">Se `Fill` descobrir que uma chave primária existe para uma tabela, ele substituirá os dados no `DataSet` pelos dados da fonte de dados para as linhas onde os valores de coluna de chave primária coincidirem com os da linha retornada da fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-123">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="6e970-124">Se nenhuma chave primária tiver sido encontrada, os dados serão adicionados às tabelas no `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-124">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="6e970-125">`Fill`usa os mapeamentos que podem existir quando você preenche o `DataSet` (consulte [DataAdapter DataTable e](../../../../docs/framework/data/adonet/dataadapter-datatable-and-datacolumn-mappings.md)os mapeamentos de DataColumn).</span><span class="sxs-lookup"><span data-stu-id="6e970-125">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](../../../../docs/framework/data/adonet/dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6e970-126">Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de `PrimaryKey` para o`DataTable` resultante.</span><span class="sxs-lookup"><span data-stu-id="6e970-126">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="6e970-127">Você deve definir o `PrimaryKey` você mesmo para garantir que as linhas duplicadas sejam resolvidas corretamente.</span><span class="sxs-lookup"><span data-stu-id="6e970-127">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="6e970-128">Para obter mais informações, consulte [definindo chaves primárias](../../../../docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="6e970-128">For more information, see [Defining Primary Keys](../../../../docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="6e970-129">O exemplo de código a seguir cria uma instância de um <xref:System.Data.SqlClient.SqlDataAdapter> que usa um <xref:System.Data.SqlClient.SqlConnection> para o banco de dados `Northwind` do Microsoft SQL Server e preenche uma <xref:System.Data.DataTable> em um `DataSet` com a lista de clientes.</span><span class="sxs-lookup"><span data-stu-id="6e970-129">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="6e970-130">A instrução SQL e os argumentos <xref:System.Data.SqlClient.SqlConnection> passados para o construtor de <xref:System.Data.SqlClient.SqlDataAdapter> são usados para criar a propriedade de <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> de <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="6e970-130">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="6e970-131">Exemplo</span><span class="sxs-lookup"><span data-stu-id="6e970-131">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =   
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
> <span data-ttu-id="6e970-132">O código mostrado neste exemplo não abre e não fecha explicitamente a `Connection`.</span><span class="sxs-lookup"><span data-stu-id="6e970-132">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="6e970-133">O método `Fill` abre implicitamente a `Connection` que o `DataAdapter` estiver usando se descobrir que a conexão ainda não está aberta.</span><span class="sxs-lookup"><span data-stu-id="6e970-133">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="6e970-134">Se `Fill` tiver aberto a conexão, ele também fechará a conexão quando `Fill` terminar.</span><span class="sxs-lookup"><span data-stu-id="6e970-134">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="6e970-135">Isso pode simplificar o seu código quando você manipula uma única operação como `Fill` ou `Update`.</span><span class="sxs-lookup"><span data-stu-id="6e970-135">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="6e970-136">No entanto, se você estiver executando várias operações que exigem uma conexão aberta, poderá melhorar o desempenho do seu aplicativo explicitamente chamando o método `Open` da `Connection`, executando operações na fonte de dados e, em seguida, chamando o método `Close` da `Connection`.</span><span class="sxs-lookup"><span data-stu-id="6e970-136">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="6e970-137">Você deve tentar manter abertas as conexões para a fonte de dados o mais rapidamente possível para liberar recursos para o uso por outros aplicativos cliente.</span><span class="sxs-lookup"><span data-stu-id="6e970-137">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="6e970-138">Vários conjuntos de resultados</span><span class="sxs-lookup"><span data-stu-id="6e970-138">Multiple Result Sets</span></span>  
 <span data-ttu-id="6e970-139">Se o `DataAdapter` encontrar vários conjuntos de resultados, criará várias tabelas no `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-139">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="6e970-140">As tabelas recebem um nome padrão incremental da tabela*N*, começando com "Table" para Table0.</span><span class="sxs-lookup"><span data-stu-id="6e970-140">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="6e970-141">Se um nome de tabela for passado como um argumento para `Fill` o método, as tabelas receberão um nome padrão incremental de TableName*N*, começando com "TableName" para TableName0.</span><span class="sxs-lookup"><span data-stu-id="6e970-141">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="6e970-142">Populando um DataSet a partir de vários DataAdapters</span><span class="sxs-lookup"><span data-stu-id="6e970-142">Populating a DataSet from Multiple DataAdapters</span></span>  
 <span data-ttu-id="6e970-143">Qualquer número de `DataAdapter` objetos pode ser usado com um `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-143">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="6e970-144">Cada `DataAdapter` pode ser usado para preencher um ou mais objetos `DataTable` e resolver atualizações de volta para a fonte de dados relevante.</span><span class="sxs-lookup"><span data-stu-id="6e970-144">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="6e970-145">Os objetos `DataRelation` e `Constraint` podem ser adicionados ao `DataSet` localmente, o que permite relacionar dados de fontes de dados não semelhantes.</span><span class="sxs-lookup"><span data-stu-id="6e970-145">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="6e970-146">Por exemplo, um `DataSet` pode conter dados de um banco de dados Microsoft SQL Server, um banco de dados IBM DB2 exposto por meio do OLE DB e uma fonte de dados que transmite XML.</span><span class="sxs-lookup"><span data-stu-id="6e970-146">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="6e970-147">Um ou mais objetos `DataAdapter` podem administrar a comunicação para cada fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-147">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="6e970-148">Exemplo</span><span class="sxs-lookup"><span data-stu-id="6e970-148">Example</span></span>  
 <span data-ttu-id="6e970-149">O exemplo de código a seguir preenche uma lista de clientes do banco de dados `Northwind` no Microsoft SQL Server, e uma lista de pedidos do banco de dados `Northwind` armazenado no Microsoft Access 2000.</span><span class="sxs-lookup"><span data-stu-id="6e970-149">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="6e970-150">As tabelas preenchidas estão relacionadas com um `DataRelation`, e a lista de clientes é exibida com os pedidos para aquele cliente.</span><span class="sxs-lookup"><span data-stu-id="6e970-150">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="6e970-151">Para obter mais informações `DataRelation` sobre objetos, consulte [adicionando](../../../../docs/framework/data/adonet/dataset-datatable-dataview/adding-datarelations.md) DataRelations e [navegando](../../../../docs/framework/data/adonet/dataset-datatable-dataview/navigating-datarelations.md)DataRelations.</span><span class="sxs-lookup"><span data-stu-id="6e970-151">For more information about `DataRelation` objects, see [Adding DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](../../../../docs/framework/data/adonet/dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _   
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="6e970-152">Tipo decimal do SQL Server</span><span class="sxs-lookup"><span data-stu-id="6e970-152">SQL Server Decimal Type</span></span>  
 <span data-ttu-id="6e970-153">Por padrão, o `DataSet` armazena dados usando .NET Framework tipos de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-153">By default, the `DataSet` stores data by using .NET Framework data types.</span></span> <span data-ttu-id="6e970-154">Para a maioria dos aplicativos, eles fornecem uma representação conveniente de informações da fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-154">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="6e970-155">No entanto, essa representação pode causar um problema quando o tipo de dados na fonte de dados é um decimal ou um tipo de dados numérico do SQL Server.</span><span class="sxs-lookup"><span data-stu-id="6e970-155">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="6e970-156">O tipo `decimal` de dados .NET Framework permite um máximo de 28 dígitos significativos, enquanto o `decimal` tipo de dados SQL Server permite dígitos significativos de 38.</span><span class="sxs-lookup"><span data-stu-id="6e970-156">The .NET Framework `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="6e970-157">Se o `SqlDataAdapter` determina durante uma operação de `Fill` que a precisão de um campo do SQL Server `decimal` é maior que 28 caracteres, a linha atual não será adicionada ao `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="6e970-157">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="6e970-158">Em vez disso, o evento de `FillError` ocorre, o que permite determinar se uma perda de precisão ocorrerá e responder corretamente.</span><span class="sxs-lookup"><span data-stu-id="6e970-158">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="6e970-159">Para obter mais informações sobre `FillError` o evento, consulte [manipulando eventos de DataAdapter](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="6e970-159">For more information about the `FillError` event, see [Handling DataAdapter Events](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).</span></span> <span data-ttu-id="6e970-160">Para obter o valor `decimal` do SQL Server, você também poderá usar um objeto <xref:System.Data.SqlClient.SqlDataReader> e chamar o método <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e970-160">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 <span data-ttu-id="6e970-161">O ADO.NET 2,0 introduziu suporte <xref:System.Data.SqlTypes> aprimorado `DataSet`para o no.</span><span class="sxs-lookup"><span data-stu-id="6e970-161">ADO.NET 2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="6e970-162">Para obter mais informações, consulte SqlTypes [e o DataSet](../../../../docs/framework/data/adonet/sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="6e970-162">For more information, see [SqlTypes and the DataSet](../../../../docs/framework/data/adonet/sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="6e970-163">Capítulos do OLE DB</span><span class="sxs-lookup"><span data-stu-id="6e970-163">OLE DB Chapters</span></span>  
 <span data-ttu-id="6e970-164">Os conjuntos de linhas hierárquicos ou capítulos (tipo `DBTYPE_HCHAPTER` do OLE DB, tipo `adChapter` do ADO) podem ser usados para preencher o conteúdo de um `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-164">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="6e970-165">Quando o <xref:System.Data.OleDb.OleDbDataAdapter> encontra uma coluna de capítulos durante uma operação de `Fill`, um `DataTable` é criado para a coluna de capítulos e a tabela é preenchida com as colunas e linhas do capítulo.</span><span class="sxs-lookup"><span data-stu-id="6e970-165">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="6e970-166">A tabela criada para a coluna com capítulo é nomeada usando o nome da tabela pai e o nome da coluna com capítulo no formato "*ParentTableNameChapteredColumnName*".</span><span class="sxs-lookup"><span data-stu-id="6e970-166">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="6e970-167">Se uma tabela já existir no `DataSet` que corresponde ao nome da coluna de capítulos, a tabela atual será preenchida com os dados do capítulo.</span><span class="sxs-lookup"><span data-stu-id="6e970-167">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="6e970-168">Se não houver nenhuma coluna em uma tabela existente que corresponde a uma coluna encontrada no capítulo, uma nova coluna será adicionada.</span><span class="sxs-lookup"><span data-stu-id="6e970-168">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="6e970-169">Antes que as tabelas no `DataSet` sejam preenchidas com os dados nas colunas de capítulos, um relacionamento é criado entre as tabelas pai e filho do conjunto de linhas hierárquico adicionando uma coluna de inteiros à tabela pai e filho, definindo a coluna pai para incrementar automaticamente, e criando uma `DataRelation` usando as colunas adicionadas das duas tabelas.</span><span class="sxs-lookup"><span data-stu-id="6e970-169">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="6e970-170">A relação adicionada é nomeada por meio da tabela pai e dos nomes de coluna de capítulo no formato "*ParentTableNameChapterColumnName*".</span><span class="sxs-lookup"><span data-stu-id="6e970-170">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="6e970-171">Observe que a coluna relacionada somente existe no `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="6e970-171">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="6e970-172">Os preenchimentos subsequentes da fonte de dados podem fazer novas linhas serem adicionadas às tabelas em vez de as alterações serem mescladas em linhas existentes.</span><span class="sxs-lookup"><span data-stu-id="6e970-172">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="6e970-173">Observe também que, se você usar a sobrecarga de `DataAdapter.Fill` que utiliza uma `DataTable`, somente essa tabela será preenchida.</span><span class="sxs-lookup"><span data-stu-id="6e970-173">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="6e970-174">Uma coluna de inteiros de incremento automático ainda será adicionada à tabela, mas nenhuma tabela filho será criada ou preenchida, e nenhuma relação será criada.</span><span class="sxs-lookup"><span data-stu-id="6e970-174">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="6e970-175">O exemplo a seguir usa o provedor de MSDataShape para gerar uma coluna de capítulo de pedidos para cada cliente em uma lista de clientes.</span><span class="sxs-lookup"><span data-stu-id="6e970-175">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="6e970-176">Um `DataSet` é então preenchido com os dados.</span><span class="sxs-lookup"><span data-stu-id="6e970-176">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="6e970-177">Quando a operação de `Fill` estiver concluída, o `DataSet` conterá duas tabelas: `Customers` e `CustomersOrders`, onde `CustomersOrders` representa a coluna de capítulos.</span><span class="sxs-lookup"><span data-stu-id="6e970-177">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="6e970-178">Uma coluna adicional chamada `Orders` é adicionada à tabela `Customers` e uma coluna extra chamada `CustomersOrders` é adicionada à tabela `CustomersOrders`.</span><span class="sxs-lookup"><span data-stu-id="6e970-178">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="6e970-179">A coluna `Orders` na tabela `Customers` é definida para incrementar automaticamente.</span><span class="sxs-lookup"><span data-stu-id="6e970-179">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="6e970-180">Um `DataRelation`, `CustomersOrders`, é criado usando as colunas que foram adicionadas às tabelas com `Customers` como a tabela pai.</span><span class="sxs-lookup"><span data-stu-id="6e970-180">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="6e970-181">As tabelas a seguir mostram alguns resultados de exemplo.</span><span class="sxs-lookup"><span data-stu-id="6e970-181">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="6e970-182">TableName Clientes</span><span class="sxs-lookup"><span data-stu-id="6e970-182">TableName: Customers</span></span>  
  
|<span data-ttu-id="6e970-183">CustomerID</span><span class="sxs-lookup"><span data-stu-id="6e970-183">CustomerID</span></span>|<span data-ttu-id="6e970-184">CompanyName</span><span class="sxs-lookup"><span data-stu-id="6e970-184">CompanyName</span></span>|<span data-ttu-id="6e970-185">Orders</span><span class="sxs-lookup"><span data-stu-id="6e970-185">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="6e970-186">ALFKI</span><span class="sxs-lookup"><span data-stu-id="6e970-186">ALFKI</span></span>|<span data-ttu-id="6e970-187">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="6e970-187">Alfreds Futterkiste</span></span>|<span data-ttu-id="6e970-188">0</span><span class="sxs-lookup"><span data-stu-id="6e970-188">0</span></span>|  
|<span data-ttu-id="6e970-189">ANATR</span><span class="sxs-lookup"><span data-stu-id="6e970-189">ANATR</span></span>|<span data-ttu-id="6e970-190">Ana Trujillo Emparedados y helados</span><span class="sxs-lookup"><span data-stu-id="6e970-190">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="6e970-191">1</span><span class="sxs-lookup"><span data-stu-id="6e970-191">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="6e970-192">TableName CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="6e970-192">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="6e970-193">CustomerID</span><span class="sxs-lookup"><span data-stu-id="6e970-193">CustomerID</span></span>|<span data-ttu-id="6e970-194">OrderID</span><span class="sxs-lookup"><span data-stu-id="6e970-194">OrderID</span></span>|<span data-ttu-id="6e970-195">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="6e970-195">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="6e970-196">ALFKI</span><span class="sxs-lookup"><span data-stu-id="6e970-196">ALFKI</span></span>|<span data-ttu-id="6e970-197">10643</span><span class="sxs-lookup"><span data-stu-id="6e970-197">10643</span></span>|<span data-ttu-id="6e970-198">0</span><span class="sxs-lookup"><span data-stu-id="6e970-198">0</span></span>|  
|<span data-ttu-id="6e970-199">ALFKI</span><span class="sxs-lookup"><span data-stu-id="6e970-199">ALFKI</span></span>|<span data-ttu-id="6e970-200">10692</span><span class="sxs-lookup"><span data-stu-id="6e970-200">10692</span></span>|<span data-ttu-id="6e970-201">0</span><span class="sxs-lookup"><span data-stu-id="6e970-201">0</span></span>|  
|<span data-ttu-id="6e970-202">ANATR</span><span class="sxs-lookup"><span data-stu-id="6e970-202">ANATR</span></span>|<span data-ttu-id="6e970-203">10308</span><span class="sxs-lookup"><span data-stu-id="6e970-203">10308</span></span>|<span data-ttu-id="6e970-204">1</span><span class="sxs-lookup"><span data-stu-id="6e970-204">1</span></span>|  
|<span data-ttu-id="6e970-205">ANATR</span><span class="sxs-lookup"><span data-stu-id="6e970-205">ANATR</span></span>|<span data-ttu-id="6e970-206">10625</span><span class="sxs-lookup"><span data-stu-id="6e970-206">10625</span></span>|<span data-ttu-id="6e970-207">1</span><span class="sxs-lookup"><span data-stu-id="6e970-207">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="6e970-208">Consulte também</span><span class="sxs-lookup"><span data-stu-id="6e970-208">See also</span></span>

- [<span data-ttu-id="6e970-209">DataAdapters e DataReaders</span><span class="sxs-lookup"><span data-stu-id="6e970-209">DataAdapters and DataReaders</span></span>](../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)
- <span data-ttu-id="6e970-210">[Data Type Mappings in ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md) (Mapeamentos de tipo de dados no ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="6e970-210">[Data Type Mappings in ADO.NET](../../../../docs/framework/data/adonet/data-type-mappings-in-ado-net.md)</span></span>
- [<span data-ttu-id="6e970-211">Modificando dados com um DbDataAdapter</span><span class="sxs-lookup"><span data-stu-id="6e970-211">Modifying Data with a DbDataAdapter</span></span>](../../../../docs/framework/data/adonet/modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="6e970-212">MARS (Conjunto de Resultados Ativos Múltiplos)</span><span class="sxs-lookup"><span data-stu-id="6e970-212">Multiple Active Result Sets (MARS)</span></span>](../../../../docs/framework/data/adonet/sql/multiple-active-result-sets-mars.md)
- <span data-ttu-id="6e970-213">[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917) (Central de desenvolvedores do DataSet e de provedores gerenciados do ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="6e970-213">[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)</span></span>
