---
title: "Inicialização lenta"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
caps.latest.revision: 22
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 7c176079cba9e866c10d7979de8e5c118e3e438f
ms.contentlocale: pt-br
ms.lasthandoff: 08/21/2017

---
# <a name="lazy-initialization"></a><span data-ttu-id="746b3-102">Inicialização lenta</span><span class="sxs-lookup"><span data-stu-id="746b3-102">Lazy Initialization</span></span>
<span data-ttu-id="746b3-103">*Inicialização lenta* de um objeto significa que a criação dele é adiada até que ele seja usado pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="746b3-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="746b3-104">(Para este tópico, os termos *inicialização lenta* e *instanciação lenta* são sinônimos.) A inicialização lenta é usada principalmente para melhorar o desempenho, evitar a computação dispendiosa e reduzir os requisitos de memória do programa.</span><span class="sxs-lookup"><span data-stu-id="746b3-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="746b3-105">Estes são os cenários mais comuns:</span><span class="sxs-lookup"><span data-stu-id="746b3-105">These are the most common scenarios:</span></span>  
  
-   <span data-ttu-id="746b3-106">Quando você tem um objeto de criação dispendiosa e o programa pode não vir a usá-lo.</span><span class="sxs-lookup"><span data-stu-id="746b3-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="746b3-107">Por exemplo, suponha que você tenha na memória um objeto `Customer` que tem uma propriedade `Orders` contendo uma grande variedade de objetos `Order` que, ao serem inicializados, requerem uma conexão de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="746b3-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="746b3-108">Se o usuário nunca solicita a exibição das Ordens nem usa os dados em uma computação, não há motivo para usar a memória do sistema ou ciclos de computação para criá-lo.</span><span class="sxs-lookup"><span data-stu-id="746b3-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="746b3-109">Ao usar `Lazy<Orders>` para declarar o objeto `Orders` para inicialização lenta, você pode evitar desperdício de recursos de sistema quando o objeto não é usado.</span><span class="sxs-lookup"><span data-stu-id="746b3-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
-   <span data-ttu-id="746b3-110">Quando você tem um objeto cuja criação é dispendiosa e você deseja adiar a criação até após a conclusão de outras operações dispendiosas.</span><span class="sxs-lookup"><span data-stu-id="746b3-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="746b3-111">Por exemplo, suponha que seu programa carrega várias instâncias de objeto quando ele é iniciado, mas apenas algumas delas são necessárias imediatamente.</span><span class="sxs-lookup"><span data-stu-id="746b3-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="746b3-112">Você pode melhorar o desempenho de inicialização do programa, adiando a inicialização dos objetos que não são necessários até que os objetos necessários tenham sido criados.</span><span class="sxs-lookup"><span data-stu-id="746b3-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="746b3-113">Embora você possa escrever seu próprio código para executar a inicialização lenta, recomendamos que você use <xref:System.Lazy%601> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="746b3-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="746b3-114"><xref:System.Lazy%601> e seus tipos relacionados também dão suporte a segurança do thread e fornecem uma política de propagação de exceção consistente.</span><span class="sxs-lookup"><span data-stu-id="746b3-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="746b3-115">A tabela a seguir lista os tipos que o .NET Framework versão 4 fornece para permitir a inicialização lenta em cenários diferentes.</span><span class="sxs-lookup"><span data-stu-id="746b3-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="746b3-116">Tipo</span><span class="sxs-lookup"><span data-stu-id="746b3-116">Type</span></span>|<span data-ttu-id="746b3-117">Descrição</span><span class="sxs-lookup"><span data-stu-id="746b3-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="746b3-118">Uma classe wrapper que fornece a semântica de inicialização lenta para qualquer biblioteca de classes ou tipo definido pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="746b3-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="746b3-119">Ela é semelhante a <xref:System.Lazy%601>, exceto pelo fato de que ela fornece a semântica de inicialização lenta por local de thread.</span><span class="sxs-lookup"><span data-stu-id="746b3-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="746b3-120">Cada thread tem acesso ao seu próprio valor exclusivo.</span><span class="sxs-lookup"><span data-stu-id="746b3-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="746b3-121">Fornece métodos `static` avançados (`Shared` no Visual Basic) para inicialização lenta de objetos sem a sobrecarga de uma classe.</span><span class="sxs-lookup"><span data-stu-id="746b3-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="746b3-122">Inicialização lenta básica</span><span class="sxs-lookup"><span data-stu-id="746b3-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="746b3-123">Para definir um tipo de inicialização lenta, por exemplo, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` no Visual Basic), conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="746b3-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="746b3-124">Se nenhum delegado é passado ao construtor <xref:System.Lazy%601>, o tipo encapsulado é criado usando <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> quando a propriedade de valor é acessada pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="746b3-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> when the value property is first accessed.</span></span> <span data-ttu-id="746b3-125">Se o tipo não tem um construtor padrão, uma exceção de tempo de execução é gerada.</span><span class="sxs-lookup"><span data-stu-id="746b3-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="746b3-126">No exemplo a seguir, suponha que `Orders` é uma classe que contém uma matriz de objetos `Order` recuperados de um banco de dados.</span><span class="sxs-lookup"><span data-stu-id="746b3-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="746b3-127">Um objeto `Customer` contém uma instância de `Orders`, mas, dependendo de ações do usuário, os dados do objeto `Orders` talvez não sejam necessário.</span><span class="sxs-lookup"><span data-stu-id="746b3-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 <span data-ttu-id="746b3-128">[!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)] [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="746b3-128">[!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)] [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]</span></span>  
  
 <span data-ttu-id="746b3-129">Você também pode passar um delegado no construtor <xref:System.Lazy%601> que invoca uma sobrecarga de construtor específica no tipo encapsulado no momento da criação e pode executar outras etapas de inicialização necessárias, conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="746b3-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 <span data-ttu-id="746b3-130">[!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)] [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="746b3-130">[!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)] [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]</span></span>  
  
 <span data-ttu-id="746b3-131">Depois que o objeto lento é criado, nenhuma instância de `Orders` é criada até a propriedade <xref:System.Lazy%601.Value%2A> da variável lenta ser acessada pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="746b3-131">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="746b3-132">No primeiro acesso, o tipo encapsulado é criado e retornado e então é armazenado para eventuais acessos futuros.</span><span class="sxs-lookup"><span data-stu-id="746b3-132">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 <span data-ttu-id="746b3-133">[!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)] [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="746b3-133">[!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)] [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]</span></span>  
  
 <span data-ttu-id="746b3-134">Um objeto <xref:System.Lazy%601> sempre retorna o mesmo objeto ou valor com o qual ele foi inicializado.</span><span class="sxs-lookup"><span data-stu-id="746b3-134">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="746b3-135">Portanto, a propriedade <xref:System.Lazy%601.Value%2A> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="746b3-135">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="746b3-136">Se <xref:System.Lazy%601.Value%2A> armazena um tipo de referência, você não pode atribuir um novo objeto a ela.</span><span class="sxs-lookup"><span data-stu-id="746b3-136">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="746b3-137">(No entanto, você pode alterar o valor das propriedades e campos públicos configuráveis dela.) Se <xref:System.Lazy%601.Value%2A> armazena um valor de tipo, você não pode modificar o valor dela.</span><span class="sxs-lookup"><span data-stu-id="746b3-137">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="746b3-138">No entanto, você pode criar uma nova variável, invocando o construtor de variável novamente usando novos argumentos.</span><span class="sxs-lookup"><span data-stu-id="746b3-138">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 <span data-ttu-id="746b3-139">[!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)] [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="746b3-139">[!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)] [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]</span></span>  
  
 <span data-ttu-id="746b3-140">A nova instância lenta, semelhante à anterior, não instanciará `Orders` até que propriedade <xref:System.Lazy%601.Value%2A> dele seja acessada pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="746b3-140">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="746b3-141">Inicialização thread-safe</span><span class="sxs-lookup"><span data-stu-id="746b3-141">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="746b3-142">Por padrão, objetos <xref:System.Lazy%601> são thread-safe.</span><span class="sxs-lookup"><span data-stu-id="746b3-142">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="746b3-143">Ou seja, se o construtor não especificar o tipo de acesso thread-safe, os objetos <xref:System.Lazy%601> que ele criar serão thread-safe.</span><span class="sxs-lookup"><span data-stu-id="746b3-143">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="746b3-144">Em cenários com vários threads, o primeiro thread para acessar a propriedade <xref:System.Lazy%601.Value%2A> de um objeto <xref:System.Lazy%601> thread-safe inicializa-o para todos os acessos subsequentes em todos os threads e todos os threads compartilham os mesmos dados.</span><span class="sxs-lookup"><span data-stu-id="746b3-144">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="746b3-145">Portanto, não importa qual thread inicializa o objeto e as condições de corrida são benignas.</span><span class="sxs-lookup"><span data-stu-id="746b3-145">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="746b3-146">Você pode estender essa consistência às condições de erro usando o cache de exceções.</span><span class="sxs-lookup"><span data-stu-id="746b3-146">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="746b3-147">Para obter mais informações, consulte a próxima seção, [Exceções em objetos lentos](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="746b3-147">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="746b3-148">O exemplo a seguir mostra que a mesma instância `Lazy<int>` tem o mesmo valor para três threads separados.</span><span class="sxs-lookup"><span data-stu-id="746b3-148">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 <span data-ttu-id="746b3-149">[!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)] [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="746b3-149">[!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)] [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]</span></span>  
  
 <span data-ttu-id="746b3-150">Se você precisar de dados separados em cada thread, use o tipo <xref:System.Threading.ThreadLocal%601>, conforme descrito posteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="746b3-150">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="746b3-151">Alguns construtores <xref:System.Lazy%601> têm um parâmetro booliano denominado `isThreadSafe` que é usado para especificar se a propriedade <xref:System.Lazy%601.Value%2A> será acessada de vários threads.</span><span class="sxs-lookup"><span data-stu-id="746b3-151">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="746b3-152">Se você pretende acessar a propriedade de apenas um thread, passe `false` para obter uma discreta melhora no desempenho.</span><span class="sxs-lookup"><span data-stu-id="746b3-152">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="746b3-153">Se você pretende acessar a propriedade de vários threads, passe `true` para instruir a instância <xref:System.Lazy%601> para lidar corretamente com condições de corrida em que um thread gera uma exceção em tempo de inicialização.</span><span class="sxs-lookup"><span data-stu-id="746b3-153">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="746b3-154">Alguns construtores <xref:System.Lazy%601> têm um parâmetro <xref:System.Threading.LazyThreadSafetyMode> chamado `mode`.</span><span class="sxs-lookup"><span data-stu-id="746b3-154">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="746b3-155">Esses construtores fornecem um modo adicional de acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="746b3-155">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="746b3-156">A tabela a seguir mostra como o acesso thread-safe de um objeto <xref:System.Lazy%601> é afetado pelos parâmetros de construtor que especificam o acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="746b3-156">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="746b3-157">Cada construtor tem no máximo um desses parâmetros.</span><span class="sxs-lookup"><span data-stu-id="746b3-157">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="746b3-158">Acesso thread-safe do objeto</span><span class="sxs-lookup"><span data-stu-id="746b3-158">Thread safety of the object</span></span>|<span data-ttu-id="746b3-159">Parâmetro de `mode` `LazyThreadSafetyMode`</span><span class="sxs-lookup"><span data-stu-id="746b3-159">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="746b3-160">Parâmetro `isThreadSafe` booliano</span><span class="sxs-lookup"><span data-stu-id="746b3-160">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="746b3-161">Sem parâmetros de acesso thread-safe</span><span class="sxs-lookup"><span data-stu-id="746b3-161">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="746b3-162">Totalmente thread-safe; apenas um thread por vez tenta inicializar o valor.</span><span class="sxs-lookup"><span data-stu-id="746b3-162">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode>|`true`|<span data-ttu-id="746b3-163">Sim.</span><span class="sxs-lookup"><span data-stu-id="746b3-163">Yes.</span></span>|  
|<span data-ttu-id="746b3-164">Não é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="746b3-164">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode>|`false`|<span data-ttu-id="746b3-165">Não aplicável.</span><span class="sxs-lookup"><span data-stu-id="746b3-165">Not applicable.</span></span>|  
|<span data-ttu-id="746b3-166">Totalmente thread-safe; os threads fazem corrida para inicializar o valor.</span><span class="sxs-lookup"><span data-stu-id="746b3-166">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode>|<span data-ttu-id="746b3-167">Não aplicável.</span><span class="sxs-lookup"><span data-stu-id="746b3-167">Not applicable.</span></span>|<span data-ttu-id="746b3-168">Não aplicável.</span><span class="sxs-lookup"><span data-stu-id="746b3-168">Not applicable.</span></span>|  
  
 <span data-ttu-id="746b3-169">Conforme demonstrado na tabela, especificar <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> para o parâmetro `mode` é o mesmo que especificar `true` para o parâmetro `isThreadSafe` e especificar <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> é o mesmo que especificar `false`.</span><span class="sxs-lookup"><span data-stu-id="746b3-169">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="746b3-170">Especificar <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> permite que vários threads tentar inicializar a instância <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="746b3-170">Specifying <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="746b3-171">Apenas um thread pode vencer essa corrida e todos os outros threads recebem o valor que foi inicializado pelo thread bem-sucedido.</span><span class="sxs-lookup"><span data-stu-id="746b3-171">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="746b3-172">Se uma exceção for lançada em um thread durante a inicialização, esse thread não receberá o valor definido pelo thread bem-sucedido.</span><span class="sxs-lookup"><span data-stu-id="746b3-172">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="746b3-173">Exceções não são armazenadas em cache, portanto, uma tentativa subsequente de acessar a propriedade <xref:System.Lazy%601.Value%2A> pode resultar em inicialização bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="746b3-173">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="746b3-174">Isso é diferente da maneira como exceções são tratadas em outros modos, o que é descrito na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="746b3-174">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="746b3-175">Para obter mais informações, consulte a enumeração <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="746b3-175">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="746b3-176">Exceções em objetos lentos</span><span class="sxs-lookup"><span data-stu-id="746b3-176">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="746b3-177">Conforme mencionado anteriormente, um objeto <xref:System.Lazy%601> sempre retorna o mesmo objeto ou valor com o qual ele foi inicializado e, portanto, a propriedade <xref:System.Lazy%601.Value%2A> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="746b3-177">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="746b3-178">Se você habilitar o cache de exceção, essa imutabilidade também se estenderá ao comportamento de exceção.</span><span class="sxs-lookup"><span data-stu-id="746b3-178">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="746b3-179">Se um objeto de inicialização lenta tem o cache de exceção habilitado e gera uma exceção de seu método de inicialização quando a propriedade <xref:System.Lazy%601.Value%2A> é acessada pela primeira vez, essa mesma exceção será gerada em cada tentativa subsequente de acessar a propriedade <xref:System.Lazy%601.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="746b3-179">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A>property.</span></span> <span data-ttu-id="746b3-180">Em outras palavras, o construtor do tipo encapsulado nunca será invocado novamente, mesmo em cenários com vários threads.</span><span class="sxs-lookup"><span data-stu-id="746b3-180">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="746b3-181">Portanto, o objeto <xref:System.Lazy%601> não é capaz de gerar uma exceção em um acesso e retorna um valor em um acesso subsequente.</span><span class="sxs-lookup"><span data-stu-id="746b3-181">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="746b3-182">O cache de exceção é habilitado quando você usar qualquer construtor <xref:System.Lazy%601?displayProperty=fullName> que usa um método de inicialização (parâmetro `valueFactory`); por exemplo, ele é habilitado quando você usa o construtor `Lazy(T)(Func(T))`.</span><span class="sxs-lookup"><span data-stu-id="746b3-182">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=fullName> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="746b3-183">Se o construtor também usa um valor <xref:System.Threading.LazyThreadSafetyMode> (parâmetro `mode`), especifique <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> ou <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="746b3-183">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> or <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName>.</span></span> <span data-ttu-id="746b3-184">Especificar um método de inicialização permite o cache de exceções para esses dois modos.</span><span class="sxs-lookup"><span data-stu-id="746b3-184">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="746b3-185">O método de inicialização pode ser muito simples.</span><span class="sxs-lookup"><span data-stu-id="746b3-185">The initialization method can be very simple.</span></span> <span data-ttu-id="746b3-186">Por exemplo, ele pode chamar o construtor padrão para `T`: `new Lazy<Contents>(() => new Contents(), mode)` em C# ou `New Lazy(Of Contents)(Function() New Contents())` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="746b3-186">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="746b3-187">Se você usar um construtor <xref:System.Lazy%601?displayProperty=fullName> que não especifique um método de inicialização, exceções geradas pelo construtor padrão para `T` não serão armazenadas em cache.</span><span class="sxs-lookup"><span data-stu-id="746b3-187">If you use a <xref:System.Lazy%601?displayProperty=fullName>constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="746b3-188">Para obter mais informações, consulte a enumeração <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="746b3-188">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="746b3-189">Se você criar um objeto <xref:System.Lazy%601> com o parâmetro de construtor `isThreadSafe` definido como `false` ou o parâmetro de construtor `mode` definido como <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName>, você deverá acessar o objeto <xref:System.Lazy%601> de um único thread ou fornecer sua própria sincronização.</span><span class="sxs-lookup"><span data-stu-id="746b3-189">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="746b3-190">Isso se aplica a todos os aspectos do objeto, incluindo o cache de exceção.</span><span class="sxs-lookup"><span data-stu-id="746b3-190">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="746b3-191">Conforme observado na seção anterior, objetos <xref:System.Lazy%601> criados com a especificação <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> tratam exceções de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="746b3-191">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> treat exceptions differently.</span></span> <span data-ttu-id="746b3-192">Com <xref:System.Threading.LazyThreadSafetyMode>, vários threads podem competir para inicializar a instância <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="746b3-192">With <xref:System.Threading.LazyThreadSafetyMode>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="746b3-193">Nesse caso, as exceções não são armazenadas em cache e tentativas de acessar a propriedade <xref:System.Lazy%601.Value%2A> podem continuar até que a inicialização seja bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="746b3-193">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="746b3-194">A tabela a seguir resume a maneira como os construtores <xref:System.Lazy%601> controlam o cache de exceção.</span><span class="sxs-lookup"><span data-stu-id="746b3-194">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="746b3-195">Construtor</span><span class="sxs-lookup"><span data-stu-id="746b3-195">Constructor</span></span>|<span data-ttu-id="746b3-196">Modo de acesso thread-safe</span><span class="sxs-lookup"><span data-stu-id="746b3-196">Thread safety mode</span></span>|<span data-ttu-id="746b3-197">Usa o método de inicialização</span><span class="sxs-lookup"><span data-stu-id="746b3-197">Uses initialization method</span></span>|<span data-ttu-id="746b3-198">Exceções são armazenadas em cache</span><span class="sxs-lookup"><span data-stu-id="746b3-198">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="746b3-199">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="746b3-199">Lazy(T)()</span></span>|<span data-ttu-id="746b3-200">(<xref:System.Threading.LazyThreadSafetyMode>)</span><span class="sxs-lookup"><span data-stu-id="746b3-200">(<xref:System.Threading.LazyThreadSafetyMode>)</span></span>|<span data-ttu-id="746b3-201">Não</span><span class="sxs-lookup"><span data-stu-id="746b3-201">No</span></span>|<span data-ttu-id="746b3-202">Não</span><span class="sxs-lookup"><span data-stu-id="746b3-202">No</span></span>|  
|<span data-ttu-id="746b3-203">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="746b3-203">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="746b3-204">(<xref:System.Threading.LazyThreadSafetyMode>)</span><span class="sxs-lookup"><span data-stu-id="746b3-204">(<xref:System.Threading.LazyThreadSafetyMode>)</span></span>|<span data-ttu-id="746b3-205">Sim</span><span class="sxs-lookup"><span data-stu-id="746b3-205">Yes</span></span>|<span data-ttu-id="746b3-206">Sim</span><span class="sxs-lookup"><span data-stu-id="746b3-206">Yes</span></span>|  
|<span data-ttu-id="746b3-207">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="746b3-207">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="746b3-208">`True` (<xref:System.Threading.LazyThreadSafetyMode>) ou `false` (<xref:System.Threading.LazyThreadSafetyMode>)</span><span class="sxs-lookup"><span data-stu-id="746b3-208">`True` (<xref:System.Threading.LazyThreadSafetyMode>) or `false` (<xref:System.Threading.LazyThreadSafetyMode>)</span></span>|<span data-ttu-id="746b3-209">Não</span><span class="sxs-lookup"><span data-stu-id="746b3-209">No</span></span>|<span data-ttu-id="746b3-210">Não</span><span class="sxs-lookup"><span data-stu-id="746b3-210">No</span></span>|  
|<span data-ttu-id="746b3-211">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="746b3-211">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="746b3-212">`True` (<xref:System.Threading.LazyThreadSafetyMode>) ou `false` (<xref:System.Threading.LazyThreadSafetyMode>)</span><span class="sxs-lookup"><span data-stu-id="746b3-212">`True` (<xref:System.Threading.LazyThreadSafetyMode>) or `false` (<xref:System.Threading.LazyThreadSafetyMode>)</span></span>|<span data-ttu-id="746b3-213">Sim</span><span class="sxs-lookup"><span data-stu-id="746b3-213">Yes</span></span>|<span data-ttu-id="746b3-214">Sim</span><span class="sxs-lookup"><span data-stu-id="746b3-214">Yes</span></span>|  
|<span data-ttu-id="746b3-215">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="746b3-215">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="746b3-216">Especificado pelo usuário</span><span class="sxs-lookup"><span data-stu-id="746b3-216">User-specified</span></span>|<span data-ttu-id="746b3-217">Não</span><span class="sxs-lookup"><span data-stu-id="746b3-217">No</span></span>|<span data-ttu-id="746b3-218">Não</span><span class="sxs-lookup"><span data-stu-id="746b3-218">No</span></span>|  
|<span data-ttu-id="746b3-219">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="746b3-219">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="746b3-220">Especificado pelo usuário</span><span class="sxs-lookup"><span data-stu-id="746b3-220">User-specified</span></span>|<span data-ttu-id="746b3-221">Sim</span><span class="sxs-lookup"><span data-stu-id="746b3-221">Yes</span></span>|<span data-ttu-id="746b3-222">Não se o usuário especifica <xref:System.Threading.LazyThreadSafetyMode>; caso contrário, sim.</span><span class="sxs-lookup"><span data-stu-id="746b3-222">No if user specifies <xref:System.Threading.LazyThreadSafetyMode>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="746b3-223">Implementando uma propriedade de inicialização lenta</span><span class="sxs-lookup"><span data-stu-id="746b3-223">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="746b3-224">Para implementar uma propriedade pública usando inicialização lenta, defina o campo de suporte da propriedade como um <xref:System.Lazy%601> e retorne a propriedade <xref:System.Lazy%601.Value%2A> do acessador `get` da propriedade.</span><span class="sxs-lookup"><span data-stu-id="746b3-224">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 <span data-ttu-id="746b3-225">[!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)] [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="746b3-225">[!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)] [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]</span></span>  
  
 <span data-ttu-id="746b3-226">A propriedade <xref:System.Lazy%601.Value%2A> é somente leitura; portanto, a propriedade que a expõe não tem nenhum acessador `set`.</span><span class="sxs-lookup"><span data-stu-id="746b3-226">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="746b3-227">Se você precisar de uma propriedade de leitura/gravação com o apoio de um objeto <xref:System.Lazy%601>, o acessador `set` deverá criar um novo objeto <xref:System.Lazy%601> e atribuí-lo ao repositório de backup.</span><span class="sxs-lookup"><span data-stu-id="746b3-227">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="746b3-228">O acessador `set` deve criar uma expressão lambda que retorna o novo valor da propriedade que foi passado para o acessador `set` e passar essa expressão lambda para o construtor para o novo objeto <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="746b3-228">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="746b3-229">O próximo acesso à propriedade <xref:System.Lazy%601.Value%2A> causará a inicialização do novo <xref:System.Lazy%601> e a propriedade <xref:System.Lazy%601.Value%2A> dele retornará posteriormente o novo valor atribuído à propriedade.</span><span class="sxs-lookup"><span data-stu-id="746b3-229">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="746b3-230">A razão para essa organização complicada é preservar as proteções de multithreading como internas em <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="746b3-230">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="746b3-231">Caso contrário, os acessadores de propriedade precisariam armazenar em cache o primeiro valor retornado pela propriedade <xref:System.Lazy%601.Value%2A> e modificar apenas o valor armazenado em cache e você precisa escrever seu próprio código thread-safe para fazer isso.</span><span class="sxs-lookup"><span data-stu-id="746b3-231">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="746b3-232">Devido às inicializações adicionais requeridas por uma propriedade de leitura/gravação com o suporte de um objeto <xref:System.Lazy%601>, o desempenho pode não ser aceitável.</span><span class="sxs-lookup"><span data-stu-id="746b3-232">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="746b3-233">Além disso, dependendo do cenário específico, pode ser necessária coordenação adicional para evitar condições de corrida entre setters e getters.</span><span class="sxs-lookup"><span data-stu-id="746b3-233">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="746b3-234">Inicialização lenta de local de thread</span><span class="sxs-lookup"><span data-stu-id="746b3-234">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="746b3-235">Em alguns cenários com vários threads, você talvez queira dar a cada thread seus próprios dados privados.</span><span class="sxs-lookup"><span data-stu-id="746b3-235">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="746b3-236">Esses dados são chamados de *dados locais de thread*.</span><span class="sxs-lookup"><span data-stu-id="746b3-236">Such data is called *thread-local data*.</span></span> <span data-ttu-id="746b3-237">No .NET Framework versão 3.5 e anteriores, você pode aplicar o atributo `ThreadStatic` a uma variável estática para torná-la local de thread.</span><span class="sxs-lookup"><span data-stu-id="746b3-237">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="746b3-238">No entanto, usar o atributo `ThreadStatic` pode levar a erros.</span><span class="sxs-lookup"><span data-stu-id="746b3-238">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="746b3-239">Por exemplo, até mesmo instruções de inicialização básicas farão com que a variável a seja inicializada somente no primeiro thread que a acessar, conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="746b3-239">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 <span data-ttu-id="746b3-240">[!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)] [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="746b3-240">[!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)] [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]</span></span>  
  
 <span data-ttu-id="746b3-241">Em todos os outros threads, a variável será inicializada usando seu valor padrão (zero).</span><span class="sxs-lookup"><span data-stu-id="746b3-241">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="746b3-242">Como alternativa no .NET Framework versão 4, você pode usar o tipo <xref:System.Threading.ThreadLocal%601?displayProperty=fullName> para criar uma variável local de thread baseada em instância, que é inicializada em todos os threads pelo delegado <xref:System.Action%601> que você fornece.</span><span class="sxs-lookup"><span data-stu-id="746b3-242">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=fullName> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="746b3-243">No exemplo a seguir, todos os threads que acessarem `counter` verão seu valor inicial como 1.</span><span class="sxs-lookup"><span data-stu-id="746b3-243">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 <span data-ttu-id="746b3-244">[!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)] [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="746b3-244">[!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)] [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]</span></span>  
  
 <span data-ttu-id="746b3-245"><xref:System.Threading.ThreadLocal%601> encapsula seu objeto da mesma maneira que <xref:System.Lazy%601>, com estas diferenças essenciais:</span><span class="sxs-lookup"><span data-stu-id="746b3-245"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
-   <span data-ttu-id="746b3-246">Cada thread inicializa a variável local de thread usando seus próprios dados privados que não são acessíveis de outros threads.</span><span class="sxs-lookup"><span data-stu-id="746b3-246">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
-   <span data-ttu-id="746b3-247">A propriedade <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=fullName> é de leitura-gravação e pode ser modificada qualquer número de vezes.</span><span class="sxs-lookup"><span data-stu-id="746b3-247">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=fullName> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="746b3-248">Isso pode afetar a propagação de exceção, por exemplo, uma operação `get` pode gerar uma exceção, mas a próxima pode inicializar o valor com êxito.</span><span class="sxs-lookup"><span data-stu-id="746b3-248">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
-   <span data-ttu-id="746b3-249">Se nenhum delegado de inicialização for fornecido, <xref:System.Threading.ThreadLocal%601> inicializará seu tipo encapsulado usando o valor padrão do tipo.</span><span class="sxs-lookup"><span data-stu-id="746b3-249">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="746b3-250">Nesse sentido, <xref:System.Threading.ThreadLocal%601> é consistente com o atributo <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="746b3-250">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="746b3-251">O exemplo a seguir demonstra que cada thread que acessa a instância de `ThreadLocal<int>` obtém sua própria cópia exclusiva dos dados.</span><span class="sxs-lookup"><span data-stu-id="746b3-251">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 <span data-ttu-id="746b3-252">[!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)] [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]</span><span class="sxs-lookup"><span data-stu-id="746b3-252">[!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)] [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]</span></span>  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="746b3-253">Variáveis locais de thread em Parallel.For e ForEach</span><span class="sxs-lookup"><span data-stu-id="746b3-253">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="746b3-254">Quando você usa o método <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=fullName> ou o método <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> para iterar por fontes de dados em paralelo, você pode usar as sobrecargas que têm suporte interno para dados locais de thread.</span><span class="sxs-lookup"><span data-stu-id="746b3-254">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=fullName> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="746b3-255">Esses métodos, a localidade do thread é obtida usando delegados locais para criar, acessar e limpar os dados.</span><span class="sxs-lookup"><span data-stu-id="746b3-255">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="746b3-256">Para obter mais informações, consulte [Como escrever um loop Parallel.For com variáveis locais de thread](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) e [Como escrever um loop Parallel.ForEach com variáveis locais de thread](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="746b3-256">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="746b3-257">Usando inicialização lenta para cenários de baixa sobrecarga</span><span class="sxs-lookup"><span data-stu-id="746b3-257">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="746b3-258">Em cenários em que você precisa fazer inicialização lenta de um grande número de objetos, você pode decidir que encapsular cada objeto em um <xref:System.Lazy%601> requer memória ou recursos de computação demais.</span><span class="sxs-lookup"><span data-stu-id="746b3-258">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="746b3-259">Ou então, você pode ter requisitos rigorosos para como a inicialização lenta é exposta.</span><span class="sxs-lookup"><span data-stu-id="746b3-259">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="746b3-260">Nesses casos, você pode usar os métodos `static` (`Shared` no Visual Basic) da classe <xref:System.Threading.LazyInitializer?displayProperty=fullName> para fazer inicialização lenta de cada objeto sem encapsulá-lo em uma instância de <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="746b3-260">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=fullName> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="746b3-261">No exemplo a seguir, suponha que, em vez de encapsular todo um objeto `Orders` em um objeto <xref:System.Lazy%601>, você inicializou lentamente objetos `Order` individuais somente se eles são necessários.</span><span class="sxs-lookup"><span data-stu-id="746b3-261">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 <span data-ttu-id="746b3-262">[!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)] [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]</span><span class="sxs-lookup"><span data-stu-id="746b3-262">[!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)] [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]</span></span>  
  
 <span data-ttu-id="746b3-263">Neste exemplo, observe que o procedimento de inicialização é invocado em cada iteração do loop.</span><span class="sxs-lookup"><span data-stu-id="746b3-263">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="746b3-264">Em cenários com vários threads, o primeiro thread a invocar o procedimento de inicialização é aquele cujo valor é visto por todos os threads.</span><span class="sxs-lookup"><span data-stu-id="746b3-264">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="746b3-265">Threads posteriores também chamam o procedimento de inicialização, mas os resultados não são usados.</span><span class="sxs-lookup"><span data-stu-id="746b3-265">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="746b3-266">Se esse tipo de condição de corrida potencial não é aceitável, use a sobrecarga de <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=fullName> que usa um argumento booliano e um objeto de sincronização.</span><span class="sxs-lookup"><span data-stu-id="746b3-266">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=fullName> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="746b3-267">Consulte também</span><span class="sxs-lookup"><span data-stu-id="746b3-267">See Also</span></span>  
 <span data-ttu-id="746b3-268">[Noções básicas de threading gerenciado](../../../docs/standard/threading/managed-threading-basics.md) </span><span class="sxs-lookup"><span data-stu-id="746b3-268">[Managed Threading Basics](../../../docs/standard/threading/managed-threading-basics.md) </span></span>  
 <span data-ttu-id="746b3-269">[Threads e threading](../../../docs/standard/threading/threads-and-threading.md) </span><span class="sxs-lookup"><span data-stu-id="746b3-269">[Threads and Threading](../../../docs/standard/threading/threads-and-threading.md) </span></span>  
 <span data-ttu-id="746b3-270">[TPL (Biblioteca de Paralelismo de Tarefas)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md) </span><span class="sxs-lookup"><span data-stu-id="746b3-270">[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md) </span></span>  
 [<span data-ttu-id="746b3-271">Como executar a inicialização lenta de objetos</span><span class="sxs-lookup"><span data-stu-id="746b3-271">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)

