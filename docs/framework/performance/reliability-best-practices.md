---
title: Práticas recomendadas de confiabilidade
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 280e73ccd3d8a90b2f2b3a485d3f4240b434359b
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54714848"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="4752a-102">Práticas recomendadas de confiabilidade</span><span class="sxs-lookup"><span data-stu-id="4752a-102">Reliability Best Practices</span></span>
<span data-ttu-id="4752a-103">As seguintes regras de confiabilidade estão orientadas ao SQL Server. No entanto, eles também se aplicam a qualquer aplicativo para servidores baseado em host.</span><span class="sxs-lookup"><span data-stu-id="4752a-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="4752a-104">É extremamente importante que os servidores como o SQL Server não tenham perda de recursos e não fiquem inoperantes.</span><span class="sxs-lookup"><span data-stu-id="4752a-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="4752a-105">No entanto, isso não pode ser feito para escrever código de recuo para cada método que altera o estado de um objeto.</span><span class="sxs-lookup"><span data-stu-id="4752a-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="4752a-106">A meta é não gravar código gerenciado 100 por cento confiável que se recuperará de erros em todos os locais com o código de recuo.</span><span class="sxs-lookup"><span data-stu-id="4752a-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="4752a-107">Isso seria uma tarefa difícil, com pouca probabilidade de êxito.</span><span class="sxs-lookup"><span data-stu-id="4752a-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="4752a-108">O CLR (Common Language Runtime) não pode fornecer com facilidade garantias suficientemente fortes para que o código gerenciado possa tornar a tarefa de escrever código perfeito viável.</span><span class="sxs-lookup"><span data-stu-id="4752a-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="4752a-109">Observe que, diferentemente do ASP.NET, o SQL Server usa somente um processo que não pode ser reciclado sem a interrupção de um banco de dados por um período de tempo inaceitavelmente longo.</span><span class="sxs-lookup"><span data-stu-id="4752a-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>  
  
 <span data-ttu-id="4752a-110">Com essas garantias mais fracas e em execução em um único processo, a confiabilidade é baseada no encerramento de threads ou na reciclagem de domínios do aplicativo quando necessário, além tomar precauções para garantir que os recursos do sistema operacional, tais como memória ou identificadores, não vazem.</span><span class="sxs-lookup"><span data-stu-id="4752a-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="4752a-111">Mesmo com essa restrição de confiabilidade mais simples, ainda há um requisito de confiabilidade significativo:</span><span class="sxs-lookup"><span data-stu-id="4752a-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>  
  
-   <span data-ttu-id="4752a-112">Nunca perder recursos do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-112">Never leak operating system resources.</span></span>  
  
-   <span data-ttu-id="4752a-113">Identificar todos os bloqueios gerenciados em todos os formulários para o CLR.</span><span class="sxs-lookup"><span data-stu-id="4752a-113">Identify all managed locks in all forms to the CLR.</span></span>  
  
-   <span data-ttu-id="4752a-114">Nunca interromper o estado compartilhado entre domínios do aplicativo, permitindo que a reciclagem <xref:System.AppDomain> funcionasse sem problemas.</span><span class="sxs-lookup"><span data-stu-id="4752a-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>  
  
 <span data-ttu-id="4752a-115">Embora seja teoricamente possível escrever código gerenciado para tratar exceções <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> e <xref:System.OutOfMemoryException>, esperar que os desenvolvedores escrevam um código tão robusto em todo um aplicativo é pouco razoável.</span><span class="sxs-lookup"><span data-stu-id="4752a-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="4752a-116">Por esse motivo, as exceções fora de banda resultam no encerramento do thread em execução; e se o thread encerrado estava editando o estado compartilhado, o que pode ser determinado dependendo de o thread manter ou não um bloqueio, o <xref:System.AppDomain> é descarregado.</span><span class="sxs-lookup"><span data-stu-id="4752a-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="4752a-117">Quando um método que estiver editando o estado compartilhado for encerrado, o estado será corrompido porque não é possível gravar código de recup confiável para atualizações para estado compartilhado.</span><span class="sxs-lookup"><span data-stu-id="4752a-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>  
  
 <span data-ttu-id="4752a-118">No .NET Framework versão 2.0, o único host que exige confiabilidade é o SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="4752a-119">Se o assembly será executado no SQL Server, você deverá fazer o trabalho de confiabilidade para todas as partes do assembly, mesmo se houver recursos específicos que ficarão desabilitados quando em execução no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="4752a-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="4752a-120">Isso é necessário porque o mecanismo de análise de código examina o código no nível de assembly e não pode diferenciar o código desabilitado.</span><span class="sxs-lookup"><span data-stu-id="4752a-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="4752a-121">Outra consideração sobre a programação do SQL Server é que o SQL Server executa tudo em um processo e a reciclagem de <xref:System.AppDomain> é usada para limpar todos os recursos como memória e identificadores do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>  
  
 <span data-ttu-id="4752a-122">Você não pode depender de finalizadores ou destruidores ou blocos `try/finally` para código de recuo.</span><span class="sxs-lookup"><span data-stu-id="4752a-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="4752a-123">Eles podem ser interrompidos ou não chamados.</span><span class="sxs-lookup"><span data-stu-id="4752a-123">They might be interrupted or not called.</span></span>  
  
 <span data-ttu-id="4752a-124">Exceções assíncronas podem ser geradas em locais inesperados, possivelmente em toda instrução do computador: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> e <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="4752a-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>  
  
 <span data-ttu-id="4752a-125">Threads gerenciados não são necessariamente threads Win32 em SQL; eles podem ser fibras.</span><span class="sxs-lookup"><span data-stu-id="4752a-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>  
  
 <span data-ttu-id="4752a-126">É muito difícil alterar um estado compartilhado mutável entre domínios do aplicativo ou em todo o processo com segurança e isso deve ser evitado sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="4752a-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>  
  
 <span data-ttu-id="4752a-127">Condições de falta de memória não são raras no SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-127">Out-of-memory conditions are not rare in SQL Server.</span></span>  
  
 <span data-ttu-id="4752a-128">Se bibliotecas hospedadas no SQL Server não atualizarem corretamente o estado compartilhado, há uma grande probabilidade de que o código não se recuperará até o banco de dados ter sido reiniciado.</span><span class="sxs-lookup"><span data-stu-id="4752a-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="4752a-129">Além disso, em alguns casos extremos, é possível que isso possa causar falha no processo do SQL Server, fazendo com que o banco de dados seja reinicializado.</span><span class="sxs-lookup"><span data-stu-id="4752a-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="4752a-130">Reinicializar o banco de dados pode deixar um site da Web inoperante ou afetar as operações da empresa, afetando a disponibilidade.</span><span class="sxs-lookup"><span data-stu-id="4752a-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="4752a-131">Uma perda lenta de recursos de sistema operacional como memória ou identificadores pode fazer com que o servidor eventualmente falhe ao alocar identificadores sem possibilidade de recuperação; também é possível que o desempenho do servidor se degrade lentamente e reduza a disponibilidade de aplicativos do cliente.</span><span class="sxs-lookup"><span data-stu-id="4752a-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="4752a-132">É claro que queremos evitar esses cenários.</span><span class="sxs-lookup"><span data-stu-id="4752a-132">Clearly we want to avoid these scenarios.</span></span>  
  
## <a name="best-practice-rules"></a><span data-ttu-id="4752a-133">Regras de prática recomendada</span><span class="sxs-lookup"><span data-stu-id="4752a-133">Best Practice Rules</span></span>  
 <span data-ttu-id="4752a-134">A introdução se concentrou no que a revisão de código para o código gerenciado que é executado no servidor precisaria capturar para aumentar a estabilidade e a confiabilidade do framework.</span><span class="sxs-lookup"><span data-stu-id="4752a-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="4752a-135">Todas essas verificações são uma boa prática em geral e uma necessidade absoluta no servidor.</span><span class="sxs-lookup"><span data-stu-id="4752a-135">All these checks are good practice in general and an absolute must on the server.</span></span>  
  
 <span data-ttu-id="4752a-136">No caso de uma restrição de recurso ou um deadlock, o SQL Server anulará um thread ou subdividirá um <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="4752a-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="4752a-137">Quando isso acontece, o único elemento que certamente está em execução é o código de recuo em uma CER (região de execução restrita).</span><span class="sxs-lookup"><span data-stu-id="4752a-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>  
  
### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="4752a-138">Usar SafeHandle para evitar perdas de recursos</span><span class="sxs-lookup"><span data-stu-id="4752a-138">Use SafeHandle to Avoid Resource Leaks</span></span>  
 <span data-ttu-id="4752a-139">No caso de um descarregamento de <xref:System.AppDomain>, você não pode depender de blocos `finally` ou finalizadores serem executados, portanto, é importante abstrair todo acesso a recursos do sistema operacional por meio da classe <xref:System.Runtime.InteropServices.SafeHandle> em vez de <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> ou classes semelhantes.</span><span class="sxs-lookup"><span data-stu-id="4752a-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="4752a-140">Isso permite que o CLR acompanhe e feche os identificadores que você usa até mesmo no caso de desativação de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="4752a-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="4752a-141"><xref:System.Runtime.InteropServices.SafeHandle> estará usando um finalizador crítico que o CLR sempre executará.</span><span class="sxs-lookup"><span data-stu-id="4752a-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>  
  
 <span data-ttu-id="4752a-142">O identificador de sistema operacional é armazenado no SafeHandle desde o momento em que ele é criado até o momento em que ele é liberado.</span><span class="sxs-lookup"><span data-stu-id="4752a-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="4752a-143">Não há período durante o qual um <xref:System.Threading.ThreadAbortException> pode ocorrer para que haja perda de um identificador.</span><span class="sxs-lookup"><span data-stu-id="4752a-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="4752a-144">Além disso, uma invocação de plataforma faz a contagem de referências do identificador, o que permite um acompanhamento preciso do tempo de vida dele e evita um problema de segurança com uma condição de corrida entre `Dispose` e um método que está usando atualmente o identificador.</span><span class="sxs-lookup"><span data-stu-id="4752a-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>  
  
 <span data-ttu-id="4752a-145">A maioria das classes que atualmente têm um finalizador apenas para limpar um identificador de sistema operacional não precisarão mais do finalizador.</span><span class="sxs-lookup"><span data-stu-id="4752a-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="4752a-146">Em vez disso, o finalizador estará na classe derivada <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="4752a-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>  
  
 <span data-ttu-id="4752a-147">Observe que <xref:System.Runtime.InteropServices.SafeHandle> não é substituição para <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4752a-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="4752a-148">Ainda há possibilidade de contenção de recursos e vantagens de desempenho para descartar explicitamente os recursos de sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="4752a-149">Observe que apenas blocos `finally` que descartam explicitamente os recursos podem não ser executados até a conclusão.</span><span class="sxs-lookup"><span data-stu-id="4752a-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>  
  
 <span data-ttu-id="4752a-150"><xref:System.Runtime.InteropServices.SafeHandle> permite que você implemente seu próprio método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> que executa o trabalho para liberar o identificador, tal como passar o estado para uma rotina de liberação de identificador de sistema operacional ou liberar um conjunto de identificadores em um loop.</span><span class="sxs-lookup"><span data-stu-id="4752a-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="4752a-151">O CLR assegura que esse método seja executado.</span><span class="sxs-lookup"><span data-stu-id="4752a-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="4752a-152">É responsabilidade do autor da implementação de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> assegurar que o identificador seja liberado em todas as circunstâncias.</span><span class="sxs-lookup"><span data-stu-id="4752a-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="4752a-153">Falha em fazê-lo causará perda do identificador, o que geralmente resultará em perda de recursos nativos associados com o identificador.</span><span class="sxs-lookup"><span data-stu-id="4752a-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="4752a-154">Portanto, é essencial estruturar classes derivadas <xref:System.Runtime.InteropServices.SafeHandle> de modo que a implementação de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> não exija a alocação de todos os recursos que podem não estar disponíveis em tempo de invocação.</span><span class="sxs-lookup"><span data-stu-id="4752a-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="4752a-155">Observe que é permitido chamar os métodos que podem falhar dentro da implementação do <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, contanto que seu código possa lidar com tais falhas e concluir o contrato para liberar o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="4752a-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="4752a-156">Para fins de depuração, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> tem um valor retornado <xref:System.Boolean> que pode ser definido como `false` se é encontrado um erro catastrófico que impede a liberação do recurso.</span><span class="sxs-lookup"><span data-stu-id="4752a-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="4752a-157">Isso ativará o MDA [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md), se habilitado, para ajudar a identificar o problema.</span><span class="sxs-lookup"><span data-stu-id="4752a-157">Doing so will activate the [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="4752a-158">Ele não afeta o tempo de execução de nenhuma outra forma; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> não será chamado novamente para o mesmo recurso e, consequentemente, o identificador será perdido.</span><span class="sxs-lookup"><span data-stu-id="4752a-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>  
  
 <span data-ttu-id="4752a-159"><xref:System.Runtime.InteropServices.SafeHandle> não é apropriado em determinados contextos.</span><span class="sxs-lookup"><span data-stu-id="4752a-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="4752a-160">Já que o método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> pode ser executado em um thread do finalizador <xref:System.GC>, quaisquer identificadores que seja necessário liberar em um determinado thread não devem ser encapsulados em um <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="4752a-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
 <span data-ttu-id="4752a-161">RCWs (Runtime Callable Wrappers) podem ser limpos pelo CLR sem código adicional.</span><span class="sxs-lookup"><span data-stu-id="4752a-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="4752a-162">Para o código que usa a invocação de plataforma e trata um objeto COM como um `IUnknown*` ou um <xref:System.IntPtr>, o código deve ser reescrito para usar um RCW.</span><span class="sxs-lookup"><span data-stu-id="4752a-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="4752a-163"><xref:System.Runtime.InteropServices.SafeHandle> pode não ser adequado para esse cenário devido à possibilidade de um método de liberação não gerenciado retornar a chamada em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4752a-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-164">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-164">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-165">Use <xref:System.Runtime.InteropServices.SafeHandle> para encapsular recursos do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="4752a-166">Não use <xref:System.Runtime.InteropServices.HandleRef> ou campos do tipo <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="4752a-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>  
  
### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="4752a-167">Verifique se os finalizadores não precisam executar para impedir a perda de recursos do sistema operacional</span><span class="sxs-lookup"><span data-stu-id="4752a-167">Ensure Finalizers Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="4752a-168">Examine seus finalizadores cuidadosamente para assegurar que, mesmo se eles não forem executados, um recurso crítico do sistema operacional não será perdido.</span><span class="sxs-lookup"><span data-stu-id="4752a-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="4752a-169">Ao contrário de um descarregamento de <xref:System.AppDomain> normal quando o aplicativo está em execução em um estado estável ou quando um servidor como o SQL Server é desligado, objetos não são finalizados durante um descarregamento de <xref:System.AppDomain> abrupto.</span><span class="sxs-lookup"><span data-stu-id="4752a-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="4752a-170">Verifique se recursos não são perdidos no caso de um descarregamento abrupto, já que a correção de um aplicativo não pode ser garantida, mas a integridade do servidor deve ser mantida evitando-se a perda de recursos.</span><span class="sxs-lookup"><span data-stu-id="4752a-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="4752a-171">Use <xref:System.Runtime.InteropServices.SafeHandle> para liberar eventuais recursos do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>  
  
### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="4752a-172">Verifique se as cláusulas finally não precisam executar para impedir a perda de recursos do sistema operacional</span><span class="sxs-lookup"><span data-stu-id="4752a-172">Ensure That finally Clauses Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="4752a-173">Não há garantia de que cláusulas `finally` sejam executadas fora de CERs, exigindo que os desenvolvedores de biblioteca não confiem no código dentro de um bloco `finally` para liberar recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="4752a-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="4752a-174">Usar <xref:System.Runtime.InteropServices.SafeHandle> é a solução recomendada.</span><span class="sxs-lookup"><span data-stu-id="4752a-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-175">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-175">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-176">Use <xref:System.Runtime.InteropServices.SafeHandle> para limpar os recursos do sistema operacional, em vez de `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="4752a-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="4752a-177">Não use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> para encapsular recursos.</span><span class="sxs-lookup"><span data-stu-id="4752a-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="4752a-178">Se a cláusula finally precisa ser executada, coloque-a em uma CER.</span><span class="sxs-lookup"><span data-stu-id="4752a-178">If the finally clause must run, place it in a CER.</span></span>  
  
### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="4752a-179">Todos os bloqueios devem passar pelo código de bloqueio gerenciado existente</span><span class="sxs-lookup"><span data-stu-id="4752a-179">All Locks Should Go Through Existing Managed Locking Code</span></span>  
 <span data-ttu-id="4752a-180">O CLR deve saber quando o código está em um bloqueio para que ele saiba subdividir o <xref:System.AppDomain> em vez de apenas anular o thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="4752a-181">Anular o thread pode ser perigoso, já que os dados operados pelo thread podem ser deixados em um estado inconsistente.</span><span class="sxs-lookup"><span data-stu-id="4752a-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="4752a-182">Portanto, todo o <xref:System.AppDomain> deve ser reciclado.</span><span class="sxs-lookup"><span data-stu-id="4752a-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="4752a-183">As consequências de falhar em identificar um bloqueio podem ser deadlocks ou resultados incorretos.</span><span class="sxs-lookup"><span data-stu-id="4752a-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="4752a-184">Use os métodos <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> para identificar regiões de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="4752a-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="4752a-185">Eles são métodos estáticos na classe <xref:System.Threading.Thread> que se aplicam somente ao thread atual, ajudando a impedir que um thread edite a contagem de bloqueio de outro thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>  
  
 <span data-ttu-id="4752a-186"><xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> têm essa notificação de CLR como interna, portanto, o uso deles é recomendado, bem como o uso da [instrução lock](~/docs/csharp/language-reference/keywords/lock-statement.md), a qual usa esses métodos.</span><span class="sxs-lookup"><span data-stu-id="4752a-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>  
  
 <span data-ttu-id="4752a-187">Outros mecanismos de bloqueio como bloqueios de rotação e <xref:System.Threading.AutoResetEvent> devem chamar esses métodos para notificar o CLR que uma seção crítica está sendo inserida.</span><span class="sxs-lookup"><span data-stu-id="4752a-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="4752a-188">Esses métodos não usam nenhum bloqueio; eles informam o CLR que o código está em execução em uma seção crítica e anular o thread poderia deixar o estado compartilhado inconsistente.</span><span class="sxs-lookup"><span data-stu-id="4752a-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="4752a-189">Se você definiu seu próprio tipo de bloqueio, por exemplo, uma classe <xref:System.Threading.ReaderWriterLock> personalizada, use esses métodos de contagem de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="4752a-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-190">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-190">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-191">Marcar e identificar todos os bloqueios usando <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="4752a-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="4752a-192">Não use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> e <xref:System.Threading.Interlocked.Decrement%2A> em um loop.</span><span class="sxs-lookup"><span data-stu-id="4752a-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="4752a-193">Não faça uma plataforma de invocação das variantes Win32 desses métodos.</span><span class="sxs-lookup"><span data-stu-id="4752a-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="4752a-194">Não use <xref:System.Threading.Thread.Sleep%2A> em loop.</span><span class="sxs-lookup"><span data-stu-id="4752a-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="4752a-195">Não use campos voláteis.</span><span class="sxs-lookup"><span data-stu-id="4752a-195">Do not use volatile fields.</span></span>  
  
### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="4752a-196">O código de limpeza deve estar em um bloco finally ou catch e não deve seguir um catch</span><span class="sxs-lookup"><span data-stu-id="4752a-196">Cleanup Code Must Be in a finally or a catch Block, Not Following a catch</span></span>  
 <span data-ttu-id="4752a-197">Código de limpeza nunca deve seguir um bloco `catch`; ele deve estar em um `finally` ou no bloco `catch` em si.</span><span class="sxs-lookup"><span data-stu-id="4752a-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span>  <span data-ttu-id="4752a-198">Isso deve ser uma prática recomendada normal.</span><span class="sxs-lookup"><span data-stu-id="4752a-198">This should be a normal good practice.</span></span>  <span data-ttu-id="4752a-199">Um bloco `finally` é geralmente preferível porque ele executa o mesmo código de erro quando uma exceção é gerada e quando o fim do bloco `try` é normalmente encontrado.</span><span class="sxs-lookup"><span data-stu-id="4752a-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="4752a-200">No caso de uma exceção inesperada ser gerada, por exemplo uma <xref:System.Threading.ThreadAbortException>, o código de limpeza não será executado.</span><span class="sxs-lookup"><span data-stu-id="4752a-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="4752a-201">Quaisquer recursos não gerenciados que você limparia em um `finally` devem idealmente estar encapsulados em um <xref:System.Runtime.InteropServices.SafeHandle> para evitar perdas.</span><span class="sxs-lookup"><span data-stu-id="4752a-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="4752a-202">Observe que a palavra-chave `using` do C# pode ser usada com eficiência para descartar objetos, incluindo identificadores.</span><span class="sxs-lookup"><span data-stu-id="4752a-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>  
  
 <span data-ttu-id="4752a-203">Embora a reciclagem de <xref:System.AppDomain> possa limpar recursos no thread do finalizador, ainda é importante colocar o código de limpeza no local correto.</span><span class="sxs-lookup"><span data-stu-id="4752a-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span>  <span data-ttu-id="4752a-204">Observe que, se um thread recebe uma exceção assíncrona sem manter um bloqueio, o CLR tenta encerrar o thread sem a necessidade de reciclar o <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="4752a-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="4752a-205">Assegurar que recursos sejam limpos cedo em vez de tarde ajuda por meio da disponibilização de mais recursos e do melhor gerenciamento do tempo de vida.</span><span class="sxs-lookup"><span data-stu-id="4752a-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span>  <span data-ttu-id="4752a-206">Se você não fechar explicitamente um identificador para um arquivo em algum caminho de código de erro, aguarde que o finalizador <xref:System.Runtime.InteropServices.SafeHandle> o limpe; na próxima vez que seu código executar, ele pode poderá falhar ao tentar acessar exatamente o mesmo arquivo, se o finalizador ainda não tiver executado.</span><span class="sxs-lookup"><span data-stu-id="4752a-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="4752a-207">Por esse motivo, garantir que o código de limpeza existe e está funcionando corretamente ajudará a recuperar-se de falhas de modo mais claro e rápido, embora isso não seja estritamente necessário.</span><span class="sxs-lookup"><span data-stu-id="4752a-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-208">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-208">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-209">O código de limpeza após `catch` deve estar em um bloco `finally`.</span><span class="sxs-lookup"><span data-stu-id="4752a-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="4752a-210">Faça chamadas para descartar em um bloco finally.</span><span class="sxs-lookup"><span data-stu-id="4752a-210">Place calls to dispose in a finally block.</span></span>  <span data-ttu-id="4752a-211">Blocos `catch` devem terminar com um lançamento ou relançamento.</span><span class="sxs-lookup"><span data-stu-id="4752a-211">`catch` blocks should end in a throw or rethrow.</span></span>  <span data-ttu-id="4752a-212">Embora haja exceções, tais como o código detectar se é possível estabelecer uma conexão de rede em que você pode obter uma de um grande número de exceções, qualquer código que requer a captura de um número de exceções em circunstâncias normais deve fornecer uma indicação de que o código deve ser testado para ver se terá êxito.</span><span class="sxs-lookup"><span data-stu-id="4752a-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>  
  
### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="4752a-213">Um estado compartilhado mutável de todo o processo entre domínios do aplicativo deve ser eliminado ou usar uma região de execução restrita</span><span class="sxs-lookup"><span data-stu-id="4752a-213">Process-Wide Mutable Shared State Between Application Domains Should Be Eliminated or Use a Constrained Execution Region</span></span>  
 <span data-ttu-id="4752a-214">Conforme descrito na introdução, pode ser muito difícil escrever código gerenciado que monitore o estado compartilhado em todo o processo entre domínios de aplicativo de maneira confiável.</span><span class="sxs-lookup"><span data-stu-id="4752a-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="4752a-215">Um estado compartilhado por todo o processo é qualquer tipo de estrutura de dados compartilhada entre domínios do aplicativo, podendo ser em código Win32, dentro do CLR ou então em código gerenciado usando comunicação remota.</span><span class="sxs-lookup"><span data-stu-id="4752a-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="4752a-216">Qualquer estado compartilhado mutável é muito difícil de escrever corretamente em código gerenciado e qualquer estado compartilhado estático pode ser feito somente com muito cuidado.</span><span class="sxs-lookup"><span data-stu-id="4752a-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="4752a-217">Se você tiver um estado compartilhado por todo o computador, encontre alguma forma de eliminá-lo ou proteger o estado compartilhado usando uma CER (região de execução restrita).</span><span class="sxs-lookup"><span data-stu-id="4752a-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="4752a-218">Observe que qualquer biblioteca com estado compartilhado que não é identificada e corrigida pode causar falha em um host como o SQL Server, que requer um descarregamento de <xref:System.AppDomain> limpo.</span><span class="sxs-lookup"><span data-stu-id="4752a-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>  
  
 <span data-ttu-id="4752a-219">Se o código usa um objeto COM, evite compartilhar esse objeto COM entre domínios do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4752a-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>  
  
### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="4752a-220">Os bloqueios não funcionam em todo o processo ou entre domínios do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4752a-220">Locks Do Not Work Process-Wide or Between Application Domains.</span></span>  
 <span data-ttu-id="4752a-221">No passado, <xref:System.Threading.Monitor.Enter%2A> e a [instrução lock](~/docs/csharp/language-reference/keywords/lock-statement.md) foram usados para criar bloqueios de processo global.</span><span class="sxs-lookup"><span data-stu-id="4752a-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="4752a-222">Por exemplo, isso ocorre ao bloquear classes ágeis de <xref:System.AppDomain>, tais como instâncias de <xref:System.Type> de assemblies não compartilhados, objetos de <xref:System.Threading.Thread>, cadeias de caracteres internas e algumas cadeias de caracteres compartilhadas entre domínios do aplicativo usando comunicação remota.</span><span class="sxs-lookup"><span data-stu-id="4752a-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="4752a-223">Esses bloqueios não são mais para todo o processo.</span><span class="sxs-lookup"><span data-stu-id="4752a-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="4752a-224">Para identificar a presença de um bloqueio de entre domínios do aplicativo em todo o processo, determine se o código dentro do bloqueio usa qualquer recurso externo persistente como um arquivo em disco ou, possivelmente, um banco de dados.</span><span class="sxs-lookup"><span data-stu-id="4752a-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>  
  
 <span data-ttu-id="4752a-225">Observe que usar um bloqueio dentro de um <xref:System.AppDomain> pode causar problemas se o código protegido usa um recurso externo, porque esse código pode ser executado simultaneamente em vários domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4752a-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="4752a-226">Isso pode ser um problema ao gravar para um arquivo de log ou associar a um soquete para todo o processo.</span><span class="sxs-lookup"><span data-stu-id="4752a-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="4752a-227">Essas alterações significam que, com exceção de usar uma instância nomeada <xref:System.Threading.Mutex> ou <xref:System.Threading.Semaphore>, não há modo fácil de se obter um bloqueio global no processo usando código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4752a-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="4752a-228">Crie código que não executa simultaneamente em dois domínios do aplicativo ou use as classes <xref:System.Threading.Mutex> ou <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="4752a-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="4752a-229">Se o código existente não pode ser alterado, não use um mutex nomeado do Win32 para alcançar essa sincronização, porque a execução em modo fibra significa que você não pode assegurar que um mutex será adquirido e liberado pelo mesmo thread do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="4752a-230">Você deve usar a classe <xref:System.Threading.Mutex> gerenciada ou um <xref:System.Threading.ManualResetEvent> ou <xref:System.Threading.AutoResetEvent> nomeado ou ainda um <xref:System.Threading.Semaphore> para sincronizar o bloqueio de código de maneira que o CLR reconheça, em vez de sincronizar o bloqueio usando código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4752a-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>  
  
#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="4752a-231">Evite lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="4752a-231">Avoid lock(typeof(MyType))</span></span>  
 <span data-ttu-id="4752a-232">Objetos <xref:System.Type> públicos e privados em assemblies compartilhados com apenas uma cópia do código compartilhado entre todos os domínios do aplicativo também apresentam problemas.</span><span class="sxs-lookup"><span data-stu-id="4752a-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="4752a-233">Para assemblies compartilhados, há apenas uma instância de um <xref:System.Type> por processo, o que significa que vários domínios do aplicativo compartilham exatamente a mesma instância de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4752a-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="4752a-234">A execução de um bloqueio em uma instância de <xref:System.Type> usa um bloqueio que afeta todo o processo, não apenas o <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="4752a-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="4752a-235">Se um <xref:System.AppDomain> usar um bloqueio em um objeto <xref:System.Type> e depois esse thread for anulado repentinamente, ele não liberará o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="4752a-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="4752a-236">Esse bloqueio poderá depois pode causar deadlock em outros domínios do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="4752a-236">This lock then may cause other application domains to deadlock.</span></span>  
  
 <span data-ttu-id="4752a-237">Uma boa maneira de aplicar bloqueios em métodos estáticos envolve a adição de um objeto de sincronização interno estático ao código.</span><span class="sxs-lookup"><span data-stu-id="4752a-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="4752a-238">Isso pode ser inicializado no construtor da classe se houver um, mas caso contrário, ele pode ser inicializado assim:</span><span class="sxs-lookup"><span data-stu-id="4752a-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>  
  
```  
private static Object s_InternalSyncObject;  
private static Object InternalSyncObject   
{  
    get   
    {  
        if (s_InternalSyncObject == null)   
        {  
            Object o = new Object();  
            Interlocked.CompareExchange(  
                ref s_InternalSyncObject, o, null);  
        }  
        return s_InternalSyncObject;  
    }  
}  
```  
  
 <span data-ttu-id="4752a-239">Então, ao usar um bloqueio, use a propriedade `InternalSyncObject` para obter um objeto no qual o bloqueio será usado.</span><span class="sxs-lookup"><span data-stu-id="4752a-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="4752a-240">Você não precisa usar a propriedade se você inicializou o objeto de sincronização interna no seu construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="4752a-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="4752a-241">O código de inicialização de bloqueio de verificação dupla deve ser semelhante a este exemplo:</span><span class="sxs-lookup"><span data-stu-id="4752a-241">The double checking lock initialization code should look like this example:</span></span>  
  
```  
public static MyClass SingletonProperty   
{  
    get   
    {  
        if (s_SingletonProperty == null)   
        {  
            lock(InternalSyncObject)   
            {  
                // Do not use lock(typeof(MyClass))   
                if (s_SingletonProperty == null)   
                {  
                    MyClass tmp = new MyClass(…);     
                    // Do all initialization before publishing  
                    s_SingletonProperty = tmp;  
                }  
            }  
        }  
        return s_SingletonProperty;  
    }  
}  
```  
  
#### <a name="a-note-about-lockthis"></a><span data-ttu-id="4752a-242">Uma observação sobre Lock(this)</span><span class="sxs-lookup"><span data-stu-id="4752a-242">A Note About Lock(this)</span></span>  
 <span data-ttu-id="4752a-243">É geralmente aceitável usar um bloqueio em um objeto individual que é acessível publicamente.</span><span class="sxs-lookup"><span data-stu-id="4752a-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="4752a-244">No entanto, se o objeto é um objeto singleton que pode causar deadlock em um subsistema inteiro, considere usar o padrão de design acima também.</span><span class="sxs-lookup"><span data-stu-id="4752a-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="4752a-245">Por exemplo, um bloqueio em um objeto <xref:System.Security.SecurityManager> pode causar um deadlock dentro de <xref:System.AppDomain>, tornando todo o <xref:System.AppDomain> inutilizável.</span><span class="sxs-lookup"><span data-stu-id="4752a-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="4752a-246">É recomendável não usar um bloqueio em um objeto publicamente acessível desse tipo.</span><span class="sxs-lookup"><span data-stu-id="4752a-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="4752a-247">No entanto, um bloqueio em uma matriz ou coleção individual geralmente não deve representar um problema.</span><span class="sxs-lookup"><span data-stu-id="4752a-247">However a lock on an individual collection or array should generally not present a problem.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-248">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-248">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-249">Não use bloqueios em tipos que podem ser usados em domínios do aplicativo ou não têm um forte senso de identidade.</span><span class="sxs-lookup"><span data-stu-id="4752a-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="4752a-250">Não chame <xref:System.Threading.Monitor.Enter%2A> em um <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> ou qualquer objeto que derive de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="4752a-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>  
  
### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="4752a-251">Remover chamadas GC.KeepAlive</span><span class="sxs-lookup"><span data-stu-id="4752a-251">Remove GC.KeepAlive Calls</span></span>  
 <span data-ttu-id="4752a-252">Uma quantidade significativa de código existente não usa <xref:System.GC.KeepAlive%2A> quando deveria ou então usa quando ele não é adequado.</span><span class="sxs-lookup"><span data-stu-id="4752a-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="4752a-253">Depois de converter em <xref:System.Runtime.InteropServices.SafeHandle>, as classes não precisam chamar <xref:System.GC.KeepAlive%2A>, supondo que elas não têm um finalizador, mas dependem de <xref:System.Runtime.InteropServices.SafeHandle> para finalizar os identificadores do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="4752a-254">Embora o custo de desempenho de retenção de uma chamada para <xref:System.GC.KeepAlive%2A> possa ser insignificante, a percepção de que uma chamada para <xref:System.GC.KeepAlive%2A> é necessária ou suficiente para resolver um problema de tempo de vida que talvez não exista mais torna mais difícil manter o código.</span><span class="sxs-lookup"><span data-stu-id="4752a-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="4752a-255">No entanto, ao usar os RCWs (Runtime Callable Wrappers) do CLR de interoperabilidade COM, <xref:System.GC.KeepAlive%2A> ainda é exigido pelo código.</span><span class="sxs-lookup"><span data-stu-id="4752a-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-256">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-256">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-257">Remova <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="4752a-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>  
  
### <a name="use-the-host-protection-attribute"></a><span data-ttu-id="4752a-258">Usar o atributo de proteção ao host</span><span class="sxs-lookup"><span data-stu-id="4752a-258">Use the Host Protection Attribute</span></span>  
 <span data-ttu-id="4752a-259">O <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) fornece o uso de ações de segurança declarativa para determinar os requisitos de proteção de host, permitindo que o host impeça até mesmo código totalmente confiável de chamar determinados métodos que não são apropriados para o host especificado, tais como <xref:System.Environment.Exit%2A> ou <xref:System.Windows.Forms.MessageBox.Show%2A> para o SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>  
  
 <span data-ttu-id="4752a-260">O HPA afeta somente em aplicativos não gerenciados que hospedam o Common Language Runtime e implementam a proteção de host, como o SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="4752a-261">Quando aplicada, os resultados de ação de segurança na criação de uma demanda de link baseada nos recursos de host que a classe ou método expõe.</span><span class="sxs-lookup"><span data-stu-id="4752a-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="4752a-262">Se o código for executado em um aplicativo cliente ou em um servidor que não seja protegido pelo host, o atributo "evapora"; ele não é detectado e, portanto, não é aplicado.</span><span class="sxs-lookup"><span data-stu-id="4752a-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4752a-263">O objetivo desse atributo é impor diretrizes de modelo de programação específicas do host, mas não o comportamento de segurança.</span><span class="sxs-lookup"><span data-stu-id="4752a-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="4752a-264">Embora uma demanda de link seja usada para verificar a conformidade com requisitos de modelo de programação, o <xref:System.Security.Permissions.HostProtectionAttribute> não é uma permissão de segurança.</span><span class="sxs-lookup"><span data-stu-id="4752a-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>  
  
 <span data-ttu-id="4752a-265">Se o host não tem requisitos de modelo de programação, as demandas de link não ocorrem.</span><span class="sxs-lookup"><span data-stu-id="4752a-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>  
  
 <span data-ttu-id="4752a-266">Esse atributo identifica o seguinte:</span><span class="sxs-lookup"><span data-stu-id="4752a-266">This attribute identifies the following:</span></span>  
  
-   <span data-ttu-id="4752a-267">Métodos ou classes que não se ajustam ao modelo de programação do host, mas são benignas.</span><span class="sxs-lookup"><span data-stu-id="4752a-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>  
  
-   <span data-ttu-id="4752a-268">Métodos ou classes que não se ajustam ao modelo de programação de host e podem levar à desestabilização do código do usuário gerenciado por servidor.</span><span class="sxs-lookup"><span data-stu-id="4752a-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>  
  
-   <span data-ttu-id="4752a-269">Métodos ou classes que não se ajustam ao modelo de programação de host e podem levar à desestabilização do processo do servidor em si.</span><span class="sxs-lookup"><span data-stu-id="4752a-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4752a-270">Se você está criando uma biblioteca de classes que pode vir a ser chamada por aplicativos que podem vir a ser executados em um ambiente de host protegido, você deve aplicar esse atributo aos membros que expõem categorias de recursos <xref:System.Security.Permissions.HostProtectionResource>.</span><span class="sxs-lookup"><span data-stu-id="4752a-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="4752a-271">Os membros da biblioteca de classes do .NET Framework com esse atributo fazem apenas com que o chamador imediato seja verificado.</span><span class="sxs-lookup"><span data-stu-id="4752a-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="4752a-272">O membro da biblioteca deve também causar uma verificação de seu chamador imediato da mesma maneira.</span><span class="sxs-lookup"><span data-stu-id="4752a-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>  
  
 <span data-ttu-id="4752a-273">Encontre mais informações sobre HPA em <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="4752a-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-274">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-274">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-275">Para o SQL Server, todos os métodos usados para apresentar a sincronização ou threading devem ser identificados com o HPA.</span><span class="sxs-lookup"><span data-stu-id="4752a-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="4752a-276">Isso inclui métodos que compartilham o estado, que são sincronizados ou que gerenciam processos externos.</span><span class="sxs-lookup"><span data-stu-id="4752a-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="4752a-277">Os valores de <xref:System.Security.Permissions.HostProtectionResource> que afetam o SQL Server são <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> e <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="4752a-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="4752a-278">No entanto, qualquer método que expõe qualquer <xref:System.Security.Permissions.HostProtectionResource> deve ser identificado por um HPA, não apenas aqueles usando recursos que afetam o SQL.</span><span class="sxs-lookup"><span data-stu-id="4752a-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>  
  
### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="4752a-279">Não bloquear indefinidamente em código não gerenciado</span><span class="sxs-lookup"><span data-stu-id="4752a-279">Do Not Block Indefinitely in Unmanaged Code</span></span>  
 <span data-ttu-id="4752a-280">Bloquear em código não gerenciado em vez de em código gerenciado pode causar um ataque de negação de serviço, pois o CLR não é capaz de anular o thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="4752a-281">Um thread bloqueado impede que o CLR descarregue o <xref:System.AppDomain>, pelo menos até que algumas operações extremamente não seguras sejam feitas.</span><span class="sxs-lookup"><span data-stu-id="4752a-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="4752a-282">O bloqueio usando um primitivo de sincronização do Win32 é um exemplo claro de algo que não podemos permitir.</span><span class="sxs-lookup"><span data-stu-id="4752a-282">Blocking using a Win32 synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="4752a-283">O bloqueio em uma chamada para `ReadFile` em um soquete deve ser evitado se possível – idealmente, a API do Win32 deve fornecer um mecanismo para que uma operação como essa atinja o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="4752a-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Win32 API should provide a mechanism for an operation like this to time out.</span></span>  
  
 <span data-ttu-id="4752a-284">Qualquer método que chame recursos nativos deve idealmente usar uma chamada de Win32 com um tempo limite razoável e finito.</span><span class="sxs-lookup"><span data-stu-id="4752a-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="4752a-285">Se o usuário tem permissão para especificar o tempo limite, o usuário não deve ter permissão para especificar um tempo limite infinito sem alguma permissão de segurança específica.</span><span class="sxs-lookup"><span data-stu-id="4752a-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="4752a-286">Como diretriz, se um método será bloqueado por mais de aprox. 10 segundos, você precisará estar usando uma versão que dê suporte a tempos limite ou precisará de mais suporte a CLR.</span><span class="sxs-lookup"><span data-stu-id="4752a-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>  
  
 <span data-ttu-id="4752a-287">Aqui estão alguns exemplos de APIs problemáticas.</span><span class="sxs-lookup"><span data-stu-id="4752a-287">Here are some examples of problematic API’s.</span></span>  <span data-ttu-id="4752a-288">Pipes (anônimos e nomeados) podem ser criados com um tempo limite; no entanto, o código deve assegurar que ele nunca chame `CreateNamedPipe` nem `WaitNamedPipe` com NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="4752a-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="4752a-289">Além disso, pode haver bloqueio inesperado mesmo se um tempo limite é especificado.</span><span class="sxs-lookup"><span data-stu-id="4752a-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="4752a-290">Chamar `WriteFile` em um pipe anônimo resultará em bloqueio até que todos os bytes sejam gravados, o que significa que, se o buffer tem dados não lidos, a chamada de `WriteFile` é bloqueada até o leitor ter liberado espaço no buffer do pipe.</span><span class="sxs-lookup"><span data-stu-id="4752a-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="4752a-291">Os soquetes devem sempre usar alguma API que respeita um mecanismo de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="4752a-291">Sockets should always use some API that honors a timeout mechanism.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-292">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-292">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-293">Bloquear sem um tempo limite em código não gerenciado é um ataque de negação de serviço.</span><span class="sxs-lookup"><span data-stu-id="4752a-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="4752a-294">Não execute chamadas de invocação de plataforma para `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` e `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="4752a-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="4752a-295">Não use NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="4752a-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>  
  
### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="4752a-296">Identifique quaisquer recursos dependentes de STA.</span><span class="sxs-lookup"><span data-stu-id="4752a-296">Identify Any STA-Dependent Features.</span></span>  
 <span data-ttu-id="4752a-297">Identifique qualquer código que use STAs (apartments de thread único) COM.</span><span class="sxs-lookup"><span data-stu-id="4752a-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="4752a-298">STAs são desabilitados no processo do SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="4752a-299">Recursos que dependem de `CoInitialize`, assim como contadores de desempenho ou a área de transferência, devem ser desabilitados no SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>  
  
### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="4752a-300">Assegurar que os finalizadores estão livres de problemas de sincronização</span><span class="sxs-lookup"><span data-stu-id="4752a-300">Ensure Finalizers Are Free of Synchronization Problems</span></span>  
 <span data-ttu-id="4752a-301">Vários threads finalizadores podem existir em futuras versões do .NET Framework, o que significa que os finalizadores para instâncias diferentes do mesmo tipo são executados simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="4752a-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="4752a-302">Eles não precisam ser completamente thread-safe; o coletor de lixo garante que apenas um thread executará o finalizador para uma determinada instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="4752a-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="4752a-303">No entanto, os finalizadores devem ser codificados para evitar deadlocks e condições de corrida quando executados simultaneamente em várias instâncias de objeto diferentes.</span><span class="sxs-lookup"><span data-stu-id="4752a-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="4752a-304">Ao usar qualquer estado externo, por exemplo, ao gravar em um arquivo de log em um finalizador, problemas de threading devem ser solucionados.</span><span class="sxs-lookup"><span data-stu-id="4752a-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="4752a-305">Não dependa da finalização para fornecer acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="4752a-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="4752a-306">Não use o armazenamento local de thread, gerenciado ou nativo, para armazenar o estado no thread do finalizador.</span><span class="sxs-lookup"><span data-stu-id="4752a-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-307">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-307">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-308">Os finalizadores devem estar livres de problemas de sincronização.</span><span class="sxs-lookup"><span data-stu-id="4752a-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="4752a-309">Não use um estado mutável estático em um finalizador.</span><span class="sxs-lookup"><span data-stu-id="4752a-309">Do not use a static mutable state in a finalizer.</span></span>  
  
### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="4752a-310">Evitar memória não gerenciada, se possível</span><span class="sxs-lookup"><span data-stu-id="4752a-310">Avoid Unmanaged Memory If Possible</span></span>  
 <span data-ttu-id="4752a-311">Memória não gerenciada pode ser perdida, assim como um identificador de sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="4752a-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span>  <span data-ttu-id="4752a-312">Se possível, tente usar memória na pilha usando [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) ou um objeto gerenciado fixo, como a [instrução fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md) ou um <xref:System.Runtime.InteropServices.GCHandle> usando um byte[].</span><span class="sxs-lookup"><span data-stu-id="4752a-312">If possible, try to use memory on the stack using [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) or a pinned managed object such as the [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span>  <span data-ttu-id="4752a-313">O <xref:System.GC> limpa esses elementos eventualmente.</span><span class="sxs-lookup"><span data-stu-id="4752a-313">The <xref:System.GC> eventually cleans these up.</span></span>  <span data-ttu-id="4752a-314">No entanto, se você precisar alocar memória não gerenciada, considere o uso de uma classe que deriva de <xref:System.Runtime.InteropServices.SafeHandle> para encapsular a alocação de memória.</span><span class="sxs-lookup"><span data-stu-id="4752a-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>  
  
 <span data-ttu-id="4752a-315">Observe que há pelo menos um caso em que <xref:System.Runtime.InteropServices.SafeHandle> não é adequado.</span><span class="sxs-lookup"><span data-stu-id="4752a-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span>  <span data-ttu-id="4752a-316">Para chamadas de método COM que alocam ou liberam memória, é comum que uma DLL aloque memória por meio de `CoTaskMemAlloc` e, em seguida, outra DLL libere essa memória com `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="4752a-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="4752a-317">Usar <xref:System.Runtime.InteropServices.SafeHandle> nesses locais seria inadequado, já que ele tentará associar o tempo de vida da memória não gerenciada ao tempo de vida do <xref:System.Runtime.InteropServices.SafeHandle> em vez de permitir que outra DLL controle o tempo de vida da memória.</span><span class="sxs-lookup"><span data-stu-id="4752a-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>  
  
### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="4752a-318">Examinar todos os usos de Catch(Exception)</span><span class="sxs-lookup"><span data-stu-id="4752a-318">Review All Uses of Catch(Exception)</span></span>  
 <span data-ttu-id="4752a-319">Blocos catch que capturam todas as exceções, em vez de uma exceção específica, agora capturarão exceções assíncronas também.</span><span class="sxs-lookup"><span data-stu-id="4752a-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span>  <span data-ttu-id="4752a-320">Examine cada bloco catch(Exception), procurando por nenhuma liberação de recursos importantes ou código de recuo que possa ser ignorado, bem como comportamento potencialmente incorreto dentro do próprio bloco catch para tratar uma <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> ou <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="4752a-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="4752a-321">Observe que é possível que esse código esteja registrando em log ou fazendo algumas suposições de que ele pode apenas ver determinadas exceções ou que sempre que uma exceção ocorre, ele falhou exatamente por um motivo específico.</span><span class="sxs-lookup"><span data-stu-id="4752a-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="4752a-322">Essas pressuposições talvez precisem ser atualizadas para incluir <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="4752a-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>  
  
 <span data-ttu-id="4752a-323">Considere a possibilidade de alterar todos os locais que capturam todas as exceções para capturar um tipo específico de exceção que você espera ser gerada, tal como uma <xref:System.FormatException> de métodos de formatação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="4752a-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="4752a-324">Isso impede que o bloco catch encontre exceções inesperadas e ajuda a garantir que o código não oculte bugs capturando exceções inesperadas.</span><span class="sxs-lookup"><span data-stu-id="4752a-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="4752a-325">Como regra geral, nunca manipule uma exceção no código de biblioteca (código que requer que você capture uma exceção pode indicar uma falha de design no código que você está chamando).</span><span class="sxs-lookup"><span data-stu-id="4752a-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="4752a-326">Em alguns casos, talvez você queira capturar uma exceção e gerar um tipo de exceção diferente para fornecer mais dados.</span><span class="sxs-lookup"><span data-stu-id="4752a-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="4752a-327">Usar exceções aninhadas nesse caso, armazenando a causa real da falha na propriedade <xref:System.Exception.InnerException%2A> da nova exceção.</span><span class="sxs-lookup"><span data-stu-id="4752a-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-328">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-328">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-329">Examine todos os blocos catch no código gerenciado que captura todos os objetos ou captura todas as exceções.</span><span class="sxs-lookup"><span data-stu-id="4752a-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="4752a-330">No C#, isso significa sinalizar ambos `catch` {} e `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="4752a-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="4752a-331">Considere tornar o tipo de exceção muito específico ou examine o código para garantir que ele não agirá de forma incorreta se detectar um tipo de exceção inesperado.</span><span class="sxs-lookup"><span data-stu-id="4752a-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>  
  
### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="4752a-332">Não suponha que um thread gerenciado é um thread do Win32 – ele é uma fibra</span><span class="sxs-lookup"><span data-stu-id="4752a-332">Do Not Assume a Managed Thread Is a Win32 Thread – It Is a Fiber</span></span>  
 <span data-ttu-id="4752a-333">O uso do armazenamento local de thread gerenciado funciona, mas você não pode usar o armazenamento local de thread não gerenciado ou supor que o código será executado novamente no thread do sistema operacional atual.</span><span class="sxs-lookup"><span data-stu-id="4752a-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span>  <span data-ttu-id="4752a-334">Não altere as configurações, como o local de thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-334">Do not change settings like the thread’s locale.</span></span>  <span data-ttu-id="4752a-335">Não chame `InitializeCriticalSection` ou `CreateMutex` por meio de invocação de plataforma porque eles requerem que o thread de sistema operacional que entra em um bloqueio também saia do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="4752a-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span>  <span data-ttu-id="4752a-336">Como isso não será o caso ao usar fibras, mutexes e seções críticas do Win32 não podem ser usados no SQL diretamente.</span><span class="sxs-lookup"><span data-stu-id="4752a-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="4752a-337">Observe que a classe <xref:System.Threading.Mutex> gerenciada não lida com essas preocupações de afinidade de thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>  
  
 <span data-ttu-id="4752a-338">Você pode usar com segurança a maior parte do estado em um objeto <xref:System.Threading.Thread> gerenciado, incluindo o armazenamento local de thread gerenciado e a cultura de interface do usuário atual do thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span>  <span data-ttu-id="4752a-339">Você também pode usar o <xref:System.ThreadStaticAttribute>, que torna o valor de uma variável estática existente acessível somente pelo thread gerenciado atual (essa é outra maneira de fazer o armazenamento local de fibra no CLR).</span><span class="sxs-lookup"><span data-stu-id="4752a-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span>  <span data-ttu-id="4752a-340">Para a programação de motivos de modelo, você não pode alterar a cultura atual de um thread durante a execução no SQL.</span><span class="sxs-lookup"><span data-stu-id="4752a-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-341">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-341">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-342">O SQL Server é executado no modo de fibra; não use o armazenamento local de thread.</span><span class="sxs-lookup"><span data-stu-id="4752a-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="4752a-343">Evite chamadas de invocação de plataforma para `TlsAlloc`, `TlsFree`, `TlsGetValue` e `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="4752a-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>  
  
### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="4752a-344">Permitir a representação de identificador do SQL Server</span><span class="sxs-lookup"><span data-stu-id="4752a-344">Let SQL Server Handle Impersonation</span></span>  
 <span data-ttu-id="4752a-345">Já que a representação opera em nível de thread e o SQL pode executar em modo de fibra, o código gerenciado não deve representar usuários e não deve chamar `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="4752a-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-346">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-346">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-347">Permita a representação de identificador do SQL Server.</span><span class="sxs-lookup"><span data-stu-id="4752a-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="4752a-348">Não use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` nem `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="4752a-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>  
  
### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="4752a-349">Não chame Thread::Suspend</span><span class="sxs-lookup"><span data-stu-id="4752a-349">Do Not Call Thread::Suspend</span></span>  
 <span data-ttu-id="4752a-350">A capacidade de suspender um thread pode parecer uma operação simples, mas pode causar deadlocks.</span><span class="sxs-lookup"><span data-stu-id="4752a-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="4752a-351">Se um thread mantendo que um bloqueio é suspenso por um segundo thread e, em seguida, o segundo thread tenta usar o mesmo bloqueio, ocorre um deadlock.</span><span class="sxs-lookup"><span data-stu-id="4752a-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="4752a-352"><xref:System.Threading.Thread.Suspend%2A> pode atualmente interferir com a segurança, o carregamento de classe, a comunicação remota e a reflexão.</span><span class="sxs-lookup"><span data-stu-id="4752a-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="4752a-353">Regra de análise de código</span><span class="sxs-lookup"><span data-stu-id="4752a-353">Code Analysis Rule</span></span>  
 <span data-ttu-id="4752a-354">Não chame <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="4752a-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="4752a-355">Considere o uso de um primitivo de sincronização real em vez disso, assim como um <xref:System.Threading.Semaphore> ou <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="4752a-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>  
  
### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="4752a-356">Proteger as operações essenciais com regiões de execução restrita e contratos de confiabilidade</span><span class="sxs-lookup"><span data-stu-id="4752a-356">Protect Critical Operations with Constrained Execution Regions and Reliability Contracts</span></span>  
 <span data-ttu-id="4752a-357">Ao executar uma operação complexa que atualiza um status compartilhado ou que precisa de forma determinística ser totalmente bem-sucedido ou falhar totalmente, verifique se ele é protegido por uma CER (região de execução restrita).</span><span class="sxs-lookup"><span data-stu-id="4752a-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="4752a-358">Isso garante que o código seja executado em todos os casos, até mesmo uma operação de anulação de thread abrupta ou um descarregamento de <xref:System.AppDomain> abrupto.</span><span class="sxs-lookup"><span data-stu-id="4752a-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>  
  
 <span data-ttu-id="4752a-359">Uma CER é um bloco `try/finally` específico imediatamente precedido por uma chamada para <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="4752a-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>  
  
 <span data-ttu-id="4752a-360">Fazer isso instrui o compilador Just-In-Time para preparar a todo o código no bloco finally antes de executar o bloco `try`.</span><span class="sxs-lookup"><span data-stu-id="4752a-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="4752a-361">Isso assegura que o código no bloco finally será criado e que será executado em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="4752a-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="4752a-362">Não é incomum que uma CER tenha um bloco `try` vazio.</span><span class="sxs-lookup"><span data-stu-id="4752a-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="4752a-363">Usar uma CER protege contra anulações de thread assíncronas e exceções de falta de memória.</span><span class="sxs-lookup"><span data-stu-id="4752a-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="4752a-364">Consulte <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> para um formulário de uma CER que manipula excedentes de pilha de código excessivamente profundo.</span><span class="sxs-lookup"><span data-stu-id="4752a-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4752a-365">Consulte também</span><span class="sxs-lookup"><span data-stu-id="4752a-365">See also</span></span>
- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="4752a-366">Programação em SQL Server e atributos de proteção de host</span><span class="sxs-lookup"><span data-stu-id="4752a-366">SQL Server Programming and Host Protection Attributes</span></span>](../../../docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)
