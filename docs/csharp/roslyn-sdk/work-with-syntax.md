---
title: Usar o modelo de sintaxe do SDK do .NET Compiler Platform
description: Esta visão geral fornece uma compreensão dos tipos usados para entender e manipular nós de sintaxe.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fdb13095c2b91e54d58988a51a51b05652e57ea6
ms.sourcegitcommit: 488aced39b5f374bc0a139a4993616a54d15baf0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/12/2020
ms.locfileid: "83208389"
---
# <a name="work-with-syntax"></a><span data-ttu-id="be943-103">Trabalhar com sintaxe</span><span class="sxs-lookup"><span data-stu-id="be943-103">Work with syntax</span></span>

<span data-ttu-id="be943-104">A *árvore de sintaxe* é uma estrutura de dados fundamental exposta pelas APIs do compilador.</span><span class="sxs-lookup"><span data-stu-id="be943-104">The *syntax tree* is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="be943-105">Essas árvores representam a estrutura lexical e sintática do código-fonte.</span><span class="sxs-lookup"><span data-stu-id="be943-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="be943-106">Elas servem duas finalidades importantes:</span><span class="sxs-lookup"><span data-stu-id="be943-106">They serve two important purposes:</span></span>

- <span data-ttu-id="be943-107">Para permitir ferramentas – como um IDE, suplementos, ferramentas de análise de código e refatoração – para ver e processar a estrutura sintática do código-fonte no projeto de um usuário.</span><span class="sxs-lookup"><span data-stu-id="be943-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user's project.</span></span>
- <span data-ttu-id="be943-108">Para habilitar ferramentas – como refatorações e um IDE, para criar, modificar e reorganizar o código-fonte de maneira natural sem precisar usar edições de texto direto.</span><span class="sxs-lookup"><span data-stu-id="be943-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="be943-109">Criando e manipulando árvores, as ferramentas podem criar e reorganizar o código-fonte com facilidade.</span><span class="sxs-lookup"><span data-stu-id="be943-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="be943-110">Árvores de sintaxe</span><span class="sxs-lookup"><span data-stu-id="be943-110">Syntax trees</span></span>

<span data-ttu-id="be943-111">Árvores de sintaxe são a estrutura principal usada para compilação, análise de código, associação, refatoração, recursos de IDE e geração de código.</span><span class="sxs-lookup"><span data-stu-id="be943-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="be943-112">Nenhuma parte do código-fonte é entendida sem primeiro ser identificada e categorizada em um dos muitos elementos de linguagem estrutural conhecidos.</span><span class="sxs-lookup"><span data-stu-id="be943-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="be943-113">As árvores de sintaxe têm três atributos-chave.</span><span class="sxs-lookup"><span data-stu-id="be943-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="be943-114">O primeiro atributo é que as árvores de sintaxe mantêm todas as informações de origem em fidelidade total.</span><span class="sxs-lookup"><span data-stu-id="be943-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="be943-115">Fidelidade total significa que a árvore de sintaxe contém todas as informações encontradas no texto de origem, todas as construções gramaticais, todos os tokens léxicos e todo o restante entre eles, incluindo o espaço em branco, os comentários e as diretivas de pré-processador.</span><span class="sxs-lookup"><span data-stu-id="be943-115">Full fidelity means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="be943-116">Por exemplo, cada literal mencionado na fonte é representado exatamente como foi digitado.</span><span class="sxs-lookup"><span data-stu-id="be943-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="be943-117">As árvores de sintaxe também capturam erros no código-fonte quando o programa está incompleto ou malformado, representando tokens ignorados ou ausentes.</span><span class="sxs-lookup"><span data-stu-id="be943-117">Syntax trees also capture errors in source code when the program is incomplete or malformed by representing skipped or missing tokens.</span></span>

<span data-ttu-id="be943-118">O segundo atributo de árvores de sintaxe é que eles podem produzir o texto exato do qual foram analisados.</span><span class="sxs-lookup"><span data-stu-id="be943-118">The second attribute of syntax trees is that they can produce the exact text that they were parsed from.</span></span> <span data-ttu-id="be943-119">De qualquer nó de sintaxe, é possível obter a representação de texto da subárvore com raiz nesse nó.</span><span class="sxs-lookup"><span data-stu-id="be943-119">From any syntax node, it's possible to get the text representation of the subtree rooted at that node.</span></span> <span data-ttu-id="be943-120">Essa capacidade significa que as árvores de sintaxe podem ser usadas como uma maneira de construir e editar o texto de origem.</span><span class="sxs-lookup"><span data-stu-id="be943-120">This ability means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="be943-121">Criando uma árvore que você tem, por implicação, criou o texto equivalente e editando uma árvore de sintaxe, fazendo uma nova árvore fora das alterações em uma árvore existente, você editou o texto com eficiência.</span><span class="sxs-lookup"><span data-stu-id="be943-121">By creating a tree you have, by implication, created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="be943-122">O terceiro atributo das árvores de sintaxe é que elas são imutáveis e thread-safe.</span><span class="sxs-lookup"><span data-stu-id="be943-122">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span> <span data-ttu-id="be943-123">Depois que uma árvore é obtida, é um instantâneo do estado atual do código e nunca é alterado.</span><span class="sxs-lookup"><span data-stu-id="be943-123">After a tree is obtained, it's a snapshot of the current state of the code and never changes.</span></span> <span data-ttu-id="be943-124">Isso permite que vários usuários interajam com a mesma árvore de sintaxe ao mesmo tempo em threads diferentes sem bloqueio nem duplicação.</span><span class="sxs-lookup"><span data-stu-id="be943-124">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="be943-125">Como as árvores são imutáveis e nenhuma modificação pode ser feita diretamente em uma árvore, os métodos de fábrica ajudam a criar e modificar árvores de sintaxe criando instantâneos adicionais da árvore.</span><span class="sxs-lookup"><span data-stu-id="be943-125">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="be943-126">As árvores são eficientes no modo como reutilizam os nós subjacentes, de forma que uma nova versão possa ser recompilada rapidamente e com pouca memória extra.</span><span class="sxs-lookup"><span data-stu-id="be943-126">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="be943-127">Uma árvore de sintaxe é literalmente uma estrutura de dados de árvore, em que os elementos estruturais não terminais são pais de outros elementos.</span><span class="sxs-lookup"><span data-stu-id="be943-127">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="be943-128">Cada árvore de sintaxe é composta por nós, tokens e desafios.</span><span class="sxs-lookup"><span data-stu-id="be943-128">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="be943-129">Nós de sintaxe</span><span class="sxs-lookup"><span data-stu-id="be943-129">Syntax nodes</span></span>

<span data-ttu-id="be943-130">Nós de sintaxe são um dos elementos principais das árvores de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="be943-130">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="be943-131">Esses nós representam os constructos sintáticos como declarações, instruções, cláusulas e expressões.</span><span class="sxs-lookup"><span data-stu-id="be943-131">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="be943-132">Cada categoria de nós de sintaxe é representada por uma classe separada derivada de <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be943-132">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="be943-133">O conjunto de classes de nó não é extensível.</span><span class="sxs-lookup"><span data-stu-id="be943-133">The set of node classes is not extensible.</span></span>

<span data-ttu-id="be943-134">Todos os nós de sintaxe são nós não terminais na árvore de sintaxe, o que significa que eles sempre têm outros nós e tokens como filhos.</span><span class="sxs-lookup"><span data-stu-id="be943-134">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="be943-135">Como filho de outro nó, cada nó tem um nó pai que pode ser acessado por meio da propriedade <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be943-135">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="be943-136">Como os nós e as árvores são imutáveis, o pai de um nó nunca é alterado.</span><span class="sxs-lookup"><span data-stu-id="be943-136">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="be943-137">A raiz da árvore tem um pai nulo.</span><span class="sxs-lookup"><span data-stu-id="be943-137">The root of the tree has a null parent.</span></span>

<span data-ttu-id="be943-138">Cada nó tem um método <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType>, que retorna uma lista de nós filho em ordem sequencial com base em sua posição no texto de origem.</span><span class="sxs-lookup"><span data-stu-id="be943-138">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="be943-139">Essa lista não contém tokens.</span><span class="sxs-lookup"><span data-stu-id="be943-139">This list does not contain tokens.</span></span> <span data-ttu-id="be943-140">Cada nó também tem métodos para examinar descendentes, como <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> , <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> ou <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> -que representam uma lista de todos os nós, tokens ou Trívia que existem na subárvore com raiz por esse nó.</span><span class="sxs-lookup"><span data-stu-id="be943-140">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the subtree rooted by that node.</span></span>

<span data-ttu-id="be943-141">Além disso, cada subclasse de nó de sintaxe expõe os mesmos filhos por meio de propriedades fortemente tipadas.</span><span class="sxs-lookup"><span data-stu-id="be943-141">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="be943-142">Por exemplo, uma classe de nó <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> tem três propriedades adicionais específicas aos operadores binários: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> e <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="be943-142">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="be943-143">O tipo de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> e <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> é <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> e o tipo de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> é <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="be943-143">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="be943-144">Alguns nós de sintaxe têm filhos opcionais.</span><span class="sxs-lookup"><span data-stu-id="be943-144">Some syntax nodes have optional children.</span></span> <span data-ttu-id="be943-145">Por exemplo, um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> tem um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax> opcional.</span><span class="sxs-lookup"><span data-stu-id="be943-145">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="be943-146">Se o filho não estiver presente, a propriedade retornará nulo.</span><span class="sxs-lookup"><span data-stu-id="be943-146">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="be943-147">Tokens de sintaxe</span><span class="sxs-lookup"><span data-stu-id="be943-147">Syntax tokens</span></span>

<span data-ttu-id="be943-148">Os tokens de sintaxe são os terminais da gramática da linguagem, que representam os menores fragmentos sintáticos do código.</span><span class="sxs-lookup"><span data-stu-id="be943-148">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="be943-149">Eles nunca são os pais de outros nós ou tokens.</span><span class="sxs-lookup"><span data-stu-id="be943-149">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="be943-150">Os tokens de sintaxe consistem em palavras-chave, identificadores, literais e pontuação.</span><span class="sxs-lookup"><span data-stu-id="be943-150">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="be943-151">Para fins de eficiência, o tipo <xref:Microsoft.CodeAnalysis.SyntaxToken> é um tipo de valor CLR.</span><span class="sxs-lookup"><span data-stu-id="be943-151">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="be943-152">Portanto, ao contrário dos nós de sintaxe, há apenas uma estrutura para todos os tipos de tokens com uma combinação de propriedades que têm significado, dependendo do tipo de token que está sendo representado.</span><span class="sxs-lookup"><span data-stu-id="be943-152">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="be943-153">Por exemplo, um token literal inteiro representa um valor numérico.</span><span class="sxs-lookup"><span data-stu-id="be943-153">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="be943-154">Além do texto de origem não processado abrangido pelo token, o token literal tem uma propriedade <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> que informa o valor inteiro decodificado exato.</span><span class="sxs-lookup"><span data-stu-id="be943-154">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="be943-155">Essa propriedade é tipada como <xref:System.Object> porque pode ser um dos muitos tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="be943-155">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="be943-156">A propriedade <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> indica as mesmas informações que a propriedade <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>; no entanto, essa propriedade sempre é tipada como <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="be943-156">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="be943-157">Um identificador no texto de origem C# pode incluir caracteres de escape Unicode, embora a sintaxe da sequência de escape em si não seja considerada parte do nome do identificador.</span><span class="sxs-lookup"><span data-stu-id="be943-157">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="be943-158">Portanto, embora o texto não processado abrangido pelo token inclua a sequência de escape, isso não ocorre com a propriedade <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText>.</span><span class="sxs-lookup"><span data-stu-id="be943-158">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="be943-159">Em vez disso, ela inclui os caracteres Unicode identificados pelo escape.</span><span class="sxs-lookup"><span data-stu-id="be943-159">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="be943-160">Por exemplo, se o texto de origem contiver um identificador gravado como `\u03C0`, a propriedade <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> desse token retornará `π`.</span><span class="sxs-lookup"><span data-stu-id="be943-160">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="be943-161">Desafios de sintaxe</span><span class="sxs-lookup"><span data-stu-id="be943-161">Syntax trivia</span></span>

<span data-ttu-id="be943-162">Os desafios de sintaxe representam as partes do texto de origem que são amplamente insignificantes para o reconhecimento normal do código, como espaço em branco, comentários e diretivas do pré-processador.</span><span class="sxs-lookup"><span data-stu-id="be943-162">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="be943-163">Assim como os tokens de sintaxe, os desafios são tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="be943-163">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="be943-164">O único tipo <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> é usado para descrever todos os tipos de desafios.</span><span class="sxs-lookup"><span data-stu-id="be943-164">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="be943-165">Como os desafios não fazem parte da sintaxe de linguagem normal e podem aparecer em qualquer lugar entre dois tokens quaisquer, eles não são incluídos na árvore de sintaxe como um filho de um nó.</span><span class="sxs-lookup"><span data-stu-id="be943-165">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="be943-166">Apesar disso, como eles são importantes ao implementar um recurso como refatoração e para manter fidelidade total com o texto de origem, eles existem como parte da árvore de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="be943-166">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="be943-167">Você pode acessar o Trívia inspecionando as <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> coleções ou um token <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="be943-167">You can access trivia by inspecting a token's <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="be943-168">Quando o texto de origem é analisado, sequências de desafios são associadas aos tokens.</span><span class="sxs-lookup"><span data-stu-id="be943-168">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="be943-169">Em geral, um token possui qualquer desafio após ele na mesma linha até o próximo token.</span><span class="sxs-lookup"><span data-stu-id="be943-169">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="be943-170">Qualquer desafio após essa linha é associado ao próximo token.</span><span class="sxs-lookup"><span data-stu-id="be943-170">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="be943-171">O primeiro token no arquivo de origem obtém todos as desafios iniciais e a última sequência de desafios no arquivo é anexada ao token de fim do arquivo, que, de outro modo, tem largura zero.</span><span class="sxs-lookup"><span data-stu-id="be943-171">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="be943-172">Ao contrário dos nós e tokens de sintaxe, os desafios de sintaxe não têm pais.</span><span class="sxs-lookup"><span data-stu-id="be943-172">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="be943-173">Apesar disso, como eles fazem parte da árvore e cada um deles é associado um único token, você poderá acessar o token ao qual ele está associado usando a propriedade <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be943-173">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="be943-174">Intervalos</span><span class="sxs-lookup"><span data-stu-id="be943-174">Spans</span></span>

<span data-ttu-id="be943-175">Cada nó, token ou desafio conhece sua posição dentro do texto de origem e o número de caracteres no qual ele consiste.</span><span class="sxs-lookup"><span data-stu-id="be943-175">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="be943-176">Uma posição de texto é representada como um inteiro de 32 bits, que é um índice `char` baseado em zero.</span><span class="sxs-lookup"><span data-stu-id="be943-176">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="be943-177">Um objeto <xref:Microsoft.CodeAnalysis.Text.TextSpan> é a posição inicial e uma contagem de caracteres, ambas representadas como inteiros.</span><span class="sxs-lookup"><span data-stu-id="be943-177">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="be943-178">Se <xref:Microsoft.CodeAnalysis.Text.TextSpan> tem comprimento zero, ele se refere a um local entre dois caracteres.</span><span class="sxs-lookup"><span data-stu-id="be943-178">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="be943-179">Cada nó tem duas propriedades <xref:Microsoft.CodeAnalysis.Text.TextSpan>: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> e <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="be943-179">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="be943-180">A <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> propriedade é o intervalo de texto desde o início do primeiro token na subárvore do nó até o final do último token.</span><span class="sxs-lookup"><span data-stu-id="be943-180">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node's subtree to the end of the last token.</span></span> <span data-ttu-id="be943-181">Esse intervalo não inclui nenhum desafio à esquerda ou à direita.</span><span class="sxs-lookup"><span data-stu-id="be943-181">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="be943-182">A <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> propriedade é o intervalo de texto que inclui o span normal do nó, além do intervalo de qualquer Trívia à esquerda ou à direita.</span><span class="sxs-lookup"><span data-stu-id="be943-182">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node's normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="be943-183">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="be943-183">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="be943-184">O nó de instrução dentro do bloco tem um intervalo indicado pelas barras verticais simples (|).</span><span class="sxs-lookup"><span data-stu-id="be943-184">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="be943-185">Ele inclui os caracteres `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="be943-185">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="be943-186">O intervalo total é indicado pelas barras verticais duplas (||).</span><span class="sxs-lookup"><span data-stu-id="be943-186">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="be943-187">Ele inclui os mesmos caracteres do intervalo e os caracteres associados ao desafio à esquerda e à direita.</span><span class="sxs-lookup"><span data-stu-id="be943-187">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="be943-188">Variantes</span><span class="sxs-lookup"><span data-stu-id="be943-188">Kinds</span></span>

<span data-ttu-id="be943-189">Cada nó, token ou desafio tem uma propriedade <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType>, do tipo <xref:System.Int32?displayProperty=nameWithType>, que identifica o elemento de sintaxe exato representado.</span><span class="sxs-lookup"><span data-stu-id="be943-189">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="be943-190">Esse valor pode ser convertido em uma enumeração específica a um idioma.</span><span class="sxs-lookup"><span data-stu-id="be943-190">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="be943-191">Cada idioma, C# ou Visual Basic, tem uma única `SyntaxKind` Enumeração ( <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> e <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType> , respectivamente) que lista todos os nós, tokens e elementos Trívia possíveis na gramática.</span><span class="sxs-lookup"><span data-stu-id="be943-191">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="be943-192">Esta conversão pode ser feita automaticamente acessando os métodos de extensão <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be943-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="be943-193">A propriedade <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> permite a desambiguidade fácil de tipos de nó de sintaxe que compartilham a mesma classe de nó.</span><span class="sxs-lookup"><span data-stu-id="be943-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="be943-194">Para tokens e desafios, essa propriedade é a única maneira de diferenciar um tipo de elemento de outro.</span><span class="sxs-lookup"><span data-stu-id="be943-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="be943-195">Por exemplo, uma única classe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> tem <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> e <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> como filhos.</span><span class="sxs-lookup"><span data-stu-id="be943-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="be943-196">A propriedade <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> distingue se ela é um tipo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> ou <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> de nó de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="be943-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="be943-197">Errors</span><span class="sxs-lookup"><span data-stu-id="be943-197">Errors</span></span>

<span data-ttu-id="be943-198">Mesmo quando o texto de origem contém erros de sintaxe, uma árvore de sintaxe completa com ida e volta para a origem é exposta.</span><span class="sxs-lookup"><span data-stu-id="be943-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="be943-199">Quando o analisador encontra código que não está de acordo com a sintaxe definida do idioma, ele usa uma das duas técnicas para criar uma árvore de sintaxe:</span><span class="sxs-lookup"><span data-stu-id="be943-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree:</span></span>

- <span data-ttu-id="be943-200">Se o analisador espera um tipo específico de token, mas não o encontra, ele pode inserir um token ausente na árvore de sintaxe no local em que o token era esperado.</span><span class="sxs-lookup"><span data-stu-id="be943-200">If the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="be943-201">Um token ausente representa o token real que era esperado, mas tem um intervalo vazio e sua propriedade <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="be943-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

- <span data-ttu-id="be943-202">O analisador pode ignorar tokens até encontrar um onde possa continuar a análise.</span><span class="sxs-lookup"><span data-stu-id="be943-202">The parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="be943-203">Nesse caso, os tokens ignorados são anexados como um nó de desafio com o tipo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="be943-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
