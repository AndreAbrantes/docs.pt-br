---
title: Introdução à transformação de sintaxe (APIs Roslyn)
description: Uma introdução pela travessia, consulta e percurso por árvores de sintaxe.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 3f8d152a2e17bc9e480bd0a76488c563720a63b1
ms.sourcegitcommit: 15d99019aea4a5c3c91ddc9ba23692284a7f61f3
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/12/2018
ms.locfileid: "49122559"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="0cdd8-103">Introdução à transformação de sintaxe</span><span class="sxs-lookup"><span data-stu-id="0cdd8-103">Get started with syntax transformation</span></span>

<span data-ttu-id="0cdd8-104">Este tutorial baseia-se nos conceitos e técnicas explorados nos guias de início rápido [Introdução à análise de sintaxe](syntax-analysis.md) e [Introdução à análise semântica](semantic-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="0cdd8-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="0cdd8-105">Se ainda não o fez, você deve concluir as etapas rápidas antes de começar esta.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="0cdd8-106">Neste início rápido, você explora técnicas para criar e transformar árvores de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="0cdd8-107">Em combinação com as técnicas que você aprendeu em guias de início rápido anteriores, você cria sua primeira refatoração de linha de comando!</span><span class="sxs-lookup"><span data-stu-id="0cdd8-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="0cdd8-108">Imutabilidade e a plataforma de compiladores .NET</span><span class="sxs-lookup"><span data-stu-id="0cdd8-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="0cdd8-109">**Imutabilidade** é um princípio fundamental da plataforma de compiladores .NET.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="0cdd8-110">Estruturas de dados imutáveis ​​não podem ser alteradas depois de criadas.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="0cdd8-111">Estruturas de dados imutáveis ​​podem ser compartilhadas com segurança e analisadas por vários consumidores simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="0cdd8-112">Não há perigo de que um consumidor afete o outro de maneiras imprevisíveis.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="0cdd8-113">Seu analisador não precisa de bloqueios ou outras medidas de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="0cdd8-114">Essa regra se aplica a árvores de sintaxe, compilações, símbolos, modelos semânticos e todas as outras estruturas de dados que você encontrar.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="0cdd8-115">Em vez de modificar as estruturas existentes, as APIs criam novos objetos com base nas diferenças especificadas para os antigos.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="0cdd8-116">Você aplica esse conceito a árvores de sintaxe para criar novas árvores usando transformações.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="0cdd8-117">Criar e transformar árvores</span><span class="sxs-lookup"><span data-stu-id="0cdd8-117">Create and transform trees</span></span>

<span data-ttu-id="0cdd8-118">Você escolhe uma das duas estratégias para transformações de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="0cdd8-119">Os **métodos de fábrica** são melhor usados ​​quando você está procurando por nós específicos para substituir ou locais específicos onde deseja inserir um novo código.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="0cdd8-120">**Regravadores** são a melhor opção quando você deseja examinar um projeto inteiro em busca dos padrões de código que deseja substituir.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="0cdd8-121">Criar nós com métodos de fábrica</span><span class="sxs-lookup"><span data-stu-id="0cdd8-121">Create nodes with factory methods</span></span>

<span data-ttu-id="0cdd8-122">A primeira transformação de sintaxe demonstra os métodos de fábrica.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="0cdd8-123">Substitua uma instrução `using System.Collections;` por uma instrução `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="0cdd8-124">Este exemplo demonstra como você cria objetos <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> usando os métodos de fábrica <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="0cdd8-125">Para cada tipo de **nó**, **token**ou **trivia**, há um método de fábrica que cria uma instância desse tipo.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="0cdd8-126">Você cria árvores de sintaxe compondo os nós hierarquicamente de baixa para cima.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="0cdd8-127">Em seguida, você transformará o programa existente substituindo nós existentes pela nova árvore que você criou.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="0cdd8-128">Inicie o Visual Studio e crie um novo projeto de **Ferramenta de Análise de Código Autônoma** do C#.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="0cdd8-129">No Visual Studio, escolha **Arquivo** > **Novo** > **Projeto** para exibir a caixa de diálogo Novo Projeto.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="0cdd8-130">Em **Visual C#** > **Extensibilidade**, escolha uma **Ferramenta de Análise de Código Autônoma**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="0cdd8-131">Este guia de início rápido tem dois projetos de exemplo, portanto, nomeie a solução **SyntaxTransformationQuickStart** e nomeie o projeto **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="0cdd8-132">Clique em **OK**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-132">Click **OK**.</span></span>

<span data-ttu-id="0cdd8-133">Este projeto usa os métodos de classe <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> para construir um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representando o namespace `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="0cdd8-134">Adicione o seguinte usando a diretiva no topo do arquivo `Program.cs` para importar os métodos de fábrica da classe <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> e os métodos de <xref:System.Console> para que você possa usá-los posteriormente sem qualificá-los:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="0cdd8-135">Você criará **nós de sintaxe de nome** para construir a árvore que representa a instrução `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="0cdd8-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> é a classe base para quatro tipos de nomes que aparecem no C#.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="0cdd8-137">Você compõe esses quatro tipos de nomes para criar qualquer nome que possa aparecer na linguagem C#:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="0cdd8-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, que representa nomes simples de identificadores únicos como `System` e `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="0cdd8-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, que representa um tipo genérico ou nome de método, como `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="0cdd8-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>,que representa um nome qualificado do formulário `<left-name>.<right-identifier-or-generic-name>`, como `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="0cdd8-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, que representa um nome usando um alias externo de assembly como `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="0cdd8-142">Você usa o método <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> para criar um nó <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="0cdd8-143">Adicione o seguinte código no seu método `Main` no `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="0cdd8-144">O código anterior cria um objeto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> e o atribui à variável `name`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="0cdd8-145">Muitas das APIs Roslyn retornam classes básicas para facilitar o trabalho com tipos relacionados.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="0cdd8-146">A variável `name`, um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, pode ser reutilizada conforme você constrói o <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="0cdd8-147">Não use inferência de tipo ao criar a amostra.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="0cdd8-148">Você automatizará essa etapa neste projeto.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="0cdd8-149">Você criou o nome.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-149">You've created the name.</span></span> <span data-ttu-id="0cdd8-150">Agora, é hora de criar mais nós na árvore criando um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="0cdd8-151">A nova árvore usa `name` como a esquerda do nome e um novo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> para o namespace `Collections` como o lado direito do <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="0cdd8-152">Adicione o seguinte código ao `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="0cdd8-153">Execute o código novamente e confira os resultados.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-153">Run the code again, and see the results.</span></span> <span data-ttu-id="0cdd8-154">Você está construindo uma árvore de nós que representa o código.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="0cdd8-155">Você continuará este padrão para construir o <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> para o namespace `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="0cdd8-156">Adicione o seguinte código ao `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="0cdd8-157">Execute o programa novamente para ver que você construiu a árvore para o código a ser adicionado.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="0cdd8-158">Criar uma árvore modificada</span><span class="sxs-lookup"><span data-stu-id="0cdd8-158">Create a modified tree</span></span>

<span data-ttu-id="0cdd8-159">Você criou uma pequena árvore de sintaxe que contém uma instrução.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="0cdd8-160">As APIs para criar novos nós são a escolha certa para criar instruções únicas ou outros pequenos blocos de código.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="0cdd8-161">No entanto, para construir blocos maiores de código, você deve usar métodos que substituem nós ou inserem nós em uma árvore existente.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="0cdd8-162">Lembre-se de que as árvores de sintaxe são imutáveis.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="0cdd8-163">A **API de Sintaxe** não fornece nenhum mecanismo para modificar uma árvore de sintaxe existente após a construção.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="0cdd8-164">Em vez disso, fornece métodos que produzem novas árvores com base nas alterações existentes.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="0cdd8-165">Os métodos `With*` são definidos em classes concretas que derivam de <xref:Microsoft.CodeAnalysis.SyntaxNode> ou em métodos de extensão declarados na classe <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="0cdd8-166">Esses métodos criam um novo nó aplicando alterações nas propriedades filho de um nó existente.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="0cdd8-167">Além disso, o método de extensão <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> pode ser usado para substituir um nó descendente em uma subárvore.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="0cdd8-168">Esse método também atualiza o pai para apontar para o filho recém-criado e repete esse processo até a árvore inteira — um processo conhecido como _re-spining_ da árvore.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree.</span></span>

<span data-ttu-id="0cdd8-169">O próximo passo é criar uma árvore que represente um programa inteiro (pequeno) e depois modificá-la.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="0cdd8-170">Adicione o seguinte código ao início da classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="0cdd8-171">O código de exemplo usa o namespace `System.Collections` e não o namespace `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="0cdd8-172">Em seguida, adicione o seguinte código à parte inferior do método `Main` para analisar o texto e criar uma árvore:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="0cdd8-173">Este exemplo usa o método <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> para substituir o nome em um nó <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> pelo que foi construído no código anterior.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="0cdd8-174">Crie um novo nó <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usando o método <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> para atualizar o nome `System.Collections` com o nome criado no código anterior.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="0cdd8-175">Adicione o seguinte código à parte inferior do método `Main`:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="0cdd8-176">Execute o programa e observe atentamente a saída.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="0cdd8-177">O `newusing` não foi colocado na árvore raiz.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="0cdd8-178">A árvore original não foi alterada.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="0cdd8-179">Adicione o seguinte código usando o método de extensão <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> para criar uma nova árvore.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="0cdd8-180">A nova árvore é o resultado da substituição da importação existente pelo nó `newUsing` atualizado.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="0cdd8-181">Você atribui essa nova árvore à variável `root` ​​existente:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="0cdd8-182">Execute o programa novamente.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-182">Run the program again.</span></span> <span data-ttu-id="0cdd8-183">Desta vez, a árvore importa corretamente o namespace `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="0cdd8-184">Transformar árvores usando `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="0cdd8-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="0cdd8-185">Os métodos `With*` e <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> fornecem meios convenientes para transformar ramos individuais de uma árvore de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="0cdd8-186">A classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> realiza várias transformações em uma árvore de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="0cdd8-187">A classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> é uma subclasse de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0cdd8-188">O <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> aplica uma transformação a um tipo específico de <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="0cdd8-189">Você pode aplicar transformações a vários tipos de objetos <xref:Microsoft.CodeAnalysis.SyntaxNode> sempre que eles aparecerem em uma árvore de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="0cdd8-190">O segundo projeto neste guia de início rápido cria uma refatoração de linha de comando que remove tipos explícitos em declarações de variáveis ​​locais em qualquer lugar em que a inferência de tipo possa ser usada.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="0cdd8-191">Crie um novo projeto de **Ferramenta de Análise de Código Autônoma** do C#.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="0cdd8-192">No Visual Studio, clique com o botão direito do mouse no nó da solução `SyntaxTransformationQuickStart`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="0cdd8-193">Escolha **Adicionar** > **Novo Projeto** para exibir o diálogo **Novo Projeto**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="0cdd8-194">Em **Visual C#** > **Extensibilidade**, escolha **Ferramenta de Análise de Código Autônoma**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="0cdd8-195">Nomeie seu projeto como `TransformationCS` e clique em OK.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="0cdd8-196">A primeira etapa é criar uma classe que deriva de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> para executar as transformações.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="0cdd8-197">Adicione um novo arquivo de classe ao projeto.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-197">Add a new class file to the project.</span></span> <span data-ttu-id="0cdd8-198">No Visual Studio, escolha **Projeto** > **Adicionar Classe...**. Na caixa de diálogo **Adicionar Novo Item**, digite `TypeInferenceRewriter.cs` como o nome do arquivo.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="0cdd8-199">Adicione o seguinte usando diretivas ao arquivo `TypeInferenceRewriter.cs`:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="0cdd8-200">Em seguida, faça a classe `TypeInferenceRewriter` se estender à classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="0cdd8-201">Adicione o seguinte código para declarar um campo somente leitura privado para conter um <xref:Microsoft.CodeAnalysis.SemanticModel> e inicializá-lo no construtor.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="0cdd8-202">Você precisará deste campo posteriormente para determinar onde a inferência de tipos pode ser usada:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="0cdd8-203">Substitua o método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```C#
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="0cdd8-204">Muitas das APIs Roslyn declaram os tipos de retorno que são classes base dos tipos de tempo de execução reais retornados.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="0cdd8-205">Em muitos cenários, um tipo de nó pode ser substituído inteiramente por outro tipo de nó, ou até mesmo removido.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="0cdd8-206">Neste exemplo, o método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> retorna um <xref:Microsoft.CodeAnalysis.SyntaxNode>, em vez do tipo derivado de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="0cdd8-207">Este regravador retorna um novo nó <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> baseado no existente.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="0cdd8-208">Este guia de início rápido lida com declarações de variáveis ​​locais.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="0cdd8-209">Você poderia estendê-lo para outras declarações, como loops `foreach`, loops `for`, expressões LINQ e expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="0cdd8-210">Além disso, este regravador só irá transformar as declarações da forma mais simples:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="0cdd8-211">Se você quiser explorar por conta própria, considere estender a amostra finalizada para esses tipos de declarações de variáveis:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="0cdd8-212">Adicione o seguinte código ao corpo do método `VisitLocalDeclarationStatement` para ignorar a reescrita dessas formas de declaração:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="0cdd8-213">O método indica que nenhuma reescrita ocorre retornando o parâmetro `node` não modificado.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="0cdd8-214">Se nenhuma dessas expressões `if` for verdadeira, o nó representa uma possível declaração com inicialização.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="0cdd8-215">Adicione estas instruções para extrair o nome do tipo especificado na declaração e vinculá-lo usando o campo <xref:Microsoft.CodeAnalysis.SemanticModel> para obter um símbolo de tipo:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="0cdd8-216">Agora, adicione esta instrução para associar a expressão inicializadora:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="0cdd8-217">Por fim, inclua a seguinte instrução `if` para substituir o nome do tipo existente pela palavra-chave `var`, se o tipo de expressão do inicializador corresponder ao tipo especificado:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Replace the initializer node")]

<span data-ttu-id="0cdd8-218">A condicional é necessária porque a declaração pode converter a expressão inicializadora em uma classe ou interface base.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="0cdd8-219">Se este for o caso, os tipos à esquerda e à direita da atribuição não coincidem.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="0cdd8-220">Remover o tipo explícito nesses casos alteraria a semântica de um programa.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="0cdd8-221">`var` é especificado como um identificador em vez de uma palavra-chave porque `var` é uma palavra-chave contextual.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="0cdd8-222">As trivialidades inicial e final (espaço em branco) são transferidas do nome do tipo antigo para a palavra-chave `var` para manter espaço em branco vertical e recuo.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="0cdd8-223">É mais simples usar `ReplaceNode` em vez de `With*` para transformar o <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>, pois o nome do tipo é na verdade o neto da declaração.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="0cdd8-224">Você concluiu o `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="0cdd8-225">Agora, retorne ao arquivo `Program.cs` para finalizar o exemplo.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="0cdd8-226">Crie um teste <xref:Microsoft.CodeAnalysis.Compilation> e obtenha o <xref:Microsoft.CodeAnalysis.SemanticModel> dele.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="0cdd8-227">Use esse <xref:Microsoft.CodeAnalysis.SemanticModel> para testar seu `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="0cdd8-228">Você realizará esta etapa por último.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-228">You'll do this step last.</span></span> <span data-ttu-id="0cdd8-229">Enquanto isso, declare uma variável de espaço reservado representando sua compilação de teste:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="0cdd8-230">Após uma pausa, um erro será exibido informando que não existe método `CreateTestCompilation`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="0cdd8-231">Pressione **Ctrl + Ponto** para abrir a lâmpada e pressione Enter para invocar o comando **Gerar Stub de Método**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="0cdd8-232">Este comando irá gerar um stub de método para o método `CreateTestCompilation` na classe `Program`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="0cdd8-233">Você voltará a preencher este método mais tarde:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-233">You'll come back to fill in this method later:</span></span>

![Gerar método C# a partir de uso](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="0cdd8-235">Grave o seguinte código para iterar sobre cada <xref:Microsoft.CodeAnalysis.SyntaxTree> no teste <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="0cdd8-236">Para cada um, inicialize um novo `TypeInferenceRewriter` com o <xref:Microsoft.CodeAnalysis.SemanticModel> para essa árvore:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="0cdd8-237">Dentro da instrução `foreach` criada, adicione o seguinte código para executar a transformação em cada árvore de origem.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="0cdd8-238">Este código registra condicionalmente a nova árvore transformada se alguma edição tiver sido feita.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="0cdd8-239">Seu regravador só deve modificar uma árvore se encontrar uma ou mais declarações de variáveis ​​locais que poderiam ser simplificadas usando a inferência de tipos:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="0cdd8-240">Você deve ver rabiscos abaixo do código `File.WriteAllText`.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="0cdd8-241">Selecione a lâmpada e adicione a instrução `using System.IO;` necessária.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="0cdd8-242">Você está quase lá!</span><span class="sxs-lookup"><span data-stu-id="0cdd8-242">You're almost done!</span></span> <span data-ttu-id="0cdd8-243">Resta somente uma etapa: criar um teste <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="0cdd8-244">Como você não usou a inferência de tipos durante este guia de início rápido, este seria um caso de teste perfeito.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="0cdd8-245">Infelizmente, criar uma compilação a partir de um arquivo de projeto C# está além do escopo desta explicação passo a passo.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="0cdd8-246">Mas, felizmente, se você está seguindo as instruções cuidadosamente, há esperança.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="0cdd8-247">Substitua o conteúdo do método de `CreateTestCompilation` com o código a seguir.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="0cdd8-248">Ele cria uma compilação de teste que combina coincidentemente com o projeto descrito neste guia de início rápido:</span><span class="sxs-lookup"><span data-stu-id="0cdd8-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="0cdd8-249">Cruze os dedos e execute o projeto.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="0cdd8-250">No Visual Studio, escolha **Depurar** > **Iniciar Depuração**.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="0cdd8-251">O Visual Studio exibirá um aviso dizendo que os arquivos em seu projeto foram alterados.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="0cdd8-252">Clique em "**Sim para Todos**" para recarregar os arquivos modificados.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="0cdd8-253">Examine-os para observar sua grandiosidade.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="0cdd8-254">Observe como o código parece mais limpo sem todos os especificadores de tipo explícitos e redundantes.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="0cdd8-255">Parabéns!</span><span class="sxs-lookup"><span data-stu-id="0cdd8-255">Congratulations!</span></span> <span data-ttu-id="0cdd8-256">Você usou as **APIs do compilador** para criar sua própria refatoração que pesquisa todos os arquivos em um projeto C# para determinados padrões sintáticos, analisa a semântica do código-fonte que corresponde a esses padrões e os transforma.</span><span class="sxs-lookup"><span data-stu-id="0cdd8-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="0cdd8-257">Agora você é oficialmente um autor de refatoração!</span><span class="sxs-lookup"><span data-stu-id="0cdd8-257">You're now officially refactoring author!</span></span>
