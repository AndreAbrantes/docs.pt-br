---
title: "Introdução à análise semântica"
description: "Este tutorial fornece uma visão geral de como trabalhar com análise semântica usando o SDK do .NET Compiler."
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 04bd57dfd32a51bf5d7e3a573e34140b0feec90f
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/27/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="46bed-103">Introdução à análise semântica</span><span class="sxs-lookup"><span data-stu-id="46bed-103">Get started with semantic analysis</span></span>

<span data-ttu-id="46bed-104">Este tutorial presume que você está familiarizado com a API de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="46bed-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="46bed-105">O artigo [Introdução à a análise de sintaxe](syntax-analysis.md) fornece uma introdução suficiente.</span><span class="sxs-lookup"><span data-stu-id="46bed-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="46bed-106">Neste tutorial, você explora as APIs de **Símbolo** e de **Associação**.</span><span class="sxs-lookup"><span data-stu-id="46bed-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="46bed-107">Essas APIs fornecem informações sobre o _significado semântico_ de um programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="46bed-108">Elas permitem fazer e responder perguntas sobre os tipos representado por qualquer símbolo em seu programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="46bed-109">Noções básicas sobre compilações e símbolos</span><span class="sxs-lookup"><span data-stu-id="46bed-109">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="46bed-110">Conforme você trabalha mais com o SDK do .NET Compiler, você se familiariza com as distinções entre a API de Sintaxe e a API de Semântica.</span><span class="sxs-lookup"><span data-stu-id="46bed-110">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="46bed-111">A **API de Sintaxe** permite que você examine a _estrutura_ de um programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-111">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="46bed-112">Muitas vezes, no entanto, você deseja as informações sobre a semântica ou _significado_ de um programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-112">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="46bed-113">Enquanto um trecho ou arquivo de código livre VB ou C# pode ser analisado sintaticamente de modo isolado, não faz sentido fazer a esmo perguntas como "qual é o tipo dessa variável".</span><span class="sxs-lookup"><span data-stu-id="46bed-113">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="46bed-114">O significado de um nome de tipo pode ser dependente de referências de assembly, importações de namespace ou outros arquivos de código.</span><span class="sxs-lookup"><span data-stu-id="46bed-114">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="46bed-115">Essas perguntas são respondidas usando-se a **API de Semântica**, especificamente a classe <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="46bed-115">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="46bed-116">Uma instância de <xref:Microsoft.CodeAnalysis.Compilation> é análoga a um único projeto conforme visto pelo compilador e representa tudo o que é necessário para compilar um programa Visual Basic ou C#.</span><span class="sxs-lookup"><span data-stu-id="46bed-116">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="46bed-117">A **compilação** inclui o conjunto de arquivos de origem a serem compilados, referências de assembly e opções de compilador.</span><span class="sxs-lookup"><span data-stu-id="46bed-117">The **compilation** includes the set of source files to be compiled, assembly references, compiler options.</span></span> <span data-ttu-id="46bed-118">Você pode avaliar o significado do código usando todas as outras informações neste contexto.</span><span class="sxs-lookup"><span data-stu-id="46bed-118">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="46bed-119">Um <xref:Microsoft.CodeAnalysis.Compilation> permite que você encontre **símbolos** – entidades como tipos, namespaces, membros e variáveis aos quais os nomes e outras expressões se referem.</span><span class="sxs-lookup"><span data-stu-id="46bed-119">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="46bed-120">O processo de associar nomes e expressões com **símbolos** é chamado de **associação**.</span><span class="sxs-lookup"><span data-stu-id="46bed-120">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="46bed-121">Assim como <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> é uma classe abstrata com derivativos específicos a um idioma.</span><span class="sxs-lookup"><span data-stu-id="46bed-121">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="46bed-122">Ao criar uma instância de compilação, você deve invocar um método de fábrica na classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="46bed-122">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="46bed-123">Consultar símbolos</span><span class="sxs-lookup"><span data-stu-id="46bed-123">Querying symbols</span></span>

<span data-ttu-id="46bed-124">Neste tutorial, você analisa novamente o programa "Olá, Mundo".</span><span class="sxs-lookup"><span data-stu-id="46bed-124">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="46bed-125">Dessa vez, você consulta os símbolos no programa para compreender quais tipos esses símbolos representam.</span><span class="sxs-lookup"><span data-stu-id="46bed-125">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="46bed-126">Você consulta os tipos em um namespace e aprende a localizar os métodos disponíveis em um tipo.</span><span class="sxs-lookup"><span data-stu-id="46bed-126">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="46bed-127">As amostras a seguir exigem que o **SDK do .NET Compiler** esteja instalado como parte do Visual Studio 2017.</span><span class="sxs-lookup"><span data-stu-id="46bed-127">The following samples require the **.NET Compiler SDK** installed as part of Visual Studio 2017.</span></span> <span data-ttu-id="46bed-128">Você pode encontrar o SDK do .NET Compiler como o último componente opcional listado sob a carga de trabalho do **Desenvolvimento de extensão do Visual Studio**.</span><span class="sxs-lookup"><span data-stu-id="46bed-128">You can find the .NET Compiler SDK as the last optional component listed under the **Visual Studio extension development** workload.</span></span> <span data-ttu-id="46bed-129">Os modelos não são instalados sem esse componente.</span><span class="sxs-lookup"><span data-stu-id="46bed-129">The templates aren't installed without this component.</span></span>

<span data-ttu-id="46bed-130">Você pode ver o código concluído para essa amostra no [nosso repositório de amostras do GitHub](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="46bed-130">You can see the finished code for this sample in [our GitHub samples repository](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="46bed-131">Os tipos de árvore de sintaxe usam a herança para descrever os elementos de sintaxe diferentes que são válidos em locais diferentes no programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-131">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="46bed-132">Usar essas APIs geralmente significa converter propriedades ou membros da coleção em tipos derivados específicos.</span><span class="sxs-lookup"><span data-stu-id="46bed-132">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="46bed-133">Nos exemplos a seguir, a atribuição e as conversões são instruções separadas, usando variáveis explicitamente tipadas.</span><span class="sxs-lookup"><span data-stu-id="46bed-133">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="46bed-134">Você pode ler o código para ver os tipos de retorno da API e o tipo de tempo de execução dos objetos retornados.</span><span class="sxs-lookup"><span data-stu-id="46bed-134">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="46bed-135">Na prática, é mais comum usar variáveis implicitamente tipadas e depender de nomes de API para descrever o tipo de objeto que está sendo examinado.</span><span class="sxs-lookup"><span data-stu-id="46bed-135">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="46bed-136">Criar um novo projeto de **Ferramenta de Análise de Código Autônoma** do C#:</span><span class="sxs-lookup"><span data-stu-id="46bed-136">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="46bed-137">No Visual Studio, escolha **Arquivo** > **Novo** > **Projeto** para exibir a caixa de diálogo Novo Projeto.</span><span class="sxs-lookup"><span data-stu-id="46bed-137">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="46bed-138">Em **Visual C#** > **Extensibilidade**, escolha **Ferramenta de Análise de Código Autônoma**.</span><span class="sxs-lookup"><span data-stu-id="46bed-138">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="46bed-139">Nomeie o projeto "**SemanticQuickStart**" e clique em OK.</span><span class="sxs-lookup"><span data-stu-id="46bed-139">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="46bed-140">Você analisará o programa "Olá, Mundo!" básico</span><span class="sxs-lookup"><span data-stu-id="46bed-140">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="46bed-141">mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="46bed-141">program shown earlier.</span></span>
<span data-ttu-id="46bed-142">Adicione o texto ao programa Olá, Mundo como uma constante em sua classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="46bed-142">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="46bed-143">Em seguida, adicione o código a seguir para criar a árvore de sintaxe para o texto do código na constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="46bed-143">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="46bed-144">Adicione a seguinte linha ao seu método `Main`:</span><span class="sxs-lookup"><span data-stu-id="46bed-144">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="46bed-145">Em seguida, compile uma <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> da árvore que você já criou.</span><span class="sxs-lookup"><span data-stu-id="46bed-145">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="46bed-146">A amostra "Olá, Mundo" depende dos tipos <xref:System.String> e <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="46bed-146">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="46bed-147">Você precisa fazer referência ao assembly que declara esses dois tipos em sua compilação.</span><span class="sxs-lookup"><span data-stu-id="46bed-147">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="46bed-148">Adicione a seguinte linha ao seu método `Main` para criar uma compilação de sua árvore de sintaxe, incluindo a referência ao assembly apropriado:</span><span class="sxs-lookup"><span data-stu-id="46bed-148">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="46bed-149">O método <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> adiciona referências à compilação.</span><span class="sxs-lookup"><span data-stu-id="46bed-149">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="46bed-150">O método <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> carrega um assembly como uma referência.</span><span class="sxs-lookup"><span data-stu-id="46bed-150">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="46bed-151">Consultar o modelo semântico</span><span class="sxs-lookup"><span data-stu-id="46bed-151">Querying the semantic model</span></span>

<span data-ttu-id="46bed-152">Assim que você tiver uma <xref:Microsoft.CodeAnalysis.Compilation>, você poderá solicitar a ela um <xref:Microsoft.CodeAnalysis.SemanticModel> para qualquer <xref:Microsoft.CodeAnalysis.SyntaxTree> contida nessa <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="46bed-152">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="46bed-153">Você pode pensar no modelo semântico como a origem de todas as informações normalmente obtidas do IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="46bed-153">You can think of the semantic model as the source for all the information would normally get from intellisense.</span></span> <span data-ttu-id="46bed-154">Um <xref:Microsoft.CodeAnalysis.SemanticModel> pode responder a perguntas como "Quais nomes estão no escopo nesse local?"</span><span class="sxs-lookup"><span data-stu-id="46bed-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?"</span></span> <span data-ttu-id="46bed-155">"Quais membros são acessíveis deste método?"</span><span class="sxs-lookup"><span data-stu-id="46bed-155">"What members are accessible from this method?"</span></span> <span data-ttu-id="46bed-156">"Quais variáveis são usadas neste bloco de texto?"</span><span class="sxs-lookup"><span data-stu-id="46bed-156">"What variables are used in this block of text?"</span></span> <span data-ttu-id="46bed-157">e "A que esta expressão/nome se refere?"</span><span class="sxs-lookup"><span data-stu-id="46bed-157">and "What does this name/expression refer to?"</span></span> <span data-ttu-id="46bed-158">Adicione esta instrução para criar o modelo semântico:</span><span class="sxs-lookup"><span data-stu-id="46bed-158">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="46bed-159">Associar um nome</span><span class="sxs-lookup"><span data-stu-id="46bed-159">Binding a name</span></span>

<span data-ttu-id="46bed-160">A <xref:Microsoft.CodeAnalysis.Compilation> cria o <xref:Microsoft.CodeAnalysis.SemanticModel> da <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="46bed-160">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="46bed-161">Depois de criar o modelo, você pode consultar para localizar a primeira diretiva `using` e recuperar as informações de símbolo para o namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="46bed-161">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="46bed-162">Adicione estas duas linhas a seu método `Main` para criar o modelo semântico e recuperar o símbolo para a primeira instrução using:</span><span class="sxs-lookup"><span data-stu-id="46bed-162">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="46bed-163">O código anterior mostra como obter um objeto <xref:Microsoft.CodeAnalysis.SemanticModel> para seu <xref:Microsoft.CodeAnalysis.SyntaxTree> Olá, Mundo.</span><span class="sxs-lookup"><span data-stu-id="46bed-163">The preceding code shows how to obtain a <xref:Microsoft.CodeAnalysis.SemanticModel> object for your HelloWorld <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="46bed-164">Depois que o modelo é obtido, o nome na primeira diretiva `using` deverá recuperar um <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> para o namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="46bed-164">Once the model is obtained, the name in the first `using` directive is bound to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="46bed-165">O código anterior também ilustra o uso da **sintaxe de modelo** para localizar a estrutura do código; você usa o **modelo semântico** para entender seu significado.</span><span class="sxs-lookup"><span data-stu-id="46bed-165">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="46bed-166">A **sintaxe de modelo** localiza a cadeia de caracteres `System` na instrução using.</span><span class="sxs-lookup"><span data-stu-id="46bed-166">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="46bed-167">O **modelo semântico** tem todas as informações sobre os tipos definidos no namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="46bed-167">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="46bed-168">Do objeto <xref:Microsoft.CodeAnalysis.SymbolInfo>, você pode obter o <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> usando a propriedade <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="46bed-168">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="46bed-169">Essa propriedade retorna o símbolo a que essa expressão se refere.</span><span class="sxs-lookup"><span data-stu-id="46bed-169">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="46bed-170">Para expressões que não se referem a nada (como literais numéricos), essa propriedade é `null`.</span><span class="sxs-lookup"><span data-stu-id="46bed-170">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="46bed-171">Quando o <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> não for null, o <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotará o tipo do símbolo.</span><span class="sxs-lookup"><span data-stu-id="46bed-171">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="46bed-172">Nesse exemplo, a propriedade <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> é um <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="46bed-172">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="46bed-173">Adicione o código a seguir ao método `Main`.</span><span class="sxs-lookup"><span data-stu-id="46bed-173">Add the following code to your `Main` method.</span></span> <span data-ttu-id="46bed-174">Ele recupera o símbolo para o namespace `System` e, em seguida, exibe todos os namespaces filho declarados no namespace `System`:</span><span class="sxs-lookup"><span data-stu-id="46bed-174">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="46bed-175">Execute o programa e você deverá ver a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="46bed-175">Run the program and you should see the following output:</span></span>

```
Collections
Configuration
Deployment
Diagnostics
Globalization
IO
Reflection
Resources
Runtime
Security
StubHelpers
Text
Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="46bed-176">A saída não inclui todos os namespaces que são namespaces filhos do namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="46bed-176">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="46bed-177">El exibe cada namespace presente nessa compilação, que só referencia o assembly em que `System.String` é declarada.</span><span class="sxs-lookup"><span data-stu-id="46bed-177">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="46bed-178">Quaisquer outros namespaces declarados em outros assemblies não são conhecidos desta compilação</span><span class="sxs-lookup"><span data-stu-id="46bed-178">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="46bed-179">Associar uma expressão</span><span class="sxs-lookup"><span data-stu-id="46bed-179">Binding an expression</span></span>

<span data-ttu-id="46bed-180">O código anterior mostra como encontrar um símbolo associando-o a um nome.</span><span class="sxs-lookup"><span data-stu-id="46bed-180">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="46bed-181">Há outras expressões em um programa C# que podem ser associadas que não são nomes.</span><span class="sxs-lookup"><span data-stu-id="46bed-181">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="46bed-182">Para demonstrar essa capacidade, acessaremos a associação a um único literal de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="46bed-182">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="46bed-183">O programa "Olá, Mundo" contém um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, a cadeia de caracteres "Olá, Mundo!"</span><span class="sxs-lookup"><span data-stu-id="46bed-183">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="46bed-184">exibida pelo console.</span><span class="sxs-lookup"><span data-stu-id="46bed-184">string displayed to the console.</span></span>

<span data-ttu-id="46bed-185">Você localiza a cadeia de caracteres "Olá, Mundo!"</span><span class="sxs-lookup"><span data-stu-id="46bed-185">You find the "Hello, World!"</span></span> <span data-ttu-id="46bed-186">localizando o único literal de cadeia de caracteres no programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-186">string by locating the single string literal in the program.</span></span> <span data-ttu-id="46bed-187">Em seguida, depois de localizar o nó de sintaxe, você obtém as informações de tipo para esse nó do modelo semântico.</span><span class="sxs-lookup"><span data-stu-id="46bed-187">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="46bed-188">Adicione o código a seguir ao método `Main`:</span><span class="sxs-lookup"><span data-stu-id="46bed-188">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="46bed-189">O struct <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> inclui uma propriedade <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> que permite o acesso às informações semânticas sobre o tipo do literal.</span><span class="sxs-lookup"><span data-stu-id="46bed-189">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="46bed-190">Neste exemplo, ele é do tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="46bed-190">In this example, that's the `string` type.</span></span> <span data-ttu-id="46bed-191">Adicione uma declaração que atribui essa propriedade a uma variável local:</span><span class="sxs-lookup"><span data-stu-id="46bed-191">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="46bed-192">Para concluir este tutorial, criaremos uma consulta LINQ que criará uma sequência de todos os métodos públicos declarados no tipo `string` que retorna um `string`.</span><span class="sxs-lookup"><span data-stu-id="46bed-192">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="46bed-193">Essa consulta torna-se complexa, então a compilaremos linha a linha e então a reconstruiremos como uma única consulta.</span><span class="sxs-lookup"><span data-stu-id="46bed-193">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="46bed-194">A ordem desta consulta é a sequência de todos os membros declarados no tipo `string`:</span><span class="sxs-lookup"><span data-stu-id="46bed-194">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="46bed-195">Essa sequência de origem contém todos os membros, incluindo propriedades e campos, portanto, filtre-a usando o método <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> para localizar elementos que são objetos <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="46bed-195">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="46bed-196">Em seguida, adicione outro filtro para retornar somente os métodos que são públicos e retornam um `string`:</span><span class="sxs-lookup"><span data-stu-id="46bed-196">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="46bed-197">Selecione apenas a propriedade de nome e somente os nomes distintos, removendo quaisquer sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="46bed-197">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="46bed-198">Você pode também compilar a consulta completa usando a sintaxe de consulta LINQ e, em seguida, exibir todos os nomes de método no console:</span><span class="sxs-lookup"><span data-stu-id="46bed-198">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="46bed-199">Compile e execute o programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-199">Build and run the program.</span></span> <span data-ttu-id="46bed-200">Você deverá ver a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="46bed-200">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="46bed-201">Você usou a API de semântica para localizar e exibir informações sobre os símbolos que fazem parte deste programa.</span><span class="sxs-lookup"><span data-stu-id="46bed-201">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
