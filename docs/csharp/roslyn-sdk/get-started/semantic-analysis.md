---
title: Introdução à análise semântica
description: Este tutorial fornece uma visão geral de como trabalhar com análise semântica usando o SDK do .NET Compiler.
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: b9921bc3621d6abfc37b1bf1fc4f481620ccc407
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/28/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="0a090-103">Introdução à análise semântica</span><span class="sxs-lookup"><span data-stu-id="0a090-103">Get started with semantic analysis</span></span>

<span data-ttu-id="0a090-104">Este tutorial presume que você está familiarizado com a API de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="0a090-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="0a090-105">O artigo [Introdução à a análise de sintaxe](syntax-analysis.md) fornece uma introdução suficiente.</span><span class="sxs-lookup"><span data-stu-id="0a090-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="0a090-106">Neste tutorial, você explora as APIs de **Símbolo** e de **Associação**.</span><span class="sxs-lookup"><span data-stu-id="0a090-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="0a090-107">Essas APIs fornecem informações sobre o _significado semântico_ de um programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="0a090-108">Elas permitem fazer e responder perguntas sobre os tipos representado por qualquer símbolo em seu programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="0a090-109">Você deverá instalar o **SDK do .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="0a090-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="0a090-110">Noções básicas sobre compilações e símbolos</span><span class="sxs-lookup"><span data-stu-id="0a090-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="0a090-111">Conforme você trabalha mais com o SDK do .NET Compiler, você se familiariza com as distinções entre a API de Sintaxe e a API de Semântica.</span><span class="sxs-lookup"><span data-stu-id="0a090-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="0a090-112">A **API de Sintaxe** permite que você examine a _estrutura_ de um programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="0a090-113">Muitas vezes, no entanto, você deseja as informações sobre a semântica ou _significado_ de um programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="0a090-114">Enquanto um trecho ou arquivo de código livre VB ou C# pode ser analisado sintaticamente de modo isolado, não faz sentido fazer a esmo perguntas como "qual é o tipo dessa variável".</span><span class="sxs-lookup"><span data-stu-id="0a090-114">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="0a090-115">O significado de um nome de tipo pode ser dependente de referências de assembly, importações de namespace ou outros arquivos de código.</span><span class="sxs-lookup"><span data-stu-id="0a090-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="0a090-116">Essas perguntas são respondidas usando-se a **API de Semântica**, especificamente a classe <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a090-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="0a090-117">Uma instância de <xref:Microsoft.CodeAnalysis.Compilation> é análoga a um único projeto conforme visto pelo compilador e representa tudo o que é necessário para compilar um programa Visual Basic ou C#.</span><span class="sxs-lookup"><span data-stu-id="0a090-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="0a090-118">A **compilação** inclui o conjunto de arquivos de origem a serem compilados, referências de assembly e opções de compilador.</span><span class="sxs-lookup"><span data-stu-id="0a090-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="0a090-119">Você pode avaliar o significado do código usando todas as outras informações neste contexto.</span><span class="sxs-lookup"><span data-stu-id="0a090-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="0a090-120">Um <xref:Microsoft.CodeAnalysis.Compilation> permite que você encontre **símbolos** – entidades como tipos, namespaces, membros e variáveis aos quais os nomes e outras expressões se referem.</span><span class="sxs-lookup"><span data-stu-id="0a090-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="0a090-121">O processo de associar nomes e expressões com **símbolos** é chamado de **associação**.</span><span class="sxs-lookup"><span data-stu-id="0a090-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="0a090-122">Assim como <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> é uma classe abstrata com derivativos específicos a um idioma.</span><span class="sxs-lookup"><span data-stu-id="0a090-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="0a090-123">Ao criar uma instância de compilação, você deve invocar um método de fábrica na classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="0a090-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="0a090-124">Consultar símbolos</span><span class="sxs-lookup"><span data-stu-id="0a090-124">Querying symbols</span></span>

<span data-ttu-id="0a090-125">Neste tutorial, você analisa novamente o programa "Olá, Mundo".</span><span class="sxs-lookup"><span data-stu-id="0a090-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="0a090-126">Dessa vez, você consulta os símbolos no programa para compreender quais tipos esses símbolos representam.</span><span class="sxs-lookup"><span data-stu-id="0a090-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="0a090-127">Você consulta os tipos em um namespace e aprende a localizar os métodos disponíveis em um tipo.</span><span class="sxs-lookup"><span data-stu-id="0a090-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="0a090-128">Você pode ver o código concluído para essa amostra no [nosso repositório do GitHub](https://github.com/dotnet/docs/tree/master/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="0a090-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/docs/tree/master/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="0a090-129">Os tipos de árvore de sintaxe usam a herança para descrever os elementos de sintaxe diferentes que são válidos em locais diferentes no programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="0a090-130">Usar essas APIs geralmente significa converter propriedades ou membros da coleção em tipos derivados específicos.</span><span class="sxs-lookup"><span data-stu-id="0a090-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="0a090-131">Nos exemplos a seguir, a atribuição e as conversões são instruções separadas, usando variáveis explicitamente tipadas.</span><span class="sxs-lookup"><span data-stu-id="0a090-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="0a090-132">Você pode ler o código para ver os tipos de retorno da API e o tipo de tempo de execução dos objetos retornados.</span><span class="sxs-lookup"><span data-stu-id="0a090-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="0a090-133">Na prática, é mais comum usar variáveis implicitamente tipadas e depender de nomes de API para descrever o tipo de objeto que está sendo examinado.</span><span class="sxs-lookup"><span data-stu-id="0a090-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="0a090-134">Criar um novo projeto de **Ferramenta de Análise de Código Autônoma** do C#:</span><span class="sxs-lookup"><span data-stu-id="0a090-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="0a090-135">No Visual Studio, escolha **Arquivo** > **Novo** > **Projeto** para exibir a caixa de diálogo Novo Projeto.</span><span class="sxs-lookup"><span data-stu-id="0a090-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="0a090-136">Em **Visual C#** > **Extensibilidade**, escolha **Ferramenta de Análise de Código Autônoma**.</span><span class="sxs-lookup"><span data-stu-id="0a090-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="0a090-137">Nomeie o projeto "**SemanticQuickStart**" e clique em OK.</span><span class="sxs-lookup"><span data-stu-id="0a090-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="0a090-138">Você analisará o programa "Olá, Mundo!" básico</span><span class="sxs-lookup"><span data-stu-id="0a090-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="0a090-139">mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="0a090-139">program shown earlier.</span></span>
<span data-ttu-id="0a090-140">Adicione o texto ao programa Olá, Mundo como uma constante em sua classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="0a090-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="0a090-141">Em seguida, adicione o código a seguir para criar a árvore de sintaxe para o texto do código na constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="0a090-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="0a090-142">Adicione a seguinte linha ao seu método `Main`:</span><span class="sxs-lookup"><span data-stu-id="0a090-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="0a090-143">Em seguida, compile uma <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> da árvore que você já criou.</span><span class="sxs-lookup"><span data-stu-id="0a090-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="0a090-144">A amostra "Olá, Mundo" depende dos tipos <xref:System.String> e <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="0a090-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="0a090-145">Você precisa fazer referência ao assembly que declara esses dois tipos em sua compilação.</span><span class="sxs-lookup"><span data-stu-id="0a090-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="0a090-146">Adicione a seguinte linha ao seu método `Main` para criar uma compilação de sua árvore de sintaxe, incluindo a referência ao assembly apropriado:</span><span class="sxs-lookup"><span data-stu-id="0a090-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="0a090-147">O método <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> adiciona referências à compilação.</span><span class="sxs-lookup"><span data-stu-id="0a090-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="0a090-148">O método <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> carrega um assembly como uma referência.</span><span class="sxs-lookup"><span data-stu-id="0a090-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="0a090-149">Consultar o modelo semântico</span><span class="sxs-lookup"><span data-stu-id="0a090-149">Querying the semantic model</span></span>

<span data-ttu-id="0a090-150">Assim que você tiver uma <xref:Microsoft.CodeAnalysis.Compilation>, você poderá solicitar a ela um <xref:Microsoft.CodeAnalysis.SemanticModel> para qualquer <xref:Microsoft.CodeAnalysis.SyntaxTree> contida nessa <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="0a090-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="0a090-151">Você pode pensar no modelo semântico como a origem de todas as informações normalmente obtidas do IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="0a090-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="0a090-152">Um <xref:Microsoft.CodeAnalysis.SemanticModel> pode responder a perguntas como "O que são nomes no escopo nesse local?", "Quais membros são acessíveis deste método?", "Quais variáveis são usadas neste bloco de texto?" e "A que este nome/expressão se refere?"</span><span class="sxs-lookup"><span data-stu-id="0a090-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="0a090-153">Adicione esta instrução para criar o modelo semântico:</span><span class="sxs-lookup"><span data-stu-id="0a090-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="0a090-154">Associar um nome</span><span class="sxs-lookup"><span data-stu-id="0a090-154">Binding a name</span></span>

<span data-ttu-id="0a090-155">A <xref:Microsoft.CodeAnalysis.Compilation> cria o <xref:Microsoft.CodeAnalysis.SemanticModel> da <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="0a090-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="0a090-156">Depois de criar o modelo, você pode consultar para localizar a primeira diretiva `using` e recuperar as informações de símbolo para o namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="0a090-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="0a090-157">Adicione estas duas linhas a seu método `Main` para criar o modelo semântico e recuperar o símbolo para a primeira instrução using:</span><span class="sxs-lookup"><span data-stu-id="0a090-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="0a090-158">O código anterior mostra como associar o nome na primeira diretiva `using` para recuperar um <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> para o namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="0a090-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="0a090-159">O código anterior também ilustra o uso da **sintaxe de modelo** para localizar a estrutura do código; você usa o **modelo semântico** para entender seu significado.</span><span class="sxs-lookup"><span data-stu-id="0a090-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="0a090-160">A **sintaxe de modelo** localiza a cadeia de caracteres `System` na instrução using.</span><span class="sxs-lookup"><span data-stu-id="0a090-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="0a090-161">O **modelo semântico** tem todas as informações sobre os tipos definidos no namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="0a090-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="0a090-162">Do objeto <xref:Microsoft.CodeAnalysis.SymbolInfo>, você pode obter o <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> usando a propriedade <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a090-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0a090-163">Essa propriedade retorna o símbolo a que essa expressão se refere.</span><span class="sxs-lookup"><span data-stu-id="0a090-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="0a090-164">Para expressões que não se referem a nada (como literais numéricos), essa propriedade é `null`.</span><span class="sxs-lookup"><span data-stu-id="0a090-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="0a090-165">Quando o <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> não for null, o <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotará o tipo do símbolo.</span><span class="sxs-lookup"><span data-stu-id="0a090-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="0a090-166">Nesse exemplo, a propriedade <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> é um <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a090-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0a090-167">Adicione o código a seguir ao método `Main`.</span><span class="sxs-lookup"><span data-stu-id="0a090-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="0a090-168">Ele recupera o símbolo para o namespace `System` e, em seguida, exibe todos os namespaces filho declarados no namespace `System`:</span><span class="sxs-lookup"><span data-stu-id="0a090-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="0a090-169">Execute o programa e você deverá ver a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="0a090-169">Run the program and you should see the following output:</span></span>

```
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="0a090-170">A saída não inclui todos os namespaces que são namespaces filhos do namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="0a090-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="0a090-171">El exibe cada namespace presente nessa compilação, que só referencia o assembly em que `System.String` é declarada.</span><span class="sxs-lookup"><span data-stu-id="0a090-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="0a090-172">Quaisquer outros namespaces declarados em outros assemblies não são conhecidos desta compilação</span><span class="sxs-lookup"><span data-stu-id="0a090-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="0a090-173">Associar uma expressão</span><span class="sxs-lookup"><span data-stu-id="0a090-173">Binding an expression</span></span>

<span data-ttu-id="0a090-174">O código anterior mostra como encontrar um símbolo associando-o a um nome.</span><span class="sxs-lookup"><span data-stu-id="0a090-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="0a090-175">Há outras expressões em um programa C# que podem ser associadas que não são nomes.</span><span class="sxs-lookup"><span data-stu-id="0a090-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="0a090-176">Para demonstrar essa capacidade, acessaremos a associação a um único literal de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="0a090-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="0a090-177">O programa "Olá, Mundo" contém um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, a cadeia de caracteres "Olá, Mundo!"</span><span class="sxs-lookup"><span data-stu-id="0a090-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="0a090-178">exibida pelo console.</span><span class="sxs-lookup"><span data-stu-id="0a090-178">string displayed to the console.</span></span>

<span data-ttu-id="0a090-179">Você localiza a cadeia de caracteres "Olá, Mundo!"</span><span class="sxs-lookup"><span data-stu-id="0a090-179">You find the "Hello, World!"</span></span> <span data-ttu-id="0a090-180">localizando o único literal de cadeia de caracteres no programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="0a090-181">Em seguida, depois de localizar o nó de sintaxe, você obtém as informações de tipo para esse nó do modelo semântico.</span><span class="sxs-lookup"><span data-stu-id="0a090-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="0a090-182">Adicione o código a seguir ao método `Main`:</span><span class="sxs-lookup"><span data-stu-id="0a090-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="0a090-183">O struct <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> inclui uma propriedade <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> que permite o acesso às informações semânticas sobre o tipo do literal.</span><span class="sxs-lookup"><span data-stu-id="0a090-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="0a090-184">Neste exemplo, ele é do tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="0a090-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="0a090-185">Adicione uma declaração que atribui essa propriedade a uma variável local:</span><span class="sxs-lookup"><span data-stu-id="0a090-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="0a090-186">Para concluir este tutorial, criaremos uma consulta LINQ que criará uma sequência de todos os métodos públicos declarados no tipo `string` que retorna um `string`.</span><span class="sxs-lookup"><span data-stu-id="0a090-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="0a090-187">Essa consulta torna-se complexa, então a compilaremos linha a linha e então a reconstruiremos como uma única consulta.</span><span class="sxs-lookup"><span data-stu-id="0a090-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="0a090-188">A ordem desta consulta é a sequência de todos os membros declarados no tipo `string`:</span><span class="sxs-lookup"><span data-stu-id="0a090-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="0a090-189">Essa sequência de origem contém todos os membros, incluindo propriedades e campos, portanto, filtre-a usando o método <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> para localizar elementos que são objetos <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="0a090-189">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="0a090-190">Em seguida, adicione outro filtro para retornar somente os métodos que são públicos e retornam um `string`:</span><span class="sxs-lookup"><span data-stu-id="0a090-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="0a090-191">Selecione apenas a propriedade de nome e somente os nomes distintos, removendo quaisquer sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="0a090-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="0a090-192">Você pode também compilar a consulta completa usando a sintaxe de consulta LINQ e, em seguida, exibir todos os nomes de método no console:</span><span class="sxs-lookup"><span data-stu-id="0a090-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="0a090-193">Compile e execute o programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-193">Build and run the program.</span></span> <span data-ttu-id="0a090-194">Você deverá ver a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="0a090-194">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="0a090-195">Você usou a API de semântica para localizar e exibir informações sobre os símbolos que fazem parte deste programa.</span><span class="sxs-lookup"><span data-stu-id="0a090-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
