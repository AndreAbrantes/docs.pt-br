---
title: Introdução à análise de sintaxe (APIs Roslyn)
description: Uma introdução pela travessia, consulta e percurso por árvores de sintaxe.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: d4163e8aadf577a5a5cbed225b26a0ec8390277e
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/25/2019
ms.locfileid: "75347010"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="888c1-103">Introdução à análise de sintaxe</span><span class="sxs-lookup"><span data-stu-id="888c1-103">Get started with syntax analysis</span></span>

<span data-ttu-id="888c1-104">Neste tutorial, você explorará a **API de sintaxe**.</span><span class="sxs-lookup"><span data-stu-id="888c1-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="888c1-105">A API de sintaxe fornece acesso às estruturas de dados que descrevem um programa C# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="888c1-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="888c1-106">Essas estruturas de dados têm detalhes suficientes para que possam representar qualquer programa, de qualquer tamanho.</span><span class="sxs-lookup"><span data-stu-id="888c1-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="888c1-107">Essas estruturas podem descrever programas completos que compilam e executam corretamente.</span><span class="sxs-lookup"><span data-stu-id="888c1-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="888c1-108">Elas também podem descrever programas incompletos, enquanto você os escreve no editor.</span><span class="sxs-lookup"><span data-stu-id="888c1-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="888c1-109">Para habilitar essa expressão avançada, as estruturas de dados e as APIs que compõem a API de sintaxe são necessariamente complexas.</span><span class="sxs-lookup"><span data-stu-id="888c1-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="888c1-110">Começaremos com a aparência da estrutura de dados para o programa "Olá, Mundo" típico:</span><span class="sxs-lookup"><span data-stu-id="888c1-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="888c1-111">Veja o texto do programa anterior.</span><span class="sxs-lookup"><span data-stu-id="888c1-111">Look at the text of the previous program.</span></span> <span data-ttu-id="888c1-112">Você reconhece elementos familiares.</span><span class="sxs-lookup"><span data-stu-id="888c1-112">You recognize familiar elements.</span></span> <span data-ttu-id="888c1-113">O texto inteiro representa um único arquivo de origem, ou uma **unidade de compilação**.</span><span class="sxs-lookup"><span data-stu-id="888c1-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="888c1-114">As três primeiras linhas do arquivo de origem são **diretivas de uso**.</span><span class="sxs-lookup"><span data-stu-id="888c1-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="888c1-115">A origem restante está contida em uma **declaração de namespace**.</span><span class="sxs-lookup"><span data-stu-id="888c1-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="888c1-116">A declaração de namespace contém uma **declaração de classe** filha.</span><span class="sxs-lookup"><span data-stu-id="888c1-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="888c1-117">A declaração de classe contém uma **declaração de método**.</span><span class="sxs-lookup"><span data-stu-id="888c1-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="888c1-118">A API de sintaxe cria uma estrutura de árvore com a raiz que representa a unidade de compilação.</span><span class="sxs-lookup"><span data-stu-id="888c1-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="888c1-119">Nós da árvore representam as diretivas using, a declaração de namespace e todos os outros elementos do programa.</span><span class="sxs-lookup"><span data-stu-id="888c1-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="888c1-120">A estrutura de árvore continua até os níveis mais baixos: a cadeia de caracteres "Olá, Mundo!"</span><span class="sxs-lookup"><span data-stu-id="888c1-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="888c1-121">é um **token literal da cadeia de caracteres** que é um descendente de um **argumento**.</span><span class="sxs-lookup"><span data-stu-id="888c1-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="888c1-122">A API de sintaxe fornece acesso à estrutura do programa.</span><span class="sxs-lookup"><span data-stu-id="888c1-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="888c1-123">Você pode consultar as práticas recomendadas de código específico, percorrer a árvore inteira para entender o código e criar novas árvores ao modificar a árvore existente.</span><span class="sxs-lookup"><span data-stu-id="888c1-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="888c1-124">Essa breve descrição fornece uma visão geral do tipo de informações acessíveis usando a API de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="888c1-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="888c1-125">A API de sintaxe não é nada mais de uma API formal que descreve os constructos de código familiares que você conhece do C#.</span><span class="sxs-lookup"><span data-stu-id="888c1-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="888c1-126">As funcionalidades completas incluem informações sobre como o código é formatado, incluindo quebras de linha, espaço em branco e recuo.</span><span class="sxs-lookup"><span data-stu-id="888c1-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="888c1-127">Usando essas informações, você pode representar totalmente o código como escrito e lido por programadores humanos ou pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="888c1-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="888c1-128">Usar essa estrutura permite que você interaja com o código-fonte em um nível muito significativo.</span><span class="sxs-lookup"><span data-stu-id="888c1-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="888c1-129">Não se trata mais de cadeias de caracteres de texto, mas de dados que representam a estrutura de um programa C#.</span><span class="sxs-lookup"><span data-stu-id="888c1-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="888c1-130">Para começar, será necessário instalar o **SDK do .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="888c1-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="888c1-131">Noções básicas sobre árvores de sintaxe</span><span class="sxs-lookup"><span data-stu-id="888c1-131">Understanding syntax trees</span></span>

<span data-ttu-id="888c1-132">Você pode usar a API de sintaxe para uma análise da estrutura do código C#.</span><span class="sxs-lookup"><span data-stu-id="888c1-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="888c1-133">A **API de sintaxe** expõe os analisadores, as árvores de sintaxe e os utilitários para analisar e criar árvores de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="888c1-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="888c1-134">Trata-se do modo como você pesquisa o código em busca de elementos de sintaxe específicos ou lê o código para um programa.</span><span class="sxs-lookup"><span data-stu-id="888c1-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="888c1-135">Uma árvore de sintaxe é uma estrutura de dados usada pelos compiladores C# e Visual Basic para entender programas nessas linguagens.</span><span class="sxs-lookup"><span data-stu-id="888c1-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="888c1-136">Árvores de sintaxe são produzidas pelo mesmo analisador que é executado quando um projeto é compilado ou quando um desenvolvedor pressiona F5.</span><span class="sxs-lookup"><span data-stu-id="888c1-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="888c1-137">As árvores de sintaxe têm fidelidade total com à linguagem de programação; cada bit de informações em um arquivo de código é representado na árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="888c1-138">Gravar uma árvore de sintaxe em texto reproduz o texto original exato que foi analisado.</span><span class="sxs-lookup"><span data-stu-id="888c1-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="888c1-139">As árvores de sintaxe também são **imutáveis**; uma vez criada, uma árvore de sintaxe nunca pode ser alterada.</span><span class="sxs-lookup"><span data-stu-id="888c1-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="888c1-140">Os consumidores de árvores podem analisar as árvores de vários threads, sem bloqueios ou outras medidas de simultaneidade, sabendo que os dados nunca são alterados.</span><span class="sxs-lookup"><span data-stu-id="888c1-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="888c1-141">Você pode usar APIs para criar novas árvores que são o resultado da modificação de uma árvore existente.</span><span class="sxs-lookup"><span data-stu-id="888c1-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="888c1-142">Os quatro principais blocos de construção de árvores de sintaxe são:</span><span class="sxs-lookup"><span data-stu-id="888c1-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="888c1-143">A classe <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, uma instância da qual representa uma árvore de análise inteira.</span><span class="sxs-lookup"><span data-stu-id="888c1-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="888c1-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> é uma classe abstrata que tem derivativos específicos a um idioma.</span><span class="sxs-lookup"><span data-stu-id="888c1-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="888c1-145">Você usa os métodos Parse da classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) para analisar o texto em C# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="888c1-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or Visual Basic.</span></span>
* <span data-ttu-id="888c1-146">A classe <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>, instâncias da qual representam constructos sintáticos como declarações, instruções, cláusulas e expressões.</span><span class="sxs-lookup"><span data-stu-id="888c1-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="888c1-147">A estrutura <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, que representa uma pontuação, operador, identificador ou palavra-chave individual.</span><span class="sxs-lookup"><span data-stu-id="888c1-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="888c1-148">Finalmente, a estrutura <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>, que representa os bits de informação sem significância sintática, tais como o espaço em branco entre tokens, diretivas de pré-processamento e comentários.</span><span class="sxs-lookup"><span data-stu-id="888c1-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="888c1-149">Trívia, tokens e nós são compostos hierarquicamente para formar uma árvore que representa completamente tudo em um fragmento de código do Visual Basic ou do C#.</span><span class="sxs-lookup"><span data-stu-id="888c1-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="888c1-150">Você pode ver essa estrutura usando a janela **Visualizador de Sintaxe**.</span><span class="sxs-lookup"><span data-stu-id="888c1-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="888c1-151">No Visual Studio, escolha **Exibição** > **Outras Janelas** > **Visualizador de Sintaxe**.</span><span class="sxs-lookup"><span data-stu-id="888c1-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="888c1-152">Por exemplo, o arquivo de origem C# anterior examinado usando o **Visualizador de Sintaxe** se parecerá com a figura a seguir:</span><span class="sxs-lookup"><span data-stu-id="888c1-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="888c1-153">**SyntaxNode**: Azul | **SyntaxToken**: Verde | **SyntaxTrivia**: Vermelho ![Arquivo de Código C#](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="888c1-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="888c1-154">Ao navegar nessa estrutura de árvore, você pode encontrar qualquer instrução, expressão, token ou bit de espaço em branco em um arquivo de código.</span><span class="sxs-lookup"><span data-stu-id="888c1-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="888c1-155">Embora você possa encontrar tudo em um arquivo de código usando as APIs de sintaxe, a maioria dos cenários envolvem o exame de pequenos snippets de código ou a pesquisa por instruções ou fragmentos específicos.</span><span class="sxs-lookup"><span data-stu-id="888c1-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="888c1-156">Os dois exemplos a seguir mostram usos típicos para navegar pela estrutura de códigos ou pesquisar por instruções individuais.</span><span class="sxs-lookup"><span data-stu-id="888c1-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="888c1-157">Percorrendo árvores</span><span class="sxs-lookup"><span data-stu-id="888c1-157">Traversing trees</span></span>

<span data-ttu-id="888c1-158">Você pode examinar os nós em uma árvore de sintaxe de duas maneiras.</span><span class="sxs-lookup"><span data-stu-id="888c1-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="888c1-159">Você pode percorrer a árvore para examinar cada nó, ou então consultar elementos ou nós específicos.</span><span class="sxs-lookup"><span data-stu-id="888c1-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="888c1-160">Passagem manual</span><span class="sxs-lookup"><span data-stu-id="888c1-160">Manual traversal</span></span>

<span data-ttu-id="888c1-161">Você pode ver o código concluído para essa amostra no [nosso repositório do GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="888c1-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="888c1-162">Os tipos de árvore de sintaxe usam a herança para descrever os elementos de sintaxe diferentes que são válidos em locais diferentes no programa.</span><span class="sxs-lookup"><span data-stu-id="888c1-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="888c1-163">Usar essas APIs geralmente significa converter propriedades ou membros da coleção em tipos derivados específicos.</span><span class="sxs-lookup"><span data-stu-id="888c1-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="888c1-164">Nos exemplos a seguir, a atribuição e as conversões são instruções separadas, usando variáveis explicitamente tipadas.</span><span class="sxs-lookup"><span data-stu-id="888c1-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="888c1-165">Você pode ler o código para ver os tipos de retorno da API e o tipo de runtime dos objetos retornados.</span><span class="sxs-lookup"><span data-stu-id="888c1-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="888c1-166">Na prática, é mais comum usar variáveis implicitamente tipadas e depender de nomes de API para descrever o tipo de objeto que está sendo examinado.</span><span class="sxs-lookup"><span data-stu-id="888c1-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="888c1-167">Criar um novo projeto de **Ferramenta de Análise de Código Autônoma** do C#:</span><span class="sxs-lookup"><span data-stu-id="888c1-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="888c1-168">No Visual Studio, escolha **Arquivo** > **Novo** > **Projeto** para exibir a caixa de diálogo Novo Projeto.</span><span class="sxs-lookup"><span data-stu-id="888c1-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="888c1-169">Em **Visual C#**  > **Extensibilidade**, escolha **Ferramenta de Análise de Código Autônoma**.</span><span class="sxs-lookup"><span data-stu-id="888c1-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="888c1-170">Nomeie o projeto "**SyntaxTreeManualTraversal**" e clique em OK.</span><span class="sxs-lookup"><span data-stu-id="888c1-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="888c1-171">Você analisará o programa "Olá, Mundo!" básico</span><span class="sxs-lookup"><span data-stu-id="888c1-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="888c1-172">mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="888c1-172">program shown earlier.</span></span>
<span data-ttu-id="888c1-173">Adicione o texto ao programa Olá, Mundo como uma constante em sua classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="888c1-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="888c1-174">Em seguida, adicione o código a seguir para criar a **árvore de sintaxe** para o texto do código na constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="888c1-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="888c1-175">Adicione a seguinte linha ao seu método `Main`:</span><span class="sxs-lookup"><span data-stu-id="888c1-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="888c1-176">Essas duas linhas criam a árvore e recuperam o nó raiz dessa árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="888c1-177">Agora você pode examinar os nós na árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="888c1-178">Adicione essas linhas ao seu método `Main` para exibir algumas das propriedades do nó raiz na árvore:</span><span class="sxs-lookup"><span data-stu-id="888c1-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="888c1-179">Execute o aplicativo para ver o que seu código descobriu sobre o nó raiz nessa árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="888c1-180">Normalmente, percorreria a árvore para saber mais sobre o código.</span><span class="sxs-lookup"><span data-stu-id="888c1-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="888c1-181">Neste exemplo, você está analisando código que você conhece para explorar as APIs.</span><span class="sxs-lookup"><span data-stu-id="888c1-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="888c1-182">Adicione o código a seguir para examinar o primeiro membro do nó `root`:</span><span class="sxs-lookup"><span data-stu-id="888c1-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="888c1-183">Esse membro é um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="888c1-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="888c1-184">Ele representa tudo no escopo da declaração `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="888c1-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="888c1-185">Adicione o seguinte código para examinar quais nós são declarados dentro do namespace `HelloWorld`:</span><span class="sxs-lookup"><span data-stu-id="888c1-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="888c1-186">Execute o programa para ver o que você aprendeu.</span><span class="sxs-lookup"><span data-stu-id="888c1-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="888c1-187">Agora que você sabe que a declaração é um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare uma nova variável de tipo para examinar a declaração de classe.</span><span class="sxs-lookup"><span data-stu-id="888c1-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="888c1-188">Essa classe contém somente um membro: o método `Main`.</span><span class="sxs-lookup"><span data-stu-id="888c1-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="888c1-189">Adicione o código a seguir para localizar o método `Main` e convertê-lo em um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="888c1-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="888c1-190">O nó de declaração do método contém todas as informações de sintaxe sobre o método.</span><span class="sxs-lookup"><span data-stu-id="888c1-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="888c1-191">Permite exibir o tipo de retorno do método `Main`, o número e os tipos dos argumentos e o texto do corpo do método.</span><span class="sxs-lookup"><span data-stu-id="888c1-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="888c1-192">Adicione o seguinte código:</span><span class="sxs-lookup"><span data-stu-id="888c1-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="888c1-193">Execute o programa para ver todas as informações que você descobriu sobre este programa:</span><span class="sxs-lookup"><span data-stu-id="888c1-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="888c1-194">Métodos de consulta</span><span class="sxs-lookup"><span data-stu-id="888c1-194">Query methods</span></span>

<span data-ttu-id="888c1-195">Além de percorrer árvores, você também pode explorar a árvore de sintaxe usando os métodos de consulta definidos em <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="888c1-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="888c1-196">Esses métodos devem ser imediatamente familiares a qualquer pessoa familiarizada com o XPath.</span><span class="sxs-lookup"><span data-stu-id="888c1-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="888c1-197">Você pode usar esses métodos com o LINQ para localizar itens rapidamente em uma árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="888c1-198">O <xref:Microsoft.CodeAnalysis.SyntaxNode> tem métodos de consulta como <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> e <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="888c1-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="888c1-199">Você pode usar esses métodos de consulta para localizar o argumento para o método `Main` como uma alternativa a navegar pela árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="888c1-200">Adicione o seguinte código à parte inferior do método `Main`:</span><span class="sxs-lookup"><span data-stu-id="888c1-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="888c1-201">A primeira instrução usa uma expressão LINQ e o método <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> para localizar o mesmo parâmetro do exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="888c1-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="888c1-202">Execute o programa e você poderá ver que a expressão LINQ encontrou o mesmo parâmetro encontrado ao navegar manualmente pela árvore.</span><span class="sxs-lookup"><span data-stu-id="888c1-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="888c1-203">O exemplo usa instruções `WriteLine` para exibir informações sobre as árvores de sintaxe conforme elas são percorridas.</span><span class="sxs-lookup"><span data-stu-id="888c1-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="888c1-204">Você também pode aprender mais executando o programa concluído no depurador.</span><span class="sxs-lookup"><span data-stu-id="888c1-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="888c1-205">Você pode examinar mais das propriedades e métodos que fazem parte da árvore de sintaxe criada para o programa Olá, Mundo.</span><span class="sxs-lookup"><span data-stu-id="888c1-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="888c1-206">Caminhadores de sintaxe</span><span class="sxs-lookup"><span data-stu-id="888c1-206">Syntax walkers</span></span>

<span data-ttu-id="888c1-207">Muitas vezes, você deseja localizar todos os nós de um tipo específico em uma árvore de sintaxe, por exemplo, cada declaração de propriedade em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="888c1-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="888c1-208">Ao estender a classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> e substituir o método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)>, você processa cada declaração de propriedade em uma árvore de sintaxe sem conhecer a estrutura dele com antecedência.</span><span class="sxs-lookup"><span data-stu-id="888c1-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="888c1-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> é um tipo específico de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor>, que visita recursivamente um nó e cada um dos filhos desse nó.</span><span class="sxs-lookup"><span data-stu-id="888c1-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="888c1-210">Este exemplo implementa um <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> que examina uma árvore de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="888c1-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="888c1-211">Ele coleta diretivas `using` que ele constata que não estão importando um namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="888c1-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="888c1-212">Crie um novo projeto de **Ferramenta de Análise de Código Autônoma** do C#; nomeie-o "**SyntaxWalker**".</span><span class="sxs-lookup"><span data-stu-id="888c1-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="888c1-213">Você pode ver o código concluído para essa amostra no [nosso repositório do GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="888c1-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="888c1-214">A amostra no GitHub contém os dois projetos descritos neste tutorial.</span><span class="sxs-lookup"><span data-stu-id="888c1-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="888c1-215">Assim como no exemplo anterior, você pode definir uma constante de cadeia de caracteres para conter o texto do programa que você pretende analisar:</span><span class="sxs-lookup"><span data-stu-id="888c1-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="888c1-216">Este texto de origem contém diretivas `using` espalhadas em quatro locais diferentes: o nível de arquivo, no namespace de nível superior e nos dois namespaces aninhados.</span><span class="sxs-lookup"><span data-stu-id="888c1-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="888c1-217">Este exemplo destaca um cenário principal para usar a classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> para consultar código.</span><span class="sxs-lookup"><span data-stu-id="888c1-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="888c1-218">Seria complicado visitar cada nó na árvore de sintaxe de raiz para encontrar declarações using.</span><span class="sxs-lookup"><span data-stu-id="888c1-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="888c1-219">Em vez disso, você pode criar uma classe derivada e substituir o método chamado apenas quando o nó atual na árvore é uma diretiva using.</span><span class="sxs-lookup"><span data-stu-id="888c1-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="888c1-220">O visitante não realiza nenhum trabalho em nenhum outro tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="888c1-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="888c1-221">Esse método único examina cada uma das instruções `using` e compila uma coleção de namespaces que não estão no namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="888c1-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="888c1-222">Você compila um <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> que examina todas as instruções `using`, mas apenas as instruções `using`.</span><span class="sxs-lookup"><span data-stu-id="888c1-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="888c1-223">Agora que você definiu o texto do programa, você precisa criar um `SyntaxTree` e obter a raiz dessa árvore:</span><span class="sxs-lookup"><span data-stu-id="888c1-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="888c1-224">Em seguida, crie uma nova classe.</span><span class="sxs-lookup"><span data-stu-id="888c1-224">Next, create a new class.</span></span> <span data-ttu-id="888c1-225">No Visual Studio, escolha **Projeto** > **Adicionar Novo Item**.</span><span class="sxs-lookup"><span data-stu-id="888c1-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="888c1-226">Na caixa de diálogo **Adicionar Novo Item**, digite *UsingCollector.cs* como o nome do arquivo.</span><span class="sxs-lookup"><span data-stu-id="888c1-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="888c1-227">Você implementa a funcionalidade de visitante `using` na classe `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="888c1-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="888c1-228">Para começar, crie a classe `UsingCollector` derivada de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="888c1-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="888c1-229">Você precisa de armazenamento para conter os nós de namespace que você está coletando.</span><span class="sxs-lookup"><span data-stu-id="888c1-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="888c1-230">Declare uma propriedade pública somente leitura na classe `UsingCollector`; use essa variável para armazenar os nós <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> que você encontrar:</span><span class="sxs-lookup"><span data-stu-id="888c1-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="888c1-231">A classe base <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implementa a lógica para visitar cada nó na árvore de sintaxe.</span><span class="sxs-lookup"><span data-stu-id="888c1-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="888c1-232">A classe derivada substitui os métodos chamados para os nós específicos nos quais você está interessado.</span><span class="sxs-lookup"><span data-stu-id="888c1-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="888c1-233">Nesse caso, você está interessado em qualquer diretiva `using`.</span><span class="sxs-lookup"><span data-stu-id="888c1-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="888c1-234">Isso significa que você deve substituir o método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="888c1-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="888c1-235">Um argumento para esse método é um objeto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="888c1-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="888c1-236">Essa é uma importante vantagem de se usar os visitantes: eles chamam os métodos substituídos com argumentos que já foram convertidos para o tipo de nó específico.</span><span class="sxs-lookup"><span data-stu-id="888c1-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="888c1-237">A classe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> tem uma propriedade <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> que armazena o nome do namespace que está sendo importado.</span><span class="sxs-lookup"><span data-stu-id="888c1-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="888c1-238">É um <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="888c1-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="888c1-239">Adicione o código a seguir na substituição <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="888c1-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="888c1-240">Assim como no exemplo anterior, você adicionou uma variedade de instruções `WriteLine` para ajudar na compreensão do método.</span><span class="sxs-lookup"><span data-stu-id="888c1-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="888c1-241">Você pode ver quando ele é chamado e quais argumentos são passados para ele a cada vez.</span><span class="sxs-lookup"><span data-stu-id="888c1-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="888c1-242">Por fim, você precisa adicionar duas linhas de código para criar o `UsingCollector` e fazer com que ele acesse o nó raiz, coletando todas as instruções `using`.</span><span class="sxs-lookup"><span data-stu-id="888c1-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="888c1-243">Em seguida, adicione um loop `foreach` para exibir todas as instruções `using` encontradas pelo seu coletor:</span><span class="sxs-lookup"><span data-stu-id="888c1-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="888c1-244">Compile e execute o programa.</span><span class="sxs-lookup"><span data-stu-id="888c1-244">Compile and run the program.</span></span> <span data-ttu-id="888c1-245">Você deverá ver a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="888c1-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="888c1-246">Parabéns!</span><span class="sxs-lookup"><span data-stu-id="888c1-246">Congratulations!</span></span> <span data-ttu-id="888c1-247">Você usou a **API de sintaxe** para localizar tipos específicos de instruções C# e declarações em código-fonte C#.</span><span class="sxs-lookup"><span data-stu-id="888c1-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
