---
title: Criar tipos de mixin usando métodos de interface padrão
description: Usando membros de interface padrão, você pode estender interfaces com implementações padrão opcionais para implementores.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: aaf8d34e27c9c56d95560656eb7a7b24b152c053
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240100"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="ac1da-103">Tutorial: Misture a funcionalidade ao criar classes usando interfaces com métodos de interface padrão</span><span class="sxs-lookup"><span data-stu-id="ac1da-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="ac1da-104">Desde o C# 8.0 no .NET Core 3.0, é possível definir uma implementação em que você declara um membro de uma interface.</span><span class="sxs-lookup"><span data-stu-id="ac1da-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="ac1da-105">Esse recurso fornece novos recursos onde você pode definir implementações padrão para recursos declarados em interfaces.</span><span class="sxs-lookup"><span data-stu-id="ac1da-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="ac1da-106">As classes podem escolher quando substituir a funcionalidade, quando usar a funcionalidade padrão e quando não declarar suporte para recursos discretos.</span><span class="sxs-lookup"><span data-stu-id="ac1da-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="ac1da-107">Neste tutorial, você aprenderá como:</span><span class="sxs-lookup"><span data-stu-id="ac1da-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="ac1da-108">Crie interfaces com implementações que descrevam recursos discretos.</span><span class="sxs-lookup"><span data-stu-id="ac1da-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="ac1da-109">Crie classes que usam as implementações padrão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="ac1da-110">Crie classes que sobrepõem algumas ou todas as implementações padrão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="ac1da-111">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="ac1da-111">Prerequisites</span></span>

<span data-ttu-id="ac1da-112">Você precisará configurar sua máquina para executar o .NET Core, incluindo o compilador C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="ac1da-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="ac1da-113">O compilador C# 8.0 está disponível a partir da [versão 16.3 do Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), ou do [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) ou posterior.</span><span class="sxs-lookup"><span data-stu-id="ac1da-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="ac1da-114">Limitações dos métodos de extensão</span><span class="sxs-lookup"><span data-stu-id="ac1da-114">Limitations of extension methods</span></span>

<span data-ttu-id="ac1da-115">Uma maneira de implementar o comportamento que aparece como parte de uma interface é definir métodos de [extensão](../programming-guide/classes-and-structs/extension-methods.md) que fornecem o comportamento padrão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="ac1da-116">As interfaces declaram um conjunto mínimo de membros, ao mesmo tempo em que fornecem uma área de superfície maior para qualquer classe que implemente essa interface.</span><span class="sxs-lookup"><span data-stu-id="ac1da-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="ac1da-117">Por exemplo, os métodos de extensão fornecem <xref:System.Linq.Enumerable> a implementação para que qualquer seqüência seja a fonte de uma consulta LINQ.</span><span class="sxs-lookup"><span data-stu-id="ac1da-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="ac1da-118">Os métodos de extensão são resolvidos no momento da compilação, utilizando o tipo declarado da variável.</span><span class="sxs-lookup"><span data-stu-id="ac1da-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="ac1da-119">As classes que implementam a interface podem fornecer uma melhor implementação para qualquer método de extensão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="ac1da-120">As declarações variáveis devem corresponder ao tipo de implementação para permitir que o compilador escolha essa implementação.</span><span class="sxs-lookup"><span data-stu-id="ac1da-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="ac1da-121">Quando o tipo de tempo de compilação corresponde à interface, as chamadas do método resolvem para o método de extensão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="ac1da-122">Outra preocupação com os métodos de extensão é que esses métodos são acessíveis onde a classe que contém os métodos de extensão é acessível.</span><span class="sxs-lookup"><span data-stu-id="ac1da-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="ac1da-123">As classes não podem declarar se devem ou não fornecer recursos declarados em métodos de extensão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="ac1da-124">Começando com C# 8.0, você pode declarar as implementações padrão como métodos de interface.</span><span class="sxs-lookup"><span data-stu-id="ac1da-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="ac1da-125">Em seguida, cada classe usa automaticamente a implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="ac1da-126">Qualquer classe que possa fornecer uma melhor implementação pode substituir a definição do método de interface com um algoritmo melhor.</span><span class="sxs-lookup"><span data-stu-id="ac1da-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="ac1da-127">Em certo sentido, essa técnica soa semelhante à forma como você poderia usar [métodos de extensão](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="ac1da-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="ac1da-128">Neste artigo, você aprenderá como implementações de interface padrão permitem novos cenários.</span><span class="sxs-lookup"><span data-stu-id="ac1da-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="ac1da-129">Projete o aplicativo</span><span class="sxs-lookup"><span data-stu-id="ac1da-129">Design the application</span></span>

<span data-ttu-id="ac1da-130">Considere um aplicativo de automação residencial.</span><span class="sxs-lookup"><span data-stu-id="ac1da-130">Consider a home automation application.</span></span> <span data-ttu-id="ac1da-131">Você provavelmente tem muitos tipos diferentes de luzes e indicadores que poderiam ser usados em toda a casa.</span><span class="sxs-lookup"><span data-stu-id="ac1da-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="ac1da-132">Todas as luzes devem apoiar as APIs para atilá-las e reportá-las e informar o estado atual.</span><span class="sxs-lookup"><span data-stu-id="ac1da-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="ac1da-133">Algumas luzes e indicadores podem suportar outras características, tais como:</span><span class="sxs-lookup"><span data-stu-id="ac1da-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="ac1da-134">Acenda a luz e desligue-a depois de um temporizador.</span><span class="sxs-lookup"><span data-stu-id="ac1da-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="ac1da-135">Pisque a luz por um período de tempo.</span><span class="sxs-lookup"><span data-stu-id="ac1da-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="ac1da-136">Alguns desses recursos estendidos podem ser emulados em dispositivos que suportam o conjunto mínimo.</span><span class="sxs-lookup"><span data-stu-id="ac1da-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="ac1da-137">Isso indica fornecer uma implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="ac1da-138">Para aqueles dispositivos que têm mais recursos incorporados, o software do dispositivo usaria os recursos nativos.</span><span class="sxs-lookup"><span data-stu-id="ac1da-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="ac1da-139">Para outras luzes, eles poderiam optar por implementar a interface e usar a implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="ac1da-140">Membros de interface padrão são uma solução melhor para este cenário do que métodos de extensão.</span><span class="sxs-lookup"><span data-stu-id="ac1da-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="ac1da-141">Os autores de classe podem controlar quais interfaces eles escolhem implementar.</span><span class="sxs-lookup"><span data-stu-id="ac1da-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="ac1da-142">Essas interfaces que eles escolhem estão disponíveis como métodos.</span><span class="sxs-lookup"><span data-stu-id="ac1da-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="ac1da-143">Além disso, como os métodos de interface padrão são virtuais por padrão, o despacho de métodosempre escolhe a implementação na classe.</span><span class="sxs-lookup"><span data-stu-id="ac1da-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="ac1da-144">Vamos criar o código para demonstrar essas diferenças.</span><span class="sxs-lookup"><span data-stu-id="ac1da-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="ac1da-145">Criar interfaces</span><span class="sxs-lookup"><span data-stu-id="ac1da-145">Create interfaces</span></span>

<span data-ttu-id="ac1da-146">Comece criando a interface que define o comportamento de todas as luzes:</span><span class="sxs-lookup"><span data-stu-id="ac1da-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="ac1da-147">Uma luminária de sobrecarga básica pode implementar esta interface como mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="ac1da-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="ac1da-148">Neste tutorial, o código não conduz dispositivos IoT, mas emula essas atividades escrevendo mensagens para o console.</span><span class="sxs-lookup"><span data-stu-id="ac1da-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="ac1da-149">Você pode explorar o código sem automatizar sua casa.</span><span class="sxs-lookup"><span data-stu-id="ac1da-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="ac1da-150">Em seguida, vamos definir a interface para uma luz que pode desligar automaticamente após um intervalo de tempo:</span><span class="sxs-lookup"><span data-stu-id="ac1da-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="ac1da-151">Você pode adicionar uma implementação básica à luz aérea, mas uma `virtual` solução melhor é modificar essa definição de interface para fornecer uma implementação padrão:</span><span class="sxs-lookup"><span data-stu-id="ac1da-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="ac1da-152">Adicionando essa alteração, a `OverheadLight` classe pode implementar a função temporizador declarando suporte para a interface:</span><span class="sxs-lookup"><span data-stu-id="ac1da-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="ac1da-153">Um tipo de luz diferente pode suportar um protocolo mais sofisticado.</span><span class="sxs-lookup"><span data-stu-id="ac1da-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="ac1da-154">Ele pode fornecer sua `TurnOnFor`própria implementação para, como mostrado no seguinte código:</span><span class="sxs-lookup"><span data-stu-id="ac1da-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="ac1da-155">Ao contrário de dominar métodos `TurnOnFor` de `HalogenLight` classe virtual, `override` a declaração da classe não usa a palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="ac1da-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="ac1da-156">Misturar e combinar capacidades</span><span class="sxs-lookup"><span data-stu-id="ac1da-156">Mix and match capabilities</span></span>

<span data-ttu-id="ac1da-157">As vantagens dos métodos de interface padrão tornam-se mais claras à medida que você introduz recursos mais avançados.</span><span class="sxs-lookup"><span data-stu-id="ac1da-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="ac1da-158">O uso de interfaces permite misturar e combinar recursos.</span><span class="sxs-lookup"><span data-stu-id="ac1da-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="ac1da-159">Ele também permite que cada autor de classe escolha entre a implementação padrão e uma implementação personalizada.</span><span class="sxs-lookup"><span data-stu-id="ac1da-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="ac1da-160">Vamos adicionar uma interface com uma implementação padrão para uma luz piscando:</span><span class="sxs-lookup"><span data-stu-id="ac1da-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="ac1da-161">A implementação padrão permite que qualquer luz pisce.</span><span class="sxs-lookup"><span data-stu-id="ac1da-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="ac1da-162">A luz de sobrecarga pode adicionar recursos de temporizador e piscar usando a implementação padrão:</span><span class="sxs-lookup"><span data-stu-id="ac1da-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="ac1da-163">Um novo tipo `LEDLight` de luz, suporta tanto a função do temporizador quanto a função blink diretamente.</span><span class="sxs-lookup"><span data-stu-id="ac1da-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="ac1da-164">Este estilo de luz `ITimerLight` `IBlinkingLight` implementa as interfaces `Blink` e substitui o método:</span><span class="sxs-lookup"><span data-stu-id="ac1da-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="ac1da-165">Um `ExtraFancyLight` pode suportar funções de piscar e temporizador diretamente:</span><span class="sxs-lookup"><span data-stu-id="ac1da-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="ac1da-166">O `HalogenLight` que você criou anteriormente não suporta piscar.</span><span class="sxs-lookup"><span data-stu-id="ac1da-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="ac1da-167">Então, não adicione a `IBlinkingLight` lista de suas interfaces suportadas.</span><span class="sxs-lookup"><span data-stu-id="ac1da-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="ac1da-168">Detecte os tipos de luz usando correspondência de padrão</span><span class="sxs-lookup"><span data-stu-id="ac1da-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="ac1da-169">Em seguida, vamos escrever algum código de teste.</span><span class="sxs-lookup"><span data-stu-id="ac1da-169">Next, let's write some test code.</span></span> <span data-ttu-id="ac1da-170">Você pode fazer uso do recurso de correspondência de [padrões](../pattern-matching.md) de C#para determinar as capacidades de uma luz examinando quais interfaces ela suporta.</span><span class="sxs-lookup"><span data-stu-id="ac1da-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="ac1da-171">O método a seguir exerce as capacidades suportadas de cada luz:</span><span class="sxs-lookup"><span data-stu-id="ac1da-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="ac1da-172">O código a `Main` seguir no seu método cria cada tipo de luz em seqüência e testa essa luz:</span><span class="sxs-lookup"><span data-stu-id="ac1da-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="ac1da-173">Como o compilador determina a melhor implementação</span><span class="sxs-lookup"><span data-stu-id="ac1da-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="ac1da-174">Este cenário mostra uma interface base sem implementações.</span><span class="sxs-lookup"><span data-stu-id="ac1da-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="ac1da-175">Adicionar um método `ILight` à interface introduz novas complexidades.</span><span class="sxs-lookup"><span data-stu-id="ac1da-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="ac1da-176">As regras de idioma que regem os métodos de interface padrão minimizam o efeito nas classes concretas que implementam múltiplas interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="ac1da-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="ac1da-177">Vamos melhorar a interface original com um novo método para mostrar como isso muda seu uso.</span><span class="sxs-lookup"><span data-stu-id="ac1da-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="ac1da-178">Cada luz indicadora pode relatar seu status de potência como um valor enumerado:</span><span class="sxs-lookup"><span data-stu-id="ac1da-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="ac1da-179">A implementação padrão assume a potência CA:</span><span class="sxs-lookup"><span data-stu-id="ac1da-179">The default implementation assumes AC power:</span></span>

[!code-csharp[Report a default power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="ac1da-180">Essas alterações compilam de `ExtraFancyLight` forma limpa, `ILight` embora o suporte declarado `ITimerLight` para `IBlinkingLight`a interface e ambas as interfaces derivadas, e .</span><span class="sxs-lookup"><span data-stu-id="ac1da-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="ac1da-181">Há apenas uma implementação "mais próxima" `ILight` declarada na interface.</span><span class="sxs-lookup"><span data-stu-id="ac1da-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="ac1da-182">Qualquer classe que declarasse uma substituição se tornaria a implementação "mais próxima".</span><span class="sxs-lookup"><span data-stu-id="ac1da-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="ac1da-183">Você viu exemplos nas classes anteriores que sobreporam os membros de outras interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="ac1da-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="ac1da-184">Evite sobrepor o mesmo método em várias interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="ac1da-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="ac1da-185">Isso cria uma chamada de método ambígua sempre que uma classe implementa ambas as interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="ac1da-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="ac1da-186">O compilador não pode escolher um único método melhor, então ele emite um erro.</span><span class="sxs-lookup"><span data-stu-id="ac1da-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="ac1da-187">Por exemplo, se `IBlinkingLight` `ITimerLight` o e implementado `PowerStatus`um `OverheadLight` sobreposição de , a necessidade de fornecer uma substituição mais específica.</span><span class="sxs-lookup"><span data-stu-id="ac1da-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="ac1da-188">Caso contrário, o compilador não pode escolher entre as implementações nas duas interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="ac1da-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="ac1da-189">Você geralmente pode evitar essa situação mantendo as definições de interface pequenas e focadas em um recurso.</span><span class="sxs-lookup"><span data-stu-id="ac1da-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="ac1da-190">Nesse cenário, cada capacidade de uma luz é sua própria interface; interfaces múltiplas são herdadas apenas por classes.</span><span class="sxs-lookup"><span data-stu-id="ac1da-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="ac1da-191">Esta amostra mostra um cenário onde você pode definir características discretas que podem ser misturadas em classes.</span><span class="sxs-lookup"><span data-stu-id="ac1da-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="ac1da-192">Você declara qualquer conjunto de funcionalidades suportadas declarando quais interfaces uma classe suporta.</span><span class="sxs-lookup"><span data-stu-id="ac1da-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="ac1da-193">O uso de métodos de interface padrão virtuais permite que as classes usem ou definam uma implementação diferente para qualquer ou todos os métodos de interface.</span><span class="sxs-lookup"><span data-stu-id="ac1da-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="ac1da-194">Este recurso de linguagem fornece novas maneiras de modelar os sistemas do mundo real que você está construindo.</span><span class="sxs-lookup"><span data-stu-id="ac1da-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="ac1da-195">Os métodos de interface padrão fornecem uma maneira mais clara de expressar classes relacionadas que podem misturar e combinar diferentes recursos usando implementações virtuais desses recursos.</span><span class="sxs-lookup"><span data-stu-id="ac1da-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
