### YamlMime:Tutorial
title: <span data-ttu-id="6b34d-101">Explorar o C# 7.0 – Tutorial interativo do C#</span><span class="sxs-lookup"><span data-stu-id="6b34d-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Explorar o C# 7.0 – Experimente os novos recursos do C# 7.0 de maneira interativa, usando o navegador
  description: Neste tutorial, você usará o navegador para explorar o C# 7.0 de maneira interativa. Você explorará as novas expressões que podem ser usadas com o C# 7.0 que permitem um código mais conciso e legível.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 70f4e93460c69b54702f160d502163827ec73218
  ms.sourcegitcommit: 0aca6c5d166d7961a1e354c248495645b97a1dc5
  ms.translationtype: HT
  ms.contentlocale: pt-BR
  ms.lasthandoff: 03/30/2019
  ms.locfileid: "58675517"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="6b34d-105">Este tutorial permite que você explore os recursos do C# 7.0 de maneira interativa usando o navegador para escrever em C# e ver os resultados da compilação e da execução do código.</span><span class="sxs-lookup"><span data-stu-id="6b34d-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="6b34d-106">Ele contém uma série de lições que modificam as antigas práticas de C# para usar recursos mais novos e mais concisos do C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="6b34d-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="6b34d-107">O restante deste artigo oferece uma visão geral de cada um desses recursos, com um link para explorá-los.</span><span class="sxs-lookup"><span data-stu-id="6b34d-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="6b34d-108">Declarações de variável de saída no local de atribuição</span><span class="sxs-lookup"><span data-stu-id="6b34d-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"6b34d-109\">A sintaxe existente que dá suporte a parâmetros `out` foi aperfeiçoada nesta versão.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"6b34d-110\">Clique no botão *Entrar no Modo de Foco* na parte inferior desta página e, em seguida, tente o seguinte código na janela interativa:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"6b34d-111\">Agora você pode declarar variáveis `out` na lista de argumentos de uma chamada de método, em vez de escrever uma instrução de declaração separada.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"6b34d-112\">Mova a declaração para a chamada de método.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"6b34d-113\">Adicione o seguinte código na parte inferior da janela interativa:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"6b34d-114\">Você pode alterar a declaração `int` para uma declaração `var`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"6b34d-115\">Adicione o seguinte código à janela interativa:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"6b34d-116\">A nova sintaxe fornece duas vantagens importantes em relação à sintaxe existente:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"6b34d-117\">O código é mais fácil de ler.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"6b34d-118\">Você declara a variável out onde a usa, não em outra linha acima.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"6b34d-119\">Não é necessário atribuir um valor inicial.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"6b34d-120\">Ao declarar a variável `out` onde ela é usada em uma chamada de método, você não pode usá-la acidentalmente antes de ela ser atribuída.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"6b34d-121\">O escopo da variável declarada é o escopo delimitador da instrução `if`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"6b34d-122\">Isso permite que você use a variável posteriormente.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"6b34d-123\">Modifique o último bloco `if`, conforme mostrado no snippet a seguir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="6b34d-124">As tuplas criam estruturas de dados leves</span><span class="sxs-lookup"><span data-stu-id="6b34d-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"6b34d-125\">As tuplas são estruturas de dados leves que contêm vários campos para representar os membros de dados.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"6b34d-126\">Os campos não são validados, e você não pode definir seus próprios métodos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"6b34d-127\">As tuplas estavam disponíveis antes do C# 7.0, mas elas eram ineficientes e não tinham nenhum suporte de linguagem.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"6b34d-128\">Isso significava que os elementos de tupla só podiam ser referenciados como `Item1`, `Item2` e assim por diante.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"6b34d-129\">O C# 7.0 introduz o suporte de linguagem para tuplas, que permite nomes semânticos para os campos de uma tupla usando tipos de tupla novos e mais eficientes.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"6b34d-130\">Crie uma tupla atribuindo um valor a cada membro nomeado:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"6b34d-131\">A tupla `namedLetters` contém campos denominados `Alpha` e `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"6b34d-132\">Esses nomes existem somente em tempo de compilação e não são preservados em tempo de execução (durante a inspeção da tupla usando a reflexão, por exemplo).</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"6b34d-133\">Em uma atribuição de tupla, você também pode especificar os nomes dos campos no lado direito da atribuição:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"6b34d-134\">Você poderá especificar nomes para os campos no lado esquerdo e direito da atribuição, mas os nomes no lado direito serão ignorados.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"6b34d-135\">As tuplas são mais úteis como tipos de retorno para os métodos `private` e `internal`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"6b34d-136\">As tuplas fornecem uma sintaxe simples para que esses métodos retornem vários valores discretos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"6b34d-137\">A criação de uma tupla é mais eficiente e produtiva do que a criação de uma classe ou um struct.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"6b34d-138\">Ela tem uma sintaxe mais simples e leve para definir uma estrutura de dados que contém mais de um valor.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"6b34d-139\">O método de exemplo a seguir retorna os valores mínimo e máximo encontrados em uma sequência de inteiros:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-139\">The example method below returns the minimum and maximum values found in a sequence of integers:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"6b34d-140\">Pode haver ocasiões em que você deseja descompactar os membros de uma tupla que foram retornados de um método.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-140\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"6b34d-141\">Você pode fazer isso declarando variáveis separadas para cada um dos valores na tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-141\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"6b34d-142\">Isso é chamado de *desconstrução* da tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-142\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"6b34d-143\">Adicione o seguinte código no navegador para testá-lo:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-143\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"6b34d-144\">Ao trabalhar com tuplas, você descobrirá com frequência que não usa todos os membros de um resultado de tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-144\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"6b34d-145\">Quando isso acontece, você pode indicar que um ou mais dos valores retornados são discards usando `_` no lugar de uma variável.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-145\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"6b34d-146\">Adicione o seguinte código no navegador para testá-lo:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-146\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"6b34d-147\">Saiba mais detalhes sobre tuplas no [artigo sobre tuplas](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-147\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"6b34d-148\">Saiba mais sobre discards no [artigo sobre discards](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-148\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="6b34d-149">Usar o padrão de tipo com a expressão is</span><span class="sxs-lookup"><span data-stu-id="6b34d-149">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="6b34d-150">A expressão `is` padrão estende o [operador`is`](../../language-reference/keywords/is.md#pattern-matching-with-is) familiar para consultar um objeto além de seu tipo.</span><span class="sxs-lookup"><span data-stu-id="6b34d-150">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="6b34d-151">Experimente o seguinte código na janela do navegador:</span><span class="sxs-lookup"><span data-stu-id="6b34d-151">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="6b34d-152">Altere a declaração de variável para uma cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="6b34d-152">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="6b34d-153">Agora, a expressão `is` é falsa e, portanto, o branch `else` é executado.</span><span class="sxs-lookup"><span data-stu-id="6b34d-153">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="6b34d-154">Tente alterar `count` para `number` no branch else:</span><span class="sxs-lookup"><span data-stu-id="6b34d-154">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="6b34d-155">O código acima não será compilado porque `number` não está atribuído no branch `else`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-155">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="6b34d-156">Ele é atribuído somente no branch `true` da instrução `if`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-156">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="6b34d-157">O padrão de tipo da expressão `is` é útil quando você tem um pequeno número de tipos para o teste.</span><span class="sxs-lookup"><span data-stu-id="6b34d-157">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="6b34d-158">Muitas vezes, você poderá precisar testar vários tipos.</span><span class="sxs-lookup"><span data-stu-id="6b34d-158">Often, you may need to test multiple types.</span></span> <span data-ttu-id="6b34d-159">Isso exige a instrução `switch` de correspondência de padrões.</span><span class="sxs-lookup"><span data-stu-id="6b34d-159">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="6b34d-160">Correspondência de padrões com a instrução switch</span><span class="sxs-lookup"><span data-stu-id="6b34d-160">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="6b34d-161">A *expressão de correspondência* tem uma sintaxe familiar, com base na instrução `switch` que já faz parte da linguagem C#.</span><span class="sxs-lookup"><span data-stu-id="6b34d-161">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="6b34d-162">Vamos começar com uma pequena amostra baseada na sintaxe da expressão `is` que você explorou na página anterior:</span><span class="sxs-lookup"><span data-stu-id="6b34d-162">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="6b34d-163">O código anterior verifica se há um `int` ou um `null`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-163">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="6b34d-164">Todos os outros tipos atingiram o caso padrão.</span><span class="sxs-lookup"><span data-stu-id="6b34d-164">Every other type reached the default case.</span></span> <span data-ttu-id="6b34d-165">Adicione as duas seguintes linhas para verificar o comportamento:</span><span class="sxs-lookup"><span data-stu-id="6b34d-165">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="6b34d-166">A expressão `switch` converterá um tipo que permite valor nulo em seu tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="6b34d-166">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="6b34d-167">Adicione o seguinte para verificar:</span><span class="sxs-lookup"><span data-stu-id="6b34d-167">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="6b34d-168">Você pode adicionar qualquer número de outras expressões de padrão de tipo às instruções switch.</span><span class="sxs-lookup"><span data-stu-id="6b34d-168">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="6b34d-169">Adicione o seguinte antes do caso `null`:</span><span class="sxs-lookup"><span data-stu-id="6b34d-169">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="6b34d-170">Verifique se isso funciona adicionando os seguintes testes:</span><span class="sxs-lookup"><span data-stu-id="6b34d-170">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="6b34d-171">As expressões de correspondência também dão suporte a constantes.</span><span class="sxs-lookup"><span data-stu-id="6b34d-171">The match expressions also support constants.</span></span> <span data-ttu-id="6b34d-172">Isso pode poupar tempo ao fatorar expressões case simples:</span><span class="sxs-lookup"><span data-stu-id="6b34d-172">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="6b34d-173">É necessário adicionar o caso anterior *antes* da expressão `case int:`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-173">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="6b34d-174">Se você o adicionar depois desse caso, o compilador avisará você que ele já foi tratado por um caso anterior.</span><span class="sxs-lookup"><span data-stu-id="6b34d-174">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="6b34d-175">Você pode adicionar uma cláusula `when` a qualquer caso de padrão para testar outras condições, além de um tipo ou um valor constante.</span><span class="sxs-lookup"><span data-stu-id="6b34d-175">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="6b34d-176">Experimente-o adicionando o seguinte caso acima do caso `string` geral:</span><span class="sxs-lookup"><span data-stu-id="6b34d-176">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="6b34d-177">Teste-o com algo parecido com o seguinte código:</span><span class="sxs-lookup"><span data-stu-id="6b34d-177">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="6b34d-178">A nova sintaxe para as expressões de correspondência de padrões facilita a criação de algoritmos de expedição usando uma sintaxe clara e concisa com base no tipo de um objeto ou em outras propriedades.</span><span class="sxs-lookup"><span data-stu-id="6b34d-178">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="6b34d-179">Expressões de correspondência de padrões permitem esses constructos em tipos de dados que não são relacionados por herança.</span><span class="sxs-lookup"><span data-stu-id="6b34d-179">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="6b34d-180">Saiba mais sobre a correspondência de padrões no artigo dedicado à [correspondência de padrões no C#](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="6b34d-180">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="6b34d-181">Otimizar o armazenamento de memória usando locais e retornos de ref</span><span class="sxs-lookup"><span data-stu-id="6b34d-181">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="6b34d-182">Esse recurso permite que os algoritmos que usam e retornam referências para as variáveis definidas em outro lugar.</span><span class="sxs-lookup"><span data-stu-id="6b34d-182">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="6b34d-183">Um exemplo ocorre com matrizes grandes e a localização de um único local com determinadas características.</span><span class="sxs-lookup"><span data-stu-id="6b34d-183">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="6b34d-184">Um método retornará aos dois índices um único local na matriz:</span><span class="sxs-lookup"><span data-stu-id="6b34d-184">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="6b34d-185">Você pode testar esse método usando o seguinte código:</span><span class="sxs-lookup"><span data-stu-id="6b34d-185">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="6b34d-186">Esse método `Find` retorna os índices para o item na matriz.</span><span class="sxs-lookup"><span data-stu-id="6b34d-186">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="6b34d-187">Isso leva os chamadores a escreverem um código que usa esses índices para desreferenciar a matriz e modificar um único elemento.</span><span class="sxs-lookup"><span data-stu-id="6b34d-187">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="6b34d-188">Você prefere escrever um método que retorna uma *referência* para o elemento da matriz que deseja alterar.</span><span class="sxs-lookup"><span data-stu-id="6b34d-188">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="6b34d-189">Vamos examinar uma série de alterações para demonstrar o recurso local de ref e mostrar como criar um método que retorna uma referência ao armazenamento interno.</span><span class="sxs-lookup"><span data-stu-id="6b34d-189">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="6b34d-190">Ao longo do caminho, você aprenderá as regras do recurso de retorno e local de ref que protegem contra o uso indevido acidental.</span><span class="sxs-lookup"><span data-stu-id="6b34d-190">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="6b34d-191">Comece modificando a declaração do método `Find` para que ele retorne um `ref int` em vez de uma tupla.</span><span class="sxs-lookup"><span data-stu-id="6b34d-191">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="6b34d-192">Modifique a instrução de retorno para retornar o item nos índices corretos:</span><span class="sxs-lookup"><span data-stu-id="6b34d-192">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="6b34d-193">Altere o retorno final para gerar uma exceção:</span><span class="sxs-lookup"><span data-stu-id="6b34d-193">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="6b34d-194">Observe que isso não será compilado.</span><span class="sxs-lookup"><span data-stu-id="6b34d-194">Note that this won't compile.</span></span> <span data-ttu-id="6b34d-195">A declaração de método indica um retorno de `ref`, mas a instrução de retorno especifica um retorno de valor.</span><span class="sxs-lookup"><span data-stu-id="6b34d-195">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="6b34d-196">É necessário adicionar a palavra-chave `ref` a cada instrução de retorno.</span><span class="sxs-lookup"><span data-stu-id="6b34d-196">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="6b34d-197">Isso indica o retorno pela referência e ajuda os desenvolvedores lendo o código posteriormente a lembrarem que o método retorna pela referência:</span><span class="sxs-lookup"><span data-stu-id="6b34d-197">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="6b34d-198">Agora que o método retorna uma referência para o valor inteiro na matriz, você precisa modificar onde ele é chamado.</span><span class="sxs-lookup"><span data-stu-id="6b34d-198">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="6b34d-199">A declaração `var` significa que `valItem` é agora um `int` em vez de uma tupla.</span><span class="sxs-lookup"><span data-stu-id="6b34d-199">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="6b34d-200">Altere o código de chamada para o seguinte:</span><span class="sxs-lookup"><span data-stu-id="6b34d-200">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="6b34d-201">A segunda instrução `WriteLine` no exemplo acima imprime o valor `42`, não `24`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-201">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="6b34d-202">A variável `valItem` é um `int`, não um `ref int`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-202">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="6b34d-203">A palavra-chave `var` permite que o compilador especifique o tipo, mas não adicionará implicitamente o modificador `ref`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-203">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="6b34d-204">Em vez disso, o valor referenciado pelo `ref return` é *copiado* para a variável no lado esquerdo da atribuição.</span><span class="sxs-lookup"><span data-stu-id="6b34d-204">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="6b34d-205">A variável não é um local de `ref`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-205">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="6b34d-206">Para modificar a referência retornada, você precisará adicionar o modificador `ref` à declaração de variável local e, antes da chamada a `Find`, tornar a variável uma referência quando o valor retornado for uma referência.</span><span class="sxs-lookup"><span data-stu-id="6b34d-206">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="6b34d-207">Modifique o código de teste no navegador para que ele corresponda ao seguinte:</span><span class="sxs-lookup"><span data-stu-id="6b34d-207">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="6b34d-208">Agora, a segunda instrução `WriteLine` no exemplo acima imprimirá o valor `24`, indicando que o armazenamento na matriz foi modificado.</span><span class="sxs-lookup"><span data-stu-id="6b34d-208">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="6b34d-209">A variável local foi declarada com um modificador `ref` e ele levará um retorno de `ref`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-209">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="6b34d-210">É necessário inicializar uma variável `ref` quando ela é declarada; não é possível dividir a declaração e a inicialização.</span><span class="sxs-lookup"><span data-stu-id="6b34d-210">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="6b34d-211">A linguagem C# tem outras três regras que protegem contra o uso indevido de locais e retornos de `ref`:</span><span class="sxs-lookup"><span data-stu-id="6b34d-211">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="6b34d-212">Não é possível atribuir um valor retornado do método padrão a uma variável local de `ref`.</span><span class="sxs-lookup"><span data-stu-id="6b34d-212">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="6b34d-213">Você não pode retornar um `ref` para uma variável cujo tempo de vida não ultrapassa a execução do método.</span><span class="sxs-lookup"><span data-stu-id="6b34d-213">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="6b34d-214">O locais e retornos de `ref` não podem ser usados com métodos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="6b34d-214">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="6b34d-215">A adição de locais e retornos de ref permite algoritmos que são mais eficientes evitando a cópia de valores ou a execução múltipla de operações de desreferenciamento.</span><span class="sxs-lookup"><span data-stu-id="6b34d-215">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="6b34d-216">Para saber mais, confira o artigo [Palavra-chave ref](../../language-reference/keywords/ref.md).</span><span class="sxs-lookup"><span data-stu-id="6b34d-216">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="6b34d-217">Minimizar o acesso ao código com as funções locais</span><span class="sxs-lookup"><span data-stu-id="6b34d-217">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"6b34d-218\">Agora você pode declarar as funções locais que estão aninhadas dentro de outras funções.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-218\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"6b34d-219\">Isso permite que você minimize a visibilidade dessas funções.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-219\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"6b34d-220\">Há três casos de uso óbvios para funções locais:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-220\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"6b34d-221\">Funções recursivas.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-221\">Recursive functions.</span></span>\n- <span data-ttu-id=\"6b34d-222\">Métodos iteradores.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-222\">Iterator methods.</span></span>\n- <span data-ttu-id=\"6b34d-223\">Métodos assíncronos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-223\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"6b34d-224\">Vamos começar com os métodos recursivos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-224\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"6b34d-225\">Experimente o seguinte código no navegador para calcular `6!` (fatorial):</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-225\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"6b34d-226\">As funções locais são uma ótima maneira de implementar algoritmos recursivos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-226\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"6b34d-227\">Outros usos comuns são para métodos iteradores públicos e métodos assíncronos públicos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-227\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"6b34d-228\">Ambos os tipos de métodos geram um código que relata os erros com um atraso maior do que o esperado pelos programadores.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-228\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"6b34d-229\">No caso de métodos iteradores, todas as exceções são observadas apenas ao chamar o código que enumera a sequência retornada.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-229\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"6b34d-230\">No caso de métodos assíncronos, todas as exceções são observadas apenas quando a `Task` retornada é aguardada.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-230\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"6b34d-231\">Os métodos iteradores são mais fáceis de serem explorados no navegador, portanto, vamos usá-los nessa exploração.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-231\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"6b34d-232\">Experimente o seguinte código que chama um método iterador no navegador:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-232\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"6b34d-233\">Execute o código.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-233\">Run the code.</span></span> <span data-ttu-id=\"6b34d-234\">Observe que a exceção é gerada quando o código começa a iterar pelo segundo conjunto de resultados.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-234\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"6b34d-235\">O código que itera pelo primeiro conjunto de resultados já foi executado.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-235\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"6b34d-236\">Esta amostra é pequena e não altera nenhuma estrutura de dados, portanto, é inofensiva e fácil de ser corrigida.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-236\">This sample is both small and doesn't change any data structures, dso it's harmless and easy to fix.</span></span> <span data-ttu-id=\"6b34d-237\">Porém, em um programa maior, em que os dois objetos iteradores podem ser criados em diferentes métodos filho, a causa raiz pode ser difícil de ser encontrada.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-237\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"6b34d-238\">Se o primeiro método iterador alterar o estado dos dados, ele poderá, até mesmo, gerar dados corrompidos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-238\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"6b34d-239\">Você preferirá que a exceção seja gerada imediatamente, antes que qualquer trabalho seja feito.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-239\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"6b34d-240\">Refatore o código para que o método público valide todos os argumentos e uma função local que executa a enumeração:</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-240\">You can refactor the code so that the public method validates all arguments, and a local function that performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"6b34d-241\">A versão anterior deixa claro que o método local é referenciado somente no contexto do método externo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-241\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"6b34d-242\">As regras para funções locais também garantem que um desenvolvedor não possa acidentalmente chamar a função local de outro local na classe e ignorar a validação de argumento.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-242\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"6b34d-243\">A mesma técnica pode ser empregada com métodos `async` para garantir que as exceções decorrentes da validação de argumento sejam geradas antes do início do trabalho assíncrono.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-243\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"6b34d-244\">Alguns dos designs com suporte pelas funções locais também podem ser feitos usando *expressões lambda*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-244\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"6b34d-245\">Os usuários interessados podem [ler mais sobre as diferenças](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"6b34d-245\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="6b34d-246">Você concluiu uma exploração dos principais novos recursos do C# 7.</span><span class="sxs-lookup"><span data-stu-id="6b34d-246">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="6b34d-247">Agora experimente-os em seus aplicativos.</span><span class="sxs-lookup"><span data-stu-id="6b34d-247">Now try them yourself in your applications.</span></span> <span data-ttu-id="6b34d-248">Veja a lista completa no artigo [Novidades do C# 7](../../whats-new/csharp-7.md).</span><span class="sxs-lookup"><span data-stu-id="6b34d-248">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
