---
title: Gerar e consumir fluxos assíncronos
description: Este tutorial avançado mostra como gerar e consumir fluxos assíncronos. Os fluxos assíncronos fornecem uma maneira mais natural de trabalhar com sequências de dados que podem ser gerados de forma assíncrona.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: 03254e5208a048469f4753d632de7b0d451cde40
ms.sourcegitcommit: 5988e9a29cedb8757320817deda3c08c6f44a6aa
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/28/2020
ms.locfileid: "82200100"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="646fc-104">Tutorial: gerar e consumir fluxos assíncronos usando C# 8,0 e .NET Core 3,0</span><span class="sxs-lookup"><span data-stu-id="646fc-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="646fc-105">O C# 8,0 introduz **fluxos assíncronos**, que modelam uma fonte de transmissão de dados.</span><span class="sxs-lookup"><span data-stu-id="646fc-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="646fc-106">Os fluxos de dados geralmente recuperam ou geram elementos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="646fc-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="646fc-107">Os fluxos assíncronos dependem de novas interfaces introduzidas no .NET Standard 2,1.</span><span class="sxs-lookup"><span data-stu-id="646fc-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="646fc-108">Essas interfaces têm suporte no .NET Core 3,0 e posterior.</span><span class="sxs-lookup"><span data-stu-id="646fc-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="646fc-109">Eles fornecem um modelo de programação natural para fontes de dados de streaming assíncronas.</span><span class="sxs-lookup"><span data-stu-id="646fc-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="646fc-110">Neste tutorial, você aprenderá a:</span><span class="sxs-lookup"><span data-stu-id="646fc-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="646fc-111">Criar uma fonte de dados que gera uma sequência de elementos de dados de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="646fc-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="646fc-112">Consumir essa fonte de dados de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="646fc-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="646fc-113">Suporte a cancelamento e contextos capturados para fluxos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="646fc-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="646fc-114">Reconhecer quando a nova interface e a fonte de dados forem preferenciais para sequências anteriores de dados síncronos.</span><span class="sxs-lookup"><span data-stu-id="646fc-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="646fc-115">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="646fc-115">Prerequisites</span></span>

<span data-ttu-id="646fc-116">Você precisará configurar seu computador para executar o .NET Core, incluindo o compilador C# 8,0.</span><span class="sxs-lookup"><span data-stu-id="646fc-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="646fc-117">O compilador C# 8 está disponível a partir do [Visual Studio 2019 versão 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) ou do [SDK do .NET Core 3,0](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="646fc-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="646fc-118">Você precisará criar um [token de acesso do GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) para poder acessar o ponto de extremidade GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="646fc-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="646fc-119">Selecione as seguintes permissões para o Token de acesso do GitHub:</span><span class="sxs-lookup"><span data-stu-id="646fc-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="646fc-120">repo:status</span><span class="sxs-lookup"><span data-stu-id="646fc-120">repo:status</span></span>
- <span data-ttu-id="646fc-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="646fc-121">public_repo</span></span>

<span data-ttu-id="646fc-122">Salve o token de acesso em um local seguro, de modo que possa usá-lo para acessar o ponto de extremidade da API do GitHub.</span><span class="sxs-lookup"><span data-stu-id="646fc-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="646fc-123">Mantenha seu token de acesso pessoal protegido.</span><span class="sxs-lookup"><span data-stu-id="646fc-123">Keep your personal access token secure.</span></span> <span data-ttu-id="646fc-124">Qualquer software com seu token de acesso pessoal pode fazer chamadas da API do GitHub usando seus direitos de acesso.</span><span class="sxs-lookup"><span data-stu-id="646fc-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="646fc-125">Este tutorial pressupõe que você esteja familiarizado com o C# e .NET, incluindo o Visual Studio ou a CLI do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="646fc-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="646fc-126">Executar o aplicativo inicial</span><span class="sxs-lookup"><span data-stu-id="646fc-126">Run the starter application</span></span>

<span data-ttu-id="646fc-127">Você pode obter o código para o aplicativo inicial usado neste tutorial do repositório [dotnet/docs](https://github.com/dotnet/docs) na pasta [Csharp/tutoriais/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) .</span><span class="sxs-lookup"><span data-stu-id="646fc-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="646fc-128">O aplicativo inicial é um aplicativo de console que usa a interface [GitHub GraphQL](https://developer.github.com/v4/) para recuperar os problemas recentes gravados no repositório [dotnet/docs](https://github.com/dotnet/docs).</span><span class="sxs-lookup"><span data-stu-id="646fc-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="646fc-129">Comece observando o código a seguir para o método `Main` do aplicativo inicial:</span><span class="sxs-lookup"><span data-stu-id="646fc-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="646fc-130">Você pode definir uma variável de ambiente `GitHubKey` para o token de acesso pessoal ou pode substituir o último argumento na chamada para `GenEnvVariable` com seu token de acesso pessoal.</span><span class="sxs-lookup"><span data-stu-id="646fc-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="646fc-131">Não coloque seu código de acesso no código-fonte se você estiver compartilhando a fonte com outras pessoas.</span><span class="sxs-lookup"><span data-stu-id="646fc-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="646fc-132">Nunca carregue códigos de acesso em um repositório de origem compartilhado.</span><span class="sxs-lookup"><span data-stu-id="646fc-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="646fc-133">Após criar o cliente do GitHub, o código em `Main` criará um objeto de relatório de andamento e um token de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="646fc-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="646fc-134">Depois que esses objetos forem criados, `Main` chamará `runPagedQueryAsync` para recuperar os 250 problemas mais recente criados.</span><span class="sxs-lookup"><span data-stu-id="646fc-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="646fc-135">Depois que a tarefa for concluída, os resultados serão exibidos.</span><span class="sxs-lookup"><span data-stu-id="646fc-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="646fc-136">Ao executar o aplicativo inicial, você poderá realizar algumas observações importantes sobre como esse aplicativo é executado.</span><span class="sxs-lookup"><span data-stu-id="646fc-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="646fc-137">Você verá o progresso informado para cada página retornada do GitHub.</span><span class="sxs-lookup"><span data-stu-id="646fc-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="646fc-138">É possível observar uma pausa perceptível antes do GitHub retornar cada nova página de problemas.</span><span class="sxs-lookup"><span data-stu-id="646fc-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="646fc-139">Por fim, os problemas só serão exibidos depois que todas as 10 páginas forem recuperadas do GitHub.</span><span class="sxs-lookup"><span data-stu-id="646fc-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="646fc-140">Examinar a implementação</span><span class="sxs-lookup"><span data-stu-id="646fc-140">Examine the implementation</span></span>

<span data-ttu-id="646fc-141">A implementação revela por que você observou o comportamento discutido na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="646fc-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="646fc-142">Examine o código para `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="646fc-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="646fc-143">Vamos nos concentrar no algoritmo de paginação e na estrutura assíncrona do código anterior.</span><span class="sxs-lookup"><span data-stu-id="646fc-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="646fc-144">(Você pode consultar a [documentação do GitHub GraphQL](https://developer.github.com/v4/guides/) para obter detalhes sobre a API GraphQL do github.) O `runPagedQueryAsync` método enumera os problemas do mais recente para o mais antigo.</span><span class="sxs-lookup"><span data-stu-id="646fc-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="646fc-145">Ele solicita 25 problemas por página e examina a estrutura `pageInfo` da resposta para continuar com a página anterior.</span><span class="sxs-lookup"><span data-stu-id="646fc-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="646fc-146">Isso segue o suporte de paginação padrão do GraphQL para respostas com várias páginas.</span><span class="sxs-lookup"><span data-stu-id="646fc-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="646fc-147">A resposta inclui um objeto `pageInfo` que inclui um valor `hasPreviousPages` e um valor `startCursor` usados para solicitar a página anterior.</span><span class="sxs-lookup"><span data-stu-id="646fc-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="646fc-148">Os problemas estão na matriz `nodes`.</span><span class="sxs-lookup"><span data-stu-id="646fc-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="646fc-149">O método `runPagedQueryAsync` anexa esses nós em uma matriz que contém todos os resultados de todas as páginas.</span><span class="sxs-lookup"><span data-stu-id="646fc-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="646fc-150">Após a recuperação e a restauração de uma página de resultados, `runPagedQueryAsync` informa o andamento e verifica o cancelamento.</span><span class="sxs-lookup"><span data-stu-id="646fc-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="646fc-151">Se o cancelamento tiver sido solicitado, `runPagedQueryAsync` gerará um <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="646fc-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="646fc-152">Há vários elementos nesse código que podem ser melhorados.</span><span class="sxs-lookup"><span data-stu-id="646fc-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="646fc-153">Acima de tudo, `runPagedQueryAsync` deve alocar armazenamento para todos os problemas retornados.</span><span class="sxs-lookup"><span data-stu-id="646fc-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="646fc-154">Este exemplo é interrompido em 250 problemas porque recuperar todos os problemas exigiria muito mais memória para armazenar todos os problemas recuperados.</span><span class="sxs-lookup"><span data-stu-id="646fc-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="646fc-155">Os protocolos para dar suporte a relatórios de progresso e cancelamento tornam o algoritmo mais difícil de entender em sua primeira leitura.</span><span class="sxs-lookup"><span data-stu-id="646fc-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="646fc-156">Mais tipos e APIs estão envolvidos.</span><span class="sxs-lookup"><span data-stu-id="646fc-156">More types and APIs are involved.</span></span> <span data-ttu-id="646fc-157">Você deve rastrear as comunicações por meio <xref:System.Threading.CancellationTokenSource> do e seu <xref:System.Threading.CancellationToken> associado para entender onde o cancelamento é solicitado e onde ele é concedido.</span><span class="sxs-lookup"><span data-stu-id="646fc-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="646fc-158">Os fluxos assíncronos fornecem uma melhor maneira</span><span class="sxs-lookup"><span data-stu-id="646fc-158">Async streams provide a better way</span></span>

<span data-ttu-id="646fc-159">Os fluxos assíncronos e o suporte de linguagem associado lidam com todas essas preocupações.</span><span class="sxs-lookup"><span data-stu-id="646fc-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="646fc-160">O código que gera a sequência agora pode usar `yield return` para retornar os elementos em um método que foi declarado com o modificador `async`.</span><span class="sxs-lookup"><span data-stu-id="646fc-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="646fc-161">É possível consumir um fluxo assíncrono usando um loop `await foreach` da mesma forma que é possível consumir qualquer sequência usando um loop `foreach`.</span><span class="sxs-lookup"><span data-stu-id="646fc-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="646fc-162">Esses novos recursos de linguagem dependem das três novas interfaces adicionadas ao .NET Standard 2.1 e implementadas no .NET Core 3.0:</span><span class="sxs-lookup"><span data-stu-id="646fc-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="646fc-163">Essas três interfaces devem ser familiares à maioria dos desenvolvedores C#.</span><span class="sxs-lookup"><span data-stu-id="646fc-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="646fc-164">Elas se comportam de maneira semelhante às suas contrapartes síncronas:</span><span class="sxs-lookup"><span data-stu-id="646fc-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="646fc-165">Um tipo que pode não ser familiar é <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="646fc-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="646fc-166">A estrutura `ValueTask` fornece uma API semelhante para a classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="646fc-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="646fc-167">`ValueTask` é usado nas interfaces por motivos de desempenho.</span><span class="sxs-lookup"><span data-stu-id="646fc-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="646fc-168">Converter para fluxos assíncronos</span><span class="sxs-lookup"><span data-stu-id="646fc-168">Convert to async streams</span></span>

<span data-ttu-id="646fc-169">Em seguida, converta o método `runPagedQueryAsync` para gerar um fluxo assíncrono.</span><span class="sxs-lookup"><span data-stu-id="646fc-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="646fc-170">Primeiro, altere a assinatura de `runPagedQueryAsync` para retornar um `IAsyncEnumerable<JToken>` e remova os objetos de progresso e o token de cancelamento da lista de parâmetros, conforme mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="646fc-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="646fc-171">O código inicial processa cada página à medida que a página é recuperada, como mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="646fc-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="646fc-172">Substitua essas três linhas pelo seguinte código:</span><span class="sxs-lookup"><span data-stu-id="646fc-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="646fc-173">Você também pode remover a declaração de `finalResults` anteriormente nesse método e a instrução `return` que segue o loop que você modificou.</span><span class="sxs-lookup"><span data-stu-id="646fc-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="646fc-174">Você terminou as alterações para gerar um fluxo assíncrono.</span><span class="sxs-lookup"><span data-stu-id="646fc-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="646fc-175">O método finished deve ser semelhante ao seguinte código:</span><span class="sxs-lookup"><span data-stu-id="646fc-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="646fc-176">Em seguida, você pode alterar o código que consome a coleção para consumir o fluxo assíncrono.</span><span class="sxs-lookup"><span data-stu-id="646fc-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="646fc-177">Localize o seguinte código em `Main` que processa a coleção de problemas:</span><span class="sxs-lookup"><span data-stu-id="646fc-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="646fc-178">Substitua o código pelo seguinte loop `await foreach`:</span><span class="sxs-lookup"><span data-stu-id="646fc-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="646fc-179">A nova interface <xref:System.Collections.Generic.IAsyncEnumerator%601> deriva de <xref:System.IAsyncDisposable>.</span><span class="sxs-lookup"><span data-stu-id="646fc-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="646fc-180">Isso significa que o loop anterior descartará o fluxo de forma assíncrona quando o loop for concluído.</span><span class="sxs-lookup"><span data-stu-id="646fc-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="646fc-181">Você pode imaginar que o loop é semelhante ao seguinte código:</span><span class="sxs-lookup"><span data-stu-id="646fc-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="646fc-182">Por padrão, os elementos de fluxo são processados no contexto capturado.</span><span class="sxs-lookup"><span data-stu-id="646fc-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="646fc-183">Se você quiser desabilitar a captura do contexto, use o <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> método de extensão.</span><span class="sxs-lookup"><span data-stu-id="646fc-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="646fc-184">Para obter mais informações sobre contextos de sincronização e como capturar o contexto atual, consulte o artigo sobre como [consumir o padrão assíncrono baseado em tarefa](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="646fc-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="646fc-185">Os fluxos assíncronos dão suporte ao cancelamento usando o `async` mesmo protocolo que outros métodos.</span><span class="sxs-lookup"><span data-stu-id="646fc-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="646fc-186">Você modificaria a assinatura do método de iterador assíncrono da seguinte maneira para dar suporte ao cancelamento:</span><span class="sxs-lookup"><span data-stu-id="646fc-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="646fc-187">O <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> atributo faz com que o compilador gere código para <xref:System.Collections.Generic.IAsyncEnumerator%601> o que torna o token passado `GetAsyncEnumerator` para visível para o corpo do iterador assíncrono como esse argumento.</span><span class="sxs-lookup"><span data-stu-id="646fc-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="646fc-188">Dentro `runQueryAsync`do, você pode examinar o estado do token e cancelar mais trabalho, se solicitado.</span><span class="sxs-lookup"><span data-stu-id="646fc-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="646fc-189">Você usa outro método de extensão <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>,, para passar o token de cancelamento para o fluxo assíncrono.</span><span class="sxs-lookup"><span data-stu-id="646fc-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="646fc-190">Você modificaria o loop enumerando os problemas da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="646fc-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="646fc-191">Você pode obter o código para o tutorial concluído do repositório [dotnet/docs](https://github.com/dotnet/docs) na pasta [Csharp/tutoriais/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) .</span><span class="sxs-lookup"><span data-stu-id="646fc-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="646fc-192">Executar o aplicativo finalizado</span><span class="sxs-lookup"><span data-stu-id="646fc-192">Run the finished application</span></span>

<span data-ttu-id="646fc-193">Execute o aplicativo novamente.</span><span class="sxs-lookup"><span data-stu-id="646fc-193">Run the application again.</span></span> <span data-ttu-id="646fc-194">Compare esse comportamento com o comportamento do aplicativo inicial.</span><span class="sxs-lookup"><span data-stu-id="646fc-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="646fc-195">A primeira página de resultados é enumerada assim que fica disponível.</span><span class="sxs-lookup"><span data-stu-id="646fc-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="646fc-196">Há uma pausa observável à medida que cada nova página é solicitada e recuperada, e os resultados da próxima página são rapidamente enumerados.</span><span class="sxs-lookup"><span data-stu-id="646fc-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="646fc-197">O bloco `try` / `catch` não é necessário para lidar com o cancelamento: o chamador pode interromper a enumeração da coleção.</span><span class="sxs-lookup"><span data-stu-id="646fc-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="646fc-198">O progresso é claramente informado, pois o fluxo assíncrono gera resultados à medida que cada página é baixada.</span><span class="sxs-lookup"><span data-stu-id="646fc-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="646fc-199">O status de cada problema retornado é incluído diretamente no `await foreach` loop.</span><span class="sxs-lookup"><span data-stu-id="646fc-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="646fc-200">Você não precisa de um objeto de retorno de chamada para acompanhar o progresso.</span><span class="sxs-lookup"><span data-stu-id="646fc-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="646fc-201">Você pode ver as melhorias no uso da memória examinando o código.</span><span class="sxs-lookup"><span data-stu-id="646fc-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="646fc-202">Não é mais necessário alocar uma coleção para armazenar todos os resultados antes de serem enumerados.</span><span class="sxs-lookup"><span data-stu-id="646fc-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="646fc-203">O chamador pode determinar como consumir os resultados e se uma coleção de armazenamento é necessária.</span><span class="sxs-lookup"><span data-stu-id="646fc-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="646fc-204">Execute o aplicativos inicial e o acabado, e observe você mesmo as diferenças entre as implementações.</span><span class="sxs-lookup"><span data-stu-id="646fc-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="646fc-205">Depois de terminar, você pode excluir o token de acesso de GitHub criado ao iniciar este tutorial.</span><span class="sxs-lookup"><span data-stu-id="646fc-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="646fc-206">Se um invasor obtiver acesso a esse token, ele poderá acessar as APIs do GitHub usando suas credenciais.</span><span class="sxs-lookup"><span data-stu-id="646fc-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
