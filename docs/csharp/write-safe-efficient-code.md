---
title: Escrever um código C# seguro e eficiente
description: Aprimoramentos recentes na linguagem C# permitem escrever código seguro verificável que o desempenho associou anteriormente ao código não seguro.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 3dc3213cf24f4cdd8f0f1b7752263b4a609b2fa2
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73039637"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="62ee1-103">Escrever um código C# seguro e eficiente</span><span class="sxs-lookup"><span data-stu-id="62ee1-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="62ee1-104">Novos recursos em C# permitem escrever código seguro verificável com melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="62ee1-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="62ee1-105">Se você aplicar essas técnicas com cuidado, menos cenários exigirão código não seguro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="62ee1-106">Esses recursos tornam fácil usar referências a tipos de valor como argumentos e retornos de método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="62ee1-107">Quando realizadas com segurança, essas técnicas minimizam a cópia de tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="62ee1-108">Usando tipos de valor, é possível minimizar a quantidade de alocações e passagens de coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="62ee1-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="62ee1-109">Grande parte do código de exemplo neste artigo usa recursos adicionados no C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="62ee1-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="62ee1-110">Para usar esses recursos, é necessário configurar seu projeto para usar o C# 7.2 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="62ee1-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="62ee1-111">Para saber mais sobre como definir a versão da linguagem, confira [configure the language version](language-reference/configure-language-version.md) (configurar a versão da linguagem).</span><span class="sxs-lookup"><span data-stu-id="62ee1-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="62ee1-112">Este artigo se concentra em técnicas para o gerenciamento eficiente de recursos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="62ee1-113">Uma vantagem de usar tipos de valor é que eles geralmente evitam alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="62ee1-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="62ee1-114">A desvantagem é que eles são copiados por valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="62ee1-115">Essa compensação dificulta a otimização de algoritmos que operam em grandes quantidades de dados.</span><span class="sxs-lookup"><span data-stu-id="62ee1-115">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="62ee1-116">Os novos recursos de linguagem no C# 7.2 oferecem mecanismos que habilitam o código eficiente seguro que usa referências para tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="62ee1-117">Use esses recursos criteriosamente para minimizar tanto as alocações quanto as operações de cópia.</span><span class="sxs-lookup"><span data-stu-id="62ee1-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="62ee1-118">Este artigo explora esses novos recursos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-118">This article explores those new features.</span></span>

<span data-ttu-id="62ee1-119">Este artigo se concentra nas seguintes técnicas de gerenciamento de recursos:</span><span class="sxs-lookup"><span data-stu-id="62ee1-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="62ee1-120">declarar uma [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) para expressar que um tipo é **imutável** e permite que o compilador salve cópias ao usar os parâmetros [`in`](language-reference/keywords/in-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="62ee1-120">Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="62ee1-121">Se um tipo não puder ser imutável, declare `struct` Membros `readonly` para indicar que o membro não modifica o estado.</span><span class="sxs-lookup"><span data-stu-id="62ee1-121">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="62ee1-122">usar um retorno [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) quando o valor retornado é `struct` maior que <xref:System.IntPtr.Size?displayProperty=nameWithType> e o tempo de vida de armazenamento é maior que o método que retorna o valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-122">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="62ee1-123">Quando o tamanho de um `readonly struct` é maior que <xref:System.IntPtr.Size?displayProperty=nameWithType>, você deve passá-lo como um parâmetro `in` por motivos de desempenho.</span><span class="sxs-lookup"><span data-stu-id="62ee1-123">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="62ee1-124">Nunca passe um `struct` como um parâmetro `in`, a menos que seja declarado com o modificador `readonly` ou o método chame somente membros de `readonly` da estrutura.</span><span class="sxs-lookup"><span data-stu-id="62ee1-124">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="62ee1-125">A violação dessas diretrizes pode afetar negativamente o desempenho e pode levar a um comportamento obscuro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-125">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="62ee1-126">Use um [`ref struct`](language-reference/keywords/ref.md#ref-struct-types) ou um `readonly ref struct` como <xref:System.Span%601> ou <xref:System.ReadOnlySpan%601> para trabalhar com a memória como uma sequência de bytes.</span><span class="sxs-lookup"><span data-stu-id="62ee1-126">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="62ee1-127">Essas técnicas forçam você a equilibrar duas metras concorrentes em relação às **referências** e aos **valores**.</span><span class="sxs-lookup"><span data-stu-id="62ee1-127">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="62ee1-128">As variáveis que são [tipos de referência](programming-guide/types/index.md#reference-types) mantêm uma referência ao local na memória.</span><span class="sxs-lookup"><span data-stu-id="62ee1-128">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="62ee1-129">As variáveis que são [tipos de valor](programming-guide/types/index.md#value-types) contêm diretamente seu valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-129">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="62ee1-130">Essas diferenças realçam as principais diferenças que são importantes para gerenciar recursos de memória.</span><span class="sxs-lookup"><span data-stu-id="62ee1-130">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="62ee1-131">Normalmente, os **tipos de valor** são copiados quando passados para um método ou retornados de um método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-131">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="62ee1-132">Esse comportamento inclui copiar o valor do `this` ao chamar membros de um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-132">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="62ee1-133">O custo da cópia está relacionado ao tamanho do tipo.</span><span class="sxs-lookup"><span data-stu-id="62ee1-133">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="62ee1-134">Os **tipos de referência** são alocados no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="62ee1-134">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="62ee1-135">Cada novo objeto requer uma nova alocação e, subsequentemente, deve ser recuperado.</span><span class="sxs-lookup"><span data-stu-id="62ee1-135">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="62ee1-136">Ambas as operações levam tempo.</span><span class="sxs-lookup"><span data-stu-id="62ee1-136">Both these operations take time.</span></span> <span data-ttu-id="62ee1-137">A referência é copiada quando um tipo de referência é passado como um argumento para um método ou retornado de um método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-137">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="62ee1-138">Este artigo usa o seguinte exemplo de conceito da estrutura de ponto 3D para explicar estas recomendações:</span><span class="sxs-lookup"><span data-stu-id="62ee1-138">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="62ee1-139">diferentes exemplos usam diferentes implementações deste conceito.</span><span class="sxs-lookup"><span data-stu-id="62ee1-139">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="62ee1-140">Declarar structs somente leitura para tipos de valor imutáveis</span><span class="sxs-lookup"><span data-stu-id="62ee1-140">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="62ee1-141">Declarar um `struct` usando o modificador `readonly` informa ao compilador que sua intenção é criar um tipo imutável.</span><span class="sxs-lookup"><span data-stu-id="62ee1-141">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="62ee1-142">O compilador impõe essa decisão de design com as seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="62ee1-142">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="62ee1-143">Todos os membros do campo devem ser `readonly`</span><span class="sxs-lookup"><span data-stu-id="62ee1-143">All field members must be `readonly`</span></span>
- <span data-ttu-id="62ee1-144">Todas as propriedades devem ser somente leitura, incluindo propriedades autoimplementadas.</span><span class="sxs-lookup"><span data-stu-id="62ee1-144">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="62ee1-145">Essas duas regras são suficientes para garantir que nenhum membro de um `readonly struct` modifica o estado desse struct.</span><span class="sxs-lookup"><span data-stu-id="62ee1-145">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="62ee1-146">O `struct` é imutável.</span><span class="sxs-lookup"><span data-stu-id="62ee1-146">The `struct` is immutable.</span></span> <span data-ttu-id="62ee1-147">A estrutura `Point3D` pode ser definida como um struct imutável, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="62ee1-147">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="62ee1-148">Siga esta recomendação sempre que sua intenção de design for criar um tipo de valor imutável.</span><span class="sxs-lookup"><span data-stu-id="62ee1-148">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="62ee1-149">Quaisquer melhorias no desempenho são um benefício adicional.</span><span class="sxs-lookup"><span data-stu-id="62ee1-149">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="62ee1-150">O `readonly struct` expressa claramente a intenção do design.</span><span class="sxs-lookup"><span data-stu-id="62ee1-150">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="62ee1-151">Declarar membros ReadOnly quando um struct não puder ser imutável</span><span class="sxs-lookup"><span data-stu-id="62ee1-151">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="62ee1-152">No C# 8,0 e posterior, quando um tipo de struct é mutável, você deve declarar membros que não causam a mutação para ser`readonly`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-152">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="62ee1-153">Por exemplo, a seguir está uma variação mutável da estrutura de ponto 3D:</span><span class="sxs-lookup"><span data-stu-id="62ee1-153">For example, the following is a mutable variation of the 3D point structure:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    private double _x;
    public double X 
    { 
        readonly get { return _x;}; 
        set { _x = value; }
    }
    
    private double _y;
    public double Y 
    { 
        readonly get { return _y;}; 
        set { _y = value; }
    }

    private double _z;
    public double Z 
    { 
        readonly get { return _z;}; 
        set { _z = value; }
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X, Y, Z }";
}
```

<span data-ttu-id="62ee1-154">O exemplo anterior mostra muitos dos locais em que você pode aplicar o modificador de `readonly`: métodos, propriedades e acessadores de propriedade.</span><span class="sxs-lookup"><span data-stu-id="62ee1-154">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="62ee1-155">Se você usar Propriedades autoimplementadas, o compilador adicionará o modificador de `readonly` ao acessador de `get` para propriedades de leitura/gravação.</span><span class="sxs-lookup"><span data-stu-id="62ee1-155">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="62ee1-156">O compilador adiciona o modificador de `readonly` às declarações de propriedade implementadas automaticamente para propriedades com apenas um acessador `get`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-156">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="62ee1-157">Adicionar o modificador de `readonly` a membros que não permutam o estado fornece dois benefícios relacionados.</span><span class="sxs-lookup"><span data-stu-id="62ee1-157">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="62ee1-158">Primeiro, o compilador impõe sua intenção.</span><span class="sxs-lookup"><span data-stu-id="62ee1-158">First, the compiler enforces your intent.</span></span> <span data-ttu-id="62ee1-159">Esse membro não pode mutar o estado da estrutura nem pode acessar um membro que também não esteja marcado `readonly`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-159">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="62ee1-160">Em segundo lugar, o compilador não criará cópias defensivas de parâmetros de `in` ao acessar um membro de `readonly`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-160">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="62ee1-161">O compilador pode tornar essa otimização segura porque garante que a `struct` não seja modificada por um membro de `readonly`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-161">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="62ee1-162">Use instruções `ref readonly return` para grandes estruturas, quando possível</span><span class="sxs-lookup"><span data-stu-id="62ee1-162">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="62ee1-163">É possível retornar valores por referência quando o valor que está sendo retornado não é local para o método de retorno.</span><span class="sxs-lookup"><span data-stu-id="62ee1-163">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="62ee1-164">Retornar por referência significa que somente a referência é copiada, não a estrutura.</span><span class="sxs-lookup"><span data-stu-id="62ee1-164">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="62ee1-165">No exemplo a seguir, a propriedade `Origin` não pode usar um retorno `ref`, porque o valor que está sendo retornado é uma variável local:</span><span class="sxs-lookup"><span data-stu-id="62ee1-165">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="62ee1-166">No entanto, a seguinte definição de propriedade pode ser retornada por referência, porque o valor retornado é um membro estático:</span><span class="sxs-lookup"><span data-stu-id="62ee1-166">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="62ee1-167">Você não deseja chamadores que modificam a origem, então deve retornar o valor por `readonly ref`:</span><span class="sxs-lookup"><span data-stu-id="62ee1-167">You don't want callers modifying the origin, so you should return the value by `readonly ref`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="62ee1-168">Retornar `ref readonly` permite que você salvar a cópia de estruturas maiores e preserve a imutabilidade de seus membros de dados internos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-168">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="62ee1-169">No site de chamada, os chamadores fazem a opção de usar a propriedade `Origin` como um `readonly ref` ou como um valor:</span><span class="sxs-lookup"><span data-stu-id="62ee1-169">At the call site, callers make the choice to use the `Origin` property as a `readonly ref` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="62ee1-170">A primeira atribuição no código anterior faz uma cópia da constante `Origin` e atribui essa cópia.</span><span class="sxs-lookup"><span data-stu-id="62ee1-170">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="62ee1-171">A segunda atribui uma referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-171">The second assigns a reference.</span></span> <span data-ttu-id="62ee1-172">Observe que o modificador `readonly` deve ser parte da declaração da variável.</span><span class="sxs-lookup"><span data-stu-id="62ee1-172">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="62ee1-173">A referência à qual ele se relaciona não pode ser modificada.</span><span class="sxs-lookup"><span data-stu-id="62ee1-173">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="62ee1-174">As tentativas de modificá-la resultam em um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="62ee1-174">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="62ee1-175">O modificador `readonly` é necessário na declaração de `originReference`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-175">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="62ee1-176">O compilador impõe que o autor da chamada não pode modificar a referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-176">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="62ee1-177">As tentativas de atribuir o valor diretamente geram um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="62ee1-177">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="62ee1-178">No entanto, o compilador não pode saber se algum método de membro modifica o estado do struct.</span><span class="sxs-lookup"><span data-stu-id="62ee1-178">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="62ee1-179">Para garantir que o objeto não será modificado, o compilador cria uma cópia e chama as referências de membro usando essa cópia.</span><span class="sxs-lookup"><span data-stu-id="62ee1-179">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="62ee1-180">Todas as modificações são para essa cópia de defesa.</span><span class="sxs-lookup"><span data-stu-id="62ee1-180">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="62ee1-181">Aplique o modificador `in` a parâmetros `readonly struct` maiores que `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="62ee1-181">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="62ee1-182">A palavra-chave `in` complementa as palavras-chave `ref` e `out` existentes para passar argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-182">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="62ee1-183">A palavra-chave `in` especifica a passagem do argumento por referência, mas o método chamado não modifica o valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-183">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="62ee1-184">Essa adição fornece um vocabulário completo para expressar sua intenção de design.</span><span class="sxs-lookup"><span data-stu-id="62ee1-184">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="62ee1-185">Os tipos de valor são copiados no momento em que são passados para um método chamado quando você não especifica nenhum dos modificadores a seguir na assinatura do método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-185">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="62ee1-186">Cada um desses modificadores especifica que uma variável é passada por referência, evitando a cópia.</span><span class="sxs-lookup"><span data-stu-id="62ee1-186">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="62ee1-187">Cada modificador expressa uma intenção diferente:</span><span class="sxs-lookup"><span data-stu-id="62ee1-187">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="62ee1-188">`out`: esse método define o valor do argumento usado como este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-188">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="62ee1-189">`ref`: esse método pode definir o valor do argumento usado como este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-189">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="62ee1-190">`in`: esse método não modifica o valor do argumento usado como esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-190">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="62ee1-191">Adicione o modificador `in` para passar um argumento por referência e declare que sua intenção de design é passar argumentos por referência para evitar cópias desnecessárias.</span><span class="sxs-lookup"><span data-stu-id="62ee1-191">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="62ee1-192">Você não pretende modificar o objeto usado como esse argumento.</span><span class="sxs-lookup"><span data-stu-id="62ee1-192">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="62ee1-193">Essa prática geralmente melhora o desempenho para tipos de valor somente leitura que são maiores que <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62ee1-193">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="62ee1-194">Para tipos simples (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` e `bool`, e tipos `enum`), eventuais ganhos no desempenho são mínimos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-194">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="62ee1-195">Na verdade, o desempenho pode ser degradado usando a passagem por referência para tipos menores que <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62ee1-195">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="62ee1-196">O código a seguir mostra um exemplo de um método que calcula a distância entre dois pontos no espaço 3D.</span><span class="sxs-lookup"><span data-stu-id="62ee1-196">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="62ee1-197">Os argumentos são duas estruturas que contêm três duplas.</span><span class="sxs-lookup"><span data-stu-id="62ee1-197">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="62ee1-198">Uma dupla tem 8 bytes. Então, cada argumento tem 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="62ee1-198">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="62ee1-199">Ao especificar o modificador `in`, você passa uma referência de 4 ou 8 bytes para esses argumentos, dependendo da arquitetura do computador.</span><span class="sxs-lookup"><span data-stu-id="62ee1-199">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="62ee1-200">A diferença no tamanho é pequena, mas ela aumenta rapidamente quando o aplicativo chama esse método em um loop estreito, usando muitos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="62ee1-200">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="62ee1-201">O modificador `in` complementa `out` e `ref` de outras formas também.</span><span class="sxs-lookup"><span data-stu-id="62ee1-201">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="62ee1-202">Não é possível criar sobrecargas de um método que diferem somente na presença de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-202">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="62ee1-203">Essas novas regras apresentam o mesmo comportamento que sempre foi definido para os parâmetros `out` e `ref`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-203">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="62ee1-204">Como os modificadores `out` e `ref`, os tipos de valor não estão demarcados, porque o modificador `in` é aplicado.</span><span class="sxs-lookup"><span data-stu-id="62ee1-204">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="62ee1-205">O modificador `in` pode ser aplicado a qualquer membro que usa os seguintes parâmetros: métodos, delegados, lambdas, funções locais, indexadores e operadores.</span><span class="sxs-lookup"><span data-stu-id="62ee1-205">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="62ee1-206">Outro recurso dos parâmetros `in` é que você pode usar valores literais ou constantes para o argumento para um parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-206">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="62ee1-207">Além disso, ao contrário de um parâmetro `ref` ou `out`, você não precisa aplicar o modificador `in` no local da chamada.</span><span class="sxs-lookup"><span data-stu-id="62ee1-207">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="62ee1-208">O código a seguir mostra dois exemplos para chamar o método `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-208">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="62ee1-209">O primeiro usa duas variáveis locais transmitidas por referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-209">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="62ee1-210">O segundo inclui uma variável temporária criada como parte da chamada de método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-210">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="62ee1-211">Há várias maneiras pelas quais um compilador impõe a natureza somente leitura de um argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-211">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="62ee1-212">Em primeiro lugar, o método chamado não pode ser atribuído diretamente a um parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-212">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="62ee1-213">Não é possível atribuí-lo diretamente a nenhum campo de um parâmetro `in` quando esse valor é um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-213">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="62ee1-214">Além disso, não é possível passar um parâmetro `in` para nenhum método usando o modificador `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-214">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="62ee1-215">Essas regras se aplicam a qualquer campo de um parâmetro `in`, considerando que o campo seja um tipo `struct` e o parâmetro também seja um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-215">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="62ee1-216">Na verdade, essas regras são aplicadas a várias camadas de acesso de membro, considerando que os tipos, em todos os níveis de acesso de membro, sejam `structs`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-216">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="62ee1-217">O compilador impõe que os tipos `struct` passados como argumentos `in` e seus membros `struct` sejam variáveis somente leitura quando usados como argumentos para outros métodos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-217">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="62ee1-218">O uso de parâmetros `in` pode evitar os possíveis custos de desempenho com a realização de cópias.</span><span class="sxs-lookup"><span data-stu-id="62ee1-218">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="62ee1-219">Isso não altera a semântica de nenhuma chamada de método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-219">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="62ee1-220">Portanto, não é necessário especificar o modificador `in` no site de chamada.</span><span class="sxs-lookup"><span data-stu-id="62ee1-220">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="62ee1-221">A omissão do modificador `in` no site de chamada informa ao compilador que ele tem permissão para fazer uma cópia do argumento pelos seguintes motivos:</span><span class="sxs-lookup"><span data-stu-id="62ee1-221">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="62ee1-222">Existe uma conversão implícita, mas não uma conversão de identidade do tipo de argumento no tipo de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-222">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="62ee1-223">O argumento é uma expressão, mas não tem uma variável de armazenamento conhecida.</span><span class="sxs-lookup"><span data-stu-id="62ee1-223">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="62ee1-224">Há uma sobrecarga que é distinguível pela presença ou ausência de `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-224">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="62ee1-225">Nesse caso, a sobrecarga pelo valor é uma correspondência melhor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-225">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="62ee1-226">Essas regras são úteis conforme você atualiza o código existente para usar argumentos de referência somente leitura.</span><span class="sxs-lookup"><span data-stu-id="62ee1-226">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="62ee1-227">Dentro do método chamado, você pode chamar qualquer método de instância que use parâmetros por valor.</span><span class="sxs-lookup"><span data-stu-id="62ee1-227">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="62ee1-228">Nessas instâncias, uma cópia do parâmetro `in` é criada.</span><span class="sxs-lookup"><span data-stu-id="62ee1-228">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="62ee1-229">Uma vez que o compilador pode criar uma variável temporária para qualquer parâmetro `in`, você também pode especificar valores padrão para qualquer parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-229">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="62ee1-230">O código a seguir especifica a origem (ponto 0,0) como o valor padrão para o segundo ponto:</span><span class="sxs-lookup"><span data-stu-id="62ee1-230">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="62ee1-231">Para forçar o compilador a passar argumentos somente leitura por referência, especifique o modificador `in` nos argumentos no site de chamada, conforme mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="62ee1-231">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="62ee1-232">Esse comportamento facilita a adoção de parâmetros `in` ao longo do tempo nas grandes bases de código em que os ganhos de desempenho são possíveis.</span><span class="sxs-lookup"><span data-stu-id="62ee1-232">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="62ee1-233">Primeiro você adiciona o modificador `in` às assinaturas de método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-233">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="62ee1-234">Em seguida, você adiciona o modificador `in` em sites de chamada e cria tipos `readonly struct` para que o compilador evite criar cópias de defesa de parâmetros `in` em mais locais.</span><span class="sxs-lookup"><span data-stu-id="62ee1-234">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="62ee1-235">A designação do parâmetro `in` também pode ser usada com tipos de referência ou valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-235">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="62ee1-236">No entanto, os benefícios em ambos os casos serão mínimos, se houver.</span><span class="sxs-lookup"><span data-stu-id="62ee1-236">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="never-use-mutable-structs-as-in-in-argument"></a><span data-ttu-id="62ee1-237">Nunca use structs mutáveis como no argumento `in`</span><span class="sxs-lookup"><span data-stu-id="62ee1-237">Never use mutable structs as in `in` argument</span></span>

<span data-ttu-id="62ee1-238">As técnicas descritas acima explicam como evitar cópias retornando referências e passando valores por referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-238">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="62ee1-239">Essas técnicas funcionam melhor quando os tipos de argumento são declarados como tipos `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-239">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="62ee1-240">Caso contrário, o compilador deve criar **cópias de defesa** em muitas situações, para impor a qualidade de somente leitura de quaisquer argumentos.</span><span class="sxs-lookup"><span data-stu-id="62ee1-240">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="62ee1-241">Considere o exemplo a seguir que calcula a distância de um ponto 3D da origem:</span><span class="sxs-lookup"><span data-stu-id="62ee1-241">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="62ee1-242">A estrutura `Point3D` *não* é um struct somente leitura.</span><span class="sxs-lookup"><span data-stu-id="62ee1-242">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="62ee1-243">Há seis chamadas de acesso de propriedade diferentes no corpo deste método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-243">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="62ee1-244">No primeiro exame, você pode ter achado que esses acessos estavam seguros.</span><span class="sxs-lookup"><span data-stu-id="62ee1-244">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="62ee1-245">No fim das contas, um acessador `get` não deve modificar o estado do objeto.</span><span class="sxs-lookup"><span data-stu-id="62ee1-245">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="62ee1-246">Mas não há nenhuma regra de linguagem que impõe isso.</span><span class="sxs-lookup"><span data-stu-id="62ee1-246">But there's no language rule that enforces that.</span></span> <span data-ttu-id="62ee1-247">É apenas uma convenção comum.</span><span class="sxs-lookup"><span data-stu-id="62ee1-247">It's only a common convention.</span></span> <span data-ttu-id="62ee1-248">Qualquer tipo pode implementar um acessador `get` que modificou o estado interno.</span><span class="sxs-lookup"><span data-stu-id="62ee1-248">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="62ee1-249">Sem alguma garantia de linguagem, o compilador deve criar uma cópia temporária do argumento antes de chamar qualquer membro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-249">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member.</span></span> <span data-ttu-id="62ee1-250">O armazenamento temporário é criado na pilha, os valores do argumento são copiados para o armazenamento temporário e o valor é copiado para a pilha para cada acesso de membro como o argumento `this`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-250">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="62ee1-251">Em muitas situações, essas cópias prejudicam tanto o desempenho que a passagem por valor é mais rápida do que a passagem por referência somente leitura quando o tipo de argumento não é um `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-251">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`.</span></span>

<span data-ttu-id="62ee1-252">Em vez disso, se o cálculo de distância usar a struct imutável, `ReadonlyPoint3D`, os objetos temporários não serão necessários:</span><span class="sxs-lookup"><span data-stu-id="62ee1-252">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="62ee1-253">O compilador gera um código mais eficiente quando você chama os membros de um `readonly struct`: a referência `this`, em vez de uma cópia do receptor, é sempre um parâmetro `in` passado por referência ao método membro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-253">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="62ee1-254">Essa otimização economiza cópias quando você usa um `readonly struct` como um argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-254">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="62ee1-255">Você não deve passar um tipo de valor anulável como um argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-255">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="62ee1-256">O tipo de <xref:System.Nullable%601> não é declarado como uma struct somente leitura.</span><span class="sxs-lookup"><span data-stu-id="62ee1-256">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="62ee1-257">Isso significa que o compilador deve gerar cópias defensivas para qualquer argumento de tipo de valor anulável passado para um método usando o modificador `in` na declaração de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="62ee1-257">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="62ee1-258">Você pode ver um programa de exemplo que demonstra as diferenças de desempenho usando o [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) em nosso [repositório de exemplos](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) no github.</span><span class="sxs-lookup"><span data-stu-id="62ee1-258">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="62ee1-259">Ele compara a passagem de um struct mutável por valor e por referência com a passagem de um struct imutável por valor e por referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-259">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="62ee1-260">O uso do struct imutável e da passagem por referência é mais rápido.</span><span class="sxs-lookup"><span data-stu-id="62ee1-260">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="62ee1-261">Use tipos `ref struct` para trabalhar com blocos ou memória em um único registro de ativação</span><span class="sxs-lookup"><span data-stu-id="62ee1-261">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="62ee1-262">Um recurso de linguagem relacionado é a capacidade de declarar um tipo de valor que deve ser restrito para um único registro de ativação.</span><span class="sxs-lookup"><span data-stu-id="62ee1-262">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="62ee1-263">Essa restrição permite que o compilador faça várias otimizações.</span><span class="sxs-lookup"><span data-stu-id="62ee1-263">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="62ee1-264">A principal motivação para esse recurso foi <xref:System.Span%601> e as estruturas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="62ee1-264">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="62ee1-265">Você obterá melhorias de desempenho com esses aprimoramentos usando APIs do .NET novas e atualizadas que fazem uso do tipo <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="62ee1-265">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="62ee1-266">Você pode ter requisitos semelhantes funcionando com a memória criada usando [`stackalloc`](language-reference/operators/stackalloc.md) ou ao usar a memória das APIs de interoperabilidade.</span><span class="sxs-lookup"><span data-stu-id="62ee1-266">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="62ee1-267">Você pode definir seus próprios tipos `ref struct` para essas necessidades.</span><span class="sxs-lookup"><span data-stu-id="62ee1-267">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="62ee1-268">Tipo `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="62ee1-268">`readonly ref struct` type</span></span>

<span data-ttu-id="62ee1-269">A declaração de um struct como `readonly ref` combina os benefícios e as restrições das declarações `ref struct` e `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="62ee1-269">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="62ee1-270">A memória usada pelo alcance somente leitura está restrita a um único registro de ativação, e a memória usada pelo alcance de somente leitura não pode ser modificada.</span><span class="sxs-lookup"><span data-stu-id="62ee1-270">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="62ee1-271">Conclusões</span><span class="sxs-lookup"><span data-stu-id="62ee1-271">Conclusions</span></span>

<span data-ttu-id="62ee1-272">Usar tipos de valor minimiza o número de operações de alocação:</span><span class="sxs-lookup"><span data-stu-id="62ee1-272">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="62ee1-273">o armazenamento para tipos de valor é alocado em pilhas para variáveis locais e argumentos de método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-273">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="62ee1-274">o armazenamento para tipos de valor que são membros de outros objetos é alocado como parte desse objeto, não como uma alocação separada.</span><span class="sxs-lookup"><span data-stu-id="62ee1-274">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="62ee1-275">o armazenamento para valores retornados de tipo de valor é alocado em pilhas.</span><span class="sxs-lookup"><span data-stu-id="62ee1-275">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="62ee1-276">Compare isso com tipos de referência nestas mesmas situações:</span><span class="sxs-lookup"><span data-stu-id="62ee1-276">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="62ee1-277">o armazenamento para tipos de referência é alocado em heap para variáveis locais e argumentos de método.</span><span class="sxs-lookup"><span data-stu-id="62ee1-277">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="62ee1-278">A referência é armazenada na pilha.</span><span class="sxs-lookup"><span data-stu-id="62ee1-278">The reference is stored on the stack.</span></span>
- <span data-ttu-id="62ee1-279">O armazenamento para tipos de referência que são membros de outros objetos são alocados separadamente no heap.</span><span class="sxs-lookup"><span data-stu-id="62ee1-279">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="62ee1-280">O objeto recipiente armazena a referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-280">The containing object stores the reference.</span></span>
- <span data-ttu-id="62ee1-281">O armazenamento para valores retornados de tipo de referência é alocado em heap.</span><span class="sxs-lookup"><span data-stu-id="62ee1-281">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="62ee1-282">A referência a esse armazenamento é armazenada na pilha.</span><span class="sxs-lookup"><span data-stu-id="62ee1-282">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="62ee1-283">Minimizar alocações implica compensações.</span><span class="sxs-lookup"><span data-stu-id="62ee1-283">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="62ee1-284">Você copia mais memória quando o tamanho do `struct` é maior que o tamanho de uma referência.</span><span class="sxs-lookup"><span data-stu-id="62ee1-284">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="62ee1-285">Normalmente, uma referência é 64 ou 32 bits e depende da CPU do computador de destino.</span><span class="sxs-lookup"><span data-stu-id="62ee1-285">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="62ee1-286">Essas compensações geralmente têm o mínimo de impacto no desempenho.</span><span class="sxs-lookup"><span data-stu-id="62ee1-286">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="62ee1-287">No entanto, para estruturas grandes ou coleções maiores, o impacto no desempenho aumenta.</span><span class="sxs-lookup"><span data-stu-id="62ee1-287">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="62ee1-288">O impacto pode ser grande em loops estreitos e em afunilamentos para programas.</span><span class="sxs-lookup"><span data-stu-id="62ee1-288">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="62ee1-289">Esses aprimoramentos na linguagem C# são criados para algoritmos de desempenho críticos, nos quais as alocações de memória são um importante fator para alcançar o desempenho necessário.</span><span class="sxs-lookup"><span data-stu-id="62ee1-289">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="62ee1-290">Você pode achar que geralmente não usa esses recursos no código que grava.</span><span class="sxs-lookup"><span data-stu-id="62ee1-290">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="62ee1-291">No entanto, esses aprimoramentos foram adotados por meio do .NET.</span><span class="sxs-lookup"><span data-stu-id="62ee1-291">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="62ee1-292">À medida que cada vez mais APIs utilizam esses recursos, você verá o desempenho dos seus aplicativos melhorar.</span><span class="sxs-lookup"><span data-stu-id="62ee1-292">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="62ee1-293">Consulte também</span><span class="sxs-lookup"><span data-stu-id="62ee1-293">See also</span></span>

- [<span data-ttu-id="62ee1-294">ref keyword</span><span class="sxs-lookup"><span data-stu-id="62ee1-294">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="62ee1-295">Retornos de ref e locais de ref</span><span class="sxs-lookup"><span data-stu-id="62ee1-295">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
