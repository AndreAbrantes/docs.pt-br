---
title: Os blocos de construção de programas em C# "
description: Saiba mais sobre membros, expressões e instruções C#. Os tipos contêm membros que você escreve. Esses membros são criados a partir de instruções e expressões.
ms.date: 08/06/2020
ms.openlocfilehash: e4350f2c2b6005fb59dd868f0f7f628bd07b0053
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/26/2020
ms.locfileid: "93342690"
---
# <a name="program-building-blocks"></a><span data-ttu-id="21b95-105">Blocos de construção de programas</span><span class="sxs-lookup"><span data-stu-id="21b95-105">Program building blocks</span></span>

<span data-ttu-id="21b95-106">Os tipos descritos no artigo anterior são criados usando estes blocos de construção: [ \* **Members**](../programming-guide/classes-and-structs/members.md), [ _*_Expressions_*_ e _*_Statements_*_](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="21b95-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="21b95-107">Membros</span><span class="sxs-lookup"><span data-stu-id="21b95-107">Members</span></span>

<span data-ttu-id="21b95-108">Os membros de a `class` são membros _*_estáticos_*_ ou _*_membros de instância_*_.</span><span class="sxs-lookup"><span data-stu-id="21b95-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="21b95-109">Os membros estáticos pertencem às classes e os membros de instância pertencem aos objetos (instâncias de classes).</span><span class="sxs-lookup"><span data-stu-id="21b95-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="21b95-110">A lista a seguir fornece uma visão geral dos tipos de membros que uma classe pode conter.</span><span class="sxs-lookup"><span data-stu-id="21b95-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="21b95-111">_ \* Constantes \* \*: valores constantes associados à classe</span><span class="sxs-lookup"><span data-stu-id="21b95-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="21b95-112">**Campos**: variáveis que estão associadas à classe</span><span class="sxs-lookup"><span data-stu-id="21b95-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="21b95-113">**Métodos**: ações que podem ser executadas pela classe</span><span class="sxs-lookup"><span data-stu-id="21b95-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="21b95-114">**Propriedades**: ações associadas à leitura e à gravação de propriedades nomeadas da classe</span><span class="sxs-lookup"><span data-stu-id="21b95-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="21b95-115">**Indexadores**: ações associadas à indexação de instâncias da classe como uma matriz</span><span class="sxs-lookup"><span data-stu-id="21b95-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="21b95-116">**Eventos**: notificações que podem ser geradas pela classe</span><span class="sxs-lookup"><span data-stu-id="21b95-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="21b95-117">**Operadores**: conversões e operadores de expressão com suporte na classe</span><span class="sxs-lookup"><span data-stu-id="21b95-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="21b95-118">**Construtores**: ações necessárias para inicializar instâncias da classe ou a própria classe</span><span class="sxs-lookup"><span data-stu-id="21b95-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="21b95-119">**Finalizadores**: ações executadas antes de instâncias da classe serem descartadas permanentemente</span><span class="sxs-lookup"><span data-stu-id="21b95-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="21b95-120">**Tipos**: tipos aninhados declarados pela classe</span><span class="sxs-lookup"><span data-stu-id="21b95-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="21b95-121">Acessibilidade</span><span class="sxs-lookup"><span data-stu-id="21b95-121">Accessibility</span></span>

<span data-ttu-id="21b95-122">Cada membro de uma classe tem uma acessibilidade associada, que controla as regiões do texto do programa que podem acessar o membro.</span><span class="sxs-lookup"><span data-stu-id="21b95-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="21b95-123">Existem seis formas possíveis de acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="21b95-124">Os modificadores de acesso são resumidos abaixo.</span><span class="sxs-lookup"><span data-stu-id="21b95-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="21b95-125">`public`: O acesso não é limitado.</span><span class="sxs-lookup"><span data-stu-id="21b95-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="21b95-126">`private`: O acesso é limitado a essa classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="21b95-127">`protected`: O acesso é limitado a esta classe ou classes derivadas desta classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="21b95-128">`internal`: O acesso é limitado ao assembly atual ( `.exe` ou `.dll` ).</span><span class="sxs-lookup"><span data-stu-id="21b95-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="21b95-129">`protected internal`: O acesso é limitado a essa classe, classes derivadas dessa classe ou classes dentro do mesmo assembly.</span><span class="sxs-lookup"><span data-stu-id="21b95-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="21b95-130">`private protected`: O acesso é limitado a essa classe ou classes derivadas desse tipo dentro do mesmo assembly.</span><span class="sxs-lookup"><span data-stu-id="21b95-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="21b95-131">Campos</span><span class="sxs-lookup"><span data-stu-id="21b95-131">Fields</span></span>

<span data-ttu-id="21b95-132">Um *campo* é uma variável que está associada a uma classe ou a uma instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="21b95-133">Um campo declarado com o modificador estático define um campo estático.</span><span class="sxs-lookup"><span data-stu-id="21b95-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="21b95-134">Um campo estático identifica exatamente um local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="21b95-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="21b95-135">Não importa quantas instâncias de uma classe são criadas, há apenas uma cópia de um campo estático.</span><span class="sxs-lookup"><span data-stu-id="21b95-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="21b95-136">Um campo declarado sem o modificador estático define um campo de instância.</span><span class="sxs-lookup"><span data-stu-id="21b95-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="21b95-137">Cada instância de uma classe contém uma cópia separada de todos os campos de instância dessa classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="21b95-138">No exemplo a seguir, cada instância da `Color` classe tem uma cópia separada dos campos de `R` instância,, `G` e `B` , mas há apenas uma cópia dos `Black` `White` `Red` `Green` campos estáticos,,, e `Blue` :</span><span class="sxs-lookup"><span data-stu-id="21b95-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="21b95-139">Conforme mostrado no exemplo anterior, os *campos somente leitura* podem ser declarados com um modificador `readonly`.</span><span class="sxs-lookup"><span data-stu-id="21b95-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="21b95-140">A atribuição a um campo somente leitura só pode ocorrer como parte da declaração do campo ou em um construtor na mesma classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="21b95-141">Métodos</span><span class="sxs-lookup"><span data-stu-id="21b95-141">Methods</span></span>

<span data-ttu-id="21b95-142">Um *método* é um membro que implementa um cálculo ou uma ação que pode ser executada por um objeto ou classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="21b95-143">Os *métodos estáticos* são acessados pela classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="21b95-144">Os *métodos de instância* são acessados pelas instâncias da classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="21b95-145">Os métodos podem ter uma lista de *parâmetros*, que representam valores ou referências de variáveis passadas para o método.</span><span class="sxs-lookup"><span data-stu-id="21b95-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="21b95-146">Os métodos têm um *tipo de retorno*, que especifica o tipo do valor calculado e retornado pelo método.</span><span class="sxs-lookup"><span data-stu-id="21b95-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="21b95-147">O tipo de retorno de um método é `void` se ele não retornar um valor.</span><span class="sxs-lookup"><span data-stu-id="21b95-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="21b95-148">Como os tipos, os métodos também podem ter um conjunto de parâmetros de tipo, para que os quais os argumentos de tipo devem ser especificados quando o método é chamado.</span><span class="sxs-lookup"><span data-stu-id="21b95-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="21b95-149">Ao contrário dos tipos, os argumentos de tipo geralmente podem ser inferidos de argumentos de uma chamada de método e não precisam ser fornecidos explicitamente.</span><span class="sxs-lookup"><span data-stu-id="21b95-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="21b95-150">A *assinatura* de um método deve ser exclusiva na classe na qual o método é declarado.</span><span class="sxs-lookup"><span data-stu-id="21b95-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="21b95-151">A assinatura de um método consiste no nome do método, no número de parâmetros de tipo e no número, nos modificadores e nos tipos de seus parâmetros.</span><span class="sxs-lookup"><span data-stu-id="21b95-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="21b95-152">A assinatura de um método não inclui o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="21b95-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="21b95-153">Quando um corpo de método é uma única expressão, o método pode ser definido usando um formato de expressão Compact, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="21b95-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="21b95-154">Parâmetros</span><span class="sxs-lookup"><span data-stu-id="21b95-154">Parameters</span></span>

<span data-ttu-id="21b95-155">Os parâmetros são usados para passar valores ou referências de variável aos métodos.</span><span class="sxs-lookup"><span data-stu-id="21b95-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="21b95-156">Os parâmetros de um método obtêm seus valores reais de *argumentos* que são especificados quando o método é invocado.</span><span class="sxs-lookup"><span data-stu-id="21b95-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="21b95-157">Há quatro tipos de parâmetros: parâmetros de valor, parâmetros de referência, parâmetros de saída e matrizes de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="21b95-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="21b95-158">Um *parâmetro de valor* é usado para passar argumentos de entrada.</span><span class="sxs-lookup"><span data-stu-id="21b95-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="21b95-159">Um parâmetro de valor corresponde a uma variável local que obtém seu valor inicial do argumento passado para o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="21b95-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="21b95-160">Modificações em um parâmetro de valor não afetam o argumento que foi passado para o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="21b95-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="21b95-161">Os parâmetros de valor podem ser opcionais, especificando um valor padrão para que os argumentos correspondentes possam ser omitidos.</span><span class="sxs-lookup"><span data-stu-id="21b95-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="21b95-162">Um *parâmetro de referência* é usado para passar argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="21b95-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="21b95-163">O argumento passado para um parâmetro de referência deve ser uma variável com um valor definido.</span><span class="sxs-lookup"><span data-stu-id="21b95-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="21b95-164">Durante a execução do método, o parâmetro de referência representa o mesmo local de armazenamento que a variável de argumento.</span><span class="sxs-lookup"><span data-stu-id="21b95-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="21b95-165">Um parâmetro de referência é declarado com o modificador `ref`.</span><span class="sxs-lookup"><span data-stu-id="21b95-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="21b95-166">O exemplo a seguir mostra o uso de parâmetros `ref`.</span><span class="sxs-lookup"><span data-stu-id="21b95-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="21b95-167">Um *parâmetro de saída* é usado para passar argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="21b95-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="21b95-168">Ele é semelhante a um parâmetro de referência, exceto que ele não requer que você atribua explicitamente um valor ao argumento fornecido pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="21b95-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="21b95-169">Um parâmetro de saída é declarado com o modificador `out`.</span><span class="sxs-lookup"><span data-stu-id="21b95-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="21b95-170">O exemplo a seguir mostra o uso de parâmetros `out` usando a sintaxe introduzida no C# 7.</span><span class="sxs-lookup"><span data-stu-id="21b95-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="21b95-171">Uma *matriz de parâmetros* permite que um número variável de argumentos sejam passados para um método.</span><span class="sxs-lookup"><span data-stu-id="21b95-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="21b95-172">Uma matriz de parâmetro é declarada com o modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="21b95-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="21b95-173">Somente o último parâmetro de um método pode ser uma matriz de parâmetros e o tipo de uma matriz de parâmetros deve ser um tipo de matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="21b95-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="21b95-174">Os `Write` `WriteLine` métodos e da <xref:System.Console?displayProperty=nameWithType> classe são bons exemplos de uso de matriz de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="21b95-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="21b95-175">Eles são declarados da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="21b95-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="21b95-176">Dentro de um método que usa uma matriz de parâmetros, a matriz de parâmetros se comporta exatamente como um parâmetro regular de um tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="21b95-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="21b95-177">No entanto, em uma invocação de um método com uma matriz de parâmetros, é possível passar um único argumento do tipo de matriz de parâmetro ou qualquer número de argumentos do tipo de elemento da matriz de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="21b95-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="21b95-178">No último caso, uma instância de matriz é automaticamente criada e inicializada com os argumentos determinados.</span><span class="sxs-lookup"><span data-stu-id="21b95-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="21b95-179">Esse exemplo</span><span class="sxs-lookup"><span data-stu-id="21b95-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="21b95-180">é equivalente ao escrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="21b95-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="21b95-181">Corpo do método e variáveis locais</span><span class="sxs-lookup"><span data-stu-id="21b95-181">Method body and local variables</span></span>

<span data-ttu-id="21b95-182">Um corpo do método especifica as instruções para execução quando o método é invocado.</span><span class="sxs-lookup"><span data-stu-id="21b95-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="21b95-183">Um corpo de método pode declarar variáveis que são específicas para a invocação do método.</span><span class="sxs-lookup"><span data-stu-id="21b95-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="21b95-184">Essas variáveis são chamadas de *variáveis locais*.</span><span class="sxs-lookup"><span data-stu-id="21b95-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="21b95-185">Uma declaração de variável local especifica um nome de tipo, um nome de variável e, possivelmente, um valor inicial.</span><span class="sxs-lookup"><span data-stu-id="21b95-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="21b95-186">O exemplo a seguir declara uma variável local `i` com um valor inicial de zero e uma variável local `j` sem valor inicial.</span><span class="sxs-lookup"><span data-stu-id="21b95-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="21b95-187">O C# requer que uma variável local seja *atribuída definitivamente* antes de seu valor poder ser obtido.</span><span class="sxs-lookup"><span data-stu-id="21b95-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="21b95-188">Por exemplo, se a declaração do anterior `i` não incluísse um valor inicial, o compilador relataria um erro para os usos mais recentes do porque não seria `i` `i` definitivamente atribuído a esses pontos no programa.</span><span class="sxs-lookup"><span data-stu-id="21b95-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="21b95-189">Um método pode usar instruções `return` para retornar o controle é pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="21b95-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="21b95-190">Em um método que retorna `void` , as `return` instruções não podem especificar uma expressão.</span><span class="sxs-lookup"><span data-stu-id="21b95-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="21b95-191">Em um método que retorna não nulo, as instruções `return` devem incluir uma expressão que calcula o valor retornado.</span><span class="sxs-lookup"><span data-stu-id="21b95-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="21b95-192">Métodos estáticos e de instância</span><span class="sxs-lookup"><span data-stu-id="21b95-192">Static and instance methods</span></span>

<span data-ttu-id="21b95-193">Um método declarado com um `static` modificador é um *método estático*.</span><span class="sxs-lookup"><span data-stu-id="21b95-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="21b95-194">Um método estático não opera em uma instância específica e só pode acessar diretamente membros estáticos.</span><span class="sxs-lookup"><span data-stu-id="21b95-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="21b95-195">Um método declarado sem um `static` modificador é um *método de instância*.</span><span class="sxs-lookup"><span data-stu-id="21b95-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="21b95-196">Um método de instância opera em uma instância específica e pode acessar membros estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="21b95-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="21b95-197">A instância em que um método de instância foi invocado pode ser explicitamente acessada como `this`.</span><span class="sxs-lookup"><span data-stu-id="21b95-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="21b95-198">É um erro fazer referência a `this` um método estático.</span><span class="sxs-lookup"><span data-stu-id="21b95-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="21b95-199">A seguinte classe `Entity` tem membros estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="21b95-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="21b95-200">Cada `Entity` instância contém um número de série (e, presumivelmente, algumas outras informações que não são mostradas aqui).</span><span class="sxs-lookup"><span data-stu-id="21b95-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="21b95-201">O construtor `Entity` (que é como um método de instância) inicializa a nova instância com o próximo número de série disponível.</span><span class="sxs-lookup"><span data-stu-id="21b95-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="21b95-202">Como o construtor é um membro de instância, ele tem permissão para acessar o `_serialNo` campo de instância e o `s_nextSerialNo` campo estático.</span><span class="sxs-lookup"><span data-stu-id="21b95-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="21b95-203">Os métodos estáticos `GetNextSerialNo` e `SetNextSerialNo` podem acessar o campo estático `s_nextSerialNo`, mas seria um erro para eles acessar diretamente o campo de instância `_serialNo`.</span><span class="sxs-lookup"><span data-stu-id="21b95-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="21b95-204">O exemplo a seguir mostra o uso da `Entity` classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="21b95-205">Os `SetNextSerialNo` `GetNextSerialNo` métodos estáticos e são invocados na classe, enquanto o `GetSerialNo` método de instância é invocado em instâncias da classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="21b95-206">Métodos abstratos, virtuais e de substituição</span><span class="sxs-lookup"><span data-stu-id="21b95-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="21b95-207">Quando uma declaração de método de instância inclui um modificador `virtual`, o método deve ser um *método virtual*.</span><span class="sxs-lookup"><span data-stu-id="21b95-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="21b95-208">Quando nenhum modificador virtual estiver presente, o método será um *método não virtual*.</span><span class="sxs-lookup"><span data-stu-id="21b95-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="21b95-209">Quando um método virtual é invocado, o *tipo de tempo de execução* da instância para o qual essa invocação ocorre determina a implementação real do método para invocar.</span><span class="sxs-lookup"><span data-stu-id="21b95-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="21b95-210">Em uma invocação de método não virtual, o *tipo de tempo de compilação* da instância é o fator determinante.</span><span class="sxs-lookup"><span data-stu-id="21b95-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="21b95-211">Um método virtual pode ser *substituído* em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="21b95-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="21b95-212">Quando uma declaração de método de instância inclui um modificador de substituição, o método substitui um método virtual herdado com a mesma assinatura.</span><span class="sxs-lookup"><span data-stu-id="21b95-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="21b95-213">Uma declaração de método virtual apresenta um novo método.</span><span class="sxs-lookup"><span data-stu-id="21b95-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="21b95-214">Uma declaração de método de substituição especializa um método virtual herdado existente fornecendo uma nova implementação desse método.</span><span class="sxs-lookup"><span data-stu-id="21b95-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="21b95-215">Um *método abstrato* é um método virtual sem implementação.</span><span class="sxs-lookup"><span data-stu-id="21b95-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="21b95-216">Um método abstract é declarado com o `abstract` modificador e é permitido somente em uma classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="21b95-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="21b95-217">Um método abstrato deve ser substituído em cada classe derivada não abstrata.</span><span class="sxs-lookup"><span data-stu-id="21b95-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="21b95-218">O exemplo a seguir declara uma classe abstrata, `Expression`, que representa um nó de árvore de expressão e três classes derivadas, `Constant`, `VariableReference` e `Operation`, que implementam nós de árvore de expressão para operações aritméticas, referências de variável e constantes.</span><span class="sxs-lookup"><span data-stu-id="21b95-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="21b95-219">(Este exemplo é semelhante a, mas não relacionado aos tipos de árvore de expressão).</span><span class="sxs-lookup"><span data-stu-id="21b95-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="21b95-220">As quatro classes anteriores podem ser usadas para modelar expressões aritméticas.</span><span class="sxs-lookup"><span data-stu-id="21b95-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="21b95-221">Por exemplo, usando instâncias dessas classes, a expressão `x + 3` pode ser representada da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="21b95-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="21b95-222">O método `Evaluate` de uma instância `Expression` é chamado para avaliar a expressão especificada e produzir um valor `double`.</span><span class="sxs-lookup"><span data-stu-id="21b95-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="21b95-223">O método recebe um argumento `Dictionary` que contém nomes de variáveis (como chaves das entradas) e valores (como valores das entradas).</span><span class="sxs-lookup"><span data-stu-id="21b95-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="21b95-224">Como `Evaluate` é um método abstrato, classes não abstratas derivadas de `Expression` devem substituir `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="21b95-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="21b95-225">Uma implementação de `Evaluate` do `Constant` retorna apenas a constante armazenada.</span><span class="sxs-lookup"><span data-stu-id="21b95-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="21b95-226">Uma implementação de `VariableReference` consulta o nome de variável no dicionário e retorna o valor resultante.</span><span class="sxs-lookup"><span data-stu-id="21b95-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="21b95-227">Uma implementação de `Operation` primeiro avalia os operandos esquerdo e direito (chamando recursivamente seus métodos `Evaluate`) e, em seguida, executa a operação aritmética determinada.</span><span class="sxs-lookup"><span data-stu-id="21b95-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="21b95-228">O seguinte programa usa as classes `Expression` para avaliar a expressão `x * (y + 2)` para valores diferentes de `x` e `y`.</span><span class="sxs-lookup"><span data-stu-id="21b95-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="21b95-229">Sobrecarga de método</span><span class="sxs-lookup"><span data-stu-id="21b95-229">Method overloading</span></span>

<span data-ttu-id="21b95-230">A *sobrecarga* de método permite que vários métodos na mesma classe tenham o mesmo nome, contanto que tenham assinaturas exclusivas.</span><span class="sxs-lookup"><span data-stu-id="21b95-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="21b95-231">Ao compilar uma invocação de um método sobrecarregado, o compilador usa a *resolução de sobrecarga* para determinar o método específico para invocar.</span><span class="sxs-lookup"><span data-stu-id="21b95-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="21b95-232">A resolução de sobrecarga encontra um método que melhor corresponde aos argumentos.</span><span class="sxs-lookup"><span data-stu-id="21b95-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="21b95-233">Se não for possível encontrar uma única melhor correspondência, um erro será relatado.</span><span class="sxs-lookup"><span data-stu-id="21b95-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="21b95-234">O exemplo a seguir mostra a resolução de sobrecarga em vigor.</span><span class="sxs-lookup"><span data-stu-id="21b95-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="21b95-235">O comentário para cada invocação no `UsageExample` método mostra qual método é invocado.</span><span class="sxs-lookup"><span data-stu-id="21b95-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="21b95-236">Conforme mostrado pelo exemplo, um método específico sempre pode ser selecionado por meio da conversão explícita dos argumentos para os tipos de parâmetro e argumentos de tipo exatos.</span><span class="sxs-lookup"><span data-stu-id="21b95-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="21b95-237">Outros membros da função</span><span class="sxs-lookup"><span data-stu-id="21b95-237">Other function members</span></span>

<span data-ttu-id="21b95-238">Os membros que contêm código executável são conhecidos coletivamente como *membros de função* de uma classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="21b95-239">A seção anterior descreve os métodos, que são os principais tipos de membros de função.</span><span class="sxs-lookup"><span data-stu-id="21b95-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="21b95-240">Esta seção descreve os outros tipos de membros da função com suporte do C#: construtores, propriedades, indexadores, eventos, operadores e finalizadores.</span><span class="sxs-lookup"><span data-stu-id="21b95-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="21b95-241">O exemplo a seguir mostra uma classe genérica chamada `MyList<T>` , que implementa uma lista de objetos que aumenta.</span><span class="sxs-lookup"><span data-stu-id="21b95-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="21b95-242">A classe contém vários exemplos dos tipos mais comuns de membros da função.</span><span class="sxs-lookup"><span data-stu-id="21b95-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="21b95-243">Construtores</span><span class="sxs-lookup"><span data-stu-id="21b95-243">Constructors</span></span>

<span data-ttu-id="21b95-244">O C# dá suporte aos construtores estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="21b95-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="21b95-245">Um *construtor de instância* é um membro que implementa as ações necessárias para inicializar uma instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="21b95-246">Um *construtor estático* é um membro que implementa as ações necessárias para inicializar uma classe em si quando ela é carregada pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="21b95-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="21b95-247">Um construtor é declarado como um método sem nenhum tipo de retorno e o mesmo nome que a classe continente.</span><span class="sxs-lookup"><span data-stu-id="21b95-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="21b95-248">Se uma declaração de Construtor incluir um `static` modificador, ele declara um construtor estático.</span><span class="sxs-lookup"><span data-stu-id="21b95-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="21b95-249">Caso contrário, ela declara um construtor de instância.</span><span class="sxs-lookup"><span data-stu-id="21b95-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="21b95-250">Construtores de instância podem ser sobrecarregados e ter parâmetros opcionais.</span><span class="sxs-lookup"><span data-stu-id="21b95-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="21b95-251">Por exemplo, a classe `MyList<T>` declara um construtor de instância com um único parâmetro `int` opcional.</span><span class="sxs-lookup"><span data-stu-id="21b95-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="21b95-252">Os construtores de instância são invocados usando o operador `new`.</span><span class="sxs-lookup"><span data-stu-id="21b95-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="21b95-253">As seguintes instruções alocam duas instâncias `MyList<string>` usando o construtor da classe `MyList` com e sem o argumento opcional.</span><span class="sxs-lookup"><span data-stu-id="21b95-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="21b95-254">Ao contrário de outros membros, os construtores de instância não são herdados.</span><span class="sxs-lookup"><span data-stu-id="21b95-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="21b95-255">Uma classe não tem construtores de instância diferentes dos construtores realmente declarados na classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="21b95-256">Se nenhum construtor de instância for fornecido para uma classe, então um construtor vazio sem parâmetros será fornecido automaticamente.</span><span class="sxs-lookup"><span data-stu-id="21b95-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="21b95-257">Propriedades</span><span class="sxs-lookup"><span data-stu-id="21b95-257">Properties</span></span>

<span data-ttu-id="21b95-258">As *propriedades* são uma extensão natural dos campos.</span><span class="sxs-lookup"><span data-stu-id="21b95-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="21b95-259">Elas são denominadas membros com tipos associados, e a sintaxe para acessar os campos e as propriedades é a mesma.</span><span class="sxs-lookup"><span data-stu-id="21b95-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="21b95-260">No entanto, ao contrário dos campos, as propriedades não denotam locais de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="21b95-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="21b95-261">Em vez disso, as propriedades têm *acessadores* que especificam as instruções executadas quando seus valores são lidos ou gravados.</span><span class="sxs-lookup"><span data-stu-id="21b95-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="21b95-262">Uma propriedade é declarada como um campo, exceto que a declaração termina com um acessador get ou um acessador set gravado entre os delimitadores `{` e `}` em vez de terminar em um ponto e vírgula.</span><span class="sxs-lookup"><span data-stu-id="21b95-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="21b95-263">Uma propriedade que tem um acessador get e um acessador set é uma *propriedade de leitura-gravação*. Uma propriedade que tem apenas um acessador get é uma *propriedade somente leitura*, e uma propriedade que tem apenas um acessador set é uma *propriedade somente gravação*.</span><span class="sxs-lookup"><span data-stu-id="21b95-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="21b95-264">Um acessador get corresponde a um método sem parâmetros com um valor retornado do tipo de propriedade.</span><span class="sxs-lookup"><span data-stu-id="21b95-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="21b95-265">Um acessador set corresponde a um método com um parâmetro único chamado valor e nenhum tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="21b95-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="21b95-266">O acessador get computa o valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="21b95-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="21b95-267">O acessador set fornece um novo valor para a propriedade.</span><span class="sxs-lookup"><span data-stu-id="21b95-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="21b95-268">Quando a propriedade é o destino de uma atribuição, ou o operando de `++` ou `--` , o acessador set é invocado.</span><span class="sxs-lookup"><span data-stu-id="21b95-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="21b95-269">Em outros casos em que a propriedade é referenciada, o acessador get é invocado.</span><span class="sxs-lookup"><span data-stu-id="21b95-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="21b95-270">A classe `MyList<T>` declara duas propriedades, `Count` e `Capacity`, que são somente leitura e leitura/gravação, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="21b95-270">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="21b95-271">O código a seguir é um exemplo de uso dessas propriedades:</span><span class="sxs-lookup"><span data-stu-id="21b95-271">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="21b95-272">Como nos campos e métodos, o C# dá suporte a propriedades de instância e a propriedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="21b95-272">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="21b95-273">As propriedades estáticas são declaradas com o modificador estático e as propriedades de instância são declaradas sem ele.</span><span class="sxs-lookup"><span data-stu-id="21b95-273">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="21b95-274">Os acessadores de uma propriedade podem ser virtuais.</span><span class="sxs-lookup"><span data-stu-id="21b95-274">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="21b95-275">Quando uma declaração de propriedade inclui um modificador `virtual`, `abstract` ou `override`, ela se aplica aos acessadores da propriedade.</span><span class="sxs-lookup"><span data-stu-id="21b95-275">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="21b95-276">Indexadores</span><span class="sxs-lookup"><span data-stu-id="21b95-276">Indexers</span></span>

<span data-ttu-id="21b95-277">Um *indexador* é um membro que permite que objetos sejam indexados da mesma forma que uma matriz.</span><span class="sxs-lookup"><span data-stu-id="21b95-277">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="21b95-278">Um indexador é declarado como uma propriedade, exceto se o nome do membro for `this` seguido por uma lista de parâmetros escrita entre os delimitadores `[` e `]`.</span><span class="sxs-lookup"><span data-stu-id="21b95-278">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="21b95-279">Os parâmetros estão disponíveis nos acessadores do indexador.</span><span class="sxs-lookup"><span data-stu-id="21b95-279">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="21b95-280">Semelhante às propriedades, os indexadores podem ser de leitura-gravação, somente leitura e somente gravação, e os acessadores de um indexador pode ser virtuais.</span><span class="sxs-lookup"><span data-stu-id="21b95-280">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="21b95-281">A classe `MyList<T>` declara um indexador único de leitura-gravação que usa um parâmetro `int`.</span><span class="sxs-lookup"><span data-stu-id="21b95-281">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="21b95-282">O indexador possibilita indexar instâncias `MyList<T>` com valores `int`.</span><span class="sxs-lookup"><span data-stu-id="21b95-282">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="21b95-283">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="21b95-283">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="21b95-284">Os indexadores podem ser sobrecarregados.</span><span class="sxs-lookup"><span data-stu-id="21b95-284">Indexers can be overloaded.</span></span> <span data-ttu-id="21b95-285">Uma classe pode declarar vários indexadores, desde que o número ou os tipos de seus parâmetros sejam diferentes.</span><span class="sxs-lookup"><span data-stu-id="21b95-285">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="21b95-286">Eventos</span><span class="sxs-lookup"><span data-stu-id="21b95-286">Events</span></span>

<span data-ttu-id="21b95-287">Um *evento* é um membro que permite que uma classe ou objeto forneça notificações.</span><span class="sxs-lookup"><span data-stu-id="21b95-287">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="21b95-288">Um evento é declarado como um campo, exceto que a declaração inclui uma `event` palavra-chave e o tipo deve ser um tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="21b95-288">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="21b95-289">Dentro de uma classe que declara um membro de evento, o evento se comporta exatamente como um campo de um tipo delegado (desde que o evento não seja abstrato e não declare acessadores).</span><span class="sxs-lookup"><span data-stu-id="21b95-289">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="21b95-290">O campo armazena uma referência a um delegado que representa os manipuladores de eventos que foram adicionados ao evento.</span><span class="sxs-lookup"><span data-stu-id="21b95-290">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="21b95-291">Se nenhum manipulador de evento estiver presente, o campo será `null`.</span><span class="sxs-lookup"><span data-stu-id="21b95-291">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="21b95-292">A classe `MyList<T>` declara um membro único de evento chamado `Changed`, que indica que um novo item foi adicionado à lista.</span><span class="sxs-lookup"><span data-stu-id="21b95-292">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="21b95-293">O evento Alterado é gerado pelo método virtual `OnChanged`, que primeiro verifica se o evento é `null` (o que significa que nenhum manipulador está presente).</span><span class="sxs-lookup"><span data-stu-id="21b95-293">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="21b95-294">A noção de gerar um evento é precisamente equivalente a invocar o delegado representado pelo evento.</span><span class="sxs-lookup"><span data-stu-id="21b95-294">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="21b95-295">Não há construções de linguagem especiais para gerar eventos.</span><span class="sxs-lookup"><span data-stu-id="21b95-295">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="21b95-296">Os clientes reagem a eventos por meio de *manipuladores de eventos*.</span><span class="sxs-lookup"><span data-stu-id="21b95-296">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="21b95-297">Os manipuladores de eventos são conectados usando o operador `+=` e removidos usando o operador `-=`.</span><span class="sxs-lookup"><span data-stu-id="21b95-297">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="21b95-298">O exemplo a seguir anexa um manipulador de eventos para o evento `Changed` de um `MyList<string>`.</span><span class="sxs-lookup"><span data-stu-id="21b95-298">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="21b95-299">Para cenários avançados em que o controle do armazenamento subjacente de um evento é desejado, uma declaração de evento pode fornecer explicitamente e acessadores `add` `remove` , que são semelhantes ao `set` acessador de uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="21b95-299">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="21b95-300">Operadores</span><span class="sxs-lookup"><span data-stu-id="21b95-300">Operators</span></span>

<span data-ttu-id="21b95-301">Um *operador* é um membro que define o significado da aplicação de um operador de expressão específico para instâncias de uma classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-301">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="21b95-302">Três tipos de operadores podem ser definidos: operadores unários, operadores binários e operadores de conversão.</span><span class="sxs-lookup"><span data-stu-id="21b95-302">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="21b95-303">Todos os operadores devem ser declarados como `public` e `static`.</span><span class="sxs-lookup"><span data-stu-id="21b95-303">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="21b95-304">A `MyList<T>` classe declara dois operadores `operator ==` e `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="21b95-304">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="21b95-305">Esses operadores substituídos dão um novo significado a expressões que aplicam esses operadores a `MyList` instâncias.</span><span class="sxs-lookup"><span data-stu-id="21b95-305">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="21b95-306">Especificamente, os operadores definem a igualdade de duas `MyList<T>` instâncias como comparar cada um dos objetos contidos usando seus `Equals` métodos.</span><span class="sxs-lookup"><span data-stu-id="21b95-306">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="21b95-307">O exemplo a seguir usa o operador `==` para comparar duas instâncias `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="21b95-307">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="21b95-308">O primeiro `Console.WriteLine` gera `True` porque as duas listas contêm o mesmo número de objetos com os mesmos valores na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="21b95-308">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="21b95-309">Como `MyList<T>` não definiu `operator ==`, o primeiro `Console.WriteLine` geraria `False` porque `a` e `b` referenciam diferentes instâncias `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="21b95-309">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="21b95-310">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="21b95-310">Finalizers</span></span>

<span data-ttu-id="21b95-311">Um *finalizador* é um membro que implementa as ações necessárias para finalizar uma instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="21b95-311">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="21b95-312">Normalmente, um finalizador é necessário para liberar recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="21b95-312">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="21b95-313">Os finalizadores não podem ter parâmetros, eles não podem ter modificadores de acessibilidade e não podem ser invocados explicitamente.</span><span class="sxs-lookup"><span data-stu-id="21b95-313">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="21b95-314">O finalizador de uma instância é invocado automaticamente durante a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="21b95-314">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="21b95-315">Para obter mais detalhes, consulte o artigo sobre [finalizadores](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="21b95-315">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="21b95-316">O coletor de lixo tem latitude ampla ao decidir quando coletar objetos e executar os finalizadores.</span><span class="sxs-lookup"><span data-stu-id="21b95-316">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="21b95-317">Especificamente, o tempo das invocações do finalizador não é determinístico e os finalizadores podem ser executados em qualquer thread.</span><span class="sxs-lookup"><span data-stu-id="21b95-317">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="21b95-318">Para esses e outros motivos, as classes devem implementar os finalizadores apenas quando não houver outras soluções viáveis.</span><span class="sxs-lookup"><span data-stu-id="21b95-318">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="21b95-319">A instrução `using` fornece uma abordagem melhor para a destruição de objetos.</span><span class="sxs-lookup"><span data-stu-id="21b95-319">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="21b95-320">Expressões</span><span class="sxs-lookup"><span data-stu-id="21b95-320">Expressions</span></span>

<span data-ttu-id="21b95-321">*Expressões* são construídas a partir de *operandos* e *operadores*.</span><span class="sxs-lookup"><span data-stu-id="21b95-321">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="21b95-322">Os operadores de uma expressão indicam quais operações devem ser aplicadas aos operandos.</span><span class="sxs-lookup"><span data-stu-id="21b95-322">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="21b95-323">Exemplos de operadores incluem `+`, `-`, `*`, `/` e `new`.</span><span class="sxs-lookup"><span data-stu-id="21b95-323">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="21b95-324">Exemplos de operandos incluem literais, campos, variáveis locais e expressões.</span><span class="sxs-lookup"><span data-stu-id="21b95-324">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="21b95-325">Quando uma expressão contém vários operadores, a *precedência* dos operadores controla a ordem na qual os operadores individuais são avaliados.</span><span class="sxs-lookup"><span data-stu-id="21b95-325">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="21b95-326">Por exemplo, a expressão `x + y * z` é avaliada como `x + (y * z)` porque o operador `*` tem precedência maior do que o operador `+`.</span><span class="sxs-lookup"><span data-stu-id="21b95-326">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="21b95-327">Quando ocorre um operando entre dois operadores com a mesma precedência, a *associatividade* dos operadores controla a ordem na qual as operações são executadas:</span><span class="sxs-lookup"><span data-stu-id="21b95-327">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="21b95-328">Exceto para os operadores de atribuição e de União nulo, todos os operadores binários são *associativos à esquerda*, o que significa que as operações são executadas da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="21b95-328">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="21b95-329">Por exemplo, `x + y + z` é avaliado como `(x + y) + z`.</span><span class="sxs-lookup"><span data-stu-id="21b95-329">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="21b95-330">Os operadores de atribuição, a União nula `??` e `??=` os operadores e o operador condicional `?:` são *associativos à direita*, o que significa que as operações são executadas da direita para a esquerda.</span><span class="sxs-lookup"><span data-stu-id="21b95-330">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="21b95-331">Por exemplo, `x = y = z` é avaliado como `x = (y = z)`.</span><span class="sxs-lookup"><span data-stu-id="21b95-331">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="21b95-332">Precedência e associatividade podem ser controladas usando parênteses.</span><span class="sxs-lookup"><span data-stu-id="21b95-332">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="21b95-333">Por exemplo, `x + y * z` primeiro multiplica `y` por `z` e, em seguida, adiciona o resultado a `x`, mas `(x + y) * z` primeiro adiciona `x` e `y` e, em seguida, multiplica o resultado por `z`.</span><span class="sxs-lookup"><span data-stu-id="21b95-333">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="21b95-334">A maioria dos operadores pode ser [*sobrecarregada*](../language-reference/operators/operator-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="21b95-334">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="21b95-335">A sobrecarga de operador permite que implementações de operador definidas pelo usuário sejam especificadas para operações em que um ou ambos os operandos são de um tipo struct ou de classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="21b95-335">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="21b95-336">C# fornece uma série de operadores para realizar operações [aritméticas](../language-reference/operators/arithmetic-operators.md), [lógicas](../language-reference/operators/boolean-logical-operators.md), [bit a bit e shift](../language-reference/operators/bitwise-and-shift-operators.md) e comparações de [igualdade](../language-reference/operators/equality-operators.md) e [ordem](../language-reference/operators/comparison-operators.md).</span><span class="sxs-lookup"><span data-stu-id="21b95-336">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="21b95-337">Para obter a lista completa de operadores do C# ordenada pelo nível de precedência, confira [Operadores do C#](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="21b95-337">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="21b95-338">Instruções</span><span class="sxs-lookup"><span data-stu-id="21b95-338">Statements</span></span>

<span data-ttu-id="21b95-339">As ações de um programa são expressas usando *instruções*.</span><span class="sxs-lookup"><span data-stu-id="21b95-339">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="21b95-340">O C# oferece suporte a vários tipos diferentes de instruções, algumas delas definidas em termos de instruções inseridas.</span><span class="sxs-lookup"><span data-stu-id="21b95-340">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="21b95-341">Um *bloco* permite a produção de várias instruções em contextos nos quais uma única instrução é permitida.</span><span class="sxs-lookup"><span data-stu-id="21b95-341">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="21b95-342">Um bloco é composto por uma lista de instruções escritas entre os delimitadores `{` e `}`.</span><span class="sxs-lookup"><span data-stu-id="21b95-342">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="21b95-343">*Instruções de declaração* são usadas para declarar constantes e variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="21b95-343">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="21b95-344">*Instruções de expressão* são usadas para avaliar expressões.</span><span class="sxs-lookup"><span data-stu-id="21b95-344">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="21b95-345">As expressões que podem ser usadas como instruções incluem chamadas de método, alocações de objeto usando o operador `new`, atribuições usando `=` e os operadores de atribuição compostos, operações de incremento e decremento usando os operadores `++` e `--` e as expressões `await`.</span><span class="sxs-lookup"><span data-stu-id="21b95-345">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="21b95-346">*Instruções de seleção* são usadas para selecionar uma dentre várias instruções possíveis para execução com base no valor de alguma expressão.</span><span class="sxs-lookup"><span data-stu-id="21b95-346">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="21b95-347">Esse grupo contém as `if` `switch` instruções e.</span><span class="sxs-lookup"><span data-stu-id="21b95-347">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="21b95-348">*Instruções de iteração* são usadas para executar repetidamente uma instrução inserida.</span><span class="sxs-lookup"><span data-stu-id="21b95-348">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="21b95-349">Esse grupo contém as `while` `do` instruções,, `for` e `foreach` .</span><span class="sxs-lookup"><span data-stu-id="21b95-349">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="21b95-350">*Instruções de salto* são usadas para transferir o controle.</span><span class="sxs-lookup"><span data-stu-id="21b95-350">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="21b95-351">Esse grupo contém as `break` `continue` instruções,, `goto` ,, `throw` `return` e `yield` .</span><span class="sxs-lookup"><span data-stu-id="21b95-351">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="21b95-352">A instrução `try`... `catch` é usada para capturar exceções que ocorrem durante a execução de um bloco, e a instrução `try`... `finally` é usada para especificar o código de finalização que é executado sempre, se uma exceção ocorrer ou não.</span><span class="sxs-lookup"><span data-stu-id="21b95-352">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="21b95-353">As instruções `checked` e `unchecked` são usadas para controlar o contexto de verificação de estouro para operações e conversões aritméticas do tipo integral.</span><span class="sxs-lookup"><span data-stu-id="21b95-353">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="21b95-354">A instrução `lock` é usada para obter o bloqueio de exclusão mútua para um determinado objeto, executar uma instrução e, em seguida, liberar o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="21b95-354">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="21b95-355">A instrução `using` é usada para obter um recurso, executar uma instrução e, em seguida, descartar esse recurso.</span><span class="sxs-lookup"><span data-stu-id="21b95-355">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="21b95-356">O seguinte lista os tipos de instruções que podem ser usadas:</span><span class="sxs-lookup"><span data-stu-id="21b95-356">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="21b95-357">Declaração de variável local.</span><span class="sxs-lookup"><span data-stu-id="21b95-357">Local variable declaration.</span></span>
* <span data-ttu-id="21b95-358">Declaração de constante local.</span><span class="sxs-lookup"><span data-stu-id="21b95-358">Local constant declaration.</span></span>
* <span data-ttu-id="21b95-359">Instrução de expressão.</span><span class="sxs-lookup"><span data-stu-id="21b95-359">Expression statement.</span></span>
* <span data-ttu-id="21b95-360">`if` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-360">`if` statement.</span></span>
* <span data-ttu-id="21b95-361">`switch` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-361">`switch` statement.</span></span>
* <span data-ttu-id="21b95-362">`while` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-362">`while` statement.</span></span>
* <span data-ttu-id="21b95-363">`do` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-363">`do` statement.</span></span>
* <span data-ttu-id="21b95-364">`for` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-364">`for` statement.</span></span>
* <span data-ttu-id="21b95-365">`foreach` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-365">`foreach` statement.</span></span>
* <span data-ttu-id="21b95-366">`break` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-366">`break` statement.</span></span>
* <span data-ttu-id="21b95-367">`continue` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-367">`continue` statement.</span></span>
* <span data-ttu-id="21b95-368">`goto` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-368">`goto` statement.</span></span>
* <span data-ttu-id="21b95-369">`return` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-369">`return` statement.</span></span>
* <span data-ttu-id="21b95-370">`yield` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-370">`yield` statement.</span></span>
* <span data-ttu-id="21b95-371">`throw` instruções e `try` instruções.</span><span class="sxs-lookup"><span data-stu-id="21b95-371">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="21b95-372">`checked``unchecked`instruções and.</span><span class="sxs-lookup"><span data-stu-id="21b95-372">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="21b95-373">`lock` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-373">`lock` statement.</span></span>
* <span data-ttu-id="21b95-374">`using` privacidade.</span><span class="sxs-lookup"><span data-stu-id="21b95-374">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="21b95-375">[Anterior](types.md) 
> [Avançar](features.md)</span><span class="sxs-lookup"><span data-stu-id="21b95-375">[Previous](types.md)
[Next](features.md)</span></span>
