---
title: Classes e objetos em C# - um tour pela linguagem C#
description: "Novato em C#? Leia esta visão geral de classes, objetos e herança"
keywords: ".NET, csharp, classe, instância, objeto, herança, polimorfismo"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: c71aee3dbfb6544973e1527955ca03deb6b569f3
ms.contentlocale: pt-br
ms.lasthandoff: 07/28/2017

---
# <a name="classes-and-objects"></a><span data-ttu-id="619b0-105">Classes e objetos</span><span class="sxs-lookup"><span data-stu-id="619b0-105">Classes and objects</span></span>

<span data-ttu-id="619b0-106">As *classes* são os tipos do C# mais fundamentais.</span><span class="sxs-lookup"><span data-stu-id="619b0-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="619b0-107">Uma classe é uma estrutura de dados que combina ações (métodos e outros membros da função) e estado (campos) em uma única unidade.</span><span class="sxs-lookup"><span data-stu-id="619b0-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="619b0-108">Uma classe fornece uma definição para *instâncias* da classe criadas dinamicamente, também conhecidas como *objetos*.</span><span class="sxs-lookup"><span data-stu-id="619b0-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="619b0-109">As classes dão suporte à *herança* e *polimorfismo*, mecanismos nos quais *classes derivadas* podem estender e especializar *classes base*.</span><span class="sxs-lookup"><span data-stu-id="619b0-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="619b0-110">Novas classes são criadas usando declarações de classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-110">New classes are created using class declarations.</span></span> <span data-ttu-id="619b0-111">Uma declaração de classe inicia com um cabeçalho que especifica os atributos e modificadores de classe, o nome da classe, a classe base (se fornecida) e as interfaces implementadas pela classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="619b0-112">O cabeçalho é seguido pelo corpo da classe, que consiste em uma lista de declarações de membro escrita entre os delimitadores `{` e `}`.</span><span class="sxs-lookup"><span data-stu-id="619b0-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="619b0-113">A seguir está uma declaração de uma classe simples chamada `Point`:</span><span class="sxs-lookup"><span data-stu-id="619b0-113">The following is a declaration of a simple class named `Point`:</span></span>

<span data-ttu-id="619b0-114">[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]</span><span class="sxs-lookup"><span data-stu-id="619b0-114">[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]</span></span>

<span data-ttu-id="619b0-115">Instâncias de classes são criadas usando o operador `new`, que aloca memória para uma nova instância, chama um construtor para inicializar a instância e retorna uma referência à instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-115">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="619b0-116">As instruções a seguir criam dois objetos Point e armazenam referências a esses objetos em duas variáveis:</span><span class="sxs-lookup"><span data-stu-id="619b0-116">The following statements create two Point objects and store references to those objects in two variables:</span></span>

<span data-ttu-id="619b0-117">[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]</span><span class="sxs-lookup"><span data-stu-id="619b0-117">[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]</span></span>

<span data-ttu-id="619b0-118">A memória ocupada por um objeto é recuperada automaticamente quando o objeto não está mais acessível.</span><span class="sxs-lookup"><span data-stu-id="619b0-118">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="619b0-119">Não é necessário nem possível desalocar explicitamente os objetos em C#.</span><span class="sxs-lookup"><span data-stu-id="619b0-119">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="619b0-120">Membros</span><span class="sxs-lookup"><span data-stu-id="619b0-120">Members</span></span>

<span data-ttu-id="619b0-121">Os membros de uma classe são membros estáticos ou membros de instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-121">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="619b0-122">Os membros estáticos pertencem às classes e os membros de instância pertencem aos objetos (instâncias de classes).</span><span class="sxs-lookup"><span data-stu-id="619b0-122">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="619b0-123">O exemplo a seguir fornece uma visão geral dos tipos de membros que uma classe pode conter.</span><span class="sxs-lookup"><span data-stu-id="619b0-123">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="619b0-124">Constantes</span><span class="sxs-lookup"><span data-stu-id="619b0-124">Constants</span></span>
    - <span data-ttu-id="619b0-125">Valores constantes associados à classe</span><span class="sxs-lookup"><span data-stu-id="619b0-125">Constant values associated with the class</span></span>
* <span data-ttu-id="619b0-126">Campos</span><span class="sxs-lookup"><span data-stu-id="619b0-126">Fields</span></span>
    - <span data-ttu-id="619b0-127">Variáveis de classe</span><span class="sxs-lookup"><span data-stu-id="619b0-127">Variables of the class</span></span>
* <span data-ttu-id="619b0-128">Métodos</span><span class="sxs-lookup"><span data-stu-id="619b0-128">Methods</span></span>
    - <span data-ttu-id="619b0-129">Os cálculos e as ações que podem ser executados pela classe</span><span class="sxs-lookup"><span data-stu-id="619b0-129">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="619b0-130">Propriedades</span><span class="sxs-lookup"><span data-stu-id="619b0-130">Properties</span></span>
    - <span data-ttu-id="619b0-131">Ações associadas à leitura e à gravação de propriedades nomeadas da classe</span><span class="sxs-lookup"><span data-stu-id="619b0-131">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="619b0-132">Indexadores</span><span class="sxs-lookup"><span data-stu-id="619b0-132">Indexers</span></span>
    - <span data-ttu-id="619b0-133">Ações associadas a instâncias de indexação da classe como uma matriz</span><span class="sxs-lookup"><span data-stu-id="619b0-133">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="619b0-134">Eventos</span><span class="sxs-lookup"><span data-stu-id="619b0-134">Events</span></span>
    - <span data-ttu-id="619b0-135">Notificações que podem ser geradas pela classe</span><span class="sxs-lookup"><span data-stu-id="619b0-135">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="619b0-136">Operadores</span><span class="sxs-lookup"><span data-stu-id="619b0-136">Operators</span></span>
    - <span data-ttu-id="619b0-137">Operadores de conversões e expressão com suporte da classe</span><span class="sxs-lookup"><span data-stu-id="619b0-137">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="619b0-138">Construtores</span><span class="sxs-lookup"><span data-stu-id="619b0-138">Constructors</span></span>
    - <span data-ttu-id="619b0-139">Ações necessárias para inicializar instâncias da classe ou a própria classe</span><span class="sxs-lookup"><span data-stu-id="619b0-139">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="619b0-140">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="619b0-140">Finalizers</span></span>
    - <span data-ttu-id="619b0-141">Ações a serem executadas antes de as instâncias da classe serem descartadas permanentemente</span><span class="sxs-lookup"><span data-stu-id="619b0-141">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="619b0-142">Tipos</span><span class="sxs-lookup"><span data-stu-id="619b0-142">Types</span></span>
    - <span data-ttu-id="619b0-143">Tipos aninhados declarados pela classe</span><span class="sxs-lookup"><span data-stu-id="619b0-143">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="619b0-144">Acessibilidade</span><span class="sxs-lookup"><span data-stu-id="619b0-144">Accessibility</span></span>

<span data-ttu-id="619b0-145">Cada membro de uma classe tem uma acessibilidade associada, que controla as regiões de texto do programa que são capazes de acessar o membro.</span><span class="sxs-lookup"><span data-stu-id="619b0-145">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="619b0-146">Há cinco formas possíveis de acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="619b0-146">There are five possible forms of accessibility.</span></span> <span data-ttu-id="619b0-147">Elas são resumidas abaixo.</span><span class="sxs-lookup"><span data-stu-id="619b0-147">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="619b0-148">Acesso não limitado</span><span class="sxs-lookup"><span data-stu-id="619b0-148">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="619b0-149">Acesso limitado a essa classe ou classes derivadas dessa classe</span><span class="sxs-lookup"><span data-stu-id="619b0-149">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="619b0-150">Acesso limitado ao assembly atual (.exe, .dll, etc.)</span><span class="sxs-lookup"><span data-stu-id="619b0-150">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="619b0-151">Acesso limitado à classe ou classes recipiente derivadas da classe recipiente</span><span class="sxs-lookup"><span data-stu-id="619b0-151">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="619b0-152">Acesso limitado a essa classe</span><span class="sxs-lookup"><span data-stu-id="619b0-152">Access limited to this class</span></span>

## <a name="type-parameters"></a><span data-ttu-id="619b0-153">Parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="619b0-153">Type parameters</span></span>

<span data-ttu-id="619b0-154">Uma definição de classe pode especificar um conjunto de parâmetros de tipo seguindo o nome da classe com colchetes angulares com uma lista de nomes de parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="619b0-154">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="619b0-155">Em seguida, os parâmetros de tipo podem ser usados no corpo das declarações de classe para definir os membros da classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-155">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="619b0-156">No exemplo a seguir, os parâmetros de tipo de `Pair` são `TFirst` e `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="619b0-156">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

<span data-ttu-id="619b0-157">[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]</span><span class="sxs-lookup"><span data-stu-id="619b0-157">[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]</span></span>

<span data-ttu-id="619b0-158">Um tipo de classe que é declarado para pegar parâmetros de tipo é chamado de *tipo de classe genérica*.</span><span class="sxs-lookup"><span data-stu-id="619b0-158">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="619b0-159">Tipos de struct, de interface e de delegado também podem ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="619b0-159">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="619b0-160">Quando a classe genérica é usada, os argumentos de tipo devem ser fornecidos para cada um dos parâmetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="619b0-160">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

<span data-ttu-id="619b0-161">[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]</span><span class="sxs-lookup"><span data-stu-id="619b0-161">[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]</span></span>

<span data-ttu-id="619b0-162">Um tipo genérico com argumentos de tipo fornecidos, como `Pair<int,string>` acima, é chamado de *tipo construído*.</span><span class="sxs-lookup"><span data-stu-id="619b0-162">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="619b0-163">Classes base</span><span class="sxs-lookup"><span data-stu-id="619b0-163">Base classes</span></span>

<span data-ttu-id="619b0-164">Uma declaração de classe pode especificar uma classe base, seguindo os parâmetros de nome da classe e tipo com dois-pontos e o nome da classe base.</span><span class="sxs-lookup"><span data-stu-id="619b0-164">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="619b0-165">Omitir uma especificação de classe base é o mesmo que derivar do `object` de tipo.</span><span class="sxs-lookup"><span data-stu-id="619b0-165">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="619b0-166">No exemplo a seguir, a classe base de `Point3D` é `Point` e a classe base de `Point` é `object`:</span><span class="sxs-lookup"><span data-stu-id="619b0-166">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

<span data-ttu-id="619b0-167">[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]</span><span class="sxs-lookup"><span data-stu-id="619b0-167">[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]</span></span>

<span data-ttu-id="619b0-168">Uma classe herda os membros de sua classe base.</span><span class="sxs-lookup"><span data-stu-id="619b0-168">A class inherits the members of its base class.</span></span> <span data-ttu-id="619b0-169">A herança significa que uma classe contém implicitamente todos os membros de sua classe base, exceto para a instância e os construtores estáticos, além dos finalizadores da classe base.</span><span class="sxs-lookup"><span data-stu-id="619b0-169">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="619b0-170">Uma classe derivada pode adicionar novos membros aos que ela herda, mas ela não pode remover a definição de um membro herdado.</span><span class="sxs-lookup"><span data-stu-id="619b0-170">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="619b0-171">No exemplo anterior, `Point3D` herda os campos `x` e `y` de `Point` e cada instância `Point3D` contém três campos: `x`, `y` e `z`.</span><span class="sxs-lookup"><span data-stu-id="619b0-171">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="619b0-172">Existe uma conversão implícita de um tipo de classe para qualquer um de seus tipos de classe base.</span><span class="sxs-lookup"><span data-stu-id="619b0-172">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="619b0-173">Portanto, uma variável de um tipo de classe pode referenciar uma instância dessa classe ou uma instância de qualquer classe derivada.</span><span class="sxs-lookup"><span data-stu-id="619b0-173">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="619b0-174">Por exemplo, dadas as declarações de classe anteriores, uma variável do tipo `Point` podem referenciar um `Point` ou um `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="619b0-174">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

<span data-ttu-id="619b0-175">[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]</span><span class="sxs-lookup"><span data-stu-id="619b0-175">[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]</span></span>

## <a name="fields"></a><span data-ttu-id="619b0-176">Campos</span><span class="sxs-lookup"><span data-stu-id="619b0-176">Fields</span></span>

<span data-ttu-id="619b0-177">Um *campo* é uma variável que está associada a uma classe ou a uma instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-177">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="619b0-178">Um campo declarado com o modificador estático define um campo estático.</span><span class="sxs-lookup"><span data-stu-id="619b0-178">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="619b0-179">Um campo estático identifica exatamente um local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="619b0-179">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="619b0-180">Não importa quantas instâncias de uma classe são criadas, há sempre apenas uma cópia de um campo estático.</span><span class="sxs-lookup"><span data-stu-id="619b0-180">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="619b0-181">Um campo declarado sem o modificador estático define um campo de instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-181">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="619b0-182">Cada instância de uma classe contém uma cópia separada de todos os campos de instância dessa classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-182">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="619b0-183">No exemplo a seguir, cada instância da classe `Color` tem uma cópia separada dos campos de instância `r`, `g` e `b`, mas há apenas uma cópia dos campos estáticos `Black`, `White`, `Red`, `Green` e `Blue`:</span><span class="sxs-lookup"><span data-stu-id="619b0-183">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

<span data-ttu-id="619b0-184">[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]</span><span class="sxs-lookup"><span data-stu-id="619b0-184">[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]</span></span>

<span data-ttu-id="619b0-185">Conforme mostrado no exemplo anterior, os *campos somente leitura* podem ser declarados com um modificador `readonly`.</span><span class="sxs-lookup"><span data-stu-id="619b0-185">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="619b0-186">A atribuição a um campo `readonly` só pode ocorrer como parte da declaração do campo ou em um construtor na mesma classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-186">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="619b0-187">Métodos</span><span class="sxs-lookup"><span data-stu-id="619b0-187">Methods</span></span>

<span data-ttu-id="619b0-188">Um *método* é um membro que implementa um cálculo ou uma ação que pode ser executada por um objeto ou classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-188">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="619b0-189">Os *métodos estáticos* são acessados pela classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-189">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="619b0-190">Os *métodos de instância* são acessados pelas instâncias da classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-190">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="619b0-191">Os métodos podem ter uma lista de *parâmetros* que representam valores ou referências de variável passadas para o método, e um *tipo de retorno*, que especifica o tipo do valor calculado e retornado pelo método.</span><span class="sxs-lookup"><span data-stu-id="619b0-191">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="619b0-192">Um tipo de retorno do método será `void` se ele não retornar um valor.</span><span class="sxs-lookup"><span data-stu-id="619b0-192">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="619b0-193">Como os tipos, os métodos também podem ter um conjunto de parâmetros de tipo, para que os quais os argumentos de tipo devem ser especificados quando o método é chamado.</span><span class="sxs-lookup"><span data-stu-id="619b0-193">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="619b0-194">Ao contrário dos tipos, os argumentos de tipo geralmente podem ser inferidos de argumentos de uma chamada de método e não precisam ser fornecidos explicitamente.</span><span class="sxs-lookup"><span data-stu-id="619b0-194">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="619b0-195">A *assinatura* de um método deve ser exclusiva na classe na qual o método é declarado.</span><span class="sxs-lookup"><span data-stu-id="619b0-195">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="619b0-196">A assinatura de um método consiste no nome do método, número de parâmetros de tipo e número, modificadores e tipos de seus parâmetros.</span><span class="sxs-lookup"><span data-stu-id="619b0-196">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="619b0-197">A assinatura de um método não inclui o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="619b0-197">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="619b0-198">Parâmetros</span><span class="sxs-lookup"><span data-stu-id="619b0-198">Parameters</span></span>

<span data-ttu-id="619b0-199">Os parâmetros são usados para passar valores ou referências de variável aos métodos.</span><span class="sxs-lookup"><span data-stu-id="619b0-199">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="619b0-200">Os parâmetros de um método obtêm seus valores reais de *argumentos* que são especificados quando o método é invocado.</span><span class="sxs-lookup"><span data-stu-id="619b0-200">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="619b0-201">Há quatro tipos de parâmetros: parâmetros de valor, parâmetros de referência, parâmetros de saída e matrizes de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="619b0-201">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="619b0-202">Um *parâmetro de valor* é usado para passar argumentos de entrada.</span><span class="sxs-lookup"><span data-stu-id="619b0-202">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="619b0-203">Um parâmetro de valor corresponde a uma variável local que obtém seu valor inicial do argumento passado para o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="619b0-203">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="619b0-204">As modificações em um parâmetro de valor não afetam o argumento passado para o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="619b0-204">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="619b0-205">Os parâmetros de valor podem ser opcionais, especificando um valor padrão para que os argumentos correspondentes possam ser omitidos.</span><span class="sxs-lookup"><span data-stu-id="619b0-205">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="619b0-206">Um *parâmetro de referência* é usado para passar argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="619b0-206">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="619b0-207">O argumento passado para um parâmetro de referência deve ser uma variável com um valor definido e, durante a execução do método, o parâmetro de referência representa o mesmo local de armazenamento como a variável de argumento.</span><span class="sxs-lookup"><span data-stu-id="619b0-207">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="619b0-208">Um parâmetro de referência é declarado com o modificador `ref`.</span><span class="sxs-lookup"><span data-stu-id="619b0-208">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="619b0-209">O exemplo a seguir mostra o uso de parâmetros `ref`.</span><span class="sxs-lookup"><span data-stu-id="619b0-209">The following example shows the use of `ref` parameters.</span></span>

<span data-ttu-id="619b0-210">[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]</span><span class="sxs-lookup"><span data-stu-id="619b0-210">[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]</span></span>

<span data-ttu-id="619b0-211">Um *parâmetro de saída* é usado para passar argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="619b0-211">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="619b0-212">Ele é semelhante a um parâmetro de referência, exceto que ele não requer que você atribua explicitamente um valor ao argumento fornecido pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="619b0-212">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="619b0-213">Um parâmetro de saída é declarado com o modificador `out`.</span><span class="sxs-lookup"><span data-stu-id="619b0-213">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="619b0-214">O exemplo a seguir mostra o uso de parâmetros `out` usando a sintaxe introduzida no C# 7.</span><span class="sxs-lookup"><span data-stu-id="619b0-214">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

<span data-ttu-id="619b0-215">[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]</span><span class="sxs-lookup"><span data-stu-id="619b0-215">[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]</span></span>

<span data-ttu-id="619b0-216">Uma *matriz de parâmetros* permite que um número variável de argumentos sejam passados para um método.</span><span class="sxs-lookup"><span data-stu-id="619b0-216">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="619b0-217">Uma matriz de parâmetro é declarada com o modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="619b0-217">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="619b0-218">Somente o último parâmetro de um método pode ser uma matriz de parâmetros e o tipo de uma matriz de parâmetros deve ser um tipo de matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="619b0-218">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="619b0-219">Os métodos Write e WriteLine da classe `@System.Console` são bons exemplos de uso da matriz de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="619b0-219">The Write and WriteLine methods of the `@System.Console` class are good examples of parameter array usage.</span></span> <span data-ttu-id="619b0-220">Eles são declarados como segue.</span><span class="sxs-lookup"><span data-stu-id="619b0-220">They are declared as follows.</span></span>

<span data-ttu-id="619b0-221">[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]</span><span class="sxs-lookup"><span data-stu-id="619b0-221">[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]</span></span>

<span data-ttu-id="619b0-222">Dentro de um método que usa uma matriz de parâmetros, a matriz de parâmetros se comporta exatamente como um parâmetro regular de um tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="619b0-222">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="619b0-223">No entanto, em uma invocação de um método com uma matriz de parâmetros, é possível passar um único argumento do tipo da matriz de parâmetro ou qualquer número de argumentos do tipo de elemento da matriz de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="619b0-223">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="619b0-224">No último caso, uma instância de matriz é automaticamente criada e inicializada com os argumentos determinados.</span><span class="sxs-lookup"><span data-stu-id="619b0-224">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="619b0-225">Esse exemplo</span><span class="sxs-lookup"><span data-stu-id="619b0-225">This example</span></span>

<span data-ttu-id="619b0-226">[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]</span><span class="sxs-lookup"><span data-stu-id="619b0-226">[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]</span></span>

<span data-ttu-id="619b0-227">é equivalente ao escrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="619b0-227">is equivalent to writing the following.</span></span>

<span data-ttu-id="619b0-228">[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]</span><span class="sxs-lookup"><span data-stu-id="619b0-228">[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]</span></span>

### <a name="method-body-and-local-variables"></a><span data-ttu-id="619b0-229">Corpo do método e variáveis locais</span><span class="sxs-lookup"><span data-stu-id="619b0-229">Method body and local variables</span></span>

<span data-ttu-id="619b0-230">Um corpo do método especifica as instruções para execução quando o método é invocado.</span><span class="sxs-lookup"><span data-stu-id="619b0-230">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="619b0-231">Um corpo de método pode declarar variáveis que são específicas para a invocação do método.</span><span class="sxs-lookup"><span data-stu-id="619b0-231">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="619b0-232">Essas variáveis são chamadas de *variáveis locais*.</span><span class="sxs-lookup"><span data-stu-id="619b0-232">Such variables are called *local variables*.</span></span> <span data-ttu-id="619b0-233">Uma declaração de variável local especifica um nome de tipo, um nome de variável e, possivelmente, um valor inicial.</span><span class="sxs-lookup"><span data-stu-id="619b0-233">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="619b0-234">O exemplo a seguir declara uma variável local `i` com um valor inicial de zero e uma variável local `j` sem valor inicial.</span><span class="sxs-lookup"><span data-stu-id="619b0-234">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

<span data-ttu-id="619b0-235">[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]</span><span class="sxs-lookup"><span data-stu-id="619b0-235">[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]</span></span>

<span data-ttu-id="619b0-236">O C# requer que uma variável local seja *atribuída definitivamente* antes de seu valor poder ser obtido.</span><span class="sxs-lookup"><span data-stu-id="619b0-236">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="619b0-237">Por exemplo, se a declaração do `i` anterior não incluísse um valor inicial, o compilador relataria um erro para usos subsequentes de `i` porque `i` não seria definitivamente atribuído a esses pontos do programa.</span><span class="sxs-lookup"><span data-stu-id="619b0-237">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="619b0-238">Um método pode usar instruções `return` para retornar o controle é pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="619b0-238">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="619b0-239">Em um método que retorna `void`, as instruções `return` não podem especificar uma expressão.</span><span class="sxs-lookup"><span data-stu-id="619b0-239">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="619b0-240">Em um método que retorna não nulo, as instruções `return` devem incluir uma expressão que calcula o valor retornado.</span><span class="sxs-lookup"><span data-stu-id="619b0-240">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="619b0-241">Métodos estáticos e de instância</span><span class="sxs-lookup"><span data-stu-id="619b0-241">Static and instance methods</span></span>

<span data-ttu-id="619b0-242">Um método declarado com um modificador estático é um *método estático*.</span><span class="sxs-lookup"><span data-stu-id="619b0-242">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="619b0-243">Um método estático não funciona em uma instância específica e pode acessar diretamente apenas membros estáticos.</span><span class="sxs-lookup"><span data-stu-id="619b0-243">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="619b0-244">Um método declarado sem um modificador estático é um *método de instância*.</span><span class="sxs-lookup"><span data-stu-id="619b0-244">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="619b0-245">Um método de instância opera em uma instância específica e pode acessar membros estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-245">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="619b0-246">A instância em que um método de instância foi invocado pode ser explicitamente acessada como `this`.</span><span class="sxs-lookup"><span data-stu-id="619b0-246">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="619b0-247">É um erro se referir a `this` em um método estático.</span><span class="sxs-lookup"><span data-stu-id="619b0-247">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="619b0-248">A seguinte classe `Entity` tem membros estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-248">The following `Entity` class has both static and instance members.</span></span>

<span data-ttu-id="619b0-249">[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]</span><span class="sxs-lookup"><span data-stu-id="619b0-249">[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]</span></span>

<span data-ttu-id="619b0-250">Cada instância `Entity` contém um número de série (e, possivelmente, outras informações que não são mostradas aqui).</span><span class="sxs-lookup"><span data-stu-id="619b0-250">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="619b0-251">O construtor `Entity` (que é como um método de instância) inicializa a nova instância com o próximo número de série disponível.</span><span class="sxs-lookup"><span data-stu-id="619b0-251">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="619b0-252">Como o construtor é um membro de instância, ele tem permissão para acessar tanto o campo de instância `serialNo` e o campo estático `nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="619b0-252">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="619b0-253">Os métodos estáticos `GetNextSerialNo` e `SetNextSerialNo` podem acessar o campo estático `nextSerialNo`, mas seria um erro para eles acessar diretamente o campo de instância `serialNo`.</span><span class="sxs-lookup"><span data-stu-id="619b0-253">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="619b0-254">O exemplo a seguir mostra o uso da classe Entity.</span><span class="sxs-lookup"><span data-stu-id="619b0-254">The following example shows the use of the Entity class.</span></span>

<span data-ttu-id="619b0-255">[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]</span><span class="sxs-lookup"><span data-stu-id="619b0-255">[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]</span></span>

<span data-ttu-id="619b0-256">Observe que os métodos estáticos `SetNextSerialNo` e `GetNextSerialNo` são invocados na classe enquanto o método de instância `GetSerialNo` é chamado em instâncias da classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-256">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="619b0-257">Métodos abstratos, virtuais e de substituição</span><span class="sxs-lookup"><span data-stu-id="619b0-257">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="619b0-258">Quando uma declaração de método de instância inclui um modificador `virtual`, o método deve ser um *método virtual*.</span><span class="sxs-lookup"><span data-stu-id="619b0-258">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="619b0-259">Quando nenhum modificador virtual estiver presente, o método será um *método não virtual*.</span><span class="sxs-lookup"><span data-stu-id="619b0-259">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="619b0-260">Quando um método virtual é invocado, o *tipo de tempo de execução* da instância para o qual essa invocação ocorre determina a implementação real do método para invocar.</span><span class="sxs-lookup"><span data-stu-id="619b0-260">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="619b0-261">Em uma invocação de método não virtual, o *tipo de tempo de compilação* da instância é o fator determinante.</span><span class="sxs-lookup"><span data-stu-id="619b0-261">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="619b0-262">Um método virtual pode ser *substituído* em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="619b0-262">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="619b0-263">Quando uma declaração de método de instância inclui um modificador de substituição, o método substitui um método virtual herdado com a mesma assinatura.</span><span class="sxs-lookup"><span data-stu-id="619b0-263">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="619b0-264">Enquanto uma declaração de método virtual apresenta um novo método, uma declaração de método de substituição restringe um método virtual herdado existente fornecendo uma nova implementação do método.</span><span class="sxs-lookup"><span data-stu-id="619b0-264">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="619b0-265">Um *método abstrato* é um método virtual sem implementação.</span><span class="sxs-lookup"><span data-stu-id="619b0-265">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="619b0-266">Um método abstrato é declarado com o modificador abstrato e é permitido somente em uma classe que também é declarada como abstrata.</span><span class="sxs-lookup"><span data-stu-id="619b0-266">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="619b0-267">Um método abstrato deve ser substituído em cada classe derivada não abstrata.</span><span class="sxs-lookup"><span data-stu-id="619b0-267">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="619b0-268">O exemplo a seguir declara uma classe abstrata, `Expression`, que representa um nó de árvore de expressão e três classes derivadas, `Constant`, `VariableReference` e `Operation`, que implementam nós de árvore de expressão para operações aritméticas, referências de variável e constantes.</span><span class="sxs-lookup"><span data-stu-id="619b0-268">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="619b0-269">(Isso é semelhante, mas não deve ser confundido com os tipos de árvore de expressão).</span><span class="sxs-lookup"><span data-stu-id="619b0-269">(This is similar to, but not to be confused with the expression tree types).</span></span>

<span data-ttu-id="619b0-270">[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]</span><span class="sxs-lookup"><span data-stu-id="619b0-270">[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]</span></span>

<span data-ttu-id="619b0-271">As quatro classes anteriores podem ser usadas para modelar expressões aritméticas.</span><span class="sxs-lookup"><span data-stu-id="619b0-271">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="619b0-272">Por exemplo, usando instâncias dessas classes, a expressão `x + 3` pode ser representada da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="619b0-272">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

<span data-ttu-id="619b0-273">[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]</span><span class="sxs-lookup"><span data-stu-id="619b0-273">[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]</span></span>

<span data-ttu-id="619b0-274">O método `Evaluate` de uma instância `Expression` é chamado para avaliar a expressão especificada e produzir um valor `double`.</span><span class="sxs-lookup"><span data-stu-id="619b0-274">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="619b0-275">O método recebe um argumento `Dictionary` que contém nomes de variáveis (como chaves das entradas) e valores (como valores das entradas).</span><span class="sxs-lookup"><span data-stu-id="619b0-275">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="619b0-276">Como `Evaluate` é um método abstrato, classes não abstratas derivadas de `Expression` devem substituir `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="619b0-276">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="619b0-277">Uma implementação de `Evaluate` do `Constant` retorna apenas a constante armazenada.</span><span class="sxs-lookup"><span data-stu-id="619b0-277">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="619b0-278">Uma implementação de `VariableReference` consulta o nome de variável no dicionário e retorna o valor resultante.</span><span class="sxs-lookup"><span data-stu-id="619b0-278">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="619b0-279">Uma implementação de `Operation` primeiro avalia os operandos esquerdo e direito (chamando recursivamente seus métodos `Evaluate`) e, em seguida, executa a operação aritmética determinada.</span><span class="sxs-lookup"><span data-stu-id="619b0-279">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="619b0-280">O seguinte programa usa as classes `Expression` para avaliar a expressão `x * (y + 2)` para valores diferentes de `x` e `y`.</span><span class="sxs-lookup"><span data-stu-id="619b0-280">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

<span data-ttu-id="619b0-281">[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]</span><span class="sxs-lookup"><span data-stu-id="619b0-281">[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]</span></span>

### <a name="method-overloading"></a><span data-ttu-id="619b0-282">Sobrecarga de método</span><span class="sxs-lookup"><span data-stu-id="619b0-282">Method overloading</span></span>

<span data-ttu-id="619b0-283">A *sobrecarga* de método permite que vários métodos na mesma classe tenham o mesmo nome, contanto que tenham assinaturas exclusivas.</span><span class="sxs-lookup"><span data-stu-id="619b0-283">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="619b0-284">Ao compilar uma invocação de um método sobrecarregado, o compilador usa a *resolução de sobrecarga* para determinar o método específico para invocar.</span><span class="sxs-lookup"><span data-stu-id="619b0-284">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="619b0-285">A resolução de sobrecarga localizará o método que melhor corresponde aos argumentos ou relatará um erro se nenhuma correspondência for encontrada.</span><span class="sxs-lookup"><span data-stu-id="619b0-285">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="619b0-286">O exemplo a seguir mostra a resolução de sobrecarga em vigor.</span><span class="sxs-lookup"><span data-stu-id="619b0-286">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="619b0-287">O comentário para cada invocação no método `Main` mostra qual método é realmente chamado.</span><span class="sxs-lookup"><span data-stu-id="619b0-287">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

<span data-ttu-id="619b0-288">[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]</span><span class="sxs-lookup"><span data-stu-id="619b0-288">[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]</span></span>

<span data-ttu-id="619b0-289">Conforme mostrado no exemplo, um determinado método sempre pode ser selecionado ao converter explicitamente os argumentos para os tipos de parâmetro exatos e/ou fornecendo explicitamente os argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="619b0-289">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="619b0-290">Outros membros da função</span><span class="sxs-lookup"><span data-stu-id="619b0-290">Other function members</span></span>

<span data-ttu-id="619b0-291">Os membros que contêm código executável são conhecidos coletivamente como *membros de função* de uma classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-291">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="619b0-292">A seção anterior descreve os métodos, que são o tipo principal de membros da função.</span><span class="sxs-lookup"><span data-stu-id="619b0-292">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="619b0-293">Esta seção descreve os outros tipos de membros da função com suporte do C#: construtores, propriedades, indexadores, eventos, operadores e finalizadores.</span><span class="sxs-lookup"><span data-stu-id="619b0-293">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="619b0-294">A seguir é mostrada uma classe genérica chamada List<T>, que implementa uma lista crescente de objetos.</span><span class="sxs-lookup"><span data-stu-id="619b0-294">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="619b0-295">A classe contém vários exemplos dos tipos mais comuns de membros da função.</span><span class="sxs-lookup"><span data-stu-id="619b0-295">The class contains several examples of the most common kinds of function members.</span></span>

<span data-ttu-id="619b0-296">[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]</span><span class="sxs-lookup"><span data-stu-id="619b0-296">[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]</span></span>

### <a name="constructors"></a><span data-ttu-id="619b0-297">Construtores</span><span class="sxs-lookup"><span data-stu-id="619b0-297">Constructors</span></span>

<span data-ttu-id="619b0-298">O C# dá suporte aos construtores estáticos e de instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-298">C# supports both instance and static constructors.</span></span> <span data-ttu-id="619b0-299">Um *construtor de instância* é um membro que implementa as ações necessárias para inicializar uma instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-299">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="619b0-300">Um *construtor estático* é um membro que implementa as ações necessárias para inicializar uma classe quando ele for carregado pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="619b0-300">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="619b0-301">Um construtor é declarado como um método sem nenhum tipo de retorno e o mesmo nome que a classe continente.</span><span class="sxs-lookup"><span data-stu-id="619b0-301">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="619b0-302">Se uma declaração de construtor inclui um modificador estático, ela declara um construtor estático.</span><span class="sxs-lookup"><span data-stu-id="619b0-302">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="619b0-303">Caso contrário, ela declara um construtor de instância.</span><span class="sxs-lookup"><span data-stu-id="619b0-303">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="619b0-304">Os construtores de instância podem ser sobrecarregados e podem ter parâmetros opcionais.</span><span class="sxs-lookup"><span data-stu-id="619b0-304">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="619b0-305">Por exemplo, a classe `List<T>` declara dois construtores de instância, um sem parâmetros e um que utiliza um parâmetro `int`.</span><span class="sxs-lookup"><span data-stu-id="619b0-305">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="619b0-306">Os construtores de instância são invocados usando o operador `new`.</span><span class="sxs-lookup"><span data-stu-id="619b0-306">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="619b0-307">As seguintes instruções alocam duas instâncias `List<string>` usando o construtor da classe `List` com e sem o argumento opcional.</span><span class="sxs-lookup"><span data-stu-id="619b0-307">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

<span data-ttu-id="619b0-308">[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]</span><span class="sxs-lookup"><span data-stu-id="619b0-308">[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]</span></span>

<span data-ttu-id="619b0-309">Diferentemente de outros membros, construtores de instância não são herdados e uma classe não tem nenhum construtor de instância que não os que são realmente declarados na classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-309">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="619b0-310">Se nenhum construtor de instância for fornecido para uma classe, então um construtor vazio sem parâmetros será fornecido automaticamente.</span><span class="sxs-lookup"><span data-stu-id="619b0-310">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="619b0-311">Propriedades</span><span class="sxs-lookup"><span data-stu-id="619b0-311">Properties</span></span>

<span data-ttu-id="619b0-312">As *propriedades* são uma extensão natural dos campos.</span><span class="sxs-lookup"><span data-stu-id="619b0-312">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="619b0-313">Elas são denominadas membros com tipos associados, e a sintaxe para acessar os campos e as propriedades é a mesma.</span><span class="sxs-lookup"><span data-stu-id="619b0-313">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="619b0-314">No entanto, diferentemente dos campos, as propriedades não denotam locais de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="619b0-314">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="619b0-315">Em vez disso, as propriedades têm *acessadores* que especificam as instruções a serem executadas quando os valores forem lidos ou gravados.</span><span class="sxs-lookup"><span data-stu-id="619b0-315">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="619b0-316">Uma propriedade é declarada como um campo, exceto quando a declaração termina com um acessador get e/ou um acessador set gravado entre os delimitadores `{` e `}` em vez de terminar com um ponto-e-vírgula.</span><span class="sxs-lookup"><span data-stu-id="619b0-316">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="619b0-317">Uma propriedade que tem um acessador get e um acessador set é uma *propriedade de leitura-gravação*. Uma propriedade que tem apenas um acessador get é uma *propriedade somente leitura*, e uma propriedade que tem apenas um acessador set é uma *propriedade somente gravação*.</span><span class="sxs-lookup"><span data-stu-id="619b0-317">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="619b0-318">Um acessador get corresponde a um método sem parâmetros com um valor retornado do tipo de propriedade.</span><span class="sxs-lookup"><span data-stu-id="619b0-318">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="619b0-319">Exceto como o destino de uma atribuição, quando uma propriedade é referenciada em uma expressão, o acessador get da propriedade é invocado para calcular o valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="619b0-319">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="619b0-320">Um acessador set corresponde a um método com um parâmetro único chamado valor e nenhum tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="619b0-320">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="619b0-321">Quando uma propriedade é referenciada como o destino de uma atribuição ou como o operando do + + ou --, o acessador set é invocado com um argumento que fornece o novo valor.</span><span class="sxs-lookup"><span data-stu-id="619b0-321">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="619b0-322">A classe `List<T>` declara duas propriedades, Count e Capacity, que são somente leitura e leitura/gravação, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="619b0-322">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="619b0-323">A seguir está um exemplo de uso dessas propriedades.</span><span class="sxs-lookup"><span data-stu-id="619b0-323">The following is an example of use of these properties.</span></span>

<span data-ttu-id="619b0-324">[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]</span><span class="sxs-lookup"><span data-stu-id="619b0-324">[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]</span></span>

<span data-ttu-id="619b0-325">Como nos campos e métodos, o C# dá suporte a propriedades de instância e a propriedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="619b0-325">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="619b0-326">As propriedades estáticas são declaradas com o modificador estático e as propriedades de instância são declaradas sem ele.</span><span class="sxs-lookup"><span data-stu-id="619b0-326">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="619b0-327">Os acessadores de uma propriedade podem ser virtuais.</span><span class="sxs-lookup"><span data-stu-id="619b0-327">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="619b0-328">Quando uma declaração de propriedade inclui um modificador `virtual`, `abstract` ou `override`, ela se aplica aos acessadores da propriedade.</span><span class="sxs-lookup"><span data-stu-id="619b0-328">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="619b0-329">Indexadores</span><span class="sxs-lookup"><span data-stu-id="619b0-329">Indexers</span></span>

<span data-ttu-id="619b0-330">Um *indexador* é um membro que permite que objetos sejam indexados da mesma forma que uma matriz.</span><span class="sxs-lookup"><span data-stu-id="619b0-330">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="619b0-331">Um indexador é declarado como uma propriedade, exceto se o nome do membro for seguido por uma lista de parâmetros escrita entre os delimitadores `[` e `]`.</span><span class="sxs-lookup"><span data-stu-id="619b0-331">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="619b0-332">Os parâmetros estão disponíveis nos acessadores do indexador.</span><span class="sxs-lookup"><span data-stu-id="619b0-332">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="619b0-333">Semelhante às propriedades, os indexadores podem ser de leitura-gravação, somente leitura e somente gravação, e os acessadores de um indexador pode ser virtuais.</span><span class="sxs-lookup"><span data-stu-id="619b0-333">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="619b0-334">A classe `List` declara um indexador único de leitura-gravação que usa um parâmetro `int`.</span><span class="sxs-lookup"><span data-stu-id="619b0-334">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="619b0-335">O indexador possibilita indexar instâncias `List` com valores `int`.</span><span class="sxs-lookup"><span data-stu-id="619b0-335">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="619b0-336">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="619b0-336">For example:</span></span>

<span data-ttu-id="619b0-337">[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]</span><span class="sxs-lookup"><span data-stu-id="619b0-337">[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]</span></span>

<span data-ttu-id="619b0-338">Os indexadores podem ser sobrecarregados, o que significa que uma classe pode declarar vários indexadores, desde que o número ou os tipos de seus parâmetros sejam diferentes.</span><span class="sxs-lookup"><span data-stu-id="619b0-338">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="619b0-339">Eventos</span><span class="sxs-lookup"><span data-stu-id="619b0-339">Events</span></span>

<span data-ttu-id="619b0-340">Um *evento* é um membro que permite que uma classe ou objeto forneça notificações.</span><span class="sxs-lookup"><span data-stu-id="619b0-340">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="619b0-341">Um evento é declarado como um campo exceto se a declaração incluir uma palavra-chave do evento e o tipo deverá ser um tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="619b0-341">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="619b0-342">Em uma classe que declara um membro de evento, o evento se comporta exatamente como um campo de um tipo delegado (desde que o evento não seja abstrato e não declare acessadores).</span><span class="sxs-lookup"><span data-stu-id="619b0-342">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="619b0-343">O campo armazena uma referência a um delegado que representa os manipuladores de eventos que foram adicionados ao evento.</span><span class="sxs-lookup"><span data-stu-id="619b0-343">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="619b0-344">Se nenhum manipulador de evento estiver presente, o campo será `null`.</span><span class="sxs-lookup"><span data-stu-id="619b0-344">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="619b0-345">A classe `List<T>` declara um membro único de evento chamado `Changed`, que indica que um novo item foi adicionado à lista.</span><span class="sxs-lookup"><span data-stu-id="619b0-345">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="619b0-346">O evento Alterado é gerado pelo método virtual `OnChanged`, que primeiro verifica se o evento é `null` (o que significa que nenhum manipulador está presente).</span><span class="sxs-lookup"><span data-stu-id="619b0-346">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="619b0-347">A noção de gerar um evento é precisamente equivalente a invocar o delegado representado pelo evento — assim, não há constructos de linguagem especial para gerar eventos.</span><span class="sxs-lookup"><span data-stu-id="619b0-347">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="619b0-348">Os clientes reagem a eventos por meio de *manipuladores de eventos*.</span><span class="sxs-lookup"><span data-stu-id="619b0-348">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="619b0-349">Os manipuladores de eventos são conectados usando o operador `+=` e removidos usando o operador `-=`.</span><span class="sxs-lookup"><span data-stu-id="619b0-349">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="619b0-350">O exemplo a seguir anexa um manipulador de eventos para o evento `Changed` de um `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="619b0-350">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

<span data-ttu-id="619b0-351">[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]</span><span class="sxs-lookup"><span data-stu-id="619b0-351">[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]</span></span>

<span data-ttu-id="619b0-352">Para cenários avançados nos quais o controle do armazenamento subjacente de um evento é desejado, uma declaração de evento pode fornecer explicitamente acessadores `add` e `remove`, que são um pouco semelhantes ao acessador `set` de uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="619b0-352">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="619b0-353">Operadores</span><span class="sxs-lookup"><span data-stu-id="619b0-353">Operators</span></span>

<span data-ttu-id="619b0-354">Um *operador* é um membro que define o significado da aplicação de um operador de expressão específico para instâncias de uma classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-354">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="619b0-355">Três tipos de operadores podem ser definidos: operadores unários, operadores binários e operadores de conversão.</span><span class="sxs-lookup"><span data-stu-id="619b0-355">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="619b0-356">Todos os operadores devem ser declarados como `public` e `static`.</span><span class="sxs-lookup"><span data-stu-id="619b0-356">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="619b0-357">A classe `List<T>` declara dois operadores, `operator ==` e `operator !=` e, portanto, dá um novo significado para as expressões que aplicam esses operadores a instâncias `List`.</span><span class="sxs-lookup"><span data-stu-id="619b0-357">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="619b0-358">Especificamente, os operadores definem a igualdade de duas instâncias `List<T>` ao comparar cada um dos objetos contidos usando os métodos Equals.</span><span class="sxs-lookup"><span data-stu-id="619b0-358">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="619b0-359">O exemplo a seguir usa o operador `==` para comparar duas instâncias `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="619b0-359">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

<span data-ttu-id="619b0-360">[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]</span><span class="sxs-lookup"><span data-stu-id="619b0-360">[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]</span></span>

<span data-ttu-id="619b0-361">O primeiro `Console.WriteLine` gera `True` porque as duas listas contêm o mesmo número de objetos com os mesmos valores na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="619b0-361">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="619b0-362">Como `List<T>` não definiu `operator ==`, o primeiro `Console.WriteLine` geraria `False` porque `a` e `b` referenciam diferentes instâncias `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="619b0-362">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="619b0-363">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="619b0-363">Finalizers</span></span>

<span data-ttu-id="619b0-364">Um *finalizador* é um membro que implementa as ações necessárias para finalizar uma instância de uma classe.</span><span class="sxs-lookup"><span data-stu-id="619b0-364">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="619b0-365">Os finalizadores não podem ter parâmetros, eles não podem ter modificadores de acessibilidade e não podem ser chamados explicitamente.</span><span class="sxs-lookup"><span data-stu-id="619b0-365">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="619b0-366">O finalizador de uma instância é invocado automaticamente durante a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="619b0-366">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="619b0-367">O coletor de lixo tem latitude ampla ao decidir quando coletar objetos e executar os finalizadores.</span><span class="sxs-lookup"><span data-stu-id="619b0-367">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="619b0-368">Especificamente, o tempo de invocações de finalizador não é determinístico e finalizadores podem ser executados em qualquer thread.</span><span class="sxs-lookup"><span data-stu-id="619b0-368">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="619b0-369">Para esses e outros motivos, as classes devem implementar os finalizadores apenas quando não houver outras soluções viáveis.</span><span class="sxs-lookup"><span data-stu-id="619b0-369">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="619b0-370">A instrução `using` fornece uma abordagem melhor para a destruição de objetos.</span><span class="sxs-lookup"><span data-stu-id="619b0-370">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="619b0-371">[Anterior](statements.md)
[Próximo](structs.md)</span><span class="sxs-lookup"><span data-stu-id="619b0-371">[Previous](statements.md)
[Next](structs.md)</span></span>

