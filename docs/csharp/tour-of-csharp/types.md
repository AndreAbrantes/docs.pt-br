---
title: 'Definir tipos e seus membros-um tour de C #'
description: Os blocos de construção de programas são tipos. Saiba como criar classes, estruturas, interfaces e muito mais em C#.
ms.date: 08/06/2020
ms.openlocfilehash: 69d6f0fe1e11f287fb5e385761fc210a61929d10
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88068507"
---
# <a name="types-and-members"></a><span data-ttu-id="84187-104">Tipos e membros</span><span class="sxs-lookup"><span data-stu-id="84187-104">Types and members</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="84187-105">Classes e objetos</span><span class="sxs-lookup"><span data-stu-id="84187-105">Classes and objects</span></span>

<span data-ttu-id="84187-106">As *classes* são as mais fundamentais para os tipos do C#.</span><span class="sxs-lookup"><span data-stu-id="84187-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="84187-107">Uma classe é uma estrutura de dados que combina ações (métodos e outros membros da função) e estado (campos) em uma única unidade.</span><span class="sxs-lookup"><span data-stu-id="84187-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="84187-108">Uma classe fornece uma definição para *instâncias* da classe, também conhecida como *objetos*.</span><span class="sxs-lookup"><span data-stu-id="84187-108">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="84187-109">As classes dão suporte à *herança* e *polimorfismo*, mecanismos nos quais *classes derivadas* podem estender e especializar *classes base*.</span><span class="sxs-lookup"><span data-stu-id="84187-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="84187-110">Novas classes são criadas usando declarações de classe.</span><span class="sxs-lookup"><span data-stu-id="84187-110">New classes are created using class declarations.</span></span> <span data-ttu-id="84187-111">Uma declaração de classe começa com um cabeçalho.</span><span class="sxs-lookup"><span data-stu-id="84187-111">A class declaration starts with a header.</span></span> <span data-ttu-id="84187-112">O cabeçalho especifica:</span><span class="sxs-lookup"><span data-stu-id="84187-112">The header specifies:</span></span>

- <span data-ttu-id="84187-113">Os atributos e modificadores da classe</span><span class="sxs-lookup"><span data-stu-id="84187-113">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="84187-114">O nome da classe</span><span class="sxs-lookup"><span data-stu-id="84187-114">The name of the class</span></span>
- <span data-ttu-id="84187-115">A classe base (ao herdar de uma [classe base](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="84187-115">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="84187-116">As interfaces implementadas pela classe.</span><span class="sxs-lookup"><span data-stu-id="84187-116">The interfaces implemented by the class.</span></span>

<span data-ttu-id="84187-117">O cabeçalho é seguido pelo corpo da classe, que consiste em uma lista de declarações de membro escrita entre os delimitadores `{` e `}`.</span><span class="sxs-lookup"><span data-stu-id="84187-117">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="84187-118">O código a seguir mostra uma declaração de uma classe simples chamada `Point` :</span><span class="sxs-lookup"><span data-stu-id="84187-118">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="84187-119">Instâncias de classes são criadas usando o operador `new`, que aloca memória para uma nova instância, chama um construtor para inicializar a instância e retorna uma referência à instância.</span><span class="sxs-lookup"><span data-stu-id="84187-119">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="84187-120">As instruções a seguir criam dois `Point` objetos e armazenam referências a esses objetos em duas variáveis:</span><span class="sxs-lookup"><span data-stu-id="84187-120">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="84187-121">A memória ocupada por um objeto é recuperada automaticamente quando o objeto não está mais acessível.</span><span class="sxs-lookup"><span data-stu-id="84187-121">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="84187-122">Não é necessário nem possível desalocar explicitamente objetos em C#.</span><span class="sxs-lookup"><span data-stu-id="84187-122">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="84187-123">Parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="84187-123">Type parameters</span></span>

<span data-ttu-id="84187-124">Classes genéricas definem [***parâmetros de tipo***](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="84187-124">Generic classes define [***type parameters***](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="84187-125">Parâmetros de tipo são uma lista de nomes de parâmetro de tipo entre colchetes angulares.</span><span class="sxs-lookup"><span data-stu-id="84187-125">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="84187-126">Os parâmetros de tipo seguem o nome da classe.</span><span class="sxs-lookup"><span data-stu-id="84187-126">Type parameters follow the class name.</span></span> <span data-ttu-id="84187-127">Em seguida, os parâmetros de tipo podem ser usados no corpo das declarações de classe para definir os membros da classe.</span><span class="sxs-lookup"><span data-stu-id="84187-127">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="84187-128">No exemplo a seguir, os parâmetros de tipo de `Pair` são `TFirst` e `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="84187-128">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="84187-129">Um tipo de classe que é declarado para pegar parâmetros de tipo é chamado de *tipo de classe genérica*.</span><span class="sxs-lookup"><span data-stu-id="84187-129">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="84187-130">Os tipos struct, interface e delegate também podem ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="84187-130">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="84187-131">Quando a classe genérica é usada, os argumentos de tipo devem ser fornecidos para cada um dos parâmetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="84187-131">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="84187-132">Um tipo genérico com argumentos de tipo fornecidos, como `Pair<int,string>` acima, é chamado de *tipo construído*.</span><span class="sxs-lookup"><span data-stu-id="84187-132">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="84187-133">Classes base</span><span class="sxs-lookup"><span data-stu-id="84187-133">Base classes</span></span>

<span data-ttu-id="84187-134">Uma declaração de classe pode especificar uma classe base.</span><span class="sxs-lookup"><span data-stu-id="84187-134">A class declaration may specify a base class.</span></span> <span data-ttu-id="84187-135">Siga o nome da classe e os parâmetros de tipo com dois-pontos e o nome da classe base.</span><span class="sxs-lookup"><span data-stu-id="84187-135">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="84187-136">Omitir uma especificação de classe base é o mesmo que derivar do `object` de tipo.</span><span class="sxs-lookup"><span data-stu-id="84187-136">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="84187-137">No exemplo a seguir, a classe base de `Point3D` é `Point` .</span><span class="sxs-lookup"><span data-stu-id="84187-137">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="84187-138">No primeiro exemplo, a classe base de `Point` é `object` :</span><span class="sxs-lookup"><span data-stu-id="84187-138">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="84187-139">Uma classe herda os membros de sua classe base.</span><span class="sxs-lookup"><span data-stu-id="84187-139">A class inherits the members of its base class.</span></span> <span data-ttu-id="84187-140">Herança significa que uma classe contém implicitamente quase todos os membros de sua classe base.</span><span class="sxs-lookup"><span data-stu-id="84187-140">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="84187-141">Uma classe não herda a instância e construtores estáticos e o finalizador.</span><span class="sxs-lookup"><span data-stu-id="84187-141">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="84187-142">Uma classe derivada pode adicionar novos membros a esses membros que ele herda, mas não pode remover a definição de um membro herdado.</span><span class="sxs-lookup"><span data-stu-id="84187-142">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="84187-143">No exemplo anterior, `Point3D` herda os `X` Membros e `Y` de `Point` , e cada `Point3D` instância contém três propriedades, `X` , `Y` e `Z` .</span><span class="sxs-lookup"><span data-stu-id="84187-143">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="84187-144">Existe uma conversão implícita de um tipo de classe para qualquer um de seus tipos de classe base.</span><span class="sxs-lookup"><span data-stu-id="84187-144">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="84187-145">Uma variável de um tipo de classe pode referenciar uma instância dessa classe ou uma instância de qualquer classe derivada.</span><span class="sxs-lookup"><span data-stu-id="84187-145">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="84187-146">Por exemplo, dadas as declarações de classe anteriores, uma variável do tipo `Point` podem referenciar um `Point` ou um `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="84187-146">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="84187-147">Estruturas</span><span class="sxs-lookup"><span data-stu-id="84187-147">Structs</span></span>

<span data-ttu-id="84187-148">Classes definem tipos que dão suporte a herança e polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="84187-148">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="84187-149">Eles permitem que você crie comportamentos sofisticados com base em hierarquias de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="84187-149">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="84187-150">Por outro lado, os tipos de [***struct***](../language-reference/builtin-types/struct.md) são tipos mais simples cujo objetivo principal é armazenar valores de dados.</span><span class="sxs-lookup"><span data-stu-id="84187-150">By contrast, [***struct***](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="84187-151">Structs não podem declarar um tipo base; Eles derivam implicitamente de <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="84187-151">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="84187-152">Você não pode derivar outros `struct` tipos de um `struct` tipo.</span><span class="sxs-lookup"><span data-stu-id="84187-152">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="84187-153">Eles são lacrados implicitamente.</span><span class="sxs-lookup"><span data-stu-id="84187-153">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="84187-154">Interfaces</span><span class="sxs-lookup"><span data-stu-id="84187-154">Interfaces</span></span>

<span data-ttu-id="84187-155">Uma [***interface***](../programming-guide/interfaces/index.md) define um contrato que pode ser implementado por classes e estruturas.</span><span class="sxs-lookup"><span data-stu-id="84187-155">An [***interface***](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="84187-156">Uma interface pode conter métodos, propriedades, eventos e indexadores.</span><span class="sxs-lookup"><span data-stu-id="84187-156">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="84187-157">Uma interface normalmente não fornece implementações dos membros que ele define — ela simplesmente especifica os membros que devem ser fornecidos por classes ou estruturas que implementam a interface.</span><span class="sxs-lookup"><span data-stu-id="84187-157">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="84187-158">As interfaces podem empregar a ***herança múltipla***.</span><span class="sxs-lookup"><span data-stu-id="84187-158">Interfaces may employ ***multiple inheritance***.</span></span> <span data-ttu-id="84187-159">No exemplo a seguir, a interface `IComboBox` herda de `ITextBox` e `IListBox`.</span><span class="sxs-lookup"><span data-stu-id="84187-159">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="84187-160">Classes e structs podem implementar várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="84187-160">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="84187-161">No exemplo a seguir, a classe `EditBox` implementa `IControl` e `IDataBound`.</span><span class="sxs-lookup"><span data-stu-id="84187-161">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="84187-162">Quando uma classe ou struct implementa uma interface específica, as instâncias dessa classe ou struct podem ser convertidas implicitamente para esse tipo de interface.</span><span class="sxs-lookup"><span data-stu-id="84187-162">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="84187-163">Por exemplo</span><span class="sxs-lookup"><span data-stu-id="84187-163">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="84187-164">Enumerações</span><span class="sxs-lookup"><span data-stu-id="84187-164">Enums</span></span>

<span data-ttu-id="84187-165">Um tipo de [***Enumeração***](../language-reference/builtin-types/enum.md) define um conjunto de valores constantes.</span><span class="sxs-lookup"><span data-stu-id="84187-165">An [***Enum***](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="84187-166">A seguir, as seguintes `enum` constantes declarações que definem um ou diferente de raiz:</span><span class="sxs-lookup"><span data-stu-id="84187-166">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="84187-167">Você também pode definir um `enum` para ser usado em combinação como sinalizadores.</span><span class="sxs-lookup"><span data-stu-id="84187-167">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="84187-168">A declaração a seguir declara um conjunto de sinalizadores para as quatro estações.</span><span class="sxs-lookup"><span data-stu-id="84187-168">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="84187-169">Qualquer combinação das estações pode ser aplicada, incluindo um `All` valor que inclui todas as estações:</span><span class="sxs-lookup"><span data-stu-id="84187-169">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="84187-170">O exemplo a seguir mostra declarações de ambas as enumerações anteriores:</span><span class="sxs-lookup"><span data-stu-id="84187-170">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="84187-171">Tipos anuláveis</span><span class="sxs-lookup"><span data-stu-id="84187-171">Nullable types</span></span>

<span data-ttu-id="84187-172">Variáveis de qualquer tipo podem ser declaradas como ***não anuláveis*** ou ***anuláveis***.</span><span class="sxs-lookup"><span data-stu-id="84187-172">Variables of any type may be declared as ***non-nullable*** or ***nullable***.</span></span> <span data-ttu-id="84187-173">Uma variável anulável pode conter um `null` valor adicional, indicando que não há valor.</span><span class="sxs-lookup"><span data-stu-id="84187-173">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="84187-174">Tipos de valores anuláveis (structs ou enums) são representados por <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="84187-174">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="84187-175">Os tipos de referência não anuláveis e anuláveis são representados pelo tipo de referência subjacente.</span><span class="sxs-lookup"><span data-stu-id="84187-175">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="84187-176">A distinção é representada por metadados lidos pelo compilador e por algumas bibliotecas.</span><span class="sxs-lookup"><span data-stu-id="84187-176">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="84187-177">O compilador fornece avisos quando referências anuláveis são desreferenciadas sem primeiro verificar seu valor `null` .</span><span class="sxs-lookup"><span data-stu-id="84187-177">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="84187-178">O compilador também fornece avisos quando referências não anuláveis são atribuídas a um valor que pode ser `null` .</span><span class="sxs-lookup"><span data-stu-id="84187-178">The compiler also provides warnings when non-nullable references are assigned to a value that may be `null`.</span></span> <span data-ttu-id="84187-179">O exemplo a seguir declara um ***int anulável***, inicializando-o para `null` .</span><span class="sxs-lookup"><span data-stu-id="84187-179">The following example declares a ***nullable int***, initializing it to `null`.</span></span> <span data-ttu-id="84187-180">Em seguida, ele define o valor como `5` .</span><span class="sxs-lookup"><span data-stu-id="84187-180">Then, it sets the value to `5`.</span></span> <span data-ttu-id="84187-181">Ele demonstra o mesmo conceito com uma ***cadeia de caracteres anulável***.</span><span class="sxs-lookup"><span data-stu-id="84187-181">It demonstrates the same concept with a ***nullable string***.</span></span> <span data-ttu-id="84187-182">Para obter mais informações, consulte [tipos de valor anulável](../language-reference/builtin-types/nullable-value-types.md) e [tipos de referência anuláveis](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="84187-182">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="84187-183">Tuplas</span><span class="sxs-lookup"><span data-stu-id="84187-183">Tuples</span></span>

<span data-ttu-id="84187-184">O C# oferece suporte a [***tuplas***](../language-reference/builtin-types/value-tuples.md), que fornece sintaxe concisa para agrupar vários elementos de dados em uma estrutura de dados leve.</span><span class="sxs-lookup"><span data-stu-id="84187-184">C# supports [***tuples***](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="84187-185">Você cria uma instância de uma tupla declarando os tipos e os nomes dos membros entre `(` e `)` , conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="84187-185">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="84187-186">As tuplas fornecem uma alternativa para a estrutura de dados com vários membros, sem usar os blocos de construção descritos no próximo artigo.</span><span class="sxs-lookup"><span data-stu-id="84187-186">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="84187-187">[Anterior](index.md) 
> [Avançar](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="84187-187">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
