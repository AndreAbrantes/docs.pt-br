---
title: Structs em C# - um tour pela linguagem C#
description: Aprenda os conceitos básicos dos tipos de valor C#, chamados de structs
ms.date: 08/10/2016
ms.assetid: 88a74571-f741-4a31-a2b5-1ccf165535b8
ms.openlocfilehash: d22cb23fe095874f24d7c002dfdb3eefdde66722
ms.sourcegitcommit: d9a0071d0fd490ae006c816f78a563b9946e269a
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/25/2019
ms.locfileid: "55065954"
---
# <a name="structs"></a><span data-ttu-id="265a9-103">Structs</span><span class="sxs-lookup"><span data-stu-id="265a9-103">Structs</span></span>

<span data-ttu-id="265a9-104">Como classes, os ***structs*** são estruturas de dados que podem conter membros de dados e os membros da função, mas, ao contrário das classes, as estruturas são tipos de valor e não precisam de alocação de heap.</span><span class="sxs-lookup"><span data-stu-id="265a9-104">Like classes, ***structs*** are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation.</span></span> <span data-ttu-id="265a9-105">Uma variável de um tipo struct armazena diretamente os dados do struct, enquanto que uma variável de um tipo de classe armazena uma referência a um objeto alocado dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="265a9-105">A variable of a struct type directly stores the data of the struct, whereas a variable of a class type stores a reference to a dynamically allocated object.</span></span> <span data-ttu-id="265a9-106">Os tipos de struct não dão suporte à herança especificada pelo usuário, e todos os tipos de structs são herdados implicitamente do tipo <xref:System.ValueType>, que, por sua vez, é herdado implicitamente de `object`.</span><span class="sxs-lookup"><span data-stu-id="265a9-106">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <xref:System.ValueType>, which in turn implicitly inherits from `object`.</span></span>

<span data-ttu-id="265a9-107">Os structs são particularmente úteis para estruturas de dados pequenas que têm semântica de valor.</span><span class="sxs-lookup"><span data-stu-id="265a9-107">Structs are particularly useful for small data structures that have value semantics.</span></span> <span data-ttu-id="265a9-108">Números complexos, pontos em um sistema de coordenadas ou pares chave-valor em um dicionário são exemplos de structs.</span><span class="sxs-lookup"><span data-stu-id="265a9-108">Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs.</span></span> <span data-ttu-id="265a9-109">O uso de structs, em vez de classes para estruturas de dados pequenas, pode fazer uma grande diferença no número de alocações de memória que um aplicativo executa.</span><span class="sxs-lookup"><span data-stu-id="265a9-109">The use of structs rather than classes for small data structures can make a large difference in the number of memory allocations an application performs.</span></span> <span data-ttu-id="265a9-110">Por exemplo, o programa a seguir cria e inicializa uma matriz de 100 pontos.</span><span class="sxs-lookup"><span data-stu-id="265a9-110">For example, the following program creates and initializes an array of 100 points.</span></span> <span data-ttu-id="265a9-111">Com `Point` implementado como uma classe, 101 objetos separados são instanciados — um para a matriz e um para os elementos de 100.</span><span class="sxs-lookup"><span data-stu-id="265a9-111">With `Point` implemented as a class, 101 separate objects are instantiated—one for the array and one each for the 100 elements.</span></span>

[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]

<span data-ttu-id="265a9-112">Uma alternativa é tornar um struct um Ponto.</span><span class="sxs-lookup"><span data-stu-id="265a9-112">An alternative is to make Point a struct.</span></span>

[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]

<span data-ttu-id="265a9-113">Agora, somente um objeto é instanciado — um para a matriz — e as instâncias `Point` são armazenadas em linha na matriz.</span><span class="sxs-lookup"><span data-stu-id="265a9-113">Now, only one object is instantiated—the one for the array—and the `Point` instances are stored in-line in the array.</span></span>

<span data-ttu-id="265a9-114">Os construtores struct são invocados com o operador `new`, semelhante a um construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="265a9-114">Struct constructors are invoked with the `new` operator, similar to a class constructor.</span></span> <span data-ttu-id="265a9-115">Porém, em vez de alocar dinamicamente um objeto no heap gerenciado e retornar uma referência a ele, um construtor de struct simplesmente retorna o valor do struct (normalmente em um local temporário na pilha), e esse valor é, então, copiado conforme a necessidade.</span><span class="sxs-lookup"><span data-stu-id="265a9-115">But, instead of dynamically allocating an object on the managed heap and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.</span></span>

<span data-ttu-id="265a9-116">Com classes, é possível que duas variáveis referenciem o mesmo objeto e, portanto, é possível que operações em uma variável afetem o objeto referenciado por outra variável.</span><span class="sxs-lookup"><span data-stu-id="265a9-116">With classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="265a9-117">Com structs, as variáveis têm sua própria cópia dos dados e não é possível que as operações em um afetem o outro.</span><span class="sxs-lookup"><span data-stu-id="265a9-117">With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span> <span data-ttu-id="265a9-118">Por exemplo, a saída produzida pelo seguinte fragmento de código depende de o ponto ser uma classe ou um struct.</span><span class="sxs-lookup"><span data-stu-id="265a9-118">For example, the output produced by the following code fragment depends on whether Point is a class or a struct.</span></span>

[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]

<span data-ttu-id="265a9-119">Se `Point` for uma classe, a saída será 20 porque `a` e `b` referenciam o mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="265a9-119">If `Point` is a class, the output is 20 because `a` and `b` reference the same object.</span></span> <span data-ttu-id="265a9-120">Se `Point` for um struct, a saída será 10 porque a atribuição de `a` para `b` cria uma cópia do valor e essa cópia não é afetada pela atribuição seguinte para `a.x`.</span><span class="sxs-lookup"><span data-stu-id="265a9-120">If `Point` is a struct, the output is 10 because the assignment of `a` to `b` creates a copy of the value, and this copy is unaffected by the subsequent assignment to `a.x`.</span></span>

<span data-ttu-id="265a9-121">O exemplo anterior destaca duas das limitações dos structs.</span><span class="sxs-lookup"><span data-stu-id="265a9-121">The previous example highlights two of the limitations of structs.</span></span> <span data-ttu-id="265a9-122">Primeiro, copiar um struct inteiro é, geralmente, menos eficiente do que copiar uma referência de objeto, então a passagem de atribuição e de valor do parâmetro pode ser mais custosa com structs que com tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="265a9-122">First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types.</span></span> <span data-ttu-id="265a9-123">Segundo, com exceção dos parâmetros `in`, `ref` e `out`, não é possível criar referências para structs, o que rege o uso em diversas situações.</span><span class="sxs-lookup"><span data-stu-id="265a9-123">Second, except for `in`, `ref`, and `out` parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="265a9-124">[Anterior](classes-and-objects.md)
>[Próximo](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="265a9-124">[Previous](classes-and-objects.md)
[Next](arrays.md)</span></span>
