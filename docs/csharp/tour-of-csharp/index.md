---
title: Um tour pelo C# – Guia do C#
description: Novato em C#? Conheça os fundamentos da linguagem.
ms.date: 08/06/2020
ms.openlocfilehash: 84775a436deb0958d3c05ec7d0207e76be28f27c
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/04/2020
ms.locfileid: "89464994"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="62a9b-104">Um tour pela linguagem C#</span><span class="sxs-lookup"><span data-stu-id="62a9b-104">A tour of the C# language</span></span>

<span data-ttu-id="62a9b-105">O C# (pronuncia-se "Veja nítido") é uma linguagem de programação moderna, orientada a objeto e de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="62a9b-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="62a9b-106">O C# tem suas raízes na família de linguagens C e os programadores em C, C++, Java e JavaScript a reconhecerão imediatamente.</span><span class="sxs-lookup"><span data-stu-id="62a9b-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="62a9b-107">Este tour fornece uma visão geral dos principais componentes do idioma no C# 8 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="62a9b-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="62a9b-108">Se você quiser explorar a linguagem por meio de exemplos interativos, experimente a [introdução aos](../tutorials/intro-to-csharp/index.md) tutoriais do C#.</span><span class="sxs-lookup"><span data-stu-id="62a9b-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="62a9b-109">O C# é uma linguagem de programação ***orientada*** a objetos e orientada a componentes.</span><span class="sxs-lookup"><span data-stu-id="62a9b-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="62a9b-110">O c# fornece construções de linguagem para dar suporte direto a esses conceitos, tornando o C# uma linguagem natural para criar e usar componentes de software.</span><span class="sxs-lookup"><span data-stu-id="62a9b-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="62a9b-111">Desde sua origem, o C# adicionou recursos para dar suporte a novas cargas de trabalho e práticas de design de software emergentes.</span><span class="sxs-lookup"><span data-stu-id="62a9b-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="62a9b-112">Vários recursos do C# auxiliam na construção de aplicativos robustos e duráveis.</span><span class="sxs-lookup"><span data-stu-id="62a9b-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="62a9b-113">A [***coleta de lixo***](../../standard/garbage-collection/index.md) recupera automaticamente a memória ocupada por objetos não utilizados inacessíveis.</span><span class="sxs-lookup"><span data-stu-id="62a9b-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="62a9b-114">A [***manipulação de exceção***](../programming-guide/exceptions/index.md) fornece uma abordagem estruturada e extensível para detecção e recuperação de erros.</span><span class="sxs-lookup"><span data-stu-id="62a9b-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="62a9b-115">As [***expressões lambda***](../language-reference/operators/lambda-expressions.md) dão suporte a técnicas de programação funcional.</span><span class="sxs-lookup"><span data-stu-id="62a9b-115">[***Lambda expressions***](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="62a9b-116">A [***sintaxe de consulta***](../linq/index.md) cria um padrão comum para trabalhar com dados de qualquer fonte.</span><span class="sxs-lookup"><span data-stu-id="62a9b-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="62a9b-117">O suporte a idiomas para [***operações assíncronas***](../programming-guide/concepts/async/index.md) fornece a sintaxe para a criação de sistemas distribuídos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="62a9b-118">A [***correspondência de padrões***](..//pattern-matching.md) fornece sintaxe para separar facilmente os dados de algoritmos em sistemas distribuídos modernos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="62a9b-119">O C# tem um [***sistema de tipos unificado***](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="62a9b-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="62a9b-120">Todos os tipos do C#, incluindo tipos primitivos, como `int` e `double`, herdam de um único tipo de `object` raiz.</span><span class="sxs-lookup"><span data-stu-id="62a9b-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="62a9b-121">Todos os tipos compartilham um conjunto de operações comuns.</span><span class="sxs-lookup"><span data-stu-id="62a9b-121">All types share a set of common operations.</span></span> <span data-ttu-id="62a9b-122">Os valores de qualquer tipo podem ser armazenados, transportados e operados de maneira consistente.</span><span class="sxs-lookup"><span data-stu-id="62a9b-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="62a9b-123">Além disso, o C# dá suporte a tipos de referência definidos pelo usuário e tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="62a9b-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="62a9b-124">O C# permite a alocação dinâmica de objetos e o armazenamento em linha de estruturas leves.</span><span class="sxs-lookup"><span data-stu-id="62a9b-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="62a9b-125">O C# enfatiza o ***controle de versão*** para garantir que programas e bibliotecas possam evoluir ao longo do tempo de maneira compatível.</span><span class="sxs-lookup"><span data-stu-id="62a9b-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="62a9b-126">Aspectos do design do C# que foram influenciados diretamente pelas considerações de controle de versão incluem os `virtual` `override` modificadores and separados, as regras para resolução de sobrecarga de método e suporte para declarações de membro de interface explícitas.</span><span class="sxs-lookup"><span data-stu-id="62a9b-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="62a9b-127">Hello world</span><span class="sxs-lookup"><span data-stu-id="62a9b-127">Hello world</span></span>

<span data-ttu-id="62a9b-128">O programa "Hello, World" é usado tradicionalmente para introduzir uma linguagem de programação.</span><span class="sxs-lookup"><span data-stu-id="62a9b-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="62a9b-129">Este é para C#:</span><span class="sxs-lookup"><span data-stu-id="62a9b-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="62a9b-130">O programa "Hello, World" começa com uma diretiva `using` que faz referência ao namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="62a9b-131">Namespaces fornecem um meio hierárquico de organizar bibliotecas e programas em C#.</span><span class="sxs-lookup"><span data-stu-id="62a9b-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="62a9b-132">Os namespaces contêm tipos e outros namespaces — por exemplo, o namespace `System` contém uma quantidade de tipos, como a classe `Console` referenciada no programa e diversos outros namespaces, como `IO` e `Collections`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="62a9b-133">A diretiva `using` que faz referência a um determinado namespace permite o uso não qualificado dos tipos que são membros desse namespace.</span><span class="sxs-lookup"><span data-stu-id="62a9b-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="62a9b-134">Devido à diretiva `using`, o programa pode usar `Console.WriteLine` como um atalho para `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="62a9b-135">A classe `Hello` declarada pelo programa "Hello, World" tem um único membro, o método chamado `Main`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="62a9b-136">O `Main` método é declarado com o `static` modificador.</span><span class="sxs-lookup"><span data-stu-id="62a9b-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="62a9b-137">Embora os métodos de instância possam fazer referência a uma determinada instância de objeto delimitador usando a palavra-chave `this`, métodos estáticos operam sem referência a um objeto específico.</span><span class="sxs-lookup"><span data-stu-id="62a9b-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="62a9b-138">Por convenção, um método estático chamado `Main` serve como o ponto de entrada de um programa em C#.</span><span class="sxs-lookup"><span data-stu-id="62a9b-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="62a9b-139">A saída do programa é produzida pelo método `WriteLine` da classe `Console` no namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="62a9b-140">Essa classe é fornecida pelas bibliotecas de classe padrão, que, por padrão, são referenciadas automaticamente pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="62a9b-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="62a9b-141">Tipos e variáveis</span><span class="sxs-lookup"><span data-stu-id="62a9b-141">Types and variables</span></span>

<span data-ttu-id="62a9b-142">Há dois tipos em C#: *tipos de referência* e *tipos de valor*.</span><span class="sxs-lookup"><span data-stu-id="62a9b-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="62a9b-143">As variáveis de tipos de valor contêm diretamente seus dados enquanto variáveis de tipos de referência armazenam referências a seus dados, o último sendo conhecido como objetos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="62a9b-144">Com os tipos de referência, é possível que duas variáveis referenciem o mesmo objeto e possíveis operações em uma variável afetem o objeto referenciado pela outra variável.</span><span class="sxs-lookup"><span data-stu-id="62a9b-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="62a9b-145">Com os tipos de valor, as variáveis têm sua própria cópia dos dados, e não é possível que as operações em um afetem a outra (exceto `ref` para `out` variáveis de parâmetro e).</span><span class="sxs-lookup"><span data-stu-id="62a9b-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="62a9b-146">Um ***identificador*** é um nome de variável.</span><span class="sxs-lookup"><span data-stu-id="62a9b-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="62a9b-147">Um identificador é uma sequência de caracteres Unicode sem qualquer espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="62a9b-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="62a9b-148">Um identificador pode ser uma palavra reservada em C#, se for prefixada pelo `@` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="62a9b-149">Isso pode ser útil ao interagir com outras linguagens.</span><span class="sxs-lookup"><span data-stu-id="62a9b-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="62a9b-150">Os tipos de valor do C# são divididos em *tipos simples*, *tipos de enumeração*, *tipos de struct*, *tipos de valor anulável* e *tipos de valor de tupla*.</span><span class="sxs-lookup"><span data-stu-id="62a9b-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, *nullable value types* and *tuple value types*.</span></span> <span data-ttu-id="62a9b-151">Os tipos de referência do C# são divididos em *tipos de classe*, *tipos de interface*, *tipos de matriz*e *tipos delegados*.</span><span class="sxs-lookup"><span data-stu-id="62a9b-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="62a9b-152">A seguinte estrutura de tópicos fornece uma visão geral do sistema de tipos do C#.</span><span class="sxs-lookup"><span data-stu-id="62a9b-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="62a9b-153">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="62a9b-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="62a9b-154">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="62a9b-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="62a9b-155">[Integral assinada](../language-reference/builtin-types/integral-numeric-types.md): `sbyte` , `short` , `int` , `long`</span><span class="sxs-lookup"><span data-stu-id="62a9b-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="62a9b-156">[Integral não assinada](../language-reference/builtin-types/integral-numeric-types.md): `byte` , `ushort` , `uint` , `ulong`</span><span class="sxs-lookup"><span data-stu-id="62a9b-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="62a9b-157">[Caracteres Unicode](../../standard/base-types/character-encoding-introduction.md): `char` , que representa uma unidade de código UTF-16</span><span class="sxs-lookup"><span data-stu-id="62a9b-157">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="62a9b-158">[Ponto flutuante de binário do IEEE](../language-reference/builtin-types/floating-point-numeric-types.md): `float` , `double`</span><span class="sxs-lookup"><span data-stu-id="62a9b-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="62a9b-159">[Ponto flutuante decimal de alta precisão](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span><span class="sxs-lookup"><span data-stu-id="62a9b-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="62a9b-160">Booliano: `bool` , que representa valores Boolianos — valores que são `true` ou `false`</span><span class="sxs-lookup"><span data-stu-id="62a9b-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="62a9b-161">Tipos de enumeração</span><span class="sxs-lookup"><span data-stu-id="62a9b-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="62a9b-162">Tipos definidos pelo usuário do formulário `enum E {...}` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="62a9b-163">Um tipo `enum` é um tipo distinto com constantes nomeadas.</span><span class="sxs-lookup"><span data-stu-id="62a9b-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="62a9b-164">Cada tipo `enum` tem um tipo subjacente, que deve ser um dos oito tipos integrais.</span><span class="sxs-lookup"><span data-stu-id="62a9b-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="62a9b-165">O conjunto de valores de um tipo `enum` é o mesmo que o conjunto de valores do tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="62a9b-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="62a9b-166">Tipos struct</span><span class="sxs-lookup"><span data-stu-id="62a9b-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="62a9b-167">Tipos definidos pelo usuário do formulário `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="62a9b-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="62a9b-168">Tipos de valor anuláveis</span><span class="sxs-lookup"><span data-stu-id="62a9b-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="62a9b-169">Extensões de todos os outros tipos de valor com um valor `null`</span><span class="sxs-lookup"><span data-stu-id="62a9b-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="62a9b-170">Tipos de valor de tupla</span><span class="sxs-lookup"><span data-stu-id="62a9b-170">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="62a9b-171">Tipos definidos pelo usuário do formulário `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="62a9b-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="62a9b-172">Tipos de referência</span><span class="sxs-lookup"><span data-stu-id="62a9b-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="62a9b-173">Tipos de aula</span><span class="sxs-lookup"><span data-stu-id="62a9b-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="62a9b-174">Classe base definitiva de todos os outros tipos: `object`</span><span class="sxs-lookup"><span data-stu-id="62a9b-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="62a9b-175">[Cadeias de caracteres Unicode](../../standard/base-types/character-encoding-introduction.md): `string` , que representa uma sequência de unidades de código UTF-16</span><span class="sxs-lookup"><span data-stu-id="62a9b-175">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="62a9b-176">Tipos definidos pelo usuário do formulário `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="62a9b-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="62a9b-177">Tipos de interface</span><span class="sxs-lookup"><span data-stu-id="62a9b-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="62a9b-178">Tipos definidos pelo usuário do formulário `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="62a9b-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="62a9b-179">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="62a9b-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="62a9b-180">Unidimensional, multidimensional e irregular.</span><span class="sxs-lookup"><span data-stu-id="62a9b-180">Single-dimensional, multi-dimensional and jagged.</span></span> <span data-ttu-id="62a9b-181">Por exemplo: `int[]` , `int[,]` e `int[][]`</span><span class="sxs-lookup"><span data-stu-id="62a9b-181">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="62a9b-182">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="62a9b-182">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="62a9b-183">Tipos definidos pelo usuário do formulário `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="62a9b-183">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="62a9b-184">Os programas em C# usam *declarações de tipos* para criar novos tipos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-184">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="62a9b-185">Uma declaração de tipo especifica o nome e os membros do novo tipo.</span><span class="sxs-lookup"><span data-stu-id="62a9b-185">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="62a9b-186">Seis categorias de tipos do C# são definíveis pelo usuário: tipos de classe, tipos de struct, tipos de interface, tipos de enumeração, tipos de delegado e tipos de valor de tupla.</span><span class="sxs-lookup"><span data-stu-id="62a9b-186">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types and tuple value types.</span></span>

- <span data-ttu-id="62a9b-187">Um tipo `class` define uma estrutura de dados que contém membros de dados (campos) e membros de função (métodos, propriedades e outros).</span><span class="sxs-lookup"><span data-stu-id="62a9b-187">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="62a9b-188">Os tipos de classe dão suporte à herança única e ao polimorfismo, mecanismos nos quais as classes derivadas podem estender e especializar as classes base.</span><span class="sxs-lookup"><span data-stu-id="62a9b-188">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="62a9b-189">Um tipo `struct` é semelhante a um tipo de classe que representa uma estrutura com membros de dados e membros da função.</span><span class="sxs-lookup"><span data-stu-id="62a9b-189">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="62a9b-190">No entanto, ao contrário das classes, as structs são tipos de valor e normalmente não exigem alocação de heap.</span><span class="sxs-lookup"><span data-stu-id="62a9b-190">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="62a9b-191">Tipos de struct não dão suporte à herança especificada pelo usuário e todos os tipos de struct herdam implicitamente do tipo `object` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-191">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="62a9b-192">Um `interface` tipo define um contrato como um conjunto nomeado de membros públicos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-192">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="62a9b-193">Um `class` ou `struct` que implementa um `interface` deve fornecer implementações dos membros da interface.</span><span class="sxs-lookup"><span data-stu-id="62a9b-193">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="62a9b-194">Um `interface` pode herdar de várias interfaces base e um `class` ou `struct` pode implementar várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="62a9b-194">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="62a9b-195">Um tipo `delegate` representa referências aos métodos com uma lista de parâmetros e tipo de retorno específicos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-195">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="62a9b-196">Delegados possibilitam o tratamento de métodos como entidades que podem ser atribuídos a variáveis e passadas como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="62a9b-196">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="62a9b-197">Os delegados são análogos aos tipos de função fornecidos pelas linguagens funcionais.</span><span class="sxs-lookup"><span data-stu-id="62a9b-197">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="62a9b-198">Eles também são semelhantes ao conceito de ponteiros de função encontrados em algumas outras linguagens.</span><span class="sxs-lookup"><span data-stu-id="62a9b-198">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="62a9b-199">Diferentemente de ponteiros de função, os delegados são orientados a objeto e são de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="62a9b-199">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="62a9b-200">Os `class` `struct` tipos,, e `interface` `delegate` oferecem suporte a genéricos, no qual eles podem ser parametrizados com outros tipos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-200">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="62a9b-201">O C# dá suporte a matrizes unidimensionais e multidimensionais de qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="62a9b-201">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="62a9b-202">Ao contrário dos tipos listados acima, os tipos de matriz não precisam ser declarados antes que possam ser usados.</span><span class="sxs-lookup"><span data-stu-id="62a9b-202">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="62a9b-203">Em vez disso, os tipos de matriz são construídos seguindo um nome de tipo entre colchetes.</span><span class="sxs-lookup"><span data-stu-id="62a9b-203">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="62a9b-204">Por exemplo, `int[]` é uma matriz unidimensional de `int` , `int[,]` é uma matriz bidimensional de `int` e `int[][]` é uma matriz unidimensional de matrizes unidimensionais, ou uma matriz "denteada", de `int` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-204">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="62a9b-205">Tipos anuláveis não exigem uma definição separada.</span><span class="sxs-lookup"><span data-stu-id="62a9b-205">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="62a9b-206">Para cada tipo não anulável `T` , há um tipo anulável correspondente `T?` , que pode conter um valor adicional, `null` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-206">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="62a9b-207">Por exemplo, `int?` é um tipo que pode conter qualquer número inteiro de 32 bits ou o valor `null` e `string?` é um tipo que pode conter qualquer `string` ou o valor `null` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-207">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="62a9b-208">O sistema de tipos do C# é unificado, de modo que um valor de qualquer tipo pode ser tratado como um `object` .</span><span class="sxs-lookup"><span data-stu-id="62a9b-208">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="62a9b-209">Cada tipo no C#, direta ou indiretamente, deriva do tipo de classe `object`, e `object` é a classe base definitiva de todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-209">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="62a9b-210">Os valores de tipos de referência são tratados como objetos simplesmente exibindo os valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-210">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="62a9b-211">Os valores de tipos de valor são tratados como objetos, executando *conversão boxing* e *operações de conversão unboxing*.</span><span class="sxs-lookup"><span data-stu-id="62a9b-211">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="62a9b-212">No exemplo a seguir, um valor `int` é convertido em `object` e volta novamente ao `int`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-212">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="62a9b-213">Quando um valor de um tipo de valor é atribuído a uma `object` referência, uma "caixa" é alocada para conter o valor.</span><span class="sxs-lookup"><span data-stu-id="62a9b-213">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="62a9b-214">Essa caixa é uma instância de um tipo de referência, e o valor é copiado para essa caixa.</span><span class="sxs-lookup"><span data-stu-id="62a9b-214">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="62a9b-215">Por outro lado, quando uma `object` referência é convertida em um tipo de valor, é feita uma verificação de que a referência `object` é uma caixa do tipo de valor correto.</span><span class="sxs-lookup"><span data-stu-id="62a9b-215">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="62a9b-216">Se a verificação for realizada com sucesso, o valor na caixa será copiado para o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="62a9b-216">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="62a9b-217">O sistema de tipos unificados do C# significa efetivamente que os tipos de valor são tratados como `object` referências "sob demanda".</span><span class="sxs-lookup"><span data-stu-id="62a9b-217">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="62a9b-218">Devido à unificação, as bibliotecas de uso geral que usam `object` o tipo podem ser usadas com todos os tipos que derivam de `object` , incluindo tipos de referência e tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="62a9b-218">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="62a9b-219">Existem vários tipos de *variáveis* no C#, incluindo campos, elementos de matriz, variáveis locais e parâmetros.</span><span class="sxs-lookup"><span data-stu-id="62a9b-219">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="62a9b-220">As variáveis representam locais de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="62a9b-220">Variables represent storage locations.</span></span> <span data-ttu-id="62a9b-221">Cada variável tem um tipo que determina quais valores podem ser armazenados na variável, como mostrado abaixo.</span><span class="sxs-lookup"><span data-stu-id="62a9b-221">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="62a9b-222">Tipo de valor não nulo</span><span class="sxs-lookup"><span data-stu-id="62a9b-222">Non-nullable value type</span></span>
  - <span data-ttu-id="62a9b-223">Um valor de tipo exato</span><span class="sxs-lookup"><span data-stu-id="62a9b-223">A value of that exact type</span></span>
- <span data-ttu-id="62a9b-224">Tipos de valor anulável</span><span class="sxs-lookup"><span data-stu-id="62a9b-224">Nullable value type</span></span>
  - <span data-ttu-id="62a9b-225">Um valor `null` ou um valor do tipo exato</span><span class="sxs-lookup"><span data-stu-id="62a9b-225">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="62a9b-226">objeto</span><span class="sxs-lookup"><span data-stu-id="62a9b-226">object</span></span>
  - <span data-ttu-id="62a9b-227">Uma referência `null`, uma referência a um objeto de qualquer tipo de referência ou uma referência a um valor de qualquer tipo de valor demarcado</span><span class="sxs-lookup"><span data-stu-id="62a9b-227">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="62a9b-228">Tipo de classe</span><span class="sxs-lookup"><span data-stu-id="62a9b-228">Class type</span></span>
  - <span data-ttu-id="62a9b-229">Uma referência `null`, uma referência a uma instância desse tipo de classe ou uma referência a uma instância de uma classe derivada desse tipo de classe</span><span class="sxs-lookup"><span data-stu-id="62a9b-229">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="62a9b-230">Tipo de interface</span><span class="sxs-lookup"><span data-stu-id="62a9b-230">Interface type</span></span>
  - <span data-ttu-id="62a9b-231">Uma referência `null`, uma referência a uma instância de um tipo de classe que implementa esse tipo de interface ou uma referência a um valor demarcado de um tipo de valor que implementa esse tipo de interface</span><span class="sxs-lookup"><span data-stu-id="62a9b-231">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="62a9b-232">Tipo de matriz</span><span class="sxs-lookup"><span data-stu-id="62a9b-232">Array type</span></span>
  - <span data-ttu-id="62a9b-233">Uma referência `null`, uma referência a uma instância desse tipo de matriz ou uma referência a uma instância de um tipo de matriz compatível</span><span class="sxs-lookup"><span data-stu-id="62a9b-233">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="62a9b-234">Tipo delegado</span><span class="sxs-lookup"><span data-stu-id="62a9b-234">Delegate type</span></span>
  - <span data-ttu-id="62a9b-235">Uma referência `null` ou uma referência a uma instância de um tipo de delegado compatível</span><span class="sxs-lookup"><span data-stu-id="62a9b-235">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="62a9b-236">Estrutura do programa</span><span class="sxs-lookup"><span data-stu-id="62a9b-236">Program structure</span></span>

<span data-ttu-id="62a9b-237">Os principais conceitos organizacionais do C# são [***programas***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***tipos***](../programming-guide/types/index.md), [***Membros***](../programming-guide/classes-and-structs/members.md)e [***assemblies***](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="62a9b-237">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="62a9b-238">Os programas declaram tipos que contêm membros e podem ser organizados em namespaces.</span><span class="sxs-lookup"><span data-stu-id="62a9b-238">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="62a9b-239">Classes, estruturas e interfaces são exemplos de tipos.</span><span class="sxs-lookup"><span data-stu-id="62a9b-239">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="62a9b-240">Campos, métodos, propriedades e eventos são exemplos de membros.</span><span class="sxs-lookup"><span data-stu-id="62a9b-240">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="62a9b-241">Quando programas C# são compilados, eles são fisicamente empacotados em assemblies.</span><span class="sxs-lookup"><span data-stu-id="62a9b-241">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="62a9b-242">Os assemblies normalmente têm a extensão de arquivo `.exe` ou `.dll`, dependendo se eles implementam ***aplicativos*** ou ***bibliotecas***, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="62a9b-242">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="62a9b-243">Como um pequeno exemplo, considere um assembly que contém o código a seguir:</span><span class="sxs-lookup"><span data-stu-id="62a9b-243">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="62a9b-244">O nome totalmente qualificado dessa classe é `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-244">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="62a9b-245">A classe contém vários membros: um campo chamado `top`, dois métodos chamados `Push` e `Pop` e uma classe aninhada chamada `Entry`.</span><span class="sxs-lookup"><span data-stu-id="62a9b-245">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="62a9b-246">A classe `Entry` ainda contém três membros: um campo chamado `next`, um campo chamado `data`e um construtor.</span><span class="sxs-lookup"><span data-stu-id="62a9b-246">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="62a9b-247">O `Stack` é uma classe *genérica* .</span><span class="sxs-lookup"><span data-stu-id="62a9b-247">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="62a9b-248">Ele tem um parâmetro de tipo, `T` que é substituído por um tipo concreto quando usado.</span><span class="sxs-lookup"><span data-stu-id="62a9b-248">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="62a9b-249">Uma *pilha* é uma coleção de "primeiro a entrar no final" (filo).</span><span class="sxs-lookup"><span data-stu-id="62a9b-249">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="62a9b-250">Novos elementos são adicionados à parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="62a9b-250">New elements are added to the top of the stack.</span></span> <span data-ttu-id="62a9b-251">Quando um elemento é removido, ele é removido da parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="62a9b-251">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="62a9b-252">Os assemblies contêm código executável na forma de instruções de IL (Linguagem Intermediária) e informações simbólicas na forma de metadados.</span><span class="sxs-lookup"><span data-stu-id="62a9b-252">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="62a9b-253">Antes de ser executado, o compilador JIT (just-in-time) do .NET Common Language Runtime converte o código IL em um assembly para o código específico do processador.</span><span class="sxs-lookup"><span data-stu-id="62a9b-253">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="62a9b-254">Como um assembly é uma unidade de funcionalidade autodescreveda que contém o código e os metadados, não há necessidade de `#include` diretivas e arquivos de cabeçalho em C#.</span><span class="sxs-lookup"><span data-stu-id="62a9b-254">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="62a9b-255">Os tipos públicos e os membros contidos em um assembly específico são disponibilizados em um programa C# simplesmente fazendo referência a esse assembly ao compilar o programa.</span><span class="sxs-lookup"><span data-stu-id="62a9b-255">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="62a9b-256">Por exemplo, esse programa usa a classe `Acme.Collections.Stack` do assembly `acme.dll`:</span><span class="sxs-lookup"><span data-stu-id="62a9b-256">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="62a9b-257">Para compilar esse programa, você precisa *fazer referência* ao assembly que contém a classe Stack definida no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="62a9b-257">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="62a9b-258">Os programas em C# podem ser armazenados em vários arquivos de origem.</span><span class="sxs-lookup"><span data-stu-id="62a9b-258">C# programs can be stored in several source files.</span></span> <span data-ttu-id="62a9b-259">Quando um programa em C# é compilado, todos os arquivos de origem são processados em conjunto e os arquivos de origem podem fazer referência livremente entre si.</span><span class="sxs-lookup"><span data-stu-id="62a9b-259">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="62a9b-260">Conceitualmente, é como se todos os arquivos de origem fossem concatenados em um arquivo grande antes de serem processados.</span><span class="sxs-lookup"><span data-stu-id="62a9b-260">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="62a9b-261">Declarações de encaminhamento nunca são necessárias em C# porque, com poucas exceções, a ordem de declaração é insignificante.</span><span class="sxs-lookup"><span data-stu-id="62a9b-261">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="62a9b-262">O C# não limita um arquivo de origem para declarar apenas um tipo público, nem exige o nome do arquivo de origem para corresponder a um tipo declarado no arquivo de origem.</span><span class="sxs-lookup"><span data-stu-id="62a9b-262">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="62a9b-263">Artigos adicionais neste Tour explicam esses blocos organizacionais.</span><span class="sxs-lookup"><span data-stu-id="62a9b-263">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="62a9b-264">Próximo</span><span class="sxs-lookup"><span data-stu-id="62a9b-264">Next</span></span>](types.md)
