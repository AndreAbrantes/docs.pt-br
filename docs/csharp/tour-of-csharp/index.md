---
title: Um tour pelo C# – Guia do C#
description: Novato em C#? Conheça os fundamentos da linguagem.
ms.date: 08/06/2020
ms.openlocfilehash: 42c4ff59a520a1b99bbb2fb01d79d8902e16bdd5
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063543"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="e9c4b-104">Um tour pela linguagem C#</span><span class="sxs-lookup"><span data-stu-id="e9c4b-104">A tour of the C# language</span></span>

<span data-ttu-id="e9c4b-105">O C# (pronuncia-se "Veja nítido") é uma linguagem de programação moderna, orientada a objeto e de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="e9c4b-106">O C# tem suas raízes na família de linguagens C e os programadores em C, C++, Java e JavaScript a reconhecerão imediatamente.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="e9c4b-107">Este tour fornece uma visão geral dos principais componentes do idioma no C# 8 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="e9c4b-108">Se você quiser explorar a linguagem por meio de exemplos interativos, experimente a [introdução aos](../tutorials/intro-to-csharp/index.md) tutoriais do C#.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="e9c4b-109">O C# é uma linguagem de programação ***orientada*** a objetos e orientada a componentes.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="e9c4b-110">O c# fornece construções de linguagem para dar suporte direto a esses conceitos, tornando o C# uma linguagem natural para criar e usar componentes de software.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="e9c4b-111">Desde sua origem, o C# adicionou recursos para dar suporte a novas cargas de trabalho e práticas de design de software emergentes.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="e9c4b-112">Vários recursos do C# auxiliam na construção de aplicativos robustos e duráveis.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="e9c4b-113">A [***coleta de lixo***](../../standard/garbage-collection/index.md) recupera automaticamente a memória ocupada por objetos não utilizados inacessíveis.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="e9c4b-114">A [***manipulação de exceção***](../programming-guide/exceptions/index.md) fornece uma abordagem estruturada e extensível para detecção e recuperação de erros.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="e9c4b-115">As [***expressões lambda***](../programming-guide/statements-expressions-operators/lambda-expressions.md) dão suporte a técnicas de programação funcional.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-115">[***Lambda expressions***](../programming-guide/statements-expressions-operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="e9c4b-116">A [***sintaxe de consulta***](../linq/index.md) cria um padrão comum para trabalhar com dados de qualquer fonte.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="e9c4b-117">O suporte a idiomas para [***operações assíncronas***](../programming-guide/concepts/async/index.md) fornece a sintaxe para a criação de sistemas distribuídos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="e9c4b-118">A [***correspondência de padrões***](..//pattern-matching.md) fornece sintaxe para separar facilmente os dados de algoritmos em sistemas distribuídos modernos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="e9c4b-119">O C# tem um [***sistema de tipos unificado***](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="e9c4b-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="e9c4b-120">Todos os tipos do C#, incluindo tipos primitivos, como `int` e `double`, herdam de um único tipo de `object` raiz.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="e9c4b-121">Todos os tipos compartilham um conjunto de operações comuns.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-121">All types share a set of common operations.</span></span> <span data-ttu-id="e9c4b-122">Os valores de qualquer tipo podem ser armazenados, transportados e operados de maneira consistente.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="e9c4b-123">Além disso, o C# dá suporte a tipos de referência definidos pelo usuário e tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="e9c4b-124">O C# permite a alocação dinâmica de objetos e o armazenamento em linha de estruturas leves.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="e9c4b-125">O C# enfatiza o ***controle de versão*** para garantir que programas e bibliotecas possam evoluir ao longo do tempo de maneira compatível.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="e9c4b-126">Aspectos do design do C# que foram influenciados diretamente pelas considerações de controle de versão incluem os `virtual` `override` modificadores and separados, as regras para resolução de sobrecarga de método e suporte para declarações de membro de interface explícitas.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="e9c4b-127">Hello world</span><span class="sxs-lookup"><span data-stu-id="e9c4b-127">Hello world</span></span>

<span data-ttu-id="e9c4b-128">O programa "Hello, World" é usado tradicionalmente para introduzir uma linguagem de programação.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="e9c4b-129">Este é para C#:</span><span class="sxs-lookup"><span data-stu-id="e9c4b-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="e9c4b-130">O programa "Hello, World" começa com uma diretiva `using` que faz referência ao namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="e9c4b-131">Namespaces fornecem um meio hierárquico de organizar bibliotecas e programas em C#.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="e9c4b-132">Os namespaces contêm tipos e outros namespaces — por exemplo, o namespace `System` contém uma quantidade de tipos, como a classe `Console` referenciada no programa e diversos outros namespaces, como `IO` e `Collections`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="e9c4b-133">A diretiva `using` que faz referência a um determinado namespace permite o uso não qualificado dos tipos que são membros desse namespace.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="e9c4b-134">Devido à diretiva `using`, o programa pode usar `Console.WriteLine` como um atalho para `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="e9c4b-135">A classe `Hello` declarada pelo programa "Hello, World" tem um único membro, o método chamado `Main`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="e9c4b-136">O `Main` método é declarado com o `static` modificador.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="e9c4b-137">Embora os métodos de instância possam fazer referência a uma determinada instância de objeto delimitador usando a palavra-chave `this`, métodos estáticos operam sem referência a um objeto específico.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="e9c4b-138">Por convenção, um método estático chamado `Main` serve como o ponto de entrada de um programa em C#.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="e9c4b-139">A saída do programa é produzida pelo método `WriteLine` da classe `Console` no namespace `System`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="e9c4b-140">Essa classe é fornecida pelas bibliotecas de classe padrão, que, por padrão, são referenciadas automaticamente pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="e9c4b-141">Tipos e variáveis</span><span class="sxs-lookup"><span data-stu-id="e9c4b-141">Types and variables</span></span>

<span data-ttu-id="e9c4b-142">Há dois tipos em C#: *tipos de referência* e *tipos de valor*.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="e9c4b-143">As variáveis de tipos de valor contêm diretamente seus dados enquanto variáveis de tipos de referência armazenam referências a seus dados, o último sendo conhecido como objetos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="e9c4b-144">Com os tipos de referência, é possível que duas variáveis referenciem o mesmo objeto e possíveis operações em uma variável afetem o objeto referenciado pela outra variável.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="e9c4b-145">Com os tipos de valor, as variáveis têm sua própria cópia dos dados, e não é possível que as operações em um afetem a outra (exceto `ref` para `out` variáveis de parâmetro e).</span><span class="sxs-lookup"><span data-stu-id="e9c4b-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="e9c4b-146">Um ***identificador*** é um nome de variável.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="e9c4b-147">Um identificador é uma sequência de caracteres Unicode sem qualquer espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="e9c4b-148">Um identificador pode ser uma palavra reservada em C#, se for prefixada pelo `@` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="e9c4b-149">Isso pode ser útil ao interagir com outras linguagens.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="e9c4b-150">Os tipos de valor do C# são divididos em *tipos simples*, *tipos de enumeração*, *tipos de struct*e *tipos de valor anulável*.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="e9c4b-151">Os tipos de referência do C# são divididos em *tipos de classe*, *tipos de interface*, *tipos de matriz*e *tipos delegados*.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="e9c4b-152">A seguinte estrutura de tópicos fornece uma visão geral do sistema de tipos do C#.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="e9c4b-153">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="e9c4b-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="e9c4b-154">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="e9c4b-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="e9c4b-155">[Integral assinada](../language-reference/builtin-types/integral-numeric-types.md): `sbyte` , `short` , `int` ,`long`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="e9c4b-156">[Integral não assinada](../language-reference/builtin-types/integral-numeric-types.md): `byte` , `ushort` , `uint` ,`ulong`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="e9c4b-157">[Caracteres Unicode](/dotnet/standard/base-types/character-encoding-introduction): `char` , que representa uma unidade de código UTF-16</span><span class="sxs-lookup"><span data-stu-id="e9c4b-157">[Unicode characters](/dotnet/standard/base-types/character-encoding-introduction): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="e9c4b-158">[Ponto flutuante de binário do IEEE](../language-reference/builtin-types/floating-point-numeric-types.md): `float` ,`double`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="e9c4b-159">[Ponto flutuante decimal de alta precisão](../language-reference/builtin-types/floating-point-numeric-types.md):`decimal`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="e9c4b-160">Booliano: `bool` , que representa valores Boolianos — valores que são `true` ou`false`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="e9c4b-161">Tipos de enumeração</span><span class="sxs-lookup"><span data-stu-id="e9c4b-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="e9c4b-162">Tipos definidos pelo usuário do formulário `enum E {...}` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="e9c4b-163">Um tipo `enum` é um tipo distinto com constantes nomeadas.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="e9c4b-164">Cada tipo `enum` tem um tipo subjacente, que deve ser um dos oito tipos integrais.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="e9c4b-165">O conjunto de valores de um tipo `enum` é o mesmo que o conjunto de valores do tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="e9c4b-166">Tipos struct</span><span class="sxs-lookup"><span data-stu-id="e9c4b-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="e9c4b-167">Tipos definidos pelo usuário do formulário `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="e9c4b-168">Tipos de valor anuláveis</span><span class="sxs-lookup"><span data-stu-id="e9c4b-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="e9c4b-169">Extensões de todos os outros tipos de valor com um valor `null`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="e9c4b-170">Tipos de valor de tupla</span><span class="sxs-lookup"><span data-stu-id="e9c4b-170">Tuple value types</span></span>](../tuples.md)
    - <span data-ttu-id="e9c4b-171">Tipos definidos pelo usuário do formulário `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="e9c4b-172">Tipos de referência</span><span class="sxs-lookup"><span data-stu-id="e9c4b-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="e9c4b-173">Tipos de aula</span><span class="sxs-lookup"><span data-stu-id="e9c4b-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="e9c4b-174">Classe base definitiva de todos os outros tipos: `object`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="e9c4b-175">[Cadeias de caracteres Unicode](/dotnet/standard/base-types/character-encoding-introduction): `string` , que representa uma sequência de unidades de código UTF-16</span><span class="sxs-lookup"><span data-stu-id="e9c4b-175">[Unicode strings](/dotnet/standard/base-types/character-encoding-introduction): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="e9c4b-176">Tipos definidos pelo usuário do formulário `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="e9c4b-177">Tipos de interface</span><span class="sxs-lookup"><span data-stu-id="e9c4b-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="e9c4b-178">Tipos definidos pelo usuário do formulário `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="e9c4b-179">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="e9c4b-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="e9c4b-180">Único e multidimensional e irregular, por exemplo,, `int[]` `int[,]` e`int[][]`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-180">Single- and multi-dimensional and jagged, for example, `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="e9c4b-181">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="e9c4b-181">Delegate types</span></span>](../language-reference/keywords/delegate.md)
    - <span data-ttu-id="e9c4b-182">Tipos definidos pelo usuário do formulário `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="e9c4b-182">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="e9c4b-183">Os programas em C# usam *declarações de tipos* para criar novos tipos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-183">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="e9c4b-184">Uma declaração de tipo especifica o nome e os membros do novo tipo.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-184">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="e9c4b-185">Cinco das categorias de tipos do C# são definíveis pelo usuário: tipos de classe, tipos de struct, tipos de interface, tipos de enumeração e tipos delegados.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-185">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

- <span data-ttu-id="e9c4b-186">Um tipo `class` define uma estrutura de dados que contém membros de dados (campos) e membros de função (métodos, propriedades e outros).</span><span class="sxs-lookup"><span data-stu-id="e9c4b-186">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="e9c4b-187">Os tipos de classe dão suporte à herança única e ao polimorfismo, mecanismos nos quais as classes derivadas podem estender e especializar as classes base.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-187">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="e9c4b-188">Um tipo `struct` é semelhante a um tipo de classe que representa uma estrutura com membros de dados e membros da função.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-188">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="e9c4b-189">No entanto, ao contrário das classes, as structs são tipos de valor e normalmente não exigem alocação de heap.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-189">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="e9c4b-190">Tipos de struct não dão suporte à herança especificada pelo usuário e todos os tipos de struct herdam implicitamente do tipo `object` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-190">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="e9c4b-191">Um `interface` tipo define um contrato como um conjunto nomeado de membros públicos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-191">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="e9c4b-192">Um `class` ou `struct` que implementa um `interface` deve fornecer implementações dos membros da interface.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-192">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="e9c4b-193">Um `interface` pode herdar de várias interfaces base e um `class` ou `struct` pode implementar várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-193">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="e9c4b-194">Um tipo `delegate` representa referências aos métodos com uma lista de parâmetros e tipo de retorno específicos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-194">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="e9c4b-195">Delegados possibilitam o tratamento de métodos como entidades que podem ser atribuídos a variáveis e passadas como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-195">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="e9c4b-196">Os delegados são análogos aos tipos de função fornecidos pelas linguagens funcionais.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-196">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="e9c4b-197">Eles também são semelhantes ao conceito de ponteiros de função encontrados em algumas outras linguagens.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-197">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="e9c4b-198">Diferentemente de ponteiros de função, os delegados são orientados a objeto e são de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-198">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="e9c4b-199">Os `class` `struct` tipos,, e `interface` `delegate` oferecem suporte a genéricos, no qual eles podem ser parametrizados com outros tipos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-199">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="e9c4b-200">O C# dá suporte a matrizes uni e multidimensionais de qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-200">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="e9c4b-201">Ao contrário dos tipos listados acima, os tipos de matriz não precisam ser declarados antes que possam ser usados.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-201">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="e9c4b-202">Em vez disso, os tipos de matriz são construídos seguindo um nome de tipo entre colchetes.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-202">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="e9c4b-203">Por exemplo, `int[]` é uma matriz unidimensional de `int` , `int[,]` é uma matriz bidimensional de `int` e `int[][]` é uma matriz unidimensional de matriz unidimensional ou matriz "denteada" de `int` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-203">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array or "jagged" array of `int`.</span></span>

<span data-ttu-id="e9c4b-204">Tipos anuláveis não exigem uma definição separada.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-204">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="e9c4b-205">Para cada tipo não anulável `T` , há um tipo anulável correspondente `T?` , que pode conter um valor adicional, `null` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-205">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="e9c4b-206">Por exemplo, `int?` é um tipo que pode conter qualquer número inteiro de 32 bits ou o valor `null` e `string?` é um tipo que pode conter qualquer `string` ou o valor `null` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-206">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="e9c4b-207">O sistema de tipos do C# é unificado, de modo que um valor de qualquer tipo pode ser tratado como um `object` .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-207">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="e9c4b-208">Cada tipo no C#, direta ou indiretamente, deriva do tipo de classe `object`, e `object` é a classe base definitiva de todos os tipos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-208">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="e9c4b-209">Os valores de tipos de referência são tratados como objetos simplesmente exibindo os valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-209">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="e9c4b-210">Os valores de tipos de valor são tratados como objetos, executando *conversão boxing* e *operações de conversão unboxing*.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-210">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="e9c4b-211">No exemplo a seguir, um valor `int` é convertido em `object` e volta novamente ao `int`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-211">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="e9c4b-212">Quando um valor de um tipo de valor é atribuído a uma `object` referência, uma "caixa" é alocada para conter o valor.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-212">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="e9c4b-213">Essa caixa é uma instância de um tipo de referência, e o valor é copiado para essa caixa.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-213">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="e9c4b-214">Por outro lado, quando uma `object` referência é convertida em um tipo de valor, é feita uma verificação de que a referência `object` é uma caixa do tipo de valor correto.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-214">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="e9c4b-215">Se a verificação for realizada com sucesso, o valor na caixa será copiado para o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-215">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="e9c4b-216">O sistema de tipos unificados do C# significa efetivamente que os tipos de valor são tratados como `object` referências "sob demanda".</span><span class="sxs-lookup"><span data-stu-id="e9c4b-216">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="e9c4b-217">Devido à unificação, as bibliotecas de uso geral que usam `object` o tipo podem ser usadas com todos os tipos que derivam de `object` , incluindo tipos de referência e tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-217">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="e9c4b-218">Existem vários tipos de *variáveis* no C#, incluindo campos, elementos de matriz, variáveis locais e parâmetros.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-218">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="e9c4b-219">As variáveis representam locais de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-219">Variables represent storage locations.</span></span> <span data-ttu-id="e9c4b-220">Cada variável tem um tipo que determina quais valores podem ser armazenados na variável, como mostrado abaixo.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-220">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="e9c4b-221">Tipo de valor não nulo</span><span class="sxs-lookup"><span data-stu-id="e9c4b-221">Non-nullable value type</span></span>
  - <span data-ttu-id="e9c4b-222">Um valor de tipo exato</span><span class="sxs-lookup"><span data-stu-id="e9c4b-222">A value of that exact type</span></span>
- <span data-ttu-id="e9c4b-223">Tipos de valor anulável</span><span class="sxs-lookup"><span data-stu-id="e9c4b-223">Nullable value type</span></span>
  - <span data-ttu-id="e9c4b-224">Um valor `null` ou um valor do tipo exato</span><span class="sxs-lookup"><span data-stu-id="e9c4b-224">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="e9c4b-225">object</span><span class="sxs-lookup"><span data-stu-id="e9c4b-225">object</span></span>
  - <span data-ttu-id="e9c4b-226">Uma referência `null`, uma referência a um objeto de qualquer tipo de referência ou uma referência a um valor de qualquer tipo de valor demarcado</span><span class="sxs-lookup"><span data-stu-id="e9c4b-226">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="e9c4b-227">Tipo de classe</span><span class="sxs-lookup"><span data-stu-id="e9c4b-227">Class type</span></span>
  - <span data-ttu-id="e9c4b-228">Uma referência `null`, uma referência a uma instância desse tipo de classe ou uma referência a uma instância de uma classe derivada desse tipo de classe</span><span class="sxs-lookup"><span data-stu-id="e9c4b-228">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="e9c4b-229">Tipo de interface</span><span class="sxs-lookup"><span data-stu-id="e9c4b-229">Interface type</span></span>
  - <span data-ttu-id="e9c4b-230">Uma referência `null`, uma referência a uma instância de um tipo de classe que implementa esse tipo de interface ou uma referência a um valor demarcado de um tipo de valor que implementa esse tipo de interface</span><span class="sxs-lookup"><span data-stu-id="e9c4b-230">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="e9c4b-231">Tipo de matriz</span><span class="sxs-lookup"><span data-stu-id="e9c4b-231">Array type</span></span>
  - <span data-ttu-id="e9c4b-232">Uma referência `null`, uma referência a uma instância desse tipo de matriz ou uma referência a uma instância de um tipo de matriz compatível</span><span class="sxs-lookup"><span data-stu-id="e9c4b-232">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="e9c4b-233">Tipo delegado</span><span class="sxs-lookup"><span data-stu-id="e9c4b-233">Delegate type</span></span>
  - <span data-ttu-id="e9c4b-234">Uma referência `null` ou uma referência a uma instância de um tipo de delegado compatível</span><span class="sxs-lookup"><span data-stu-id="e9c4b-234">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="e9c4b-235">Estrutura do programa</span><span class="sxs-lookup"><span data-stu-id="e9c4b-235">Program structure</span></span>

<span data-ttu-id="e9c4b-236">Os principais conceitos organizacionais do C# são [***programas***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***tipos***](../programming-guide/types/index.md), [***Membros***](../programming-guide/classes-and-structs/members.md)e [***assemblies***](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="e9c4b-236">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="e9c4b-237">Os programas declaram tipos que contêm membros e podem ser organizados em namespaces.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-237">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="e9c4b-238">Classes, estruturas e interfaces são exemplos de tipos.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-238">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="e9c4b-239">Campos, métodos, propriedades e eventos são exemplos de membros.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-239">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="e9c4b-240">Quando programas C# são compilados, eles são fisicamente empacotados em assemblies.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-240">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="e9c4b-241">Os assemblies normalmente têm a extensão de arquivo `.exe` ou `.dll`, dependendo se eles implementam ***aplicativos*** ou ***bibliotecas***, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-241">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="e9c4b-242">Como um pequeno exemplo, considere um assembly que contém o código a seguir:</span><span class="sxs-lookup"><span data-stu-id="e9c4b-242">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="e9c4b-243">O nome totalmente qualificado dessa classe é `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-243">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="e9c4b-244">A classe contém vários membros: um campo chamado `top`, dois métodos chamados `Push` e `Pop` e uma classe aninhada chamada `Entry`.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-244">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="e9c4b-245">A classe `Entry` ainda contém três membros: um campo chamado `next`, um campo chamado `data`e um construtor.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-245">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="e9c4b-246">O `Stack` é uma classe *genérica* .</span><span class="sxs-lookup"><span data-stu-id="e9c4b-246">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="e9c4b-247">Ele tem um parâmetro de tipo, `T` que é substituído por um tipo concreto quando usado.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-247">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="e9c4b-248">Uma *pilha* é uma coleção de "primeiro a entrar no final" (filo).</span><span class="sxs-lookup"><span data-stu-id="e9c4b-248">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="e9c4b-249">Novos elementos são adicionados à parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-249">New elements are added to the top of the stack.</span></span> <span data-ttu-id="e9c4b-250">Quando um elemento é removido, ele é removido da parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-250">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="e9c4b-251">Os assemblies contêm código executável na forma de instruções de IL (Linguagem Intermediária) e informações simbólicas na forma de metadados.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-251">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="e9c4b-252">Antes de ser executado, o compilador JIT (just-in-time) do .NET Common Language Runtime converte o código IL em um assembly para o código específico do processador.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-252">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="e9c4b-253">Como um assembly é uma unidade de funcionalidade autodescreveda que contém o código e os metadados, não há necessidade de `#include` diretivas e arquivos de cabeçalho em C#.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-253">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="e9c4b-254">Os tipos públicos e os membros contidos em um assembly específico são disponibilizados em um programa C# simplesmente fazendo referência a esse assembly ao compilar o programa.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-254">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="e9c4b-255">Por exemplo, esse programa usa a classe `Acme.Collections.Stack` do assembly `acme.dll`:</span><span class="sxs-lookup"><span data-stu-id="e9c4b-255">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="e9c4b-256">Para compilar esse programa, você precisa *fazer referência* ao assembly que contém a classe Stack definida no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-256">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="e9c4b-257">Os programas em C# podem ser armazenados em vários arquivos de origem.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-257">C# programs can be stored in several source files.</span></span> <span data-ttu-id="e9c4b-258">Quando um programa em C# é compilado, todos os arquivos de origem são processados em conjunto e os arquivos de origem podem fazer referência livremente entre si.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-258">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="e9c4b-259">Conceitualmente, é como se todos os arquivos de origem fossem concatenados em um arquivo grande antes de serem processados.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-259">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="e9c4b-260">Declarações de encaminhamento nunca são necessárias em C# porque, com poucas exceções, a ordem de declaração é insignificante.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-260">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="e9c4b-261">O C# não limita um arquivo de origem para declarar apenas um tipo público, nem exige o nome do arquivo de origem para corresponder a um tipo declarado no arquivo de origem.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-261">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="e9c4b-262">Artigos adicionais neste Tour explicam esses blocos organizacionais.</span><span class="sxs-lookup"><span data-stu-id="e9c4b-262">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="e9c4b-263">Próximo</span><span class="sxs-lookup"><span data-stu-id="e9c4b-263">Next</span></span>](types.md)
