---
title: "Objetos (Guia de Programação em C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
caps.latest.revision: "26"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f8a8e283b42b27a40780068be42c03fc5047a511
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/21/2017
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="304ad-102">Objetos (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="304ad-102">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="304ad-103">Uma definição de classe ou struct é como um esquema que especifica o que o tipo pode fazer.</span><span class="sxs-lookup"><span data-stu-id="304ad-103">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="304ad-104">Um objeto é basicamente um bloco de memória que foi alocado e configurado de acordo com o esquema.</span><span class="sxs-lookup"><span data-stu-id="304ad-104">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="304ad-105">Um programa pode criar vários objetos da mesma classe.</span><span class="sxs-lookup"><span data-stu-id="304ad-105">A program may create many objects of the same class.</span></span> <span data-ttu-id="304ad-106">Objetos também são chamados de instâncias e podem ser armazenados em uma variável nomeada ou em uma matriz ou coleção.</span><span class="sxs-lookup"><span data-stu-id="304ad-106">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="304ad-107">O código de cliente é o código que usa essas variáveis para chamar os métodos e acessar as propriedades públicas do objeto.</span><span class="sxs-lookup"><span data-stu-id="304ad-107">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="304ad-108">Em uma linguagem orientada a objetos, como o C#, um programa típico consiste em vários objetos que interagem dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="304ad-108">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="304ad-109">Tipos estáticos se comportam de modo diferente do que está descrito aqui.</span><span class="sxs-lookup"><span data-stu-id="304ad-109">Static types behave differently than what is described here.</span></span> <span data-ttu-id="304ad-110">Para obter mais informações, consulte [Classes Estáticas e Membros de Classes Estáticas](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="304ad-110">For more information, see [Static Classes and Static Class Members](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span></span>  
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="304ad-111">Instâncias de struct versus Instâncias de Classe</span><span class="sxs-lookup"><span data-stu-id="304ad-111">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="304ad-112">Como as classes são tipos de referência, uma variável de um objeto de classe contém uma referência ao endereço do objeto no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="304ad-112">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="304ad-113">Se um segundo objeto do mesmo tipo for atribuído ao primeiro objeto, as duas variáveis farão referência ao objeto nesse endereço.</span><span class="sxs-lookup"><span data-stu-id="304ad-113">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="304ad-114">Esse ponto é abordado com mais detalhes posteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="304ad-114">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="304ad-115">Instâncias de classes são criadas usando o [operador new](../../../csharp/language-reference/keywords/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="304ad-115">Instances of classes are created by using the [new operator](../../../csharp/language-reference/keywords/new-operator.md).</span></span> <span data-ttu-id="304ad-116">No exemplo a seguir, `Person` é o tipo e `person1` e `person 2` são instâncias ou objetos desse tipo.</span><span class="sxs-lookup"><span data-stu-id="304ad-116">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_1.cs)]  
  
 <span data-ttu-id="304ad-117">Como structs são tipos de valor, uma variável de um objeto de struct mantém uma cópia do objeto inteiro.</span><span class="sxs-lookup"><span data-stu-id="304ad-117">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="304ad-118">Instâncias de structs também podem ser criadas usando o operador `new`, mas isso não é obrigatório, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="304ad-118">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_2.cs)]  
  
 <span data-ttu-id="304ad-119">A memória de `p1` e `p2` é alocada na pilha de thread.</span><span class="sxs-lookup"><span data-stu-id="304ad-119">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="304ad-120">Essa memória é recuperada em conjunto com o tipo ou método em que ela é declarada.</span><span class="sxs-lookup"><span data-stu-id="304ad-120">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="304ad-121">Esse é um dos motivos pelos quais os structs são copiados na atribuição.</span><span class="sxs-lookup"><span data-stu-id="304ad-121">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="304ad-122">Por outro lado, a memória alocada a uma instância de classe é recuperada automaticamente (o lixo é coletado) pelo Common Language Runtime quando todas as referências ao objeto tiveram saído do escopo.</span><span class="sxs-lookup"><span data-stu-id="304ad-122">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="304ad-123">Não é possível destruir de forma determinista um objeto de classe, como é possível no C++.</span><span class="sxs-lookup"><span data-stu-id="304ad-123">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="304ad-124">Para obter mais informações sobre a coleta de lixo no [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], consulte [Coleta de lixo](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="304ad-124">For more information about garbage collection in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="304ad-125">A alocação e a desalocação de memória no heap gerenciado é altamente otimizada no Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="304ad-125">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="304ad-126">Na maioria dos casos, não há uma diferença significativa quanto ao custo do desempenho de alocar uma instância da classe no heap em vez de alocar uma instância de struct na pilha.</span><span class="sxs-lookup"><span data-stu-id="304ad-126">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>  
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="304ad-127">Identidade de objeto versus Igualdade de Valor</span><span class="sxs-lookup"><span data-stu-id="304ad-127">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="304ad-128">Quando compara dois objetos quanto à igualdade, primeiro você precisa distinguir se quer saber se as duas variáveis representam o mesmo objeto na memória ou se os valores de um ou mais de seus campos são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="304ad-128">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="304ad-129">Se estiver pretendendo comparar valores, você precisa considerar se os objetos são instâncias de tipos de valor (structs) ou tipos de referência (classes, delegados, matrizes).</span><span class="sxs-lookup"><span data-stu-id="304ad-129">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
-   <span data-ttu-id="304ad-130">Para determinar se duas instâncias de classe se referem ao mesmo local na memória (o que significa que elas têm a mesma *identidade*), use o método <xref:System.Object.Equals%2A> estático.</span><span class="sxs-lookup"><span data-stu-id="304ad-130">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="304ad-131">(<xref:System.Object?displayProperty=nameWithType> é a classe base implícita para todos os tipos de valor e tipos de referência, incluindo classes e structs definidos pelo usuário.)</span><span class="sxs-lookup"><span data-stu-id="304ad-131">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
-   <span data-ttu-id="304ad-132">Para determinar se os campos de instância em duas instâncias de struct têm os mesmos valores, use o método <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="304ad-132">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="304ad-133">Como todos os structs herdam implicitamente de <xref:System.ValueType?displayProperty=nameWithType>, você chama o método diretamente em seu objeto, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="304ad-133">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_3.cs)]  
  
 <span data-ttu-id="304ad-134">A implementação de <xref:System.ValueType?displayProperty=nameWithType> de `Equals` usa reflexão porque ela precisa ser capaz de determinar quais são os campos em qualquer struct.</span><span class="sxs-lookup"><span data-stu-id="304ad-134">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="304ad-135">Ao criar seus próprios structs, substitua o método `Equals` para fornecer um algoritmo de igualdade eficiente que é específico ao seu tipo.</span><span class="sxs-lookup"><span data-stu-id="304ad-135">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
-   <span data-ttu-id="304ad-136">Para determinar se os valores dos campos em duas instâncias de classe são iguais, você pode usar o método <xref:System.Object.Equals%2A> ou o [Operador ==](../../../csharp/language-reference/operators/equality-comparison-operator.md).</span><span class="sxs-lookup"><span data-stu-id="304ad-136">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../../csharp/language-reference/operators/equality-comparison-operator.md).</span></span> <span data-ttu-id="304ad-137">No entanto, use-os apenas se a classe os tiver substituído ou sobrecarregado para fornecer uma definição personalizada do que "igualdade" significa para objetos desse tipo.</span><span class="sxs-lookup"><span data-stu-id="304ad-137">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="304ad-138">A classe também pode implementar a interface <xref:System.IEquatable%601> ou a interface <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="304ad-138">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="304ad-139">As duas interfaces fornecem métodos que podem ser usados para testar a igualdade de valores.</span><span class="sxs-lookup"><span data-stu-id="304ad-139">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="304ad-140">Ao criar suas próprias classes que substituem `Equals`, certifique-se de seguir as diretrizes informadas em [Como definir a igualdade de valor para um tipo](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) e <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="304ad-140">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to: Define Value Equality for a Type](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>  
  
## <a name="related-sections"></a><span data-ttu-id="304ad-141">Seções relacionadas</span><span class="sxs-lookup"><span data-stu-id="304ad-141">Related Sections</span></span>  
 <span data-ttu-id="304ad-142">Para saber mais:</span><span class="sxs-lookup"><span data-stu-id="304ad-142">For more information:</span></span>  
  
-   [<span data-ttu-id="304ad-143">Classes</span><span class="sxs-lookup"><span data-stu-id="304ad-143">Classes</span></span>](../../../csharp/programming-guide/classes-and-structs/classes.md)  
  
-   [<span data-ttu-id="304ad-144">Estruturas</span><span class="sxs-lookup"><span data-stu-id="304ad-144">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)  
  
-   [<span data-ttu-id="304ad-145">Construtores</span><span class="sxs-lookup"><span data-stu-id="304ad-145">Constructors</span></span>](../../../csharp/programming-guide/classes-and-structs/constructors.md)  
  
-   [<span data-ttu-id="304ad-146">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="304ad-146">Finalizers</span></span>](../../../csharp/programming-guide/classes-and-structs/destructors.md)  
  
-   [<span data-ttu-id="304ad-147">Eventos</span><span class="sxs-lookup"><span data-stu-id="304ad-147">Events</span></span>](../../../csharp/programming-guide/events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="304ad-148">Consulte também</span><span class="sxs-lookup"><span data-stu-id="304ad-148">See Also</span></span>  
 [<span data-ttu-id="304ad-149">Guia de Programação em C#</span><span class="sxs-lookup"><span data-stu-id="304ad-149">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="304ad-150">object</span><span class="sxs-lookup"><span data-stu-id="304ad-150">object</span></span>](../../../csharp/language-reference/keywords/object.md)  
 [<span data-ttu-id="304ad-151">Herança</span><span class="sxs-lookup"><span data-stu-id="304ad-151">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)  
 [<span data-ttu-id="304ad-152">class</span><span class="sxs-lookup"><span data-stu-id="304ad-152">class</span></span>](../../../csharp/language-reference/keywords/class.md)  
 [<span data-ttu-id="304ad-153">struct</span><span class="sxs-lookup"><span data-stu-id="304ad-153">struct</span></span>](../../../csharp/language-reference/keywords/struct.md)  
 [<span data-ttu-id="304ad-154">Operador new</span><span class="sxs-lookup"><span data-stu-id="304ad-154">new Operator</span></span>](../../../csharp/language-reference/keywords/new-operator.md)  
 [<span data-ttu-id="304ad-155">Common Type System</span><span class="sxs-lookup"><span data-stu-id="304ad-155">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
