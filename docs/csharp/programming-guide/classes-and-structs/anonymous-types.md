---
title: Tipos anônimos – Guia de Programação em C#
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: 234190beb2cde69906df9d5c5f468689b7399535
ms.sourcegitcommit: bdd930b5df20a45c29483d905526a2a3e4d17c5b
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/11/2018
ms.locfileid: "53235979"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="54994-102">Tipos anônimos (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="54994-102">Anonymous Types (C# Programming Guide)</span></span>
<span data-ttu-id="54994-103">Os tipos anônimos fornecem um modo conveniente de encapsular um conjunto de propriedades somente leitura em um único objeto sem a necessidade de primeiro definir explicitamente um tipo.</span><span class="sxs-lookup"><span data-stu-id="54994-103">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="54994-104">O nome do tipo é gerado pelo compilador e não está disponível no nível do código-fonte.</span><span class="sxs-lookup"><span data-stu-id="54994-104">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="54994-105">O tipo de cada propriedade é inferido pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="54994-105">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="54994-106">Crie tipos anônimos, usando o operador [new](../../../csharp/language-reference/keywords/new.md) com um inicializador de objeto.</span><span class="sxs-lookup"><span data-stu-id="54994-106">You create anonymous types by using the [new](../../../csharp/language-reference/keywords/new.md) operator together with an object initializer.</span></span> <span data-ttu-id="54994-107">Para obter mais informações sobre inicializadores de objeto, consulte [Inicializadores de Objeto e Coleção](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="54994-107">For more information about object initializers, see [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="54994-108">O exemplo a seguir mostra um tipo anônimo que é inicializado com duas propriedades chamadas `Amount` e `Message`.</span><span class="sxs-lookup"><span data-stu-id="54994-108">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="54994-109">Os tipos anônimos são normalmente usados na cláusula [select](../../../csharp/language-reference/keywords/select-clause.md) de uma expressão de consulta para retornar um subconjunto das propriedades de cada objeto na sequência de origem.</span><span class="sxs-lookup"><span data-stu-id="54994-109">Anonymous types typically are used in the [select](../../../csharp/language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="54994-110">Para obter mais informações sobre consultas, consulte [Expressões de Consulta LINQ](../../../csharp/programming-guide/linq-query-expressions/index.md).</span><span class="sxs-lookup"><span data-stu-id="54994-110">For more information about queries, see [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md).</span></span>  
  
 <span data-ttu-id="54994-111">Os tipos anônimos contêm uma ou mais propriedades públicas somente leitura.</span><span class="sxs-lookup"><span data-stu-id="54994-111">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="54994-112">Nenhum outro tipo de membros da classe, como métodos ou eventos, é válido.</span><span class="sxs-lookup"><span data-stu-id="54994-112">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="54994-113">A expressão que é usada para inicializar uma propriedade não pode ser `null`, uma função anônima ou um tipo de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="54994-113">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="54994-114">O cenário mais comum é inicializar um tipo anônimo com propriedades de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="54994-114">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="54994-115">No exemplo a seguir, suponha que existe uma classe com o nome `Product`.</span><span class="sxs-lookup"><span data-stu-id="54994-115">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="54994-116">A classe `Product` inclui as propriedades `Color` e `Price`, além de outras propriedades que não lhe interessam.</span><span class="sxs-lookup"><span data-stu-id="54994-116">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="54994-117">A variável `products` é uma coleção de objetos do `Product`.</span><span class="sxs-lookup"><span data-stu-id="54994-117">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="54994-118">A declaração do tipo anônimo começa com a palavra-chave `new`.</span><span class="sxs-lookup"><span data-stu-id="54994-118">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="54994-119">A declaração inicializa um novo tipo que usa apenas duas propriedades de `Product`.</span><span class="sxs-lookup"><span data-stu-id="54994-119">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="54994-120">Isso faz com que uma menor quantidade de dados seja retornada na consulta.</span><span class="sxs-lookup"><span data-stu-id="54994-120">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="54994-121">Quando você não especifica os nomes de membros no tipo anônimo, o compilador dá aos membros de tipo anônimo o mesmo nome da propriedade que está sendo usada para inicializá-los.</span><span class="sxs-lookup"><span data-stu-id="54994-121">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="54994-122">Forneça um nome para a propriedade que está sendo inicializada com uma expressão, como mostrado no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="54994-122">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="54994-123">No exemplo a seguir, os nomes das propriedades do tipo anônimo são `Color` e `Price` .</span><span class="sxs-lookup"><span data-stu-id="54994-123">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/anonymous-types_1.cs)]  
  
 <span data-ttu-id="54994-124">Normalmente, ao usar um tipo anônimo para inicializar uma variável, a variável é declarada como uma variável local de tipo implícito usando [var](../../../csharp/language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="54994-124">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../../csharp/language-reference/keywords/var.md).</span></span> <span data-ttu-id="54994-125">O nome do tipo não pode ser especificado na declaração da variável, porque apenas o compilador tem acesso ao nome subjacente do tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="54994-125">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="54994-126">Para obter mais informações sobre `var`, consulte [Variáveis de local digitadas implicitamente](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="54994-126">For more information about `var`, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="54994-127">Você pode criar uma matriz de elementos de tipo anônimo combinando uma variável local de tipo implícito e uma matriz de tipo implícito, como mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="54994-127">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="54994-128">Comentários</span><span class="sxs-lookup"><span data-stu-id="54994-128">Remarks</span></span>  
 <span data-ttu-id="54994-129">Os tipos anônimos são tipos [class](../../../csharp/language-reference/keywords/class.md) que derivam diretamente de [object](../../../csharp/language-reference/keywords/object.md) e que não podem ser convertidos para qualquer tipo, exceto [object](../../../csharp/language-reference/keywords/object.md).</span><span class="sxs-lookup"><span data-stu-id="54994-129">Anonymous types are [class](../../../csharp/language-reference/keywords/class.md) types that derive directly from [object](../../../csharp/language-reference/keywords/object.md), and that cannot be cast to any type except [object](../../../csharp/language-reference/keywords/object.md).</span></span> <span data-ttu-id="54994-130">O compilador fornece um nome para cada tipo anônimo, embora o seu aplicativo não possa acessá-lo.</span><span class="sxs-lookup"><span data-stu-id="54994-130">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="54994-131">Do ponto de vista do Common Language Runtime, um tipo anônimo não é diferente de qualquer outro tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="54994-131">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="54994-132">Se dois ou mais inicializadores de objeto anônimos em um assembly especificarem uma sequência de propriedades que estão na mesma ordem e que têm os mesmos nomes e tipos, o compilador tratará os objetos como instâncias do mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="54994-132">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="54994-133">Eles compartilham o mesmo tipo de informação gerado pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="54994-133">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="54994-134">Você não pode declarar que um campo, uma propriedade, um evento ou um tipo de retorno de um método tem um tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="54994-134">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="54994-135">Da mesma forma, não pode declarar que um parâmetro formal de um método, propriedade, construtor ou indexador tem um tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="54994-135">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="54994-136">Para passar um tipo anônimo ou uma coleção que contenha tipos anônimos, como um argumento para um método, você pode declarar o parâmetro como objeto type.</span><span class="sxs-lookup"><span data-stu-id="54994-136">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="54994-137">No entanto, isso anula a finalidade dos tipos fortes.</span><span class="sxs-lookup"><span data-stu-id="54994-137">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="54994-138">Se você precisa armazenar os resultados da consulta ou passá-los fora do limite do método, considere o uso de uma estrutura ou classe com denominação comum em vez de um tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="54994-138">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="54994-139">Como os métodos <xref:System.Object.Equals%2A> e <xref:System.Object.GetHashCode%2A> em tipos anônimos são definidos em termos dos métodos das propriedades `Equals` e `GetHashCode`, duas instâncias do mesmo tipo anônimo são iguais somente se todas as suas propriedades forem iguais.</span><span class="sxs-lookup"><span data-stu-id="54994-139">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="54994-140">Consulte também</span><span class="sxs-lookup"><span data-stu-id="54994-140">See Also</span></span>

- [<span data-ttu-id="54994-141">Guia de Programação em C#</span><span class="sxs-lookup"><span data-stu-id="54994-141">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
- [<span data-ttu-id="54994-142">Inicializadores de objeto e coleção</span><span class="sxs-lookup"><span data-stu-id="54994-142">Object and Collection Initializers</span></span>](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)  
- [<span data-ttu-id="54994-143">Introdução a LINQ em C#</span><span class="sxs-lookup"><span data-stu-id="54994-143">Getting Started with LINQ in C#</span></span>](../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)  
- [<span data-ttu-id="54994-144">Expressões de consulta LINQ</span><span class="sxs-lookup"><span data-stu-id="54994-144">LINQ Query Expressions</span></span>](../../../csharp/programming-guide/linq-query-expressions/index.md)
