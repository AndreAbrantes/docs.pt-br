---
title: Controle de versão com as palavras-chave override e new – Guia de Programação em C#
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: 5c83ce79bede1ee4e5752ac0b1dcf9647df1f36c
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54555980"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="23855-102">Controle de versão com as palavras-chave override e new (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="23855-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="23855-103">A linguagem C# foi projetada para que o controle de versão entre classes derivadas e [base](../../../csharp/language-reference/keywords/base.md) em diferentes bibliotecas possa evoluir e manter a compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="23855-103">The C# language is designed so that versioning between [base](../../../csharp/language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="23855-104">Isso significa, por exemplo, que a introdução de um novo membro em uma [classe](../../../csharp/language-reference/keywords/class.md) base com o mesmo nome que um membro em uma classe derivada tem suporte completo pelo C# e não leva a comportamento inesperado.</span><span class="sxs-lookup"><span data-stu-id="23855-104">This means, for example, that the introduction of a new member in a base [class](../../../csharp/language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="23855-105">Isso também significa que uma classe deve declarar explicitamente se um método destina-se a substituir um método herdado ou se um método é um novo método que oculta um método herdado de nome semelhante.</span><span class="sxs-lookup"><span data-stu-id="23855-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="23855-106">No C#, as classes derivadas podem conter métodos com o mesmo nome que os métodos da classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
-   <span data-ttu-id="23855-107">O método de classe base deve ser definido como [virtual](../../../csharp/language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="23855-107">The base class method must be defined [virtual](../../../csharp/language-reference/keywords/virtual.md).</span></span>  
  
-   <span data-ttu-id="23855-108">Se o método na classe derivada não for precedido pelas palavras-chave [new](../../../csharp/language-reference/keywords/new.md) ou [override](../../../csharp/language-reference/keywords/override.md), o compilador emitirá um aviso e o método se comportará como se a palavra-chave `new` estivesse presente.</span><span class="sxs-lookup"><span data-stu-id="23855-108">If the method in the derived class is not preceded by [new](../../../csharp/language-reference/keywords/new.md) or [override](../../../csharp/language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
-   <span data-ttu-id="23855-109">Se o método na classe derivada for precedido pela palavra-chave `new`, o método será definido como sendo independente do método na classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
-   <span data-ttu-id="23855-110">Se o método na classe derivada for precedido pela palavra-chave `override`, os objetos da classe derivada chamarão esse método em vez do método da classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
-   <span data-ttu-id="23855-111">O método da classe base pode ser chamado de dentro da classe derivada usando a palavra-chave `base`.</span><span class="sxs-lookup"><span data-stu-id="23855-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
-   <span data-ttu-id="23855-112">As palavras-chave `override`, `virtual` e `new` também podem ser aplicadas a propriedades, indexadores e eventos.</span><span class="sxs-lookup"><span data-stu-id="23855-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="23855-113">Por padrão, os métodos C# não são virtuais.</span><span class="sxs-lookup"><span data-stu-id="23855-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="23855-114">Se um método for declarado como virtual, qualquer classe que herdar o método pode implementar sua própria versão.</span><span class="sxs-lookup"><span data-stu-id="23855-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="23855-115">Para tornar um método virtual, o modificador `virtual` é usado na declaração de método da classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="23855-116">A classe derivada pode, em seguida, substituir o método virtual base usando a palavra-chave `override` ou ocultar o método virtual na classe base usando a palavra-chave `new`.</span><span class="sxs-lookup"><span data-stu-id="23855-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="23855-117">Se nem a palavra-chave `override` nem a `new` for especificada, o compilador emitirá um aviso e o método na classe derivada ocultará o método na classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="23855-118">Para demonstrar isso na prática, suponha por um momento que a Empresa A tenha criado uma classe chamada `GraphicsClass`, que seu programa usa.</span><span class="sxs-lookup"><span data-stu-id="23855-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="23855-119">A seguir está `GraphicsClass`:</span><span class="sxs-lookup"><span data-stu-id="23855-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_1.cs)]  
  
 <span data-ttu-id="23855-120">Sua empresa usa essa classe e você a usa para derivar sua própria classe, adicionando um novo método:</span><span class="sxs-lookup"><span data-stu-id="23855-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_2.cs)]  
  
 <span data-ttu-id="23855-121">Seu aplicativo é usado sem problemas, até a Empresa A lançar uma nova versão de `GraphicsClass`, que se parece com o seguinte código:</span><span class="sxs-lookup"><span data-stu-id="23855-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_3.cs)]  
  
 <span data-ttu-id="23855-122">A nova versão de `GraphicsClass` agora contém um método chamado `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="23855-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="23855-123">Inicialmente, nada ocorre.</span><span class="sxs-lookup"><span data-stu-id="23855-123">Initially, nothing occurs.</span></span> <span data-ttu-id="23855-124">A nova versão ainda é compatível em relação ao binário com a versão antiga.</span><span class="sxs-lookup"><span data-stu-id="23855-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="23855-125">Qualquer software que você implantou continuará a funcionar, mesmo se a nova classe for instalada nesses sistemas de computador.</span><span class="sxs-lookup"><span data-stu-id="23855-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="23855-126">Todas as chamadas existentes para o método `DrawRectangle` continuarão a fazer referência à sua versão, em sua classe derivada.</span><span class="sxs-lookup"><span data-stu-id="23855-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="23855-127">No entanto, assim que você recompilar seu aplicativo usando a nova versão do `GraphicsClass`, você receberá um aviso do compilador, CS0108.</span><span class="sxs-lookup"><span data-stu-id="23855-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="23855-128">Este aviso informa que você deve considerar como deseja que seu método `DrawRectangle` se comporte em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="23855-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="23855-129">Se desejar que seu método substitua o novo método de classe base, use a palavra-chave `override`:</span><span class="sxs-lookup"><span data-stu-id="23855-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_4.cs)]  
  
 <span data-ttu-id="23855-130">A palavra-chave `override` garante que todos os objetos derivados de `YourDerivedGraphicsClass` usarão a versão da classe derivada de `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="23855-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="23855-131">Os objetos derivados de `YourDerivedGraphicsClass` ainda poderão acessar a versão da classe base de `DrawRectangle` usando a palavra-chave base:</span><span class="sxs-lookup"><span data-stu-id="23855-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_5.cs)]  
  
 <span data-ttu-id="23855-132">Se você não quiser que seu método substitua o novo método de classe base, as seguintes considerações se aplicam.</span><span class="sxs-lookup"><span data-stu-id="23855-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="23855-133">Para evitar confusão entre os dois métodos, você pode renomear seu método.</span><span class="sxs-lookup"><span data-stu-id="23855-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="23855-134">Isso pode ser demorado e propenso a erros e simplesmente não ser prático em alguns casos.</span><span class="sxs-lookup"><span data-stu-id="23855-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="23855-135">No entanto, se seu projeto for relativamente pequeno, você poderá usar opções de Refatoração do Visual Studio para renomear o método.</span><span class="sxs-lookup"><span data-stu-id="23855-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="23855-136">Para obter mais informações, consulte [Refatorando classes e tipos (Designer de Classe)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span><span class="sxs-lookup"><span data-stu-id="23855-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span></span>  
  
 <span data-ttu-id="23855-137">Como alternativa, você pode evitar o aviso usando a palavra-chave `new` na definição da classe derivada:</span><span class="sxs-lookup"><span data-stu-id="23855-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_6.cs)]  
  
 <span data-ttu-id="23855-138">Usando a palavra-chave `new` informa ao compilador que sua definição oculta a definição que está contida na classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="23855-139">Este é o comportamento padrão.</span><span class="sxs-lookup"><span data-stu-id="23855-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="23855-140">Seleção de método e substituição</span><span class="sxs-lookup"><span data-stu-id="23855-140">Override and Method Selection</span></span>  
 <span data-ttu-id="23855-141">Quando um método é chamado em uma classe, o compilador C# seleciona o melhor método a ser chamado se mais de um método for compatível com a chamada, como quando há dois métodos com o mesmo nome e parâmetros que são compatíveis com o parâmetro passado.</span><span class="sxs-lookup"><span data-stu-id="23855-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="23855-142">Os métodos a seguir seriam compatíveis:</span><span class="sxs-lookup"><span data-stu-id="23855-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_7.cs)]  
  
 <span data-ttu-id="23855-143">Quando `DoWork` é chamado em uma instância do `Derived`, o compilador C# tenta primeiro tornar a chamada compatível com as versões do `DoWork` originalmente declarado em `Derived`.</span><span class="sxs-lookup"><span data-stu-id="23855-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="23855-144">Os métodos de substituição não são considerados como declarados em uma classe, eles são novas implementações de um método declarado em uma classe base.</span><span class="sxs-lookup"><span data-stu-id="23855-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="23855-145">Somente se o compilador C# não puder corresponder a chamada de método a um método original no `Derived` ele tentará corresponder a chamada a um método com o mesmo nome e parâmetros compatíveis.</span><span class="sxs-lookup"><span data-stu-id="23855-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="23855-146">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="23855-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_8.cs)]  
  
 <span data-ttu-id="23855-147">Como a variável `val` pode ser convertida para um duplo implicitamente, o compilador C# chama `DoWork(double)` em vez de `DoWork(int)`.</span><span class="sxs-lookup"><span data-stu-id="23855-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="23855-148">Há duas formas de evitar isso.</span><span class="sxs-lookup"><span data-stu-id="23855-148">There are two ways to avoid this.</span></span> <span data-ttu-id="23855-149">Primeiro, evite declarar novos métodos com o mesmo nome que os métodos virtuais.</span><span class="sxs-lookup"><span data-stu-id="23855-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="23855-150">Segundo, você pode instruir o compilador C# para chamar o método virtual fazendo-o pesquisar a lista do método de classe base convertendo a instância do `Derived` para `Base`.</span><span class="sxs-lookup"><span data-stu-id="23855-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="23855-151">Como o método é virtual, a implementação de `DoWork(int)` em `Derived` será chamada.</span><span class="sxs-lookup"><span data-stu-id="23855-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="23855-152">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="23855-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_9.cs)]  
  
 <span data-ttu-id="23855-153">Para obter mais exemplos de `new` e `override`, consulte [Quando usar as palavras-chave override e new](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="23855-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="23855-154">Consulte também</span><span class="sxs-lookup"><span data-stu-id="23855-154">See also</span></span>

- [<span data-ttu-id="23855-155">Guia de Programação em C#</span><span class="sxs-lookup"><span data-stu-id="23855-155">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="23855-156">Classes e Structs</span><span class="sxs-lookup"><span data-stu-id="23855-156">Classes and Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/index.md)
- [<span data-ttu-id="23855-157">Métodos</span><span class="sxs-lookup"><span data-stu-id="23855-157">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)
- [<span data-ttu-id="23855-158">Herança</span><span class="sxs-lookup"><span data-stu-id="23855-158">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
