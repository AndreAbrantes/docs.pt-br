---
title: Funções locais – Guia de Programação em C#
description: As funções locais em C# são métodos privados que são aninhados em outro membro e podem ser chamados de seus membros que os contêm.
ms.date: 10/09/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: a2d389c8b1c687dc4885004fcdc33e0ed7ada977
ms.sourcegitcommit: b59237ca4ec763969a0dd775a3f8f39f8c59fe24
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/12/2020
ms.locfileid: "91955675"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="5ac73-103">Funções locais (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="5ac73-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="5ac73-104">Começando com o C# 7.0, o C# é compatível com *funções locais*.</span><span class="sxs-lookup"><span data-stu-id="5ac73-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="5ac73-105">Funções locais são métodos privados de um tipo que estão aninhados em outro membro.</span><span class="sxs-lookup"><span data-stu-id="5ac73-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="5ac73-106">Eles só podem ser chamados do membro que os contém.</span><span class="sxs-lookup"><span data-stu-id="5ac73-106">They can only be called from their containing member.</span></span> <span data-ttu-id="5ac73-107">Funções locais podem ser declaradas em e chamadas de:</span><span class="sxs-lookup"><span data-stu-id="5ac73-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="5ac73-108">Métodos, especialmente os métodos iteradores e os métodos assíncronos</span><span class="sxs-lookup"><span data-stu-id="5ac73-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="5ac73-109">Construtores</span><span class="sxs-lookup"><span data-stu-id="5ac73-109">Constructors</span></span>
- <span data-ttu-id="5ac73-110">Acessadores de propriedades</span><span class="sxs-lookup"><span data-stu-id="5ac73-110">Property accessors</span></span>
- <span data-ttu-id="5ac73-111">Acessadores de eventos</span><span class="sxs-lookup"><span data-stu-id="5ac73-111">Event accessors</span></span>
- <span data-ttu-id="5ac73-112">Métodos anônimos</span><span class="sxs-lookup"><span data-stu-id="5ac73-112">Anonymous methods</span></span>
- <span data-ttu-id="5ac73-113">Expressões lambda</span><span class="sxs-lookup"><span data-stu-id="5ac73-113">Lambda expressions</span></span>
- <span data-ttu-id="5ac73-114">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="5ac73-114">Finalizers</span></span>
- <span data-ttu-id="5ac73-115">Outras funções locais</span><span class="sxs-lookup"><span data-stu-id="5ac73-115">Other local functions</span></span>

<span data-ttu-id="5ac73-116">No entanto, as funções locais não podem ser declaradas dentro de um membro apto para expressão.</span><span class="sxs-lookup"><span data-stu-id="5ac73-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="5ac73-117">Em alguns casos, você pode usar uma expressão lambda para implementar uma funcionalidade que também tem suporte por uma função local.</span><span class="sxs-lookup"><span data-stu-id="5ac73-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="5ac73-118">Para obter uma comparação, consulte [funções locais versus expressões lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="5ac73-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="5ac73-119">Funções locais tornam a intenção do seu código clara.</span><span class="sxs-lookup"><span data-stu-id="5ac73-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="5ac73-120">Qualquer pessoa que ler seu código poderá ver que o método não pode ser chamado, exceto pelo método que o contém.</span><span class="sxs-lookup"><span data-stu-id="5ac73-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="5ac73-121">Para projetos de equipe, elas também impossibilitam que outro desenvolvedor chame o método por engano diretamente de qualquer outro lugar na classe ou no struct.</span><span class="sxs-lookup"><span data-stu-id="5ac73-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="5ac73-122">Sintaxe de função local</span><span class="sxs-lookup"><span data-stu-id="5ac73-122">Local function syntax</span></span>

<span data-ttu-id="5ac73-123">Uma função local é definida como um método aninhado dentro de um membro recipiente.</span><span class="sxs-lookup"><span data-stu-id="5ac73-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="5ac73-124">Sua definição tem a seguinte sintaxe:</span><span class="sxs-lookup"><span data-stu-id="5ac73-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="5ac73-125">Você pode usar os seguintes modificadores com uma função local:</span><span class="sxs-lookup"><span data-stu-id="5ac73-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="5ac73-126">[`static`](../../language-reference/keywords/static.md) (em C# 8,0 e posterior).</span><span class="sxs-lookup"><span data-stu-id="5ac73-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="5ac73-127">Uma função local estática não pode capturar variáveis locais ou estado de instância.</span><span class="sxs-lookup"><span data-stu-id="5ac73-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="5ac73-128">[`extern`](../../language-reference/keywords/extern.md) (em C# 9,0 e posterior).</span><span class="sxs-lookup"><span data-stu-id="5ac73-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="5ac73-129">Uma função local externa deve ser `static` .</span><span class="sxs-lookup"><span data-stu-id="5ac73-129">An external local function must be `static`.</span></span>

<span data-ttu-id="5ac73-130">Todas as variáveis locais que são definidas no membro recipiente, incluindo seus parâmetros de método, são acessíveis em uma função local não estática.</span><span class="sxs-lookup"><span data-stu-id="5ac73-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="5ac73-131">Ao contrário de uma definição de método, uma definição de função local não pode incluir o modificador de acesso de membro.</span><span class="sxs-lookup"><span data-stu-id="5ac73-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="5ac73-132">Já que todas as funções locais são privadas, incluir um modificador de acesso como a palavra-chave `private` gera o erro do compilador CS0106, "O modificador 'private' não é válido para este item".</span><span class="sxs-lookup"><span data-stu-id="5ac73-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="5ac73-133">O exemplo a seguir define uma função local chamada `AppendPathSeparator` que é privada para um método chamado `GetText`:</span><span class="sxs-lookup"><span data-stu-id="5ac73-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="5ac73-134">A partir do C# 9,0, você pode aplicar atributos a uma função local, seus parâmetros e parâmetros de tipo, como mostra o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="5ac73-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="5ac73-135">O exemplo anterior usa um [atributo especial](../../language-reference/attributes/nullable-analysis.md) para auxiliar o compilador em análise estática em um contexto anulável.</span><span class="sxs-lookup"><span data-stu-id="5ac73-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="5ac73-136">Funções locais e exceções</span><span class="sxs-lookup"><span data-stu-id="5ac73-136">Local functions and exceptions</span></span>

<span data-ttu-id="5ac73-137">Um dos recursos úteis de funções locais é que elas podem permitir que exceções sejam apresentadas imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5ac73-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="5ac73-138">Para iteradores de método, as exceções são apresentadas somente quando a sequência retornada é enumerada e não quando o iterador é recuperado.</span><span class="sxs-lookup"><span data-stu-id="5ac73-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="5ac73-139">Para métodos assíncronos, as exceções geradas em um método assíncrono são observadas quando a tarefa retornada é esperada.</span><span class="sxs-lookup"><span data-stu-id="5ac73-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="5ac73-140">O exemplo a seguir define um `OddSequence` método que enumera números ímpares em um intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="5ac73-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="5ac73-141">Já que ele passa um número maior que 100 para o método enumerador `OddSequence`, o método gera uma <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="5ac73-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="5ac73-142">Assim como demonstrado pela saída do exemplo, a exceção é apresentada somente quando você itera os números e não quando você recupera o enumerador.</span><span class="sxs-lookup"><span data-stu-id="5ac73-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="5ac73-143">Se você colocar a lógica do iterador em uma função local, as exceções de validação de argumento serão geradas quando você recuperar o enumerador, como mostra o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="5ac73-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="5ac73-144">Você pode usar funções locais de maneira semelhante com operações assíncronas.</span><span class="sxs-lookup"><span data-stu-id="5ac73-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="5ac73-145">Exceções geradas em uma superfície de método assíncrono quando a tarefa correspondente é esperada.</span><span class="sxs-lookup"><span data-stu-id="5ac73-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="5ac73-146">Funções locais permitem que seu código falhe no modo rápido e permitem que a exceção seja gerada e observada de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="5ac73-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="5ac73-147">O exemplo a seguir usa um método assíncrono chamado `GetMultipleAsync` para pausar para um número especificado de segundos e retornar um valor que é um múltiplo aleatório desse número de segundos.</span><span class="sxs-lookup"><span data-stu-id="5ac73-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="5ac73-148">O atraso máximo é de 5 segundos; um <xref:System.ArgumentOutOfRangeException> resulta em se o valor for maior que 5.</span><span class="sxs-lookup"><span data-stu-id="5ac73-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="5ac73-149">Como mostra o exemplo a seguir, a exceção gerada quando um valor de 6 é passado para o `GetMultipleAsync` método é observada somente quando a tarefa é esperada.</span><span class="sxs-lookup"><span data-stu-id="5ac73-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="5ac73-150">Assim como com o iterador de método, você pode refatorar o exemplo anterior e colocar o código da operação assíncrona em uma função local.</span><span class="sxs-lookup"><span data-stu-id="5ac73-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="5ac73-151">Como a saída do exemplo a seguir mostra, o <xref:System.ArgumentOutOfRangeException> é lançado assim que o `GetMultiple` método é chamado.</span><span class="sxs-lookup"><span data-stu-id="5ac73-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="5ac73-152">Funções locais vs. expressões lambda</span><span class="sxs-lookup"><span data-stu-id="5ac73-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="5ac73-153">À primeira vista, funções locais e [expressões lambda](../../language-reference/operators/lambda-expressions.md) são muito semelhantes.</span><span class="sxs-lookup"><span data-stu-id="5ac73-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="5ac73-154">Em muitos casos, a escolha entre usar expressões lambda e funções locais é uma questão de estilo e preferência pessoal.</span><span class="sxs-lookup"><span data-stu-id="5ac73-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="5ac73-155">No entanto, há diferenças reais nos casos em que você pode usar uma ou outra, e é importante conhecer essas diferenças.</span><span class="sxs-lookup"><span data-stu-id="5ac73-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="5ac73-156">Examinaremos as diferenças entre a função local e as implementações de expressão lambda do algoritmo fatorial.</span><span class="sxs-lookup"><span data-stu-id="5ac73-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="5ac73-157">Primeiro a versão usando uma função local:</span><span class="sxs-lookup"><span data-stu-id="5ac73-157">First the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="5ac73-158">Compare essa implementação com uma versão que usa expressões lambda:</span><span class="sxs-lookup"><span data-stu-id="5ac73-158">Contrast that implementation with a version that uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

<span data-ttu-id="5ac73-159">As funções locais têm nomes.</span><span class="sxs-lookup"><span data-stu-id="5ac73-159">The local functions have names.</span></span> <span data-ttu-id="5ac73-160">As expressões lambda são métodos anônimos que são atribuídos a variáveis dos tipos `Func` ou `Action`.</span><span class="sxs-lookup"><span data-stu-id="5ac73-160">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="5ac73-161">Quando você declara uma função local, os tipos de argumento e o tipo de retorno fazem parte da declaração da função.</span><span class="sxs-lookup"><span data-stu-id="5ac73-161">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="5ac73-162">Em vez de fazer parte do corpo da expressão lambda, os tipos de argumento e o tipo de retorno são parte da declaração de tipo de variável da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-162">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="5ac73-163">Essas duas diferenças podem resultar em um código mais claro.</span><span class="sxs-lookup"><span data-stu-id="5ac73-163">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="5ac73-164">As funções locais têm diferentes regras para atribuição definida em relação às expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-164">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="5ac73-165">Uma declaração de função local pode ser referenciada em qualquer local do código em que ela esteja no escopo.</span><span class="sxs-lookup"><span data-stu-id="5ac73-165">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="5ac73-166">Uma expressão lambda deve ser atribuída a uma variável de delegado antes de poder ser acessada (ou chamada por meio do delegado que referencia a expressão lambda).</span><span class="sxs-lookup"><span data-stu-id="5ac73-166">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="5ac73-167">Observe que a versão que usa a expressão lambda deve declarar e inicializar a expressão lambda `nthFactorial` antes de defini-la.</span><span class="sxs-lookup"><span data-stu-id="5ac73-167">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="5ac73-168">Não fazer isso resulta em um erro em tempo de compilação para referenciar `nthFactorial` antes de atribuí-lo.</span><span class="sxs-lookup"><span data-stu-id="5ac73-168">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="5ac73-169">Essas diferenças significam que os algoritmos recursivos são mais fáceis de criar usando funções locais.</span><span class="sxs-lookup"><span data-stu-id="5ac73-169">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="5ac73-170">Você pode declarar e definir uma função local que chame a si mesma.</span><span class="sxs-lookup"><span data-stu-id="5ac73-170">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="5ac73-171">As expressões lambda devem ser declaradas e atribuídas a um valor padrão antes que possam ser reatribuídas a um corpo que referencie a mesma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-171">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="5ac73-172">As regras de atribuição definidas também afetam as variáveis que são capturadas pela função local ou pela expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-172">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="5ac73-173">As regras das funções locais e das expressões lambda exigem que as variáveis capturadas sejam definitivamente atribuídas no momento em que a expressão lambda ou a função local é convertida em um delegado.</span><span class="sxs-lookup"><span data-stu-id="5ac73-173">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="5ac73-174">A diferença é que as expressões lambda são convertidas em delegados no momento em que são declaradas.</span><span class="sxs-lookup"><span data-stu-id="5ac73-174">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="5ac73-175">As funções locais são convertidas em delegados somente quando usadas como um delegado.</span><span class="sxs-lookup"><span data-stu-id="5ac73-175">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="5ac73-176">Se você declarar uma função local e só referenciá-la ao chamá-la como um método, ela não será convertida em um delegado.</span><span class="sxs-lookup"><span data-stu-id="5ac73-176">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="5ac73-177">Essa regra permite que você declare uma função local em qualquer local conveniente no respectivo escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="5ac73-177">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="5ac73-178">É comum declarar funções locais ao final do método pai, depois das instruções de retorno.</span><span class="sxs-lookup"><span data-stu-id="5ac73-178">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="5ac73-179">Em terceiro lugar, o compilador pode executar uma análise estática que permite que as funções locais atribuam definitivamente as variáveis capturadas no escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="5ac73-179">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="5ac73-180">Considere este exemplo:</span><span class="sxs-lookup"><span data-stu-id="5ac73-180">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="5ac73-181">O compilador pode determinar que `LocalFunction` definitivamente atribua `y` quando chamada.</span><span class="sxs-lookup"><span data-stu-id="5ac73-181">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="5ac73-182">Como a `LocalFunction` é chamada antes da instrução `return`, `y` é atribuído definitivamente na instrução `return`.</span><span class="sxs-lookup"><span data-stu-id="5ac73-182">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="5ac73-183">Essa análise de exemplo permite a quarta diferença.</span><span class="sxs-lookup"><span data-stu-id="5ac73-183">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="5ac73-184">Dependendo do uso, as funções locais podem evitar as alocações de heap que são sempre necessárias nas expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-184">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="5ac73-185">Se uma função local nunca é convertida em um delegado, e nenhuma das variáveis capturadas pela função local é capturada por outros lambdas ou funções locais que são convertidas em delegados, o compilador pode evitar alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="5ac73-185">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="5ac73-186">Considere este exemplo assíncrono:</span><span class="sxs-lookup"><span data-stu-id="5ac73-186">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="5ac73-187">O fechamento desta expressão lambda contém as variáveis `address`, `index` e `name`.</span><span class="sxs-lookup"><span data-stu-id="5ac73-187">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="5ac73-188">No caso de funções locais, o objeto que implementa o encerramento pode ser um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="5ac73-188">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="5ac73-189">Esse tipo de struct seria passado por referência à função local.</span><span class="sxs-lookup"><span data-stu-id="5ac73-189">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="5ac73-190">Essa diferença na implementação poderia economizar em uma alocação.</span><span class="sxs-lookup"><span data-stu-id="5ac73-190">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="5ac73-191">A instanciação necessária para expressões lambda ocasiona alocações adicionais de memória, tornando-se um fator de desempenho em caminhos de código com tempo crítico.</span><span class="sxs-lookup"><span data-stu-id="5ac73-191">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="5ac73-192">As funções locais não incorrem nessa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="5ac73-192">Local functions do not incur this overhead.</span></span> <span data-ttu-id="5ac73-193">No exemplo acima, a versão das funções locais tem duas alocações menores do que a versão da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-193">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="5ac73-194">A função local equivalente desse método também usa uma classe para o fechamento.</span><span class="sxs-lookup"><span data-stu-id="5ac73-194">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="5ac73-195">O fechamento de uma função local ser implementado como um `class` ou como um `struct`, trata-se de um detalhe de implementação.</span><span class="sxs-lookup"><span data-stu-id="5ac73-195">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="5ac73-196">Uma função local pode usar um `struct`, enquanto uma lambda sempre usará um `class`.</span><span class="sxs-lookup"><span data-stu-id="5ac73-196">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

<span data-ttu-id="5ac73-197">Uma vantagem final não demonstrada neste exemplo é que as funções locais podem ser implementadas como iteradores, usando a sintaxe `yield return` para produzir uma sequência de valores.</span><span class="sxs-lookup"><span data-stu-id="5ac73-197">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="5ac73-198">A instrução `yield return` não é permitida em expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5ac73-198">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="5ac73-199">Embora as funções locais possam parecer redundantes para expressões lambda, elas realmente têm finalidades e usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="5ac73-199">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="5ac73-200">As funções locais são mais eficientes para quando você deseja escrever uma função que é chamada apenas do contexto de outro método.</span><span class="sxs-lookup"><span data-stu-id="5ac73-200">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="5ac73-201">Veja também</span><span class="sxs-lookup"><span data-stu-id="5ac73-201">See also</span></span>

- [<span data-ttu-id="5ac73-202">Métodos</span><span class="sxs-lookup"><span data-stu-id="5ac73-202">Methods</span></span>](methods.md)
