---
title: Funções locais – Guia de Programação em C#
description: As funções locais em C# são métodos privados que são aninhados em outro membro e podem ser chamados de seus membros que os contêm.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 75accda2e40443073274ece4d8964c13a0945dad
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332894"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="87d59-103">Funções locais (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="87d59-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="87d59-104">Começando com o C# 7.0, o C# é compatível com *funções locais*.</span><span class="sxs-lookup"><span data-stu-id="87d59-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="87d59-105">Funções locais são métodos privados de um tipo que estão aninhados em outro membro.</span><span class="sxs-lookup"><span data-stu-id="87d59-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="87d59-106">Eles só podem ser chamados do membro que os contém.</span><span class="sxs-lookup"><span data-stu-id="87d59-106">They can only be called from their containing member.</span></span> <span data-ttu-id="87d59-107">Funções locais podem ser declaradas em e chamadas de:</span><span class="sxs-lookup"><span data-stu-id="87d59-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="87d59-108">Métodos, especialmente os métodos iteradores e os métodos assíncronos</span><span class="sxs-lookup"><span data-stu-id="87d59-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="87d59-109">Construtores</span><span class="sxs-lookup"><span data-stu-id="87d59-109">Constructors</span></span>
- <span data-ttu-id="87d59-110">Acessadores de propriedades</span><span class="sxs-lookup"><span data-stu-id="87d59-110">Property accessors</span></span>
- <span data-ttu-id="87d59-111">Acessadores de eventos</span><span class="sxs-lookup"><span data-stu-id="87d59-111">Event accessors</span></span>
- <span data-ttu-id="87d59-112">Métodos anônimos</span><span class="sxs-lookup"><span data-stu-id="87d59-112">Anonymous methods</span></span>
- <span data-ttu-id="87d59-113">Expressões lambda</span><span class="sxs-lookup"><span data-stu-id="87d59-113">Lambda expressions</span></span>
- <span data-ttu-id="87d59-114">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="87d59-114">Finalizers</span></span>
- <span data-ttu-id="87d59-115">Outras funções locais</span><span class="sxs-lookup"><span data-stu-id="87d59-115">Other local functions</span></span>

<span data-ttu-id="87d59-116">No entanto, as funções locais não podem ser declaradas dentro de um membro apto para expressão.</span><span class="sxs-lookup"><span data-stu-id="87d59-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="87d59-117">Em alguns casos, você pode usar uma expressão lambda para implementar uma funcionalidade que também tem suporte por uma função local.</span><span class="sxs-lookup"><span data-stu-id="87d59-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="87d59-118">Para obter uma comparação, consulte [funções locais versus expressões lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="87d59-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="87d59-119">Funções locais tornam a intenção do seu código clara.</span><span class="sxs-lookup"><span data-stu-id="87d59-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="87d59-120">Qualquer pessoa que ler seu código poderá ver que o método não pode ser chamado, exceto pelo método que o contém.</span><span class="sxs-lookup"><span data-stu-id="87d59-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="87d59-121">Para projetos de equipe, elas também impossibilitam que outro desenvolvedor chame o método por engano diretamente de qualquer outro lugar na classe ou no struct.</span><span class="sxs-lookup"><span data-stu-id="87d59-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="87d59-122">Sintaxe de função local</span><span class="sxs-lookup"><span data-stu-id="87d59-122">Local function syntax</span></span>

<span data-ttu-id="87d59-123">Uma função local é definida como um método aninhado dentro de um membro recipiente.</span><span class="sxs-lookup"><span data-stu-id="87d59-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="87d59-124">Sua definição tem a seguinte sintaxe:</span><span class="sxs-lookup"><span data-stu-id="87d59-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="87d59-125">Você pode usar os seguintes modificadores com uma função local:</span><span class="sxs-lookup"><span data-stu-id="87d59-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="87d59-126">[`static`](../../language-reference/keywords/static.md) (em C# 8,0 e posterior).</span><span class="sxs-lookup"><span data-stu-id="87d59-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="87d59-127">Uma função local estática não pode capturar variáveis locais ou estado de instância.</span><span class="sxs-lookup"><span data-stu-id="87d59-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="87d59-128">[`extern`](../../language-reference/keywords/extern.md) (em C# 9,0 e posterior).</span><span class="sxs-lookup"><span data-stu-id="87d59-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="87d59-129">Uma função local externa deve ser `static` .</span><span class="sxs-lookup"><span data-stu-id="87d59-129">An external local function must be `static`.</span></span>

<span data-ttu-id="87d59-130">Todas as variáveis locais que são definidas no membro recipiente, incluindo seus parâmetros de método, são acessíveis em uma função local não estática.</span><span class="sxs-lookup"><span data-stu-id="87d59-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="87d59-131">Ao contrário de uma definição de método, uma definição de função local não pode incluir o modificador de acesso de membro.</span><span class="sxs-lookup"><span data-stu-id="87d59-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="87d59-132">Já que todas as funções locais são privadas, incluir um modificador de acesso como a palavra-chave `private` gera o erro do compilador CS0106, "O modificador 'private' não é válido para este item".</span><span class="sxs-lookup"><span data-stu-id="87d59-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="87d59-133">O exemplo a seguir define uma função local chamada `AppendPathSeparator` que é privada para um método chamado `GetText`:</span><span class="sxs-lookup"><span data-stu-id="87d59-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="87d59-134">A partir do C# 9,0, você pode aplicar atributos a uma função local, seus parâmetros e parâmetros de tipo, como mostra o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="87d59-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="87d59-135">O exemplo anterior usa um [atributo especial](../../language-reference/attributes/nullable-analysis.md) para auxiliar o compilador em análise estática em um contexto anulável.</span><span class="sxs-lookup"><span data-stu-id="87d59-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="87d59-136">Funções locais e exceções</span><span class="sxs-lookup"><span data-stu-id="87d59-136">Local functions and exceptions</span></span>

<span data-ttu-id="87d59-137">Um dos recursos úteis de funções locais é que elas podem permitir que exceções sejam apresentadas imediatamente.</span><span class="sxs-lookup"><span data-stu-id="87d59-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="87d59-138">Para iteradores de método, as exceções são apresentadas somente quando a sequência retornada é enumerada e não quando o iterador é recuperado.</span><span class="sxs-lookup"><span data-stu-id="87d59-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="87d59-139">Para métodos assíncronos, as exceções geradas em um método assíncrono são observadas quando a tarefa retornada é esperada.</span><span class="sxs-lookup"><span data-stu-id="87d59-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="87d59-140">O exemplo a seguir define um `OddSequence` método que enumera números ímpares em um intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="87d59-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="87d59-141">Já que ele passa um número maior que 100 para o método enumerador `OddSequence`, o método gera uma <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="87d59-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="87d59-142">Assim como demonstrado pela saída do exemplo, a exceção é apresentada somente quando você itera os números e não quando você recupera o enumerador.</span><span class="sxs-lookup"><span data-stu-id="87d59-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="87d59-143">Se você colocar a lógica do iterador em uma função local, as exceções de validação de argumento serão geradas quando você recuperar o enumerador, como mostra o exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="87d59-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="87d59-144">Você pode usar funções locais de maneira semelhante com operações assíncronas.</span><span class="sxs-lookup"><span data-stu-id="87d59-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="87d59-145">Exceções geradas em uma superfície de método assíncrono quando a tarefa correspondente é esperada.</span><span class="sxs-lookup"><span data-stu-id="87d59-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="87d59-146">Funções locais permitem que seu código falhe no modo rápido e permitem que a exceção seja gerada e observada de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="87d59-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="87d59-147">O exemplo a seguir usa um método assíncrono chamado `GetMultipleAsync` para pausar para um número especificado de segundos e retornar um valor que é um múltiplo aleatório desse número de segundos.</span><span class="sxs-lookup"><span data-stu-id="87d59-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="87d59-148">O atraso máximo é de 5 segundos; um <xref:System.ArgumentOutOfRangeException> resulta em se o valor for maior que 5.</span><span class="sxs-lookup"><span data-stu-id="87d59-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="87d59-149">Como mostra o exemplo a seguir, a exceção gerada quando um valor de 6 é passado para o `GetMultipleAsync` método é observada somente quando a tarefa é esperada.</span><span class="sxs-lookup"><span data-stu-id="87d59-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="87d59-150">Assim como com o iterador de método, você pode refatorar o exemplo anterior e colocar o código da operação assíncrona em uma função local.</span><span class="sxs-lookup"><span data-stu-id="87d59-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="87d59-151">Como a saída do exemplo a seguir mostra, o <xref:System.ArgumentOutOfRangeException> é lançado assim que o `GetMultiple` método é chamado.</span><span class="sxs-lookup"><span data-stu-id="87d59-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="87d59-152">Funções locais vs. expressões lambda</span><span class="sxs-lookup"><span data-stu-id="87d59-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="87d59-153">À primeira vista, funções locais e [expressões lambda](../../language-reference/operators/lambda-expressions.md) são muito semelhantes.</span><span class="sxs-lookup"><span data-stu-id="87d59-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="87d59-154">Em muitos casos, a escolha entre usar expressões lambda e funções locais é uma questão de estilo e preferência pessoal.</span><span class="sxs-lookup"><span data-stu-id="87d59-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="87d59-155">No entanto, há diferenças reais nos casos em que você pode usar uma ou outra, e é importante conhecer essas diferenças.</span><span class="sxs-lookup"><span data-stu-id="87d59-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="87d59-156">Examinaremos as diferenças entre a função local e as implementações de expressão lambda do algoritmo fatorial.</span><span class="sxs-lookup"><span data-stu-id="87d59-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="87d59-157">Veja a versão usando uma função local:</span><span class="sxs-lookup"><span data-stu-id="87d59-157">Here's the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="87d59-158">Esta versão usa expressões lambda:</span><span class="sxs-lookup"><span data-stu-id="87d59-158">This version uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a><span data-ttu-id="87d59-159">Nomenclatura</span><span class="sxs-lookup"><span data-stu-id="87d59-159">Naming</span></span>

<span data-ttu-id="87d59-160">As funções locais são explicitamente nomeadas como métodos.</span><span class="sxs-lookup"><span data-stu-id="87d59-160">Local functions are explicitly named like methods.</span></span> <span data-ttu-id="87d59-161">As expressões lambda são métodos anônimos e precisam ser atribuídas a variáveis de um `delegate` tipo, normalmente `Action` ou `Func` tipos.</span><span class="sxs-lookup"><span data-stu-id="87d59-161">Lambda expressions are anonymous methods and need to be assigned to variables of a `delegate` type, typically either `Action` or `Func` types.</span></span> <span data-ttu-id="87d59-162">Quando você declara uma função local, o processo é como escrever um método normal; Você declara um tipo de retorno e uma assinatura de função.</span><span class="sxs-lookup"><span data-stu-id="87d59-162">When you declare a local function, the process is like writing a normal method; you declare a return type and a function signature.</span></span>

### <a name="function-signatures-and-lambda-expression-types"></a><span data-ttu-id="87d59-163">Assinaturas de função e tipos de expressão lambda</span><span class="sxs-lookup"><span data-stu-id="87d59-163">Function signatures and lambda expression types</span></span>

<span data-ttu-id="87d59-164">Expressões lambda dependem do tipo da `Action` / `Func` variável que são atribuídas para determinar o argumento e os tipos de retorno.</span><span class="sxs-lookup"><span data-stu-id="87d59-164">Lambda expressions rely on the type of the `Action`/`Func` variable that they're assigned to determine the argument and return types.</span></span> <span data-ttu-id="87d59-165">Em funções locais, como a sintaxe é muito parecida com a escrita de um método normal, tipos de argumento e tipo de retorno já fazem parte da declaração da função.</span><span class="sxs-lookup"><span data-stu-id="87d59-165">In local functions, since the syntax is much like writing a normal method, argument types and return type are already part of the function declaration.</span></span>

### <a name="definite-assignment"></a><span data-ttu-id="87d59-166">Atribuição definida</span><span class="sxs-lookup"><span data-stu-id="87d59-166">Definite assignment</span></span>

<span data-ttu-id="87d59-167">Expressões lambda são objetos declarados e atribuídos em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="87d59-167">Lambda expressions are objects that are declared and assigned at runtime.</span></span> <span data-ttu-id="87d59-168">Para que uma expressão lambda seja usada, ela precisa ser definitivamente atribuída: a `Action` / `Func` variável à qual ela será atribuída deve ser declarada e a expressão lambda atribuída a ela.</span><span class="sxs-lookup"><span data-stu-id="87d59-168">In order for a lambda expression to be used, it needs to be definitely assigned: the `Action`/`Func` variable that it will be assigned to must be declared and the lambda expression assigned to it.</span></span> <span data-ttu-id="87d59-169">Observe que `LambdaFactorial` o deve declarar e inicializar a expressão lambda `nthFactorial` antes de defini-la.</span><span class="sxs-lookup"><span data-stu-id="87d59-169">Notice that `LambdaFactorial` must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="87d59-170">Não fazer isso resulta em um erro em tempo de compilação para referenciar `nthFactorial` antes de atribuí-lo.</span><span class="sxs-lookup"><span data-stu-id="87d59-170">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>

<span data-ttu-id="87d59-171">As funções locais são definidas no momento da compilação.</span><span class="sxs-lookup"><span data-stu-id="87d59-171">Local functions are defined at compile time.</span></span> <span data-ttu-id="87d59-172">Como eles não são atribuídos a variáveis, eles podem ser referenciados de qualquer local de código **em que esteja no escopo**; em nosso primeiro exemplo `LocalFunctionFactorial` , poderíamos declarar nossa função local acima ou abaixo da `return` instrução e não disparar nenhum erro de compilador.</span><span class="sxs-lookup"><span data-stu-id="87d59-172">As they're not assigned to variables, they can be referenced from any code location **where it is in scope**; in our first example `LocalFunctionFactorial`, we could declare our local function either above or below the `return` statement and not trigger any compiler errors.</span></span>

<span data-ttu-id="87d59-173">Essas diferenças significam que os algoritmos recursivos são mais fáceis de criar usando funções locais.</span><span class="sxs-lookup"><span data-stu-id="87d59-173">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="87d59-174">Você pode declarar e definir uma função local que chame a si mesma.</span><span class="sxs-lookup"><span data-stu-id="87d59-174">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="87d59-175">As expressões lambda devem ser declaradas e atribuídas a um valor padrão antes que possam ser reatribuídas a um corpo que referencie a mesma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="87d59-175">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

### <a name="implementation-as-a-delegate"></a><span data-ttu-id="87d59-176">Implementação como um delegado</span><span class="sxs-lookup"><span data-stu-id="87d59-176">Implementation as a delegate</span></span>

<span data-ttu-id="87d59-177">As expressões lambda são convertidas em delegados quando são declaradas.</span><span class="sxs-lookup"><span data-stu-id="87d59-177">Lambda expressions are converted to delegates when they're declared.</span></span> <span data-ttu-id="87d59-178">As funções locais são mais flexíveis, pois podem ser escritas como um método tradicional *ou* como um delegado.</span><span class="sxs-lookup"><span data-stu-id="87d59-178">Local functions are more flexible in that they can be written like a traditional method *or* as a delegate.</span></span> <span data-ttu-id="87d59-179">As funções locais só são convertidas em delegados quando ***usadas*** como um delegado.</span><span class="sxs-lookup"><span data-stu-id="87d59-179">Local functions are only converted to delegates when ***used*** as a delegate.</span></span>

<span data-ttu-id="87d59-180">Se você declarar uma função local e só referenciá-la ao chamá-la como um método, ela não será convertida em um delegado.</span><span class="sxs-lookup"><span data-stu-id="87d59-180">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span>

### <a name="variable-capture"></a><span data-ttu-id="87d59-181">Captura de variável</span><span class="sxs-lookup"><span data-stu-id="87d59-181">Variable capture</span></span>

<span data-ttu-id="87d59-182">As regras de [atribuição definitiva](../../../../_csharplang/spec/variables.md#definite-assignment) também afetam qualquer variável capturada pela função local ou expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="87d59-182">The rules of [definite assignment](../../../../_csharplang/spec/variables.md#definite-assignment) also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="87d59-183">O compilador pode executar uma análise estática que permite que as funções locais atribuam definitivamente variáveis capturadas no escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="87d59-183">The compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="87d59-184">Considere este exemplo:</span><span class="sxs-lookup"><span data-stu-id="87d59-184">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="87d59-185">O compilador pode determinar que `LocalFunction` definitivamente atribua `y` quando chamada.</span><span class="sxs-lookup"><span data-stu-id="87d59-185">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="87d59-186">Como a `LocalFunction` é chamada antes da instrução `return`, `y` é atribuído definitivamente na instrução `return`.</span><span class="sxs-lookup"><span data-stu-id="87d59-186">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="87d59-187">Observe que quando uma função local captura variáveis no escopo delimitador, a função local é implementada como um tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="87d59-187">Note that when a local function captures variables in the enclosing scope, the local function is implemented as a delegate type.</span></span>

### <a name="heap-allocations"></a><span data-ttu-id="87d59-188">Alocações de heap</span><span class="sxs-lookup"><span data-stu-id="87d59-188">Heap allocations</span></span>

<span data-ttu-id="87d59-189">Dependendo do uso, as funções locais podem evitar as alocações de heap que são sempre necessárias nas expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="87d59-189">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="87d59-190">Se uma função local nunca for convertida em um delegado, e nenhuma das variáveis capturadas pela função local forem capturadas por outras lambdas ou funções locais que são convertidas em delegados, o compilador poderá evitar alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="87d59-190">If a local function is never converted to a delegate, and none of the variables captured by the local function are captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="87d59-191">Considere este exemplo assíncrono:</span><span class="sxs-lookup"><span data-stu-id="87d59-191">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="87d59-192">O fechamento desta expressão lambda contém as variáveis `address`, `index` e `name`.</span><span class="sxs-lookup"><span data-stu-id="87d59-192">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="87d59-193">No caso de funções locais, o objeto que implementa o encerramento pode ser um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="87d59-193">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="87d59-194">Esse tipo de struct seria passado por referência à função local.</span><span class="sxs-lookup"><span data-stu-id="87d59-194">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="87d59-195">Essa diferença na implementação poderia economizar em uma alocação.</span><span class="sxs-lookup"><span data-stu-id="87d59-195">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="87d59-196">A instanciação necessária para expressões lambda ocasiona alocações adicionais de memória, tornando-se um fator de desempenho em caminhos de código com tempo crítico.</span><span class="sxs-lookup"><span data-stu-id="87d59-196">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="87d59-197">As funções locais não incorrem nessa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="87d59-197">Local functions do not incur this overhead.</span></span> <span data-ttu-id="87d59-198">No exemplo acima, a versão das funções locais tem duas alocações menores do que a versão da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="87d59-198">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="87d59-199">Se você souber que a função local não será convertida em um delegado e nenhuma das variáveis capturadas por ela for capturada por outras lambdas ou funções locais que são convertidas em delegados, você poderá garantir que a função local Evite ser alocada no heap declarando-a como uma `static` função local.</span><span class="sxs-lookup"><span data-stu-id="87d59-199">If you know that your local function won't be converted to a delegate and none of the variables captured by it are captured by other lambdas or local functions that are converted to delegates, you can guarantee that your local function avoids being allocated on the heap by declaring it as a `static` local function.</span></span> <span data-ttu-id="87d59-200">Observe que esse recurso está disponível em C# 8,0 e mais recente.</span><span class="sxs-lookup"><span data-stu-id="87d59-200">Note that this feature is available in C# 8.0 and newer.</span></span>

> [!NOTE]
> <span data-ttu-id="87d59-201">A função local equivalente desse método também usa uma classe para o fechamento.</span><span class="sxs-lookup"><span data-stu-id="87d59-201">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="87d59-202">O fechamento de uma função local ser implementado como um `class` ou como um `struct`, trata-se de um detalhe de implementação.</span><span class="sxs-lookup"><span data-stu-id="87d59-202">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="87d59-203">Uma função local pode usar um `struct`, enquanto uma lambda sempre usará um `class`.</span><span class="sxs-lookup"><span data-stu-id="87d59-203">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a><span data-ttu-id="87d59-204">Uso da `yield` palavra-chave</span><span class="sxs-lookup"><span data-stu-id="87d59-204">Usage of the `yield` keyword</span></span>

<span data-ttu-id="87d59-205">Uma vantagem final não demonstrada neste exemplo é que as funções locais podem ser implementadas como iteradores, usando a sintaxe `yield return` para produzir uma sequência de valores.</span><span class="sxs-lookup"><span data-stu-id="87d59-205">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

<span data-ttu-id="87d59-206">A `yield return` instrução não é permitida em expressões lambda, consulte o [erro do compilador CS1621](../../misc/cs1621.md).</span><span class="sxs-lookup"><span data-stu-id="87d59-206">The `yield return` statement is not allowed in lambda expressions, see [compiler error CS1621](../../misc/cs1621.md).</span></span>

<span data-ttu-id="87d59-207">Embora as funções locais possam parecer redundantes para expressões lambda, elas realmente têm finalidades e usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="87d59-207">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="87d59-208">As funções locais são mais eficientes para quando você deseja escrever uma função que é chamada apenas do contexto de outro método.</span><span class="sxs-lookup"><span data-stu-id="87d59-208">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="87d59-209">Consulte também</span><span class="sxs-lookup"><span data-stu-id="87d59-209">See also</span></span>

- [<span data-ttu-id="87d59-210">Métodos</span><span class="sxs-lookup"><span data-stu-id="87d59-210">Methods</span></span>](methods.md)
