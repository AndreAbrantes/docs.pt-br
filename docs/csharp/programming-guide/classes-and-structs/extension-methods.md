---
title: "Métodos de extensão (Guia de Programação em C#)"
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
caps.latest.revision: 35
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: d74c1d0760d4e776c2cf4c7dea1dac060c85a83c
ms.openlocfilehash: 657f9ebfba5d6f49d3a88cb1cf790e4a0134a007
ms.contentlocale: pt-br
ms.lasthandoff: 09/05/2017

---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="0aace-102">Métodos de extensão (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="0aace-102">Extension Methods (C# Programming Guide)</span></span>
<span data-ttu-id="0aace-103">Os métodos de extensão permitem que você "adicione" tipos existentes sem criar um novo tipo derivado, recompilar ou, caso contrário, modificar o tipo original.</span><span class="sxs-lookup"><span data-stu-id="0aace-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="0aace-104">Os métodos de extensão são um tipo especial de método estático, mas são chamados como se fossem métodos de instância no tipo estendido.</span><span class="sxs-lookup"><span data-stu-id="0aace-104">Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="0aace-105">No caso do código cliente gravado em C#, F# e Visual Basic, não há nenhuma diferença aparente entre chamar um método de extensão e os métodos realmente definidos em um tipo.</span><span class="sxs-lookup"><span data-stu-id="0aace-105">For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</span></span>  
  
 <span data-ttu-id="0aace-106">Os métodos de extensão mais comuns são os operadores de consulta padrão [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] que adicionam funcionalidade de consulta aos tipos <xref:System.Collections.IEnumerable?displayProperty=fullName> e <xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName> existentes.</span><span class="sxs-lookup"><span data-stu-id="0aace-106">The most common extension methods are the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=fullName> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName> types.</span></span> <span data-ttu-id="0aace-107">Para usar os operadores de consulta padrão, traga-os primeiro ao escopo com uma diretiva `using System.Linq`.</span><span class="sxs-lookup"><span data-stu-id="0aace-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="0aace-108">Em seguida, qualquer tipo que implemente <xref:System.Collections.Generic.IEnumerable%601> parece ter métodos de instância como <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="0aace-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="0aace-109">Você pode exibir esses métodos adicionais no preenchimento de declaração do IntelliSense ao digitar "ponto" após uma instância de um tipo <xref:System.Collections.Generic.IEnumerable%601> como <xref:System.Collections.Generic.List%601> ou <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="0aace-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="0aace-110">O exemplo a seguir mostra como chamar o método de consulta padrão `OrderBy` em qualquer matriz de inteiros.</span><span class="sxs-lookup"><span data-stu-id="0aace-110">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="0aace-111">A expressão entre parênteses é uma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="0aace-111">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="0aace-112">Vários operadores de consulta padrão obtêm expressões lambda como parâmetros, mas isso não é um requisito para métodos de extensão.</span><span class="sxs-lookup"><span data-stu-id="0aace-112">Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods.</span></span> <span data-ttu-id="0aace-113">Para obter mais informações, consulte [Expressões Lambda](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="0aace-113">For more information, see [Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
 <span data-ttu-id="0aace-114">[!code-cs[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="0aace-114">[!code-cs[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]</span></span>  
  
 <span data-ttu-id="0aace-115">Os métodos de extensão são definidos como estáticos, mas são chamados usando a sintaxe do método de instância.</span><span class="sxs-lookup"><span data-stu-id="0aace-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="0aace-116">Seu primeiro parâmetro especifica em que tipo o método opera e o parâmetro é precedido pelo modificador [this](../../../csharp/language-reference/keywords/this.md).</span><span class="sxs-lookup"><span data-stu-id="0aace-116">Their first parameter specifies which type the method operates on, and the parameter is preceded by the [this](../../../csharp/language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="0aace-117">Os métodos de extensão só estarão no escopo quando você importar explicitamente o namespace para seu código-fonte com uma diretiva `using`.</span><span class="sxs-lookup"><span data-stu-id="0aace-117">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>  
  
 <span data-ttu-id="0aace-118">O exemplo a seguir mostra um método de extensão definido para a classe <xref:System.String?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="0aace-118">The following example shows an extension method defined for the <xref:System.String?displayProperty=fullName> class.</span></span> <span data-ttu-id="0aace-119">Observe que isso é definido em uma classe estática não aninhada e não genérica:</span><span class="sxs-lookup"><span data-stu-id="0aace-119">Note that it is defined inside a non-nested, non-generic static class:</span></span>  
  
 <span data-ttu-id="0aace-120">[!code-cs[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="0aace-120">[!code-cs[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]</span></span>  
  
 <span data-ttu-id="0aace-121">O método de extensão `WordCount` pode ser colocado no escopo com esta diretiva `using`:</span><span class="sxs-lookup"><span data-stu-id="0aace-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>  
  
```  
using ExtensionMethods;  
```  
  
 <span data-ttu-id="0aace-122">E pode ser chamado a partir de um aplicativo usando esta sintaxe:</span><span class="sxs-lookup"><span data-stu-id="0aace-122">And it can be called from an application by using this syntax:</span></span>  
  
```  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 <span data-ttu-id="0aace-123">Em seu código, você chama o método de extensão com sintaxe de método de instância.</span><span class="sxs-lookup"><span data-stu-id="0aace-123">In your code you invoke the extension method with instance method syntax.</span></span> <span data-ttu-id="0aace-124">No entanto, a linguagem intermediária (IL) gerada pelo compilador converte seu código em uma chamada no método estático.</span><span class="sxs-lookup"><span data-stu-id="0aace-124">However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="0aace-125">Portanto, o princípio de encapsulamento ainda não está realmente sendo violado.</span><span class="sxs-lookup"><span data-stu-id="0aace-125">Therefore, the principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="0aace-126">De fato, os métodos de extensão não podem acessar variáveis particulares no tipo que estão estendendo.</span><span class="sxs-lookup"><span data-stu-id="0aace-126">In fact, extension methods cannot access private variables in the type they are extending.</span></span>  
  
 <span data-ttu-id="0aace-127">Para obter mais informações, consulte [Como implementar e chamar um método de extensão personalizado](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="0aace-127">For more information, see [How to: Implement and Call a Custom  Extension Method](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span></span>  
  
 <span data-ttu-id="0aace-128">Em geral, provavelmente você chamará métodos de extensão com muito mais frequência do que implementará os seus próprios.</span><span class="sxs-lookup"><span data-stu-id="0aace-128">In general, you will probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="0aace-129">Como os métodos de extensão são chamados com a sintaxe do método de instância, nenhum conhecimento especial é necessário para usá-los no código do cliente.</span><span class="sxs-lookup"><span data-stu-id="0aace-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="0aace-130">Para habilitar métodos de extensão para um tipo específico, apenas adicione uma diretiva `using` para o namespace no qual os métodos estão definidos.</span><span class="sxs-lookup"><span data-stu-id="0aace-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="0aace-131">Por exemplo, para usar os operadores de consulta padrão, adicione esta diretiva `using` ao seu código:</span><span class="sxs-lookup"><span data-stu-id="0aace-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>  
  
```  
using System.Linq;  
```  
  
 <span data-ttu-id="0aace-132">(Também pode ser necessário adicionar uma referência a System.Core.dll.) Você observará que os operadores de consulta padrão agora são exibidos no IntelliSense como métodos adicionais disponíveis para a maioria dos tipos <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="0aace-132">(You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0aace-133">Embora os operadores de consulta padrão não sejam exibidos no IntelliSense para <xref:System.String>, eles ainda estarão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="0aace-133">Although standard query operators do not appear in IntelliSense for <xref:System.String>, they are still available.</span></span>  
  
## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="0aace-134">Associando Métodos de Extensão no Momento da Compilação</span><span class="sxs-lookup"><span data-stu-id="0aace-134">Binding Extension Methods at Compile Time</span></span>  
 <span data-ttu-id="0aace-135">Você pode usar métodos de extensão para estender uma classe ou interface, mas não os substituir.</span><span class="sxs-lookup"><span data-stu-id="0aace-135">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="0aace-136">Um método de extensão com o mesmo nome e assinatura que um método de interface ou classe nunca será chamado.</span><span class="sxs-lookup"><span data-stu-id="0aace-136">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="0aace-137">No tempo de compilação, os métodos de extensão sempre têm menos prioridade que os métodos de instância definidos no próprio tipo.</span><span class="sxs-lookup"><span data-stu-id="0aace-137">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="0aace-138">Em outras palavras, se um tipo possuir um método chamado `Process(int i)` e se você tiver um método de extensão com a mesma assinatura, o compilador sempre se associará ao método de instância.</span><span class="sxs-lookup"><span data-stu-id="0aace-138">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="0aace-139">Quando o compilador encontra uma invocação de método, primeiro ele procura uma correspondência nos métodos de instância do tipo.</span><span class="sxs-lookup"><span data-stu-id="0aace-139">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="0aace-140">Se nenhuma correspondência for encontrada, ele irá procurar todos os métodos de extensão definidos para o tipo e associará o primeiro método de extensão que encontrar.</span><span class="sxs-lookup"><span data-stu-id="0aace-140">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="0aace-141">O exemplo a seguir demonstra como o compilador determina a qual método de extensão ou método de instância associar.</span><span class="sxs-lookup"><span data-stu-id="0aace-141">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>  
  
## <a name="example"></a><span data-ttu-id="0aace-142">Exemplo</span><span class="sxs-lookup"><span data-stu-id="0aace-142">Example</span></span>  
 <span data-ttu-id="0aace-143">O exemplo a seguir demonstra as regras que o compilador C# segue ao determinar se deve associar uma chamada de método a um método de instância no tipo ou a um método de extensão.</span><span class="sxs-lookup"><span data-stu-id="0aace-143">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="0aace-144">A classe estática `Extensions` contém métodos de extensão definidos para qualquer tipo que implementa `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="0aace-144">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="0aace-145">As classes `A`, `B` e `C` implementam a interface.</span><span class="sxs-lookup"><span data-stu-id="0aace-145">Classes `A`, `B`, and `C` all implement the interface.</span></span>  
  
 <span data-ttu-id="0aace-146">O método de extensão `MethodB` nunca é chamado porque seu nome e assinatura são exatamente iguais aos métodos já implementados pelas classes.</span><span class="sxs-lookup"><span data-stu-id="0aace-146">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>  
  
 <span data-ttu-id="0aace-147">Quando o compilador não consegue localizar um método de instância com uma assinatura compatível, ele se associa a um método de extensão correspondente se houver.</span><span class="sxs-lookup"><span data-stu-id="0aace-147">When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>  
  
 <span data-ttu-id="0aace-148">[!code-cs[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="0aace-148">[!code-cs[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]</span></span>  
  
## <a name="general-guidelines"></a><span data-ttu-id="0aace-149">Diretrizes gerais</span><span class="sxs-lookup"><span data-stu-id="0aace-149">General Guidelines</span></span>  
 <span data-ttu-id="0aace-150">Em geral, recomendamos que você implemente métodos de extensão com parcimônia e somente quando for necessário.</span><span class="sxs-lookup"><span data-stu-id="0aace-150">In general, we recommend that you implement extension methods sparingly and only when you have to.</span></span> <span data-ttu-id="0aace-151">Sempre que possível, o código do cliente que deve estender um tipo existente deve fazer isso ao criar um novo tipo derivado do tipo existente.</span><span class="sxs-lookup"><span data-stu-id="0aace-151">Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type.</span></span> <span data-ttu-id="0aace-152">Para obter mais informações, consulte [Herança](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="0aace-152">For more information, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
 <span data-ttu-id="0aace-153">Ao usar um método de extensão para estender um tipo cujo código-fonte você não pode alterar, há o risco de uma alteração na implementação do tipo fazer com que o método de extensão interrompa.</span><span class="sxs-lookup"><span data-stu-id="0aace-153">When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>  
  
 <span data-ttu-id="0aace-154">Se você implementar métodos de extensão para um determinado tipo, lembre-se das seguintes considerações:</span><span class="sxs-lookup"><span data-stu-id="0aace-154">If you do implement extension methods for a given type, remember the following points:</span></span>  
  
-   <span data-ttu-id="0aace-155">Um método de extensão nunca será chamado se possuir a mesma assinatura que um método definido no tipo.</span><span class="sxs-lookup"><span data-stu-id="0aace-155">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>  
  
-   <span data-ttu-id="0aace-156">Os métodos de extensão são trazidos para o escopo no nível do namespace.</span><span class="sxs-lookup"><span data-stu-id="0aace-156">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="0aace-157">Por exemplo, se você tiver várias classes estáticas que contenham métodos de extensão em um único namespace chamado `Extensions`, todos eles serão trazidos para o escopo pela diretiva `using Extensions;`.</span><span class="sxs-lookup"><span data-stu-id="0aace-157">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they will all be brought into scope by the `using Extensions;` directive.</span></span>  
  
 <span data-ttu-id="0aace-158">Para uma biblioteca de classes que você implemente, não use métodos de extensão para evitar incrementar o número de versão de um assembly.</span><span class="sxs-lookup"><span data-stu-id="0aace-158">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="0aace-159">Se desejar adicionar funcionalidade significativa a uma biblioteca da qual você possua o código-fonte, siga as diretrizes padrão do .NET Framework para controle de versão do assembly.</span><span class="sxs-lookup"><span data-stu-id="0aace-159">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="0aace-160">Para obter mais informações, consulte [Controle de versão do assembly](https://msdn.microsoft.com/library/51ket42z).</span><span class="sxs-lookup"><span data-stu-id="0aace-160">For more information, see [Assembly Versioning](https://msdn.microsoft.com/library/51ket42z).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0aace-161">Consulte também</span><span class="sxs-lookup"><span data-stu-id="0aace-161">See Also</span></span>  
 <span data-ttu-id="0aace-162">[Guia de Programação em C#](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="0aace-162">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="0aace-163">[Exemplos de programação paralela (inclui vários métodos de extensão de exemplo)](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364) </span><span class="sxs-lookup"><span data-stu-id="0aace-163">[Parallel Programming Samples (these include many example extension methods)](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364) </span></span>  
 <span data-ttu-id="0aace-164">[Expressões Lambda](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) </span><span class="sxs-lookup"><span data-stu-id="0aace-164">[Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) </span></span>  
 <span data-ttu-id="0aace-165">[Visão Geral de Operadores de Consulta Padrão](http://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2) </span><span class="sxs-lookup"><span data-stu-id="0aace-165">[Standard Query Operators Overview](http://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2) </span></span>  
 <span data-ttu-id="0aace-166">[Regras de conversão para parâmetros de instância e seu impacto](http://go.microsoft.com/fwlink/?LinkId=112385) </span><span class="sxs-lookup"><span data-stu-id="0aace-166">[Conversion rules for Instance parameters and their impact](http://go.microsoft.com/fwlink/?LinkId=112385) </span></span>  
 <span data-ttu-id="0aace-167">[Interoperabilidade de métodos de extensão entre linguagens](http://go.microsoft.com/fwlink/?LinkId=112386) </span><span class="sxs-lookup"><span data-stu-id="0aace-167">[Extension methods Interoperability between languages](http://go.microsoft.com/fwlink/?LinkId=112386) </span></span>  
 <span data-ttu-id="0aace-168">[Métodos de extensão e representantes via currying](http://go.microsoft.com/fwlink/?LinkId=112387) </span><span class="sxs-lookup"><span data-stu-id="0aace-168">[Extension methods and Curried Delegates](http://go.microsoft.com/fwlink/?LinkId=112387) </span></span>  
 [<span data-ttu-id="0aace-169">Associação do método de extensão e relatório de erros</span><span class="sxs-lookup"><span data-stu-id="0aace-169">Extension method Binding and Error reporting</span></span>](http://go.microsoft.com/fwlink/?LinkId=112388)

