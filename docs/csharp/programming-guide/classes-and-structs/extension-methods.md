---
title: Métodos de extensão – Guia de Programação em C#
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: fc816123134995b753beda0a6f281133d6ddd691
ms.sourcegitcommit: 1cb64b53eb1f253e6a3f53ca9510ef0be1fd06fe
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/29/2020
ms.locfileid: "82506812"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="23210-102">Métodos de extensão (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="23210-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="23210-103">Os métodos de extensão permitem que você "adicione" tipos existentes sem criar um novo tipo derivado, recompilar ou, caso contrário, modificar o tipo original.</span><span class="sxs-lookup"><span data-stu-id="23210-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="23210-104">Os métodos de extensão são métodos estáticos, mas são chamados como se fossem métodos de instância no tipo estendido.</span><span class="sxs-lookup"><span data-stu-id="23210-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="23210-105">Para o código de cliente escrito em C#, F # e Visual Basic, não há nenhuma diferença aparente entre chamar um método de extensão e os métodos definidos em um tipo.</span><span class="sxs-lookup"><span data-stu-id="23210-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="23210-106">Os métodos de extensão mais comuns são os operadores de consulta padrão do LINQ que adicionam a <xref:System.Collections.IEnumerable?displayProperty=nameWithType> funcionalidade <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> de consulta aos tipos existentes e.</span><span class="sxs-lookup"><span data-stu-id="23210-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="23210-107">Para usar os operadores de consulta padrão, traga-os primeiro ao escopo com uma diretiva `using System.Linq`.</span><span class="sxs-lookup"><span data-stu-id="23210-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="23210-108">Em seguida, qualquer tipo que implemente <xref:System.Collections.Generic.IEnumerable%601> parece ter métodos de instância como <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="23210-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="23210-109">Você pode exibir esses métodos adicionais no preenchimento de declaração do IntelliSense ao digitar "ponto" após uma instância de um tipo <xref:System.Collections.Generic.IEnumerable%601> como <xref:System.Collections.Generic.List%601> ou <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="23210-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="23210-110">Exemplo de OrderBy</span><span class="sxs-lookup"><span data-stu-id="23210-110">OrderBy Example</span></span>

<span data-ttu-id="23210-111">O exemplo a seguir mostra como chamar o método de consulta padrão `OrderBy` em qualquer matriz de inteiros.</span><span class="sxs-lookup"><span data-stu-id="23210-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="23210-112">A expressão entre parênteses é uma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="23210-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="23210-113">Muitos operadores de consulta padrão usam expressões lambda como parâmetros, mas isso não é um requisito para métodos de extensão.</span><span class="sxs-lookup"><span data-stu-id="23210-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="23210-114">Para obter mais informações, consulte [Expressões Lambda](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="23210-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="23210-115">Os métodos de extensão são definidos como estáticos, mas são chamados usando a sintaxe do método de instância.</span><span class="sxs-lookup"><span data-stu-id="23210-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="23210-116">Seu primeiro parâmetro especifica em qual tipo o método opera.</span><span class="sxs-lookup"><span data-stu-id="23210-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="23210-117">O parâmetro é precedido por [este](../../language-reference/keywords/this.md) modificador.</span><span class="sxs-lookup"><span data-stu-id="23210-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="23210-118">Os métodos de extensão só estarão no escopo quando você importar explicitamente o namespace para seu código-fonte com uma diretiva `using`.</span><span class="sxs-lookup"><span data-stu-id="23210-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="23210-119">O exemplo a seguir mostra um método de extensão definido para a classe <xref:System.String?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="23210-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="23210-120">Ele é definido dentro de uma classe estática não aninhada não genérica:</span><span class="sxs-lookup"><span data-stu-id="23210-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="23210-121">O método de extensão `WordCount` pode ser colocado no escopo com esta diretiva `using`:</span><span class="sxs-lookup"><span data-stu-id="23210-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="23210-122">E pode ser chamado a partir de um aplicativo usando esta sintaxe:</span><span class="sxs-lookup"><span data-stu-id="23210-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="23210-123">Você invoca o método de extensão em seu código com a sintaxe do método de instância.</span><span class="sxs-lookup"><span data-stu-id="23210-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="23210-124">A IL (linguagem intermediária) gerada pelo compilador converte seu código em uma chamada no método estático.</span><span class="sxs-lookup"><span data-stu-id="23210-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="23210-125">O princípio do encapsulamento não está realmente violado.</span><span class="sxs-lookup"><span data-stu-id="23210-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="23210-126">Os métodos de extensão não podem acessar variáveis privadas no tipo que estão sendo estendidas.</span><span class="sxs-lookup"><span data-stu-id="23210-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="23210-127">Para obter mais informações, consulte [como implementar e chamar um método de extensão personalizado](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="23210-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="23210-128">Em geral, você provavelmente estará chamando métodos de extensão muito mais frequentemente do que implementar seus próprios.</span><span class="sxs-lookup"><span data-stu-id="23210-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="23210-129">Como os métodos de extensão são chamados com a sintaxe do método de instância, nenhum conhecimento especial é necessário para usá-los no código do cliente.</span><span class="sxs-lookup"><span data-stu-id="23210-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="23210-130">Para habilitar métodos de extensão para um tipo específico, apenas adicione uma diretiva `using` para o namespace no qual os métodos estão definidos.</span><span class="sxs-lookup"><span data-stu-id="23210-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="23210-131">Por exemplo, para usar os operadores de consulta padrão, adicione esta diretiva `using` ao seu código:</span><span class="sxs-lookup"><span data-stu-id="23210-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="23210-132">(Você também pode precisar adicionar uma referência a System. Core. dll.) Você observará que os operadores de consulta padrão agora aparecem no IntelliSense como métodos adicionais disponíveis para <xref:System.Collections.Generic.IEnumerable%601> a maioria dos tipos.</span><span class="sxs-lookup"><span data-stu-id="23210-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="23210-133">Associando Métodos de Extensão no Momento da Compilação</span><span class="sxs-lookup"><span data-stu-id="23210-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="23210-134">Você pode usar métodos de extensão para estender uma classe ou interface, mas não os substituir.</span><span class="sxs-lookup"><span data-stu-id="23210-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="23210-135">Um método de extensão com o mesmo nome e assinatura que um método de interface ou classe nunca será chamado.</span><span class="sxs-lookup"><span data-stu-id="23210-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="23210-136">No tempo de compilação, os métodos de extensão sempre têm menos prioridade que os métodos de instância definidos no próprio tipo.</span><span class="sxs-lookup"><span data-stu-id="23210-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="23210-137">Em outras palavras, se um tipo possuir um método chamado `Process(int i)` e se você tiver um método de extensão com a mesma assinatura, o compilador sempre se associará ao método de instância.</span><span class="sxs-lookup"><span data-stu-id="23210-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="23210-138">Quando o compilador encontra uma invocação de método, primeiro ele procura uma correspondência nos métodos de instância do tipo.</span><span class="sxs-lookup"><span data-stu-id="23210-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="23210-139">Se nenhuma correspondência for encontrada, ele irá procurar todos os métodos de extensão definidos para o tipo e associará o primeiro método de extensão que encontrar.</span><span class="sxs-lookup"><span data-stu-id="23210-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="23210-140">O exemplo a seguir demonstra como o compilador determina a qual método de extensão ou método de instância associar.</span><span class="sxs-lookup"><span data-stu-id="23210-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="23210-141">Exemplo</span><span class="sxs-lookup"><span data-stu-id="23210-141">Example</span></span>

<span data-ttu-id="23210-142">O exemplo a seguir demonstra as regras que o compilador C# segue ao determinar se deve associar uma chamada de método a um método de instância no tipo ou a um método de extensão.</span><span class="sxs-lookup"><span data-stu-id="23210-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="23210-143">A classe estática `Extensions` contém métodos de extensão definidos para qualquer tipo que implementa `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="23210-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="23210-144">As classes `A`, `B` e `C` implementam a interface.</span><span class="sxs-lookup"><span data-stu-id="23210-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="23210-145">O método de extensão `MethodB` nunca é chamado porque seu nome e assinatura são exatamente iguais aos métodos já implementados pelas classes.</span><span class="sxs-lookup"><span data-stu-id="23210-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="23210-146">Quando o compilador não consegue localizar um método de instância com uma assinatura correspondente, ele se associará a um método de extensão correspondente, se houver.</span><span class="sxs-lookup"><span data-stu-id="23210-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="23210-147">Padrões de uso comuns</span><span class="sxs-lookup"><span data-stu-id="23210-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="23210-148">Funcionalidade de coleção</span><span class="sxs-lookup"><span data-stu-id="23210-148">Collection Functionality</span></span>

<span data-ttu-id="23210-149">No passado, era comum criar "classes de coleção" que implementavam a <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface para um determinado tipo e uma funcionalidade contida que atuava em coleções desse tipo.</span><span class="sxs-lookup"><span data-stu-id="23210-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="23210-150">Embora não haja nada de errado ao criar esse tipo de objeto de coleção, a mesma funcionalidade pode ser obtida usando uma extensão no <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="23210-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="23210-151">As extensões têm a vantagem de permitir que a funcionalidade seja chamada de qualquer coleção, como <xref:System.Array?displayProperty=nameWithType> uma <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> ou implementada <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> nesse tipo.</span><span class="sxs-lookup"><span data-stu-id="23210-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="23210-152">Um exemplo disso é usar uma matriz de Int32, que pode ser encontrada [anteriormente neste artigo](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="23210-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="23210-153">Funcionalidade específica de camada</span><span class="sxs-lookup"><span data-stu-id="23210-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="23210-154">Ao usar uma arquitetura de cebola ou outro design de aplicativo em camadas, é comum ter um conjunto de entidades de domínio ou Transferência de Dados objetos que podem ser usados para se comunicar entre os limites do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="23210-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="23210-155">Esses objetos geralmente não contêm nenhuma funcionalidade ou apenas funcionalidade mínima que se aplica a todas as camadas do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="23210-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="23210-156">Os métodos de extensão podem ser usados para adicionar funcionalidade específica a cada camada de aplicativo sem carregar o objeto com métodos não necessários ou desejados em outras camadas.</span><span class="sxs-lookup"><span data-stu-id="23210-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="23210-157">Estendendo tipos predefinidos</span><span class="sxs-lookup"><span data-stu-id="23210-157">Extending Predefined Types</span></span>

<span data-ttu-id="23210-158">Em vez de criar novos objetos quando a funcionalidade reutilizável precisa ser criada, muitas vezes podemos estender um tipo existente, como um .NET Framework ou um tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="23210-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type such as a .NET Framework or CLR type.</span></span> <span data-ttu-id="23210-159">Por exemplo, se não usarmos métodos de extensão, podemos criar uma `Engine` classe or `Query` para fazer o trabalho de executar uma consulta em um SQL Server que pode ser chamado de vários locais em nosso código.</span><span class="sxs-lookup"><span data-stu-id="23210-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="23210-160">No entanto, podemos estender <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> a classe usando métodos de extensão para executar essa consulta em qualquer lugar em que tenhamos uma conexão com um SQL Server.</span><span class="sxs-lookup"><span data-stu-id="23210-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="23210-161">Outros exemplos <xref:System.String?displayProperty=nameWithType> podem ser adicionar funcionalidade comum à classe, estender os recursos de processamento de dados dos objetos <xref:System.IO.File?displayProperty=nameWithType> e <xref:System.IO.Stream?displayProperty=nameWithType> e <xref:System.Exception?displayProperty=nameWithType> objetos para a funcionalidade de tratamento de erros específica.</span><span class="sxs-lookup"><span data-stu-id="23210-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="23210-162">Esses tipos de casos de uso são limitados apenas por sua imaginação e bom sentido.</span><span class="sxs-lookup"><span data-stu-id="23210-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="23210-163">A extensão de tipos predefinidos `struct` pode ser difícil com tipos porque eles são passados por valor para métodos.</span><span class="sxs-lookup"><span data-stu-id="23210-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="23210-164">Isso significa que qualquer alteração na estrutura é feita em uma cópia da estrutura.</span><span class="sxs-lookup"><span data-stu-id="23210-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="23210-165">Essas alterações não serão visíveis depois que o método de extensão sair.</span><span class="sxs-lookup"><span data-stu-id="23210-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="23210-166">A partir do C# 7,2, você pode adicionar `ref` o modificador ao primeiro argumento de um método de extensão.</span><span class="sxs-lookup"><span data-stu-id="23210-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="23210-167">Adicionar o `ref` modificador significa que o primeiro argumento é passado por referência.</span><span class="sxs-lookup"><span data-stu-id="23210-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="23210-168">Isso permite que você escreva métodos de extensão que alteram o estado da estrutura que está sendo estendida.</span><span class="sxs-lookup"><span data-stu-id="23210-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="23210-169">Diretrizes gerais</span><span class="sxs-lookup"><span data-stu-id="23210-169">General Guidelines</span></span>

<span data-ttu-id="23210-170">Embora ainda seja considerado preferível adicionar funcionalidade modificando o código de um objeto ou derivando um novo tipo sempre que for razoável e possível fazer isso, os métodos de extensão se tornaram uma opção crucial para a criação de funcionalidade reutilizável em todo o ecossistema do .NET.</span><span class="sxs-lookup"><span data-stu-id="23210-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="23210-171">Para as ocasiões em que a fonte original não está sob seu controle, quando um objeto derivado é inadequado ou impossível, ou quando a funcionalidade não deve ser exposta além do escopo aplicável, os métodos de extensão são uma opção excelente.</span><span class="sxs-lookup"><span data-stu-id="23210-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="23210-172">Para obter mais informações sobre tipos derivados, consulte [herança](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="23210-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="23210-173">Ao usar um método de extensão para estender um tipo cujo código-fonte você não está controlando, você corre o risco de que uma alteração na implementação do tipo cause a interrupção do método de extensão.</span><span class="sxs-lookup"><span data-stu-id="23210-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="23210-174">Se você implementar métodos de extensão para um determinado tipo, lembre-se das seguintes considerações:</span><span class="sxs-lookup"><span data-stu-id="23210-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="23210-175">Um método de extensão nunca será chamado se possuir a mesma assinatura que um método definido no tipo.</span><span class="sxs-lookup"><span data-stu-id="23210-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="23210-176">Os métodos de extensão são trazidos para o escopo no nível do namespace.</span><span class="sxs-lookup"><span data-stu-id="23210-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="23210-177">Por exemplo, se você tiver várias classes estáticas que contêm métodos de extensão em um único `Extensions`namespace chamado, elas serão colocadas no escopo pela `using Extensions;` diretiva.</span><span class="sxs-lookup"><span data-stu-id="23210-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="23210-178">Para uma biblioteca de classes que você implemente, não use métodos de extensão para evitar incrementar o número de versão de um assembly.</span><span class="sxs-lookup"><span data-stu-id="23210-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="23210-179">Se desejar adicionar funcionalidade significativa a uma biblioteca da qual você possua o código-fonte, siga as diretrizes padrão do .NET Framework para controle de versão do assembly.</span><span class="sxs-lookup"><span data-stu-id="23210-179">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="23210-180">Para obter mais informações, consulte [Controle de versão do assembly](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="23210-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="23210-181">Confira também</span><span class="sxs-lookup"><span data-stu-id="23210-181">See also</span></span>

- [<span data-ttu-id="23210-182">Guia de programação C#</span><span class="sxs-lookup"><span data-stu-id="23210-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="23210-183">Exemplos de programação paralela (incluem vários métodos de extensão de exemplo)</span><span class="sxs-lookup"><span data-stu-id="23210-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="23210-184">Expressões lambda</span><span class="sxs-lookup"><span data-stu-id="23210-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="23210-185">Visão geral de operadores de consulta padrão</span><span class="sxs-lookup"><span data-stu-id="23210-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="23210-186">Regras de conversão para parâmetros de instância e seu impacto</span><span class="sxs-lookup"><span data-stu-id="23210-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="23210-187">Interoperabilidade de métodos de extensão entre linguagens</span><span class="sxs-lookup"><span data-stu-id="23210-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="23210-188">Métodos de extensão e representantes via currying</span><span class="sxs-lookup"><span data-stu-id="23210-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="23210-189">Associação do método de extensão e relatório de erros</span><span class="sxs-lookup"><span data-stu-id="23210-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
