---
title: 'Como: iterar em uma árvore de diretório – Guia de Programação em C#'
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 22d3883470f1435a50ae27f9d633ef566fec2913
ms.sourcegitcommit: bdd930b5df20a45c29483d905526a2a3e4d17c5b
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/11/2018
ms.locfileid: "53237071"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="a9d84-102">Como: iterar em uma árvore de diretório (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="a9d84-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="a9d84-103">A expressão "iterar uma árvore de diretório" significa acessar cada arquivo em cada subdiretório aninhado em uma pasta raiz especificada, em qualquer profundidade.</span><span class="sxs-lookup"><span data-stu-id="a9d84-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="a9d84-104">Você não precisa necessariamente abrir cada arquivo.</span><span class="sxs-lookup"><span data-stu-id="a9d84-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="a9d84-105">Você pode recuperar apenas o nome do arquivo ou subdiretório como um `string`, ou então você pode recuperar informações adicionais na forma de um objeto <xref:System.IO.FileInfo?displayProperty=nameWithType> ou <xref:System.IO.DirectoryInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9d84-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a9d84-106">No Windows, os termos "diretório" e "pasta" são usados de forma intercambiável.</span><span class="sxs-lookup"><span data-stu-id="a9d84-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="a9d84-107">A maior parte do texto da documentação e da interface do usuário usa o termo "pasta", mas a biblioteca de classes [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] usa o termo "diretório".</span><span class="sxs-lookup"><span data-stu-id="a9d84-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="a9d84-108">No caso mais simples, em que você sabe com certeza que tem permissões de acesso a todos os diretórios em uma raiz especificada, é possível usar o sinalizador `System.IO.SearchOption.AllDirectories`.</span><span class="sxs-lookup"><span data-stu-id="a9d84-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="a9d84-109">Esse sinalizador retorna todos os subdiretórios aninhados que correspondem ao padrão especificado.</span><span class="sxs-lookup"><span data-stu-id="a9d84-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="a9d84-110">O exemplo a seguir mostra como usar o sinalizador.</span><span class="sxs-lookup"><span data-stu-id="a9d84-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="a9d84-111">As desvantagem dessa abordagem é que, se qualquer um dos subdiretórios na raiz especificada causar um <xref:System.IO.DirectoryNotFoundException> ou <xref:System.UnauthorizedAccessException>, o método inteiro falhará e não retornará nenhum diretório.</span><span class="sxs-lookup"><span data-stu-id="a9d84-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="a9d84-112">O mesmo é verdadeiro quando você usa o método <xref:System.IO.DirectoryInfo.GetFiles%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9d84-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="a9d84-113">Se precisar manipular essas exceções em subpastas específicas, você precisa percorrer manualmente a árvore de diretório, conforme mostrado nos exemplos a seguir.</span><span class="sxs-lookup"><span data-stu-id="a9d84-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="a9d84-114">Quando percorre manualmente uma árvore de diretório, você pode manipular os subdiretórios primeiro (*passagem da pré-encomenda*) ou os arquivos primeiro (*passagem da pós-encomenda*).</span><span class="sxs-lookup"><span data-stu-id="a9d84-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="a9d84-115">Se executar uma passagem da pré-encomenda, você percorre toda a árvore na pasta atual antes iterar nos arquivos que estão diretamente na própria pasta.</span><span class="sxs-lookup"><span data-stu-id="a9d84-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="a9d84-116">Os exemplos mais adiante neste documento executam a passagem da pós-encomenda, mas você pode facilmente modificá-los para executar a passagem da pré-encomenda.</span><span class="sxs-lookup"><span data-stu-id="a9d84-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="a9d84-117">Outra opção é usar a recursão ou uma passagem baseada em pilha.</span><span class="sxs-lookup"><span data-stu-id="a9d84-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="a9d84-118">Os exemplos mais adiante neste documento mostram as duas abordagens.</span><span class="sxs-lookup"><span data-stu-id="a9d84-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="a9d84-119">Se precisar executar uma série de operações em arquivos e pastas, você pode modularizar esses exemplos refatorando a operação em funções separadas que podem ser invocadas usando um único delegado.</span><span class="sxs-lookup"><span data-stu-id="a9d84-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a9d84-120">Sistemas de arquivos NTFS podem conter *pontos de nova análise* na forma de *pontos de junção*, *links simbólicos* e *links físicos*.</span><span class="sxs-lookup"><span data-stu-id="a9d84-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="a9d84-121">Os métodos do .NET Framework, tais como <xref:System.IO.DirectoryInfo.GetFiles%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A>, não retornarão nenhum subdiretório em um ponto de nova análise.</span><span class="sxs-lookup"><span data-stu-id="a9d84-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="a9d84-122">Esse comportamento protege contra o risco de entrar em um loop infinito quando dois pontos de nova análise fazem referência um ao outro.</span><span class="sxs-lookup"><span data-stu-id="a9d84-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="a9d84-123">De modo geral, você deve ter muito cuidado ao lidar com pontos de nova análise para garantir que arquivos não sejam modificados ou excluídos inadvertidamente.</span><span class="sxs-lookup"><span data-stu-id="a9d84-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="a9d84-124">Se precisar ter um controle preciso sobre pontos de nova análise, use a invocação de plataforma ou código nativo para chamar diretamente os métodos apropriados do sistema de arquivos Win32.</span><span class="sxs-lookup"><span data-stu-id="a9d84-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="a9d84-125">Exemplo</span><span class="sxs-lookup"><span data-stu-id="a9d84-125">Example</span></span>  
 <span data-ttu-id="a9d84-126">O exemplo a seguir mostra como percorrer uma árvore de diretório usando a recursão.</span><span class="sxs-lookup"><span data-stu-id="a9d84-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="a9d84-127">A abordagem recursiva é elegante, mas tem o potencial de causar uma exceção de estouro de pilha se a árvore de diretório for grande e profundamente aninhada.</span><span class="sxs-lookup"><span data-stu-id="a9d84-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="a9d84-128">As exceções específicas que são tratadas, bem como as ações específicas que são executadas em cada arquivo ou pasta, são fornecidas apenas como exemplo.</span><span class="sxs-lookup"><span data-stu-id="a9d84-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="a9d84-129">Você deve modificar este código para atender às suas necessidades específicas.</span><span class="sxs-lookup"><span data-stu-id="a9d84-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="a9d84-130">Consulte os comentários no código para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="a9d84-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## <a name="example"></a><span data-ttu-id="a9d84-131">Exemplo</span><span class="sxs-lookup"><span data-stu-id="a9d84-131">Example</span></span>  
 <span data-ttu-id="a9d84-132">O exemplo a seguir mostra como iterar em arquivos e pastas em uma árvore de diretório sem o uso de recursão.</span><span class="sxs-lookup"><span data-stu-id="a9d84-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="a9d84-133">Essa técnica usa o tipo de coleção genérico <xref:System.Collections.Generic.Stack%601>, que é uma pilha UEPS (último a entrar, primeiro a sair).</span><span class="sxs-lookup"><span data-stu-id="a9d84-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="a9d84-134">As exceções específicas que são tratadas, bem como as ações específicas que são executadas em cada arquivo ou pasta, são fornecidas apenas como exemplo.</span><span class="sxs-lookup"><span data-stu-id="a9d84-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="a9d84-135">Você deve modificar este código para atender às suas necessidades específicas.</span><span class="sxs-lookup"><span data-stu-id="a9d84-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="a9d84-136">Consulte os comentários no código para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="a9d84-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 <span data-ttu-id="a9d84-137">Geralmente, é muito demorado testar cada pasta para determinar se seu aplicativo tem permissão para abri-la.</span><span class="sxs-lookup"><span data-stu-id="a9d84-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="a9d84-138">Portanto, o exemplo de código apenas coloca essa parte da operação em um bloco `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="a9d84-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="a9d84-139">É possível modificar o bloco `catch` para que, quando lhe for negado acesso a uma pasta, você possa tentar elevar as permissões e acessá-la novamente.</span><span class="sxs-lookup"><span data-stu-id="a9d84-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="a9d84-140">Como regra, capture apenas as exceções que você puder manipular sem deixar seu aplicativo em um estado desconhecido.</span><span class="sxs-lookup"><span data-stu-id="a9d84-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="a9d84-141">Se você precisar armazenar o conteúdo de uma árvore de diretório, seja na memória ou no disco, a melhor opção é armazenar apenas a propriedade <xref:System.IO.FileSystemInfo.FullName%2A> (do tipo `string`) para cada arquivo.</span><span class="sxs-lookup"><span data-stu-id="a9d84-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="a9d84-142">Você pode, então, usar essa cadeia de caracteres para criar um novo objeto <xref:System.IO.FileInfo> ou <xref:System.IO.DirectoryInfo>, conforme necessário ou abra qualquer arquivo que precisar de processamento adicional.</span><span class="sxs-lookup"><span data-stu-id="a9d84-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="a9d84-143">Programação robusta</span><span class="sxs-lookup"><span data-stu-id="a9d84-143">Robust Programming</span></span>  
 <span data-ttu-id="a9d84-144">O código de iteração de arquivo robusto deve levar em conta muitas complexidades do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="a9d84-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="a9d84-145">Para saber mais sobre o sistema de arquivos do Windows, confira [Visão geral do NTFS](/windows-server/storage/file-server/ntfs-overview).</span><span class="sxs-lookup"><span data-stu-id="a9d84-145">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a9d84-146">Consulte também</span><span class="sxs-lookup"><span data-stu-id="a9d84-146">See Also</span></span>

- <xref:System.IO>  
- [<span data-ttu-id="a9d84-147">LINQ e Diretórios de Arquivos</span><span class="sxs-lookup"><span data-stu-id="a9d84-147">LINQ and File Directories</span></span>](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)  
- [<span data-ttu-id="a9d84-148">Sistema de arquivos e o Registro (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="a9d84-148">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)
