---
title: "Restrições a parâmetros de tipo (Guia de Programação em C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="853cb-102">Restrições a parâmetros de tipo (Guia de Programação em C#)</span><span class="sxs-lookup"><span data-stu-id="853cb-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="853cb-103">Ao definir uma classe genérica, é possível aplicar restrições às modalidades de tipos que o código de cliente pode utilizar para argumentos de tipo ao criar uma instância da classe.</span><span class="sxs-lookup"><span data-stu-id="853cb-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="853cb-104">Se o código de cliente tentar criar uma instância da classe usando um tipo não permitido por uma restrição, o resultado será um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="853cb-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="853cb-105">Essas restrições são chamadas de restrições.</span><span class="sxs-lookup"><span data-stu-id="853cb-105">These restrictions are called constraints.</span></span> <span data-ttu-id="853cb-106">Restrições são especificadas usando a palavra-chave contextual `where`.</span><span class="sxs-lookup"><span data-stu-id="853cb-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="853cb-107">A tabela a seguir lista os seis tipos de restrições:</span><span class="sxs-lookup"><span data-stu-id="853cb-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="853cb-108">Restrição</span><span class="sxs-lookup"><span data-stu-id="853cb-108">Constraint</span></span>|<span data-ttu-id="853cb-109">Descrição</span><span class="sxs-lookup"><span data-stu-id="853cb-109">Description</span></span>|  
|----------------|-----------------|  
|<span data-ttu-id="853cb-110">em que T: struct</span><span class="sxs-lookup"><span data-stu-id="853cb-110">where T: struct</span></span>|<span data-ttu-id="853cb-111">O argumento de tipo deve ser um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="853cb-111">The type argument must be a value type.</span></span> <span data-ttu-id="853cb-112">Qualquer valor de tipo com exceção de <xref:System.Nullable> pode ser especificado.</span><span class="sxs-lookup"><span data-stu-id="853cb-112">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="853cb-113">Para obter mais informações, consulte [Usando Tipos Anuláveis](../../../csharp/programming-guide/nullable-types/using-nullable-types.md).</span><span class="sxs-lookup"><span data-stu-id="853cb-113">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|<span data-ttu-id="853cb-114">em que T: class</span><span class="sxs-lookup"><span data-stu-id="853cb-114">where T : class</span></span>|<span data-ttu-id="853cb-115">O argumento de tipo deve ser um tipo de referência. Isso também se aplica a qualquer classe, interface, delegado ou tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="853cb-115">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|<span data-ttu-id="853cb-116">em que T: new()</span><span class="sxs-lookup"><span data-stu-id="853cb-116">where T : new()</span></span>|<span data-ttu-id="853cb-117">O argumento de tipo deve ter um construtor público sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="853cb-117">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="853cb-118">Quando usado em conjunto com outras restrições, a restrição `new()` deve ser a última a ser especificada.</span><span class="sxs-lookup"><span data-stu-id="853cb-118">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="853cb-119">em que T: \<base class name></span><span class="sxs-lookup"><span data-stu-id="853cb-119">where T : \<base class name></span></span>|<span data-ttu-id="853cb-120">O argumento de tipo deve ser ou derivar da classe base especificada.</span><span class="sxs-lookup"><span data-stu-id="853cb-120">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="853cb-121">em que T: \<interface name></span><span class="sxs-lookup"><span data-stu-id="853cb-121">where T : \<interface name></span></span>|<span data-ttu-id="853cb-122">O argumento de tipo deve ser ou implementar a interface especificada.</span><span class="sxs-lookup"><span data-stu-id="853cb-122">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="853cb-123">Várias restrições de interface podem ser especificadas.</span><span class="sxs-lookup"><span data-stu-id="853cb-123">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="853cb-124">A interface de restrição também pode ser genérica.</span><span class="sxs-lookup"><span data-stu-id="853cb-124">The constraining interface can also be generic.</span></span>|  
|<span data-ttu-id="853cb-125">em que T: U</span><span class="sxs-lookup"><span data-stu-id="853cb-125">where T : U</span></span>|<span data-ttu-id="853cb-126">O argumento de tipo fornecido para T deve ser ou derivar do argumento fornecido para U.</span><span class="sxs-lookup"><span data-stu-id="853cb-126">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="853cb-127">Por que usar restrições</span><span class="sxs-lookup"><span data-stu-id="853cb-127">Why Use Constraints</span></span>  
 <span data-ttu-id="853cb-128">Caso queira examinar um item em uma lista genérica a fim de determinar se ele é válido ou compará-lo a outro item, o compilador deve ter a garantia de que o operador ou método a ser chamado terá suporte de qualquer argumento de tipo especificado pelo código de cliente.</span><span class="sxs-lookup"><span data-stu-id="853cb-128">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="853cb-129">Essa garantia é obtida pela aplicação de uma ou mais restrições à definição de classe genérica.</span><span class="sxs-lookup"><span data-stu-id="853cb-129">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="853cb-130">Por exemplo, a restrição de classe base informa ao compilador que somente os objetos desse tipo ou derivados desse tipo serão usados como argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="853cb-130">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="853cb-131">Uma vez que o compilador tiver essa garantia, ele poderá permitir que métodos desse tipo sejam chamados na classe genérica.</span><span class="sxs-lookup"><span data-stu-id="853cb-131">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="853cb-132">As restrições são aplicadas usando a palavra-chave contextual `where`.</span><span class="sxs-lookup"><span data-stu-id="853cb-132">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="853cb-133">O exemplo de código a seguir demonstra a funcionalidade que pode ser adicionada à classe `GenericList<T>` (em [Introdução aos Genéricos](../../../csharp/programming-guide/generics/introduction-to-generics.md)) ao aplicar uma restrição de classe base.</span><span class="sxs-lookup"><span data-stu-id="853cb-133">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="853cb-134">A restrição permite que a classe genérica use a propriedade `Employee.Name`, pois há a garantia de que todos os itens do tipo T são um objeto `Employee` ou um objeto que herda de `Employee`.</span><span class="sxs-lookup"><span data-stu-id="853cb-134">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="853cb-135">Várias restrições podem ser aplicadas ao mesmo parâmetro de tipo e as restrições em si podem ser tipos genéricos, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="853cb-135">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="853cb-136">Ao restringir o parâmetro de tipo, aumenta-se a quantidade de operações e chamadas de método permitidas àqueles com suporte do tipo de restrição e de todos os tipos de sua hierarquia de herança.</span><span class="sxs-lookup"><span data-stu-id="853cb-136">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="853cb-137">Portanto, ao projetar classes genéricas ou métodos, caso deseje executar qualquer operação nos membros genéricos (além da simples atribuição) ou chamar métodos sem suporte de `System.Object`, será necessário aplicar restrições ao parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="853cb-137">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="853cb-138">Ao aplicar a restrição `where T : class`, evite os operadores `==` e `!=` no parâmetro de tipo, pois esses operadores testarão somente a identidade de referência e não a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="853cb-138">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="853cb-139">Esse será o caso mesmo se esses operadores forem sobrecarregados em um tipo usado como argumento.</span><span class="sxs-lookup"><span data-stu-id="853cb-139">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="853cb-140">O código a seguir ilustra esse ponto; a saída é false, muito embora a classe <xref:System.String> sobrecarregue o operador `==`.</span><span class="sxs-lookup"><span data-stu-id="853cb-140">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="853cb-141">O motivo para esse comportamento é que, no tempo de compilação, o compilador só sabe que T é um tipo de referência e, portanto, deve usar os operadores padrão válidos para todos os tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="853cb-141">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="853cb-142">Caso seja necessário testar a igualdade de valor, recomenda-se aplicar a restrição `where T : IComparable<T>` e implementar essa interface na classe que será usada para construir a classe genérica.</span><span class="sxs-lookup"><span data-stu-id="853cb-142">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="853cb-143">Restrição de Vários Parâmetros</span><span class="sxs-lookup"><span data-stu-id="853cb-143">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="853cb-144">É possível aplicar restrições a vários parâmetros e várias restrições a um único parâmetro, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="853cb-144">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="853cb-145">Parâmetros de Tipo Não Associado</span><span class="sxs-lookup"><span data-stu-id="853cb-145">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="853cb-146">Os parâmetros de tipo que não têm restrições, como o T na classe pública `SampleClass<T>{}`, são denominados “parâmetros de tipo não associado”.</span><span class="sxs-lookup"><span data-stu-id="853cb-146">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="853cb-147">Os parâmetros de tipo não associado têm as seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="853cb-147">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="853cb-148">Os operadores `!=` e `==` não podem ser usados, pois não há garantia de que o argumento de tipo concreto oferecerá suporte a esses operadores.</span><span class="sxs-lookup"><span data-stu-id="853cb-148">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="853cb-149">Eles podem ser convertidos para e de `System.Object` ou explicitamente convertidos para qualquer tipo de interface.</span><span class="sxs-lookup"><span data-stu-id="853cb-149">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="853cb-150">É possível compará-los a [nulo](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="853cb-150">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="853cb-151">Se um parâmetro não associado for comparado a `null`, a comparação sempre retornará false se o argumento de tipo for um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="853cb-151">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="853cb-152">Parâmetros de Tipo como Restrições</span><span class="sxs-lookup"><span data-stu-id="853cb-152">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="853cb-153">O uso de um parâmetro de tipo genérico como uma restrição será útil quando uma função membro com parâmetro de tipo próprio tiver que restringir esse parâmetro para o parâmetro de tipo do tipo recipiente, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="853cb-153">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="853cb-154">No exemplo anterior, `T` é uma restrição de tipo no contexto do método `Add` e um parâmetro de tipo não associado no contexto da classe `List`.</span><span class="sxs-lookup"><span data-stu-id="853cb-154">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="853cb-155">Parâmetros de tipo também podem ser usados como restrições em definições de classe genérica.</span><span class="sxs-lookup"><span data-stu-id="853cb-155">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="853cb-156">Observe que o parâmetro de tipo deve ser declarado entre colchetes angulares junto com quaisquer outros parâmetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="853cb-156">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="853cb-157">A utilidade dos parâmetros de tipo como restrições com classes genéricas é bastante limitada, pois o compilador não pode presumir nada sobre o parâmetro de tipo, exceto que ele deriva de `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="853cb-157">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="853cb-158">Use parâmetros de tipo como restrições em classes genéricas em cenários nos quais deseja impor uma relação de herança entre dois parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="853cb-158">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="853cb-159">Consulte também</span><span class="sxs-lookup"><span data-stu-id="853cb-159">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="853cb-160">Guia de Programação em C#</span><span class="sxs-lookup"><span data-stu-id="853cb-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="853cb-161">Introdução aos genéricos</span><span class="sxs-lookup"><span data-stu-id="853cb-161">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="853cb-162">Classes genéricas</span><span class="sxs-lookup"><span data-stu-id="853cb-162">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="853cb-163">Restrição new</span><span class="sxs-lookup"><span data-stu-id="853cb-163">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
