---
title: where (restrição de tipo genérico) – Referência de C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 5a56b8058735d3ca786520a82424c79d1975bfc4
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/16/2020
ms.locfileid: "81463006"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="b99b0-102">where (restrição de tipo genérico) (Referência de C#)</span><span class="sxs-lookup"><span data-stu-id="b99b0-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="b99b0-103">A cláusula `where` em uma definição genérica especifica restrições sobre os tipos que são usados como argumentos para parâmetros de tipo em um tipo genérico, método, delegado ou função local.</span><span class="sxs-lookup"><span data-stu-id="b99b0-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="b99b0-104">As restrições podem especificar interfaces, classes básicas ou exigir que um tipo genérico seja um tipo de referência, valor ou não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b99b0-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="b99b0-105">Eles declaram capacidades que o argumento do tipo deve ter.</span><span class="sxs-lookup"><span data-stu-id="b99b0-105">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="b99b0-106">Por exemplo, você pode declarar uma classe genérica, `MyGenericClass`, de modo que o parâmetro de tipo `T` implementa a interface <xref:System.IComparable%601>:</span><span class="sxs-lookup"><span data-stu-id="b99b0-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="b99b0-107">Para obter mais informações sobre a cláusula where em uma expressão de consulta, consulte [Cláusula where](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b99b0-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="b99b0-108">A cláusula `where` também pode incluir uma restrição de classe base.</span><span class="sxs-lookup"><span data-stu-id="b99b0-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="b99b0-109">A restrição da classe base afirma que um tipo a ser usado como um argumento de tipo para esse tipo genérico tem a classe especificada como uma classe base, ou é essa classe base.</span><span class="sxs-lookup"><span data-stu-id="b99b0-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="b99b0-110">Se a restrição de classe base for usada, ela deverá aparecer antes de qualquer outra restrição nesse parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="b99b0-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="b99b0-111">Alguns tipos não têm permissão como uma restrição de classe base: <xref:System.Object>, <xref:System.Array> e <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="b99b0-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="b99b0-112">Antes de C# <xref:System.Enum>7.3, , <xref:System.Delegate>e <xref:System.MulticastDelegate> também foram proibidos como restrições de classe base.</span><span class="sxs-lookup"><span data-stu-id="b99b0-112">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="b99b0-113">O exemplo a seguir mostra os tipos que agora podem ser especificados como classe base:</span><span class="sxs-lookup"><span data-stu-id="b99b0-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#2)]

<span data-ttu-id="b99b0-114">Em um contexto nulo em C# 8.0 e posterior, a nulidade do tipo de classe base é aplicada.</span><span class="sxs-lookup"><span data-stu-id="b99b0-114">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="b99b0-115">Se a classe base não for `Base`anulada (por exemplo), o argumento do tipo deve ser não anulado.</span><span class="sxs-lookup"><span data-stu-id="b99b0-115">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="b99b0-116">Se a classe base for `Base?`anulada (por exemplo), o argumento do tipo pode ser um tipo de referência anulado ou não anulado.</span><span class="sxs-lookup"><span data-stu-id="b99b0-116">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="b99b0-117">O compilador emite um aviso se o argumento do tipo for um tipo de referência anulado quando a classe base não for anulada.</span><span class="sxs-lookup"><span data-stu-id="b99b0-117">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="b99b0-118">A cláusula `where` pode especificar que o tipo é um `class` ou um `struct`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-118">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="b99b0-119">A restrição `struct` elimina a necessidade de especificar uma restrição de classe base de `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-119">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="b99b0-120">O tipo `System.ValueType` não pode ser usado como uma restrição de classe base.</span><span class="sxs-lookup"><span data-stu-id="b99b0-120">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="b99b0-121">O exemplo a seguir mostra as restrições `class` e `struct`:</span><span class="sxs-lookup"><span data-stu-id="b99b0-121">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#3)]

<span data-ttu-id="b99b0-122">Em um contexto nulo em C# 8.0 e posterior, a `class` restrição requer que um tipo seja um tipo de referência não anulado.</span><span class="sxs-lookup"><span data-stu-id="b99b0-122">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="b99b0-123">Para permitir tipos de referência `class?` anulados, use a restrição, que permite tipos de referência nula e não anulado.</span><span class="sxs-lookup"><span data-stu-id="b99b0-123">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="b99b0-124">A `where` cláusula pode `notnull` incluir a restrição.</span><span class="sxs-lookup"><span data-stu-id="b99b0-124">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="b99b0-125">A `notnull` restrição limita o parâmetro de tipo a tipos não anulados.</span><span class="sxs-lookup"><span data-stu-id="b99b0-125">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="b99b0-126">Esse tipo pode ser um [tipo de valor](../builtin-types/value-types.md) ou um tipo de referência não anulado.</span><span class="sxs-lookup"><span data-stu-id="b99b0-126">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="b99b0-127">A `notnull` restrição está disponível a partir de C# [ `nullable enable` ](../../nullable-references.md#nullable-contexts)8.0 para código compilado em um contexto .</span><span class="sxs-lookup"><span data-stu-id="b99b0-127">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="b99b0-128">Ao contrário de outras restrições, se um argumento de tipo violar a `notnull` restrição, o compilador gera um aviso em vez de um erro.</span><span class="sxs-lookup"><span data-stu-id="b99b0-128">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="b99b0-129">Os avisos só `nullable enable` são gerados em um contexto.</span><span class="sxs-lookup"><span data-stu-id="b99b0-129">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b99b0-130">Declarações genéricas `notnull` que incluem a restrição podem ser usadas em um contexto alheio nulo, mas o compilador não impõe a restrição.</span><span class="sxs-lookup"><span data-stu-id="b99b0-130">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="b99b0-131">A cláusula `where` também pode incluir uma restrição `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-131">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="b99b0-132">A restrição `unmanaged` limita o parâmetro de tipo a tipos conhecidos como [tipos não gerenciados](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="b99b0-132">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="b99b0-133">Usando a restrição `unmanaged`, é mais fácil escrever o código de interoperabilidade de nível baixo em C#.</span><span class="sxs-lookup"><span data-stu-id="b99b0-133">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="b99b0-134">Essa restrição habilita rotinas reutilizáveis em todos os tipos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="b99b0-134">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="b99b0-135">A restrição `unmanaged` não pode ser combinada à restrição `class` ou `struct`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-135">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="b99b0-136">A restrição `unmanaged` impõe que o tipo deve ser um `struct`:</span><span class="sxs-lookup"><span data-stu-id="b99b0-136">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#4)]

<span data-ttu-id="b99b0-137">A cláusula `where` também pode incluir uma restrição de construtor, `new()`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-137">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="b99b0-138">Essa restrição torna possível criar uma instância de um parâmetro de tipo usando o operador `new`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-138">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="b99b0-139">A [nova () Restrição](new-constraint.md) permite ao compilador saber que qualquer argumento de tipo fornecido deve ter um construtor sem parâmetros acessível.</span><span class="sxs-lookup"><span data-stu-id="b99b0-139">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="b99b0-140">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="b99b0-140">For example:</span></span>

[!code-csharp[using the new constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#5)]

<span data-ttu-id="b99b0-141">A restrição `new()` aparece por último na cláusula `where`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-141">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="b99b0-142">A restrição `new()` não pode ser combinada às restrições `struct` ou `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="b99b0-142">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="b99b0-143">Todos os tipos que satisfazem as restrições devem ter um construtor sem parâmetros acessível, tornando a restrição `new()` redundante.</span><span class="sxs-lookup"><span data-stu-id="b99b0-143">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="b99b0-144">Com vários parâmetros de tipo, use uma cláusula `where` para cada parâmetro de tipo, por exemplo:</span><span class="sxs-lookup"><span data-stu-id="b99b0-144">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#6)]

<span data-ttu-id="b99b0-145">Você também pode anexar restrições a parâmetros de tipo de métodos genéricos, como mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="b99b0-145">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#7)]

<span data-ttu-id="b99b0-146">Observe que a sintaxe para descrever as restrições de parâmetro de tipo em delegados é a mesma que a dos métodos:</span><span class="sxs-lookup"><span data-stu-id="b99b0-146">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#8)]

<span data-ttu-id="b99b0-147">Para obter informações sobre delegados genéricos, consulte [Delegados genéricos](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="b99b0-147">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="b99b0-148">Para obter detalhes sobre a sintaxe e o uso de restrições, consulte [Restrições a parâmetros de tipo](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="b99b0-148">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="b99b0-149">especificação da linguagem C#</span><span class="sxs-lookup"><span data-stu-id="b99b0-149">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="b99b0-150">Confira também</span><span class="sxs-lookup"><span data-stu-id="b99b0-150">See also</span></span>

- [<span data-ttu-id="b99b0-151">C# Referência</span><span class="sxs-lookup"><span data-stu-id="b99b0-151">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="b99b0-152">C# Guia de Programação</span><span class="sxs-lookup"><span data-stu-id="b99b0-152">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="b99b0-153">Introdução aos genéricos</span><span class="sxs-lookup"><span data-stu-id="b99b0-153">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="b99b0-154">nova Restrição</span><span class="sxs-lookup"><span data-stu-id="b99b0-154">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="b99b0-155">Restrições a parâmetros de tipo</span><span class="sxs-lookup"><span data-stu-id="b99b0-155">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
