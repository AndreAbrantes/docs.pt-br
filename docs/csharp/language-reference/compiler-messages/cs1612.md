---
title: Erro do Compilador CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: 80813a587f3d518d3cd3f37a3628ea5ea49fbafd
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33217015"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="8670d-102">Erro do Compilador CS1612</span><span class="sxs-lookup"><span data-stu-id="8670d-102">Compiler Error CS1612</span></span>
<span data-ttu-id="8670d-103">Não é possível modificar o valor retornado 'expressão' porque ele não é uma variável</span><span class="sxs-lookup"><span data-stu-id="8670d-103">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="8670d-104">Foi feita uma tentativa de modificar um tipo de valor que é gerado como resultado de uma expressão intermediária, mas não é armazenado em uma variável.</span><span class="sxs-lookup"><span data-stu-id="8670d-104">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="8670d-105">Esse erro pode ocorrer quando você tenta modificar diretamente um struct em uma coleção genérica, como mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="8670d-105">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="8670d-106">Para modificar o struct, primeiro atribua-o a uma variável local, modifique a variável e, em seguida, atribua a variável de volta ao item na coleção.</span><span class="sxs-lookup"><span data-stu-id="8670d-106">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="8670d-107">Esse erro ocorre porque os tipos de valor são copiados na atribuição.</span><span class="sxs-lookup"><span data-stu-id="8670d-107">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="8670d-108">Quando você recupera um tipo de valor de uma propriedade ou de um indexador, você está obtendo uma cópia do objeto e não uma referência ao próprio objeto.</span><span class="sxs-lookup"><span data-stu-id="8670d-108">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="8670d-109">A cópia que é retornada não é armazenada pela propriedade ou indexador porque eles são, na verdade, métodos e não locais de armazenamento (variáveis).</span><span class="sxs-lookup"><span data-stu-id="8670d-109">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="8670d-110">Você deve armazenar a cópia em uma variável que você declara antes de modificá-la.</span><span class="sxs-lookup"><span data-stu-id="8670d-110">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="8670d-111">O erro não ocorre com tipos de referência, pois uma propriedade ou um indexador, nesse caso, retorna uma referência a um objeto existente, que é um local de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="8670d-111">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="8670d-112">Se você estiver definindo a classe ou struct, você poderá resolver esse erro, modificando sua declaração de propriedade para fornecer acesso aos membros de um struct.</span><span class="sxs-lookup"><span data-stu-id="8670d-112">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="8670d-113">Se você estiver escrevendo o código cliente, será possível resolver o erro criando sua própria instância de struct, modificando seus campos e, em seguida, atribuindo todo o struct de volta à propriedade.</span><span class="sxs-lookup"><span data-stu-id="8670d-113">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="8670d-114">Como uma terceira alternativa, você pode alterar seu struct para uma classe.</span><span class="sxs-lookup"><span data-stu-id="8670d-114">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="8670d-115">Exemplo</span><span class="sxs-lookup"><span data-stu-id="8670d-115">Example</span></span>  
 <span data-ttu-id="8670d-116">O erro CS1612 também ocorre quando você tenta acessar o membro de um struct através de uma propriedade em uma classe delimitadora que está retornando todo o struct, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="8670d-116">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;  // CS1612  
    }  
  
    public static void Main()   
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();     
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="8670d-117">Consulte também</span><span class="sxs-lookup"><span data-stu-id="8670d-117">See Also</span></span>  
 [<span data-ttu-id="8670d-118">Estruturas</span><span class="sxs-lookup"><span data-stu-id="8670d-118">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)  
 [<span data-ttu-id="8670d-119">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="8670d-119">Value Types</span></span>](../../../csharp/language-reference/keywords/value-types.md)  
 [<span data-ttu-id="8670d-120">Tipos de referência</span><span class="sxs-lookup"><span data-stu-id="8670d-120">Reference Types</span></span>](../../../csharp/language-reference/keywords/reference-types.md)
