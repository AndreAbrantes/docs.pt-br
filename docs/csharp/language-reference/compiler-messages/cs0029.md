---
description: Erro do Compilador CS0029
title: Erro do Compilador CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 4f6a1f9bfc16ebaaecf38645de377b9b29bbbf8e
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465020"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="cc8bc-103">Erro do Compilador CS0029</span><span class="sxs-lookup"><span data-stu-id="cc8bc-103">Compiler Error CS0029</span></span>

<span data-ttu-id="cc8bc-104">Não é possível converter implicitamente o tipo 'type' para 'type'</span><span class="sxs-lookup"><span data-stu-id="cc8bc-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="cc8bc-105">O compilador requer uma conversão explícita.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="cc8bc-106">Por exemplo, talvez seja necessário converter um valor r para ser do mesmo tipo de valor l.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="cc8bc-107">De outro modo, é necessário fornecer rotinas de conversão para dar suporte a determinadas sobrecargas de operador.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="cc8bc-108">As conversões devem ocorrer ao atribuir uma variável de um tipo a uma variável de um tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="cc8bc-109">Ao atribuir entre variáveis de tipos diferentes, o compilador deve converter o tipo ao lado direito do operador de atribuição para o tipo ao lado esquerdo do operador de atribuição.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="cc8bc-110">Use os códigos a seguir:</span><span class="sxs-lookup"><span data-stu-id="cc8bc-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="cc8bc-111">`i = lng;` faz uma atribuição, mas os tipos de dados das variáveis dos lados esquerdo e direito do operador de atribuição não são correspondentes.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="cc8bc-112">Antes de fazer a atribuição, o compilador está convertendo implicitamente a variável `lng` , que é do tipo Long, em um int. Isso é implícito porque nenhum código instruiu explicitamente o compilador para executar essa conversão.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="cc8bc-113">O problema com esse código é que isso é considerado uma conversão de estreitamento e o compilador não permite conversões de estreitamento implícitas porque pode haver uma perda de dados.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="cc8bc-114">Uma conversão de estreitamento existirá ao converter para um tipo de dados que ocupa menos espaço de armazenamento na memória do que o tipo de dados que estão sendo convertidos.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="cc8bc-115">Por exemplo, converter um long para um int seria considerado uma conversão de estreitamento.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="cc8bc-116">Um long ocupa 8 bytes de memória, enquanto um int ocupa 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="cc8bc-117">Para saber como a perda de dados pode ocorrer, considere o seguinte exemplo:</span><span class="sxs-lookup"><span data-stu-id="cc8bc-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="cc8bc-118">Agora, a variável `lng` contém um valor que não pode ser armazenado na variável `i`, porque ele é muito grande.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="cc8bc-119">Se convertêssemos esse valor para um tipo int, perderíamos alguns de nossos dados e o valor convertido não seria o mesmo de antes da conversão.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="cc8bc-120">Uma conversão de expansão seria o oposto de uma conversão de estreitamento.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="cc8bc-121">Nas conversões de expansão, converte-se para um tipo de dados que ocupa mais espaço de armazenamento na memória do que o tipo de dados que estão sendo convertidos.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="cc8bc-122">Aqui está um exemplo de uma conversão de expansão:</span><span class="sxs-lookup"><span data-stu-id="cc8bc-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="cc8bc-123">Observe a diferença entre este exemplo de código e o primeiro.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="cc8bc-124">Dessa vez, a variável `lng` está à esquerda do operador de atribuição, assim, ela será o destino da atribuição.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="cc8bc-125">Antes de realizar a atribuição, o compilador deve converter implicitamente a variável `i`, que é do tipo int, para o tipo long.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="cc8bc-126">Essa é uma conversão de expansão, pois a conversão é de um tipo que ocupa 4 bytes de memória (um int) para um tipo que ocupa 8 bytes de memória (um long).</span><span class="sxs-lookup"><span data-stu-id="cc8bc-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="cc8bc-127">Conversões de expansão implícitas são permitidas porque não há nenhuma perda de dados.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="cc8bc-128">Qualquer valor que pode ser armazenado em um int também pode ser armazenado em um long.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="cc8bc-129">Sabemos que conversões de estreitamento implícitas não são permitidas, então, para que seja possível compilar esse código, é necessário converter explicitamente o tipo de dados.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="cc8bc-130">Conversões explícitas são feitas usando a conversão.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="cc8bc-131">“Conversão” é o termo usado no C# para descrever a conversão de um tipo de dados para outro.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="cc8bc-132">Para obter o código a ser compilado, seria necessário usar a sintaxe a seguir:</span><span class="sxs-lookup"><span data-stu-id="cc8bc-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="cc8bc-133">A terceira linha de código instrui o compilador a converter explicitamente a variável `lng`, que é do tipo long, para int, antes de realizar a atribuição.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="cc8bc-134">Lembre-se de que na conversão de estreitamento há uma possível perda de dados.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="cc8bc-135">Conversões de estreitamento devem ser usadas com cuidado e, mesmo que o código seja compilado, é possível obter resultados inesperados no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="cc8bc-136">Essa discussão foi apenas para tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-136">This discussion has only been for value types.</span></span> <span data-ttu-id="cc8bc-137">Ao trabalhar com tipos de valor, trabalha-se diretamente com os dados armazenados na variável.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="cc8bc-138">No entanto, o .NET também tem tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-138">However, .NET also has reference types.</span></span> <span data-ttu-id="cc8bc-139">Ao trabalhar com tipos de referência, trabalha-se com uma referência a uma variável e não com os dados reais.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="cc8bc-140">Exemplos de tipos de referência podem ser classes, interfaces e matrizes.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="cc8bc-141">Não é possível converter implícita ou explicitamente um tipo de referência para outro a menos que o compilador permita a conversão específica ou os operadores de conversão apropriados sejam implementados.</span><span class="sxs-lookup"><span data-stu-id="cc8bc-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="cc8bc-142">O exemplo a seguir gera o erro CS0029:</span><span class="sxs-lookup"><span data-stu-id="cc8bc-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="cc8bc-143">Veja também</span><span class="sxs-lookup"><span data-stu-id="cc8bc-143">See also</span></span>

- [<span data-ttu-id="cc8bc-144">Operadores de conversões definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="cc8bc-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
