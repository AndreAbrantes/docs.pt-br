---
title: Métodos – Guia de C#
description: Visão geral dos métodos, parâmetros de método e valores retornados de método
ms.technology: csharp-fundamentals
ms.date: 05/21/2018
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: d5ca96ab3a07b85fa525dd06c975f8e3221c82e8
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223662"
---
# <a name="methods-in-c"></a><span data-ttu-id="7a1d9-103">Métodos em (C#)</span><span class="sxs-lookup"><span data-stu-id="7a1d9-103">Methods in (C#)</span></span>

<span data-ttu-id="7a1d9-104">Um método é um bloco de código que contém uma série de instruções.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-104">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="7a1d9-105">Um programa faz com que as instruções sejam executadas chamando o método e especificando os argumentos de método necessários.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-105">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="7a1d9-106">No C#, todas as instruções executadas são realizadas no contexto de um método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-106">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="7a1d9-107">O método `Main` é o ponto de entrada para todos os aplicativos C# e é chamado pelo CLR (Common Language Runtime) quando o programa é iniciado.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-107">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="7a1d9-108">Este tópico aborda os métodos nomeados.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-108">This topic discusses named methods.</span></span> <span data-ttu-id="7a1d9-109">Para obter informações sobre funções anônimas, consulte [Funções anônimas](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-109">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<a name="signatures"></a>

## <a name="method-signatures"></a><span data-ttu-id="7a1d9-110">Assinaturas de método</span><span class="sxs-lookup"><span data-stu-id="7a1d9-110">Method signatures</span></span>

<span data-ttu-id="7a1d9-111">Os métodos são declarados em uma `class` ou `struct` especificando:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-111">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="7a1d9-112">Um nível de acesso opcional, como `public` ou `private`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-112">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="7a1d9-113">O padrão é `private`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-113">The default is `private`.</span></span>
- <span data-ttu-id="7a1d9-114">Modificadores opcionais como `abstract` ou `sealed`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-114">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="7a1d9-115">O valor retornado ou `void` se o método não tiver nenhum.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-115">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="7a1d9-116">O nome do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-116">The method name.</span></span>
- <span data-ttu-id="7a1d9-117">Quaisquer parâmetros de método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-117">Any method parameters.</span></span> <span data-ttu-id="7a1d9-118">Os parâmetros de método estão entre parênteses e separados por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-118">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="7a1d9-119">Parênteses vazios indicam que o método não requer parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-119">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="7a1d9-120">Essas partes juntas formam a assinatura do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-120">These parts together form the method signature.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7a1d9-121">Um tipo de retorno de um método não faz parte da assinatura do método para fins de sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-121">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="7a1d9-122">No entanto, ele faz parte da assinatura do método ao determinar a compatibilidade entre um delegado e o método para o qual ele aponta.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-122">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="7a1d9-123">O exemplo a seguir define uma classe chamada `Motorcycle` que contém cinco métodos:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-123">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="7a1d9-124">Observe que a classe `Motorcycle` inclui um método sobrecarregado, `Drive`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-124">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="7a1d9-125">Dois métodos têm o mesmo nome, mas devem ser diferenciados por seus tipos de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-125">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>

## <a name="method-invocation"></a><span data-ttu-id="7a1d9-126">Invocação de método</span><span class="sxs-lookup"><span data-stu-id="7a1d9-126">Method invocation</span></span>

<span data-ttu-id="7a1d9-127">Os métodos podem ser de *instância* ou *estáticos*.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-127">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="7a1d9-128">Invocar um método de instância requer que você crie uma instância de um objeto e chame o método nesse objeto. Um método de instância opera nessa instância e seus dados.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-128">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="7a1d9-129">Você invoca um método estático referenciando o nome do tipo ao qual o método pertence; os métodos estáticos não operam nos dados da instância.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-129">You invoke a static method by referencing the name of the type to which the method belongs; static methods do not operate on instance data.</span></span> <span data-ttu-id="7a1d9-130">Tentar chamar um método estático por meio de uma instância do objeto gera um erro do compilador.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-130">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="7a1d9-131">Chamar um método é como acessar um campo.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-131">Calling a method is like accessing a field.</span></span> <span data-ttu-id="7a1d9-132">Após o nome do objeto (se você estiver chamando um método de instância) ou o nome do tipo (se você estiver chamando um método `static`), adicione um ponto, o nome do método e parênteses.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-132">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="7a1d9-133">Os argumentos são listados dentro dos parênteses e são separados por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-133">Arguments are listed within the parentheses, and are separated by commas.</span></span>

<span data-ttu-id="7a1d9-134">A definição do método especifica os nomes e tipos de quaisquer parâmetros obrigatórios.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-134">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="7a1d9-135">Quando um chamador invoca o método, ele fornece valores concretos, chamados argumentos, para cada parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-135">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="7a1d9-136">Os argumentos devem ser compatíveis com o tipo de parâmetro, mas o nome do argumento, se for usado no código de chamada, não precisa ser o mesmo que o parâmetro denominado definido no método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-136">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="7a1d9-137">No exemplo a seguir, o método `Square` inclui um único parâmetro do tipo `int` chamado *i*.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-137">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="7a1d9-138">A primeira chamada do método passa para o método `Square` uma variável do tipo `int` chamada *num*, a segunda, uma constante numérica e a terceira, uma expressão.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-138">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="7a1d9-139">A forma mais comum de invocação de método usa argumentos posicionais, ela fornece os argumentos na mesma ordem que os parâmetros de método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-139">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="7a1d9-140">Os métodos da classe `Motorcycle`, podem, portanto, ser chamados como no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-140">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="7a1d9-141">A chamada para o método `Drive`, por exemplo, inclui dois argumentos que correspondem aos dois parâmetros na sintaxe do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-141">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="7a1d9-142">O primeiro se torna o valor do parâmetro `miles`, o segundo o valor do parâmetro `speed`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-142">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="7a1d9-143">Você também pode usar *argumentos nomeados* em vez de argumentos posicionais ao invocar um método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-143">You can also used *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="7a1d9-144">Ao usar argumentos nomeados, você especifica o nome do parâmetro seguido por dois pontos (":") e o argumento.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-144">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="7a1d9-145">Os argumentos do método podem aparecer em qualquer ordem, desde que todos os argumentos necessários estejam presentes.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-145">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="7a1d9-146">O exemplo a seguir usa argumentos nomeados para invocar o método `TestMotorcycle.Drive`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-146">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="7a1d9-147">Neste exemplo, os argumentos nomeados são passados na ordem oposta da lista de parâmetros do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-147">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="7a1d9-148">Você pode invocar um método usando argumentos posicionais e argumentos nomeados.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-148">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="7a1d9-149">No entanto, os argumentos posicionais só podem seguir os argumentos nomeados quando os argumentos nomeados estão nas posições corretas.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-149">However, positional arguments can only follow named arguments when the named arguments are in the correct positions.</span></span> <span data-ttu-id="7a1d9-150">O exemplo a seguir invoca o método `TestMotorcycle.Drive` do exemplo anterior usando um argumento posicional e um argumento nomeado.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-150">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

<a name="inherited"></a>

## <a name="inherited-and-overridden-methods"></a><span data-ttu-id="7a1d9-151">Métodos herdados e substituídos</span><span class="sxs-lookup"><span data-stu-id="7a1d9-151">Inherited and overridden methods</span></span>

<span data-ttu-id="7a1d9-152">Além dos membros que são definidos explicitamente em um tipo, um tipo herda membros definidos em suas classes base.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-152">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="7a1d9-153">Como todos os tipos no sistema de tipos gerenciado são herdados direta ou indiretamente da classe <xref:System.Object>, todos os tipos herdam seus membros, como <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType> e <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-153">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="7a1d9-154">O exemplo a seguir define uma classe `Person`, instancia dois objetos `Person` e chama o método `Person.Equals` para determinar se os dois objetos são iguais.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-154">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="7a1d9-155">O método `Equals`, no entanto, não é definido na classe `Person`, ele é herdado do <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-155">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="7a1d9-156">Tipos podem substituir membros herdados usando a palavra-chave `override` e fornecendo uma implementação para o método substituído.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-156">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="7a1d9-157">A assinatura do método precisa ser igual à do método substituído.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-157">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="7a1d9-158">O exemplo a seguir é semelhante ao anterior, exceto que ele substitui o método <xref:System.Object.Equals(System.Object)>.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-158">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="7a1d9-159">(Ele também substitui o método <xref:System.Object.GetHashCode>, uma vez que os dois métodos destinam-se a fornecer resultados consistentes.)</span><span class="sxs-lookup"><span data-stu-id="7a1d9-159">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>

## <a name="passing-parameters"></a><span data-ttu-id="7a1d9-160">Passando parâmetros</span><span class="sxs-lookup"><span data-stu-id="7a1d9-160">Passing parameters</span></span>

<span data-ttu-id="7a1d9-161">Os tipos no C# são *tipos de valor* ou *tipos de referência*.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-161">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="7a1d9-162">Para obter uma lista de tipos de valor internos, consulte [tipos](./tour-of-csharp/types.md).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-162">For a list of built-in value types, see [Types](./tour-of-csharp/types.md).</span></span> <span data-ttu-id="7a1d9-163">Por padrão, os tipos de referência e tipos de valor são passados para um método por valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-163">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>

### <a name="passing-parameters-by-value"></a><span data-ttu-id="7a1d9-164">Passando parâmetros por valor</span><span class="sxs-lookup"><span data-stu-id="7a1d9-164">Passing parameters by value</span></span>

<span data-ttu-id="7a1d9-165">Quando um tipo de valor é passado para um método por valor, uma cópia do objeto, em vez do próprio objeto, é passada para o método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-165">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="7a1d9-166">Portanto, as alterações no objeto do método chamado não têm efeito no objeto original quando o controle retorna ao chamador.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-166">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="7a1d9-167">O exemplo a seguir passa um tipo de valor para um método por valor e o método chamado tenta alterar o valor do tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-167">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="7a1d9-168">Ele define uma variável do tipo `int`, que é um tipo de valor, inicializa o valor para 20 e o passa para um método chamado `ModifyValue` que altera o valor da variável para 30.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-168">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="7a1d9-169">No entanto, quando o método retorna, o valor da variável permanece inalterado.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-169">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="7a1d9-170">Quando um objeto do tipo de referência é passado para um método por valor, uma referência ao objeto é passada por valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-170">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="7a1d9-171">Ou seja, o método recebe não o objeto em si, mas um argumento que indica o local do objeto.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-171">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="7a1d9-172">Se você alterar um membro do objeto usando essa referência, a alteração será refletida no objeto quando o controle retornar para o método de chamada.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-172">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="7a1d9-173">No entanto, substituir o objeto passado para o método não tem efeito no objeto original quando o controle retorna para o chamador.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-173">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="7a1d9-174">O exemplo a seguir define uma classe (que é um tipo de referência) chamada `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-174">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="7a1d9-175">Ele cria uma instância de um objeto `SampleRefType`, atribui 44 ao seu campo `value` e passa o objeto para o método `ModifyObject`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-175">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="7a1d9-176">Este exemplo faz essencialmente a mesma coisa que o exemplo anterior, ele passa um argumento por valor para um método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-176">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="7a1d9-177">Mas como um tipo de referência é usado, o resultado é diferente.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-177">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="7a1d9-178">A modificação feita em `ModifyObject` para o campo `obj.value` também muda o campo `value` do argumento, `rt`, no método `Main` para 33, como a saída do exemplo mostra.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-178">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>

### <a name="passing-parameters-by-reference"></a><span data-ttu-id="7a1d9-179">Passando parâmetros por referência</span><span class="sxs-lookup"><span data-stu-id="7a1d9-179">Passing parameters by reference</span></span>

<span data-ttu-id="7a1d9-180">Você passa um parâmetro por referência quando deseja alterar o valor de um argumento em um método e deseja refletir essa alteração quando o controle retorna para o método de chamada.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-180">You pass a parameter by reference when you want to change the value of an argument in a method and want to reflect that change when control returns to the calling method.</span></span> <span data-ttu-id="7a1d9-181">Para passar um parâmetro por referência, use a [`ref`](language-reference/keywords/ref.md) [`out`](language-reference/keywords/out-parameter-modifier.md) palavra-chave ou.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-181">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="7a1d9-182">Você também pode passar um valor por referência para evitar copiar, mas ainda evitar modificações usando a [`in`](language-reference/keywords/in-parameter-modifier.md) palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-182">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="7a1d9-183">O exemplo a seguir é idêntico ao anterior, exceto que o valor é passado por referência para o método `ModifyValue`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-183">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="7a1d9-184">Quando o valor do parâmetro é modificado no método `ModifyValue`, a alteração no valor é refletida quando o controle retorna ao chamador.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-184">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="7a1d9-185">Um padrão comum que usa parâmetros pela referência envolve a troca os valores das variáveis.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-185">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="7a1d9-186">Você passa duas variáveis para um método por referência e o método troca seus conteúdos.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-186">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="7a1d9-187">O exemplo a seguir troca valores inteiros.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-187">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="7a1d9-188">Passar um parâmetro de tipo de referência permite que você altere o valor da própria referência, em vez de o valor de seus campos ou elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-188">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>

### <a name="parameter-arrays"></a><span data-ttu-id="7a1d9-189">Matrizes de parâmetros</span><span class="sxs-lookup"><span data-stu-id="7a1d9-189">Parameter arrays</span></span>

<span data-ttu-id="7a1d9-190">Às vezes, o requisito de que você especifique o número exato de argumentos para o método é restritivo.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-190">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="7a1d9-191">Usando a palavra-chave `params` para indicar que um parâmetro é uma matriz de parâmetros, você permite que o método seja chamado com um número variável de argumentos.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-191">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="7a1d9-192">O parâmetro marcado com a palavra-chave `params` deve ser um tipo de matriz e ele deve ser o último parâmetro na lista de parâmetros do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-192">The parameter tagged with the `params` keyword must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="7a1d9-193">Um chamador pode invocar o método de uma das quatro maneiras:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-193">A caller can then invoke the method in either of four ways:</span></span>

- <span data-ttu-id="7a1d9-194">Passando uma matriz do tipo apropriado que contém o número de elementos desejado.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-194">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="7a1d9-195">Passando uma lista separada por vírgulas de argumentos individuais do tipo apropriado para o método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-195">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="7a1d9-196">Passando `null` .</span><span class="sxs-lookup"><span data-stu-id="7a1d9-196">By passing `null`.</span></span>
- <span data-ttu-id="7a1d9-197">Não fornecendo um argumento para a matriz de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-197">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="7a1d9-198">O exemplo a seguir define um método chamado `GetVowels` que retorna todas as vogais de uma matriz de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-198">The following example defines a method named `GetVowels` that returns all the vowels from a parameter array.</span></span> <span data-ttu-id="7a1d9-199">O `Main` método ilustra todas as quatro maneiras de invocar o método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-199">The `Main` method illustrates all four ways of invoking the method.</span></span> <span data-ttu-id="7a1d9-200">Os chamadores não precisam fornecer argumentos para parâmetros que incluem o modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-200">Callers are not required to supply any arguments for parameters that include the `params` modifier.</span></span> <span data-ttu-id="7a1d9-201">Nesse caso, o parâmetro é uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-201">In that case, the parameter is an empty array.</span></span>

[!code-csharp[csSnippets.Methods#75](~/samples/snippets/csharp/concepts/methods/params75.cs#75)]

<a name="optional"></a>

## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="7a1d9-202">Parâmetros e argumentos opcionais</span><span class="sxs-lookup"><span data-stu-id="7a1d9-202">Optional parameters and arguments</span></span>

<span data-ttu-id="7a1d9-203">Uma definição de método pode especificar que os parâmetros são obrigatórios ou que são opcionais.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-203">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="7a1d9-204">Por padrão, os parâmetros são obrigatórios.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-204">By default, parameters are required.</span></span> <span data-ttu-id="7a1d9-205">Os parâmetros opcionais são especificados incluindo o valor padrão do parâmetro na definição do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-205">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="7a1d9-206">Quando o método for chamado, se nenhum argumento for fornecido para um parâmetro opcional, o valor padrão será usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-206">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="7a1d9-207">O valor padrão do parâmetro deve ser atribuído por um dos tipos de expressões a seguir:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-207">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="7a1d9-208">Uma constante, como um número ou uma cadeia de caracteres literal.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-208">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="7a1d9-209">Uma expressão da forma `new ValType()`, em que `ValType` é um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-209">An expression of the form `new ValType()`, where `ValType` is a value type.</span></span> <span data-ttu-id="7a1d9-210">Isso invoca o construtor sem parâmetros implícito do tipo de valor, que não é de fato um membro do tipo.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-210">Note that this invokes the value type's implicit parameterless constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="7a1d9-211">Uma expressão da forma `default(ValType)`, em que `ValType` é um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-211">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="7a1d9-212">Se um método inclui parâmetros obrigatórios e opcionais, os parâmetros opcionais são definidos no final da lista de parâmetros, após todos os parâmetros obrigatórios.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-212">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="7a1d9-213">O exemplo a seguir define um método, `ExampleMethod`, que tem um parâmetro obrigatório e dois opcionais.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-213">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="7a1d9-214">Se um método com vários argumentos opcionais for invocado usando argumentos posicionais, o chamador deverá fornecer um argumento para todos os parâmetros opcionais do primeiro ao último para o qual um argumento é fornecido.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-214">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="7a1d9-215">No caso do método `ExampleMethod`, por exemplo, se o chamador fornecer um argumento para o parâmetro `description`, ele deverá fornecer também um para o parâmetro `optionalInt`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-215">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="7a1d9-216">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` é uma chamada de método válida, `opt.ExampleMethod(2, , "Addition of 2 and 0");` gera um erro do compilador de “Argumento ausente”.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-216">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0");` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="7a1d9-217">Se um método for chamado usando argumentos nomeados ou uma combinação de argumentos posicionais e nomeados, o chamador poderá omitir todos os argumentos após o último argumento posicional na chamada do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-217">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="7a1d9-218">A exemplo a seguir chama o método `ExampleMethod` três vezes.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-218">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="7a1d9-219">As duas primeiras chamadas de método usam argumentos posicionais.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-219">The first two method calls use positional arguments.</span></span> <span data-ttu-id="7a1d9-220">O primeiro omite ambos os argumentos opcionais, enquanto o segundo omite o último argumento.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-220">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="7a1d9-221">A terceira chamada de método fornece um argumento posicional para o parâmetro obrigatório, mas usa um argumento nomeado para fornecer um valor para o parâmetro `description` enquanto omite o argumento `optionalInt`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-221">The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="7a1d9-222">O uso de parâmetros opcionais afeta a *resolução de sobrecarga* ou a maneira em que o compilador C# determina qual sobrecarga específica deve ser invocada pela invocada de método, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-222">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="7a1d9-223">Um método, indexador ou construtor é um candidato para a execução se cada um dos parâmetros é opcional ou corresponde, por nome ou posição, a um único argumento na instrução de chamada e esse argumento pode ser convertido para o tipo do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-223">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="7a1d9-224">Se mais de um candidato for encontrado, as regras de resolução de sobrecarga de conversões preferenciais serão aplicadas aos argumentos que são especificados explicitamente.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-224">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="7a1d9-225">Os argumentos omitidos para parâmetros opcionais são ignorados.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-225">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="7a1d9-226">Se dois candidatos são considerados igualmente bons, a preferência vai para um candidato que não tem parâmetros opcionais para os quais argumentos foram omitidos na chamada.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-226">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="7a1d9-227">Esta é uma consequência da preferência geral na resolução de sobrecarga de candidatos que têm menos parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-227">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

<a name="return"></a>

## <a name="return-values"></a><span data-ttu-id="7a1d9-228">Valores retornados</span><span class="sxs-lookup"><span data-stu-id="7a1d9-228">Return values</span></span>

<span data-ttu-id="7a1d9-229">Os métodos podem retornar um valor para o chamador.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-229">Methods can return a value to the caller.</span></span> <span data-ttu-id="7a1d9-230">Se o tipo de retorno (o tipo listado antes do nome do método) não for `void`, o método poderá retornar o valor usando palavra-chave `return`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-230">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="7a1d9-231">Uma instrução com a palavra-chave `return` seguida por uma variável, constante ou expressão que corresponde ao tipo de retorno retornará esse valor para o chamador do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-231">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="7a1d9-232">Métodos com um tipo de retorno não nulo devem usar a palavra-chave `return` para retornar um valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-232">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="7a1d9-233">A palavra-chave `return` também interrompe a execução do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-233">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="7a1d9-234">Se o tipo de retorno for `void`, uma instrução `return` sem um valor ainda será útil para interromper a execução do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-234">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="7a1d9-235">Sem a palavra-chave `return`, a execução do método será interrompida quando chegar ao final do bloco de código.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-235">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="7a1d9-236">Por exemplo, esses dois métodos usam a palavra-chave `return` para retornar inteiros:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-236">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="7a1d9-237">Para usar um valor retornado de um método, o método de chamada pode usar a chamada de método em si em qualquer lugar que um valor do mesmo tipo seria suficiente.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-237">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="7a1d9-238">Você também pode atribuir o valor retornado a uma variável.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-238">You can also assign the return value to a variable.</span></span> <span data-ttu-id="7a1d9-239">Por exemplo, os dois exemplos de código a seguir obtêm a mesma meta:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-239">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="7a1d9-240">Usar uma variável local, nesse caso, `result`, para armazenar um valor é opcional.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-240">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="7a1d9-241">Isso pode ajudar a legibilidade do código ou pode ser necessário se você precisar armazenar o valor original do argumento para todo o escopo do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-241">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="7a1d9-242">Às vezes, você deseja que seu método retorne mais de um único valor.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-242">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="7a1d9-243">A partir do C# 7.0, você pode fazer isso facilmente usando *tipos de tupla* e *literais de tupla*.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-243">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="7a1d9-244">O tipo de tupla define os tipos de dados dos elementos da tupla.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-244">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="7a1d9-245">Os literais de tupla fornecem os valores reais da tupla retornada.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-245">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="7a1d9-246">No exemplo a seguir, `(string, string, string, int)` define o tipo de tupla que é retornado pelo método `GetPersonalInfo`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-246">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="7a1d9-247">A expressão `(per.FirstName, per.MiddleName, per.LastName, per.Age)` é a tupla literal, o método retorna o nome, o nome do meio e o sobrenome, juntamente com a idade, de um objeto `PersonInfo`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-247">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="7a1d9-248">O chamador pode então consumir a tupla retornada com o código semelhante ao seguinte:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-248">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
Console.WriteLine($"{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="7a1d9-249">Os nomes também podem ser atribuídos aos elementos da tupla na definição de tipo de tupla.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-249">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="7a1d9-250">O exemplo a seguir mostra uma versão alternativa do método `GetPersonalInfo` que usa elementos nomeados:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-250">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="7a1d9-251">A chamada anterior para o método `GetPersonInfo` pode ser modificada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-251">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
Console.WriteLine($"{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="7a1d9-252">Se um método passa uma matriz como um argumento e modifica o valor de elementos individuais, o método não precisa retornar a matriz, embora você possa optar por fazer isso para obter um bom estilo ou um fluxo de valores funcional.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-252">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="7a1d9-253">Isso ocorre porque o C# passa todos os tipos de referência por valor e o valor de uma referência de matriz é o ponteiro para a matriz.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-253">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="7a1d9-254">No exemplo a seguir, as alterações no conteúdo da matriz `values` realizados pelo método `DoubleValues` são observáveis por qualquer código que faz referência à matriz.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-254">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

<a name="extension"></a>

## <a name="extension-methods"></a><span data-ttu-id="7a1d9-255">Métodos de extensão</span><span class="sxs-lookup"><span data-stu-id="7a1d9-255">Extension methods</span></span>

<span data-ttu-id="7a1d9-256">Normalmente, há duas maneiras de adicionar um método a um tipo existente:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-256">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="7a1d9-257">Modificar o código-fonte para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-257">Modify the source code for that type.</span></span> <span data-ttu-id="7a1d9-258">Você não pode fazer isso, é claro, se não possui o código-fonte do tipo.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-258">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="7a1d9-259">E isso se torna uma alteração significativa se você também adicionar campos de dados privados para dar suporte ao método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-259">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="7a1d9-260">Definir o novo método em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-260">Define the new method in a derived class.</span></span> <span data-ttu-id="7a1d9-261">Não é possível adicionar um método dessa forma usando a herança para outros tipos, como estruturas e enumerações.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-261">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="7a1d9-262">Isso também não pode ser usado para “adicionar” um método a uma classe selada.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-262">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="7a1d9-263">Os métodos de extensão permitem que você “adicione” um método a um tipo existente sem modificar o tipo em si ou implementar o novo método em um tipo herdado.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-263">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="7a1d9-264">O método de extensão também não precisa residir no mesmo assembly que o tipo que ele estende.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-264">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="7a1d9-265">Você chama um método de extensão como se fosse um membro definido de um tipo.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-265">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="7a1d9-266">Para obter mais informações, consulte [Métodos de extensão](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-266">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>

## <a name="async-methods"></a><span data-ttu-id="7a1d9-267">Métodos assíncronos</span><span class="sxs-lookup"><span data-stu-id="7a1d9-267">Async Methods</span></span>

<span data-ttu-id="7a1d9-268">Usando o recurso async, você pode invocar métodos assíncronos sem usar retornos de chamada explícitos ou dividir manualmente seu código entre vários métodos ou expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-268">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="7a1d9-269">Se marcar um método com o modificador [async](language-reference/keywords/async.md), você poderá usar o operador [await](language-reference/operators/await.md) no método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-269">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/operators/await.md) operator in the method.</span></span> <span data-ttu-id="7a1d9-270">Quando o controle atingir uma expressão `await` no método assíncrono, o controle retornará para o chamador se a tarefa aguardada não estiver concluída e o progresso no método com a palavra-chave `await` será suspenso até a tarefa aguardada ser concluída.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-270">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="7a1d9-271">Quando a tarefa for concluída, a execução poderá ser retomada no método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-271">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="7a1d9-272">Um método assíncrono retorna ao chamador quando encontra o primeiro objeto esperado que ainda não está concluído ou chega ao final do método Async, o que ocorrer primeiro.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-272">An async method returns to the caller when either it encounters the first awaited object that's not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="7a1d9-273">Um método assíncrono pode ter um tipo de retorno <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task> ou `void`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-273">An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or `void`.</span></span> <span data-ttu-id="7a1d9-274">O tipo de retorno `void` é usado principalmente para definir manipuladores de eventos, nos quais o tipo de retorno `void` é necessário.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-274">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="7a1d9-275">Um método assíncrono que retorna `void` não pode ser aguardado e o chamador de um método de retorno nulo não pode capturar as exceções que esse método gera.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-275">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="7a1d9-276">Começando com o C# 7.0, um método assíncrono pode ter [qualquer tipo de retorno como os de tarefa](./whats-new/csharp-7.md#generalized-async-return-types).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-276">Starting with C# 7.0, an async method can have [any task-like return type](./whats-new/csharp-7.md#generalized-async-return-types).</span></span>

<span data-ttu-id="7a1d9-277">No exemplo a seguir, `DelayAsync` é um método assíncrono que contém uma instrução return que retorna um inteiro.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-277">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="7a1d9-278">Como é um método assíncrono, sua declaração de método deve ter um tipo de retorno de `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-278">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="7a1d9-279">Como o tipo de retorno é `Task<int>`, a avaliação da expressão `await` em `DoSomethingAsync` produz um inteiro, como a instrução `int result = await delayTask` a seguir demonstra.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-279">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

:::code language="csharp" source="programming-guide/classes-and-structs/snippets/classes-and-structs/methods/Program.cs":::

<span data-ttu-id="7a1d9-280">Um método assíncrono não pode declarar os parâmetros [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md) nem [out](language-reference/keywords/out-parameter-modifier.md), mas pode chamar métodos que tenham esses parâmetros.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-280">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="7a1d9-281">Para obter mais informações sobre métodos assíncronos, consulte [programação assíncrona com tipos de retorno Async e Await](async.md) e [Async](programming-guide/concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-281">For more information about async methods, see [Asynchronous programming with async and await](async.md) and [Async return types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>

## <a name="expression-bodied-members"></a><span data-ttu-id="7a1d9-282">Membros aptos para expressão</span><span class="sxs-lookup"><span data-stu-id="7a1d9-282">Expression-bodied members</span></span>

<span data-ttu-id="7a1d9-283">É comum ter definições de método que simplesmente retornam imediatamente com o resultado de uma expressão ou que têm uma única instrução como o corpo do método.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-283">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="7a1d9-284">Há um atalho de sintaxe para definir esses métodos usando `=>`:</span><span class="sxs-lookup"><span data-stu-id="7a1d9-284">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="7a1d9-285">Se o método retornar `void` ou for um método assíncrono, o corpo do método deverá ser uma expressão de instrução (igual aos lambdas).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-285">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="7a1d9-286">Para propriedades e indexadores, eles devem ser somente leitura e não usar a palavra-chave do acessador `get`.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-286">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>

## <a name="iterators"></a><span data-ttu-id="7a1d9-287">Iterators</span><span class="sxs-lookup"><span data-stu-id="7a1d9-287">Iterators</span></span>

<span data-ttu-id="7a1d9-288">Um iterador realiza uma iteração personalizada em uma coleção, como uma lista ou uma matriz.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-288">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="7a1d9-289">Um iterador usa a instrução [yield return](language-reference/keywords/yield.md) para retornar um elemento de cada vez.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-289">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="7a1d9-290">Quando uma instrução `yield return` for atingida, o local atual será lembrado para que o chamador possa solicitar o próximo elemento na sequência.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-290">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="7a1d9-291">O tipo de retorno de um iterador pode ser <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator> ou <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="7a1d9-291">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="7a1d9-292">Para obter mais informações, consulte [Iteradores](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="7a1d9-292">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="7a1d9-293">Consulte também</span><span class="sxs-lookup"><span data-stu-id="7a1d9-293">See also</span></span>

- [<span data-ttu-id="7a1d9-294">Modificadores de acesso</span><span class="sxs-lookup"><span data-stu-id="7a1d9-294">Access Modifiers</span></span>](language-reference/keywords/access-modifiers.md)
- [<span data-ttu-id="7a1d9-295">Classes static e membros de classes static</span><span class="sxs-lookup"><span data-stu-id="7a1d9-295">Static Classes and Static Class Members</span></span>](programming-guide/classes-and-structs/static-classes-and-static-class-members.md)
- [<span data-ttu-id="7a1d9-296">Herança</span><span class="sxs-lookup"><span data-stu-id="7a1d9-296">Inheritance</span></span>](programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="7a1d9-297">Classes e membros de classes abstract e sealed</span><span class="sxs-lookup"><span data-stu-id="7a1d9-297">Abstract and Sealed Classes and Class Members</span></span>](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="7a1d9-298">params</span><span class="sxs-lookup"><span data-stu-id="7a1d9-298">params</span></span>](language-reference/keywords/params.md)
- [<span data-ttu-id="7a1d9-299">fora</span><span class="sxs-lookup"><span data-stu-id="7a1d9-299">out</span></span>](language-reference/keywords/out-parameter-modifier.md)
- [<span data-ttu-id="7a1d9-300">ref</span><span class="sxs-lookup"><span data-stu-id="7a1d9-300">ref</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="7a1d9-301">Em</span><span class="sxs-lookup"><span data-stu-id="7a1d9-301">in</span></span>](language-reference/keywords/in-parameter-modifier.md)
- [<span data-ttu-id="7a1d9-302">Passando parâmetros</span><span class="sxs-lookup"><span data-stu-id="7a1d9-302">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)
