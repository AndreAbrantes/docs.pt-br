---
title: "Correspondência de padrões – Guia de C#"
description: "Saiba mais sobre expressões de correspondência de padrões em C#"
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: cf17b68514ff263b784bcb42d2015d27015328d9
ms.contentlocale: pt-br
ms.lasthandoff: 07/28/2017

---

# <a name="pattern-matching"></a><span data-ttu-id="20adf-104">Correspondência padrão</span><span class="sxs-lookup"><span data-stu-id="20adf-104">Pattern Matching</span></span> #

<span data-ttu-id="20adf-105">Os padrões testam um valor que tem uma determinada *forma* e podem *extrair* informações do valor quando ele tem a forma correspondente.</span><span class="sxs-lookup"><span data-stu-id="20adf-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="20adf-106">A correspondência de padrões fornece uma sintaxe mais concisa para algoritmos que você já usa atualmente.</span><span class="sxs-lookup"><span data-stu-id="20adf-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="20adf-107">Você já cria algoritmos de correspondência de padrões usando a sintaxe existente.</span><span class="sxs-lookup"><span data-stu-id="20adf-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="20adf-108">Você escreve instruções `if` ou `switch` que testam os valores.</span><span class="sxs-lookup"><span data-stu-id="20adf-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="20adf-109">Então, quando essas instruções correspondem, você extrai e usa informações desse valor.</span><span class="sxs-lookup"><span data-stu-id="20adf-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="20adf-110">Os novos elementos de sintaxe são extensões para as instruções com as quais você já está familiarizado: `is` e `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="20adf-111">Essas novas extensões combinam o teste de um valor e a extração dessas informações.</span><span class="sxs-lookup"><span data-stu-id="20adf-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="20adf-112">Neste tópico, vamos examinar a nova sintaxe para mostrar a você como ela possibilita um código conciso e legível.</span><span class="sxs-lookup"><span data-stu-id="20adf-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="20adf-113">A correspondência de padrões habilita expressões em que os dados e o código são separados, diferente dos designs orientados a objeto em que os dados e os métodos que os manipulam estão intimamente ligados.</span><span class="sxs-lookup"><span data-stu-id="20adf-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="20adf-114">Para ilustrar essas novas expressões, vamos trabalhar com estruturas que representam formas geométricas usando instruções de correspondência de padrões.</span><span class="sxs-lookup"><span data-stu-id="20adf-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="20adf-115">Provavelmente você está familiarizado com a criação de hierarquias de classe com a criação de [métodos virtuais e métodos substituídos](methods.md#inherited) para personalizar o comportamento do objeto com base no tipo de tempo de execução do objeto.</span><span class="sxs-lookup"><span data-stu-id="20adf-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="20adf-116">Essas técnicas não são possíveis para dados não estruturados em uma hierarquia de classe.</span><span class="sxs-lookup"><span data-stu-id="20adf-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="20adf-117">Quando os dados e métodos são separados, você precisa de outras ferramentas.</span><span class="sxs-lookup"><span data-stu-id="20adf-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="20adf-118">Os novos constructos de *correspondência de padrões* permitem uma sintaxe mais clara para examinar dados e manipular o fluxo de controle com base em qualquer condição desses dados.</span><span class="sxs-lookup"><span data-stu-id="20adf-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="20adf-119">Você já escreve instruções `if` e `switch` que testam o valor da variável.</span><span class="sxs-lookup"><span data-stu-id="20adf-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="20adf-120">Você escreve instruções `is` que testam o tipo da variável.</span><span class="sxs-lookup"><span data-stu-id="20adf-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="20adf-121">A *correspondência de padrões* adiciona novos recursos a essas instruções.</span><span class="sxs-lookup"><span data-stu-id="20adf-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="20adf-122">Neste tópico, você criará um método que calcula a área de diferentes formas geométricas.</span><span class="sxs-lookup"><span data-stu-id="20adf-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="20adf-123">Mas fará isso sem recorrer às técnicas orientadas a objeto e sem criar uma hierarquia de classe para as diferentes formas.</span><span class="sxs-lookup"><span data-stu-id="20adf-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="20adf-124">Em vez disso, você usará *correspondência de padrões*.</span><span class="sxs-lookup"><span data-stu-id="20adf-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="20adf-125">Para enfatizar ainda mais que não estamos usando a herança, você fará de cada forma um `struct` em vez de uma classe.</span><span class="sxs-lookup"><span data-stu-id="20adf-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="20adf-126">Observe que diferentes tipos `struct` não podem especificar um tipo base definido pelo usuário comum, portanto, a herança não é um design possível.</span><span class="sxs-lookup"><span data-stu-id="20adf-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="20adf-127">Conforme percorrer esse exemplo, contraste esse código com como ele seria estruturado em uma hierarquia de objeto.</span><span class="sxs-lookup"><span data-stu-id="20adf-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="20adf-128">Quando os dados que você deve consultar e manipular não são uma hierarquia de classe, a correspondência de padrões permite designs muito elegantes.</span><span class="sxs-lookup"><span data-stu-id="20adf-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="20adf-129">Em vez de iniciar com uma definição de forma abstrata e adicionar classes de forma específicas diferentes, vamos começar com os dados simples, apenas definições de dados para cada uma das formas geométricas:</span><span class="sxs-lookup"><span data-stu-id="20adf-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

<span data-ttu-id="20adf-130">[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Definições de forma")]</span><span class="sxs-lookup"><span data-stu-id="20adf-130">[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]</span></span>

<span data-ttu-id="20adf-131">Dessas estruturas, vamos escrever um método que calcula a área de uma forma.</span><span class="sxs-lookup"><span data-stu-id="20adf-131">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="20adf-132">A expressão padrão de tipo `is`</span><span class="sxs-lookup"><span data-stu-id="20adf-132">The `is` type pattern expression</span></span>

<span data-ttu-id="20adf-133">Antes do C# 7, você precisaria testar cada tipo de uma série de instruções `if` e `is`:</span><span class="sxs-lookup"><span data-stu-id="20adf-133">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

<span data-ttu-id="20adf-134">[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Padrão de tipo clássico usando is")]</span><span class="sxs-lookup"><span data-stu-id="20adf-134">[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]</span></span>

<span data-ttu-id="20adf-135">O código acima é uma expressão clássica do *padrão de tipo*: você está testando uma variável para determinar seu tipo e adotando uma ação diferente com base no tipo.</span><span class="sxs-lookup"><span data-stu-id="20adf-135">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="20adf-136">Esse código se torna mais simples usando extensões para a expressão `is` para atribuir uma variável se o teste tiver êxito:</span><span class="sxs-lookup"><span data-stu-id="20adf-136">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

<span data-ttu-id="20adf-137">[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "Expressão padrão is")]</span><span class="sxs-lookup"><span data-stu-id="20adf-137">[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]</span></span>

<span data-ttu-id="20adf-138">Nesta versão atualizadas, a expressão `is` testa a variável e a atribui a uma nova variável do tipo adequado.</span><span class="sxs-lookup"><span data-stu-id="20adf-138">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="20adf-139">Além disso, observe que essa versão inclui o tipo `Rectangle`, que é um `struct`.</span><span class="sxs-lookup"><span data-stu-id="20adf-139">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="20adf-140">A nova expressão `is` funciona com tipos de valor, bem como com tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="20adf-140">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="20adf-141">As regras da linguagem para expressões de correspondência de padrões ajudam a evitar usar incorretamente os resultados de uma expressão de correspondência.</span><span class="sxs-lookup"><span data-stu-id="20adf-141">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="20adf-142">No exemplo acima, as variáveis `s`, `c` e `r` estão somente no escopo e são atribuídas definitivamente quando as expressões de correspondência de padrão têm resultados `true`.</span><span class="sxs-lookup"><span data-stu-id="20adf-142">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="20adf-143">Se você tentar usar qualquer variável em outro local, seu código gerará erros de compilador.</span><span class="sxs-lookup"><span data-stu-id="20adf-143">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="20adf-144">Vamos examinar ambas as regras detalhadamente, começando com o escopo.</span><span class="sxs-lookup"><span data-stu-id="20adf-144">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="20adf-145">A variável `c` está no escopo somente no branch `else` da primeira instrução `if`.</span><span class="sxs-lookup"><span data-stu-id="20adf-145">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="20adf-146">A variável `s` está no escopo no método `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="20adf-146">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="20adf-147">Isso ocorre porque cada branch de uma instrução `if` estabelece um escopo separado para as variáveis.</span><span class="sxs-lookup"><span data-stu-id="20adf-147">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="20adf-148">No entanto, a instrução `if` em si não.</span><span class="sxs-lookup"><span data-stu-id="20adf-148">However, the `if` statement itself does not.</span></span> <span data-ttu-id="20adf-149">Isso significa que as variáveis declaradas na instrução `if` estão no mesmo escopo da instrução `if` (o método nesse caso). Esse comportamento não é específico para correspondência de padrões, mas é o comportamento definido para escopos de variável e instruções `if` e `else`.</span><span class="sxs-lookup"><span data-stu-id="20adf-149">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="20adf-150">As variáveis `c` e `s` são atribuídas quando as respectivas instruções `if` são verdadeiras por causa do mecanismo atribuído definitivamente quando elas são verdadeiras.</span><span class="sxs-lookup"><span data-stu-id="20adf-150">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="20adf-151">Os exemplos neste tópico usam o constructo recomendado quando uma expressão `is` de correspondência de padrão atribui definitivamente a variável correspondente no branch `true` da instrução `if`.</span><span class="sxs-lookup"><span data-stu-id="20adf-151">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="20adf-152">Você poderia reverter a lógica dizendo que `if (!(shape is Square s))` e a variável `s` seriam definitivamente atribuídas apenas no branch `false`.</span><span class="sxs-lookup"><span data-stu-id="20adf-152">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="20adf-153">Embora isso seja válido no C#, não é recomendável porque é mais confuso para acompanhar a lógica.</span><span class="sxs-lookup"><span data-stu-id="20adf-153">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="20adf-154">Essas regras significam que é improvável que você acesse acidentalmente o resultado de uma expressão de correspondência de padrão quando esse padrão não foi atendido.</span><span class="sxs-lookup"><span data-stu-id="20adf-154">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="20adf-155">Usando instruções `switch` de correspondência de padrões</span><span class="sxs-lookup"><span data-stu-id="20adf-155">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="20adf-156">Com o tempo, talvez seja necessário dar suporte a outros tipos de forma.</span><span class="sxs-lookup"><span data-stu-id="20adf-156">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="20adf-157">Conforme o número de condições sendo testadas aumenta, você descobrirá que usar as expressões de correspondência de padrões `is` pode se tornar complicado.</span><span class="sxs-lookup"><span data-stu-id="20adf-157">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="20adf-158">Além de exigirem instruções `if` em cada tipo que você deseja verificar, as expressões `is` são limitadas a testar se a entrada corresponder a um único tipo.</span><span class="sxs-lookup"><span data-stu-id="20adf-158">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="20adf-159">Nesse caso, você descobrirá que as expressões de correspondência de padrões `switch` se tornam uma opção melhor.</span><span class="sxs-lookup"><span data-stu-id="20adf-159">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="20adf-160">A instrução `switch` tradicional era uma expressão padrão: ela dava suporte ao padrão de constante.</span><span class="sxs-lookup"><span data-stu-id="20adf-160">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="20adf-161">Você poderia comparar uma variável a qualquer constante usada em uma instrução `case`:</span><span class="sxs-lookup"><span data-stu-id="20adf-161">You could compare a variable to any constant used in a `case` statement:</span></span>

<span data-ttu-id="20adf-162">[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Instrução switch clássica")]</span><span class="sxs-lookup"><span data-stu-id="20adf-162">[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]</span></span>

<span data-ttu-id="20adf-163">O único padrão com suporte pela instrução `switch` era o padrão de constante.</span><span class="sxs-lookup"><span data-stu-id="20adf-163">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="20adf-164">Ele era ainda mais limitado a tipos numéricos e ao tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="20adf-164">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="20adf-165">Essas restrições foram removidas e agora você pode escrever uma instrução `switch` usando o padrão de tipo:</span><span class="sxs-lookup"><span data-stu-id="20adf-165">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

<span data-ttu-id="20adf-166">[!code-csharp[Padrão do tipo de switch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Calcular com a expressão ‘switch’")]</span><span class="sxs-lookup"><span data-stu-id="20adf-166">[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]</span></span>

<span data-ttu-id="20adf-167">A instrução `switch` da correspondência de padrões usa a sintaxe familiar para os desenvolvedores que usaram a instrução `switch` de estilo C tradicional.</span><span class="sxs-lookup"><span data-stu-id="20adf-167">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="20adf-168">Cada `case` é avaliada e o código sob a condição que corresponde a variável de entrada é executado.</span><span class="sxs-lookup"><span data-stu-id="20adf-168">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="20adf-169">A execução de código não pode "passar" de uma expressão case para a seguinte, a sintaxe da instrução `case` requer que cada `case` termine com um `break`, `return` ou `goto`.</span><span class="sxs-lookup"><span data-stu-id="20adf-169">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="20adf-170">As instruções `goto` para pular para outro rótulo são válidas somente para o padrão de constante, a instrução switch clássica.</span><span class="sxs-lookup"><span data-stu-id="20adf-170">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="20adf-171">Há novas regras importantes regendo a instrução `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-171">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="20adf-172">As restrições no tipo da variável na expressão `switch` foram removidas.</span><span class="sxs-lookup"><span data-stu-id="20adf-172">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="20adf-173">Qualquer tipo, como `object` neste exemplo, pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="20adf-173">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="20adf-174">As expressões case não são mais limitadas a valores de constantes.</span><span class="sxs-lookup"><span data-stu-id="20adf-174">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="20adf-175">Remover essa limitação significa que reordenar seções `switch` pode alterar o comportamento do programa.</span><span class="sxs-lookup"><span data-stu-id="20adf-175">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="20adf-176">Quando limitado a valores de constantes, no máximo um rótulo `case` poderia corresponder ao valor da expressão `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-176">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="20adf-177">Combine isso com a regra de que cada seção `switch` não deve passar para a próxima seção e isso resulta em que as seções `switch` poderiam ser reorganizadas em qualquer ordem sem afetar o comportamento.</span><span class="sxs-lookup"><span data-stu-id="20adf-177">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="20adf-178">Agora, com expressões `switch` mais generalizadas, a ordem de cada seção é importante.</span><span class="sxs-lookup"><span data-stu-id="20adf-178">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="20adf-179">As expressões `switch` são avaliadas na ordem textual.</span><span class="sxs-lookup"><span data-stu-id="20adf-179">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="20adf-180">A execução transfere o primeiro rótulo `switch` que corresponde à expressão `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-180">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="20adf-181">Observe que o case `default` será executado somente se nenhum outro rótulo case corresponder.</span><span class="sxs-lookup"><span data-stu-id="20adf-181">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="20adf-182">O case `default` é avaliado por último, independentemente de sua ordem textual.</span><span class="sxs-lookup"><span data-stu-id="20adf-182">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="20adf-183">Se não houver nenhum case `default` e nenhuma das outras instruções `case` corresponder, a execução continuará na instrução após a instrução `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-183">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="20adf-184">Nenhum dos códigos de rótulos `case` será executado.</span><span class="sxs-lookup"><span data-stu-id="20adf-184">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="20adf-185">Cláusulas `when` em expressões `case`</span><span class="sxs-lookup"><span data-stu-id="20adf-185">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="20adf-186">Você pode criar cases especiais para essas formas que têm área 0 usando uma cláusula `when` no rótulo `case`.</span><span class="sxs-lookup"><span data-stu-id="20adf-186">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="20adf-187">Um quadrado com um comprimento do lado 0 ou um círculo com um raio 0 tem uma área 0.</span><span class="sxs-lookup"><span data-stu-id="20adf-187">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="20adf-188">Você especifica essa condição usando uma cláusula `when` no rótulo `case`:</span><span class="sxs-lookup"><span data-stu-id="20adf-188">You specify that condition using a `when` clause on the `case` label:</span></span>  

<span data-ttu-id="20adf-189">[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Calcular formas com área 0")]</span><span class="sxs-lookup"><span data-stu-id="20adf-189">[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]</span></span>

<span data-ttu-id="20adf-190">Essa alteração demonstra alguns pontos importantes sobre a nova sintaxe.</span><span class="sxs-lookup"><span data-stu-id="20adf-190">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="20adf-191">Primeiro, vários rótulos `case` podem ser aplicados a uma seção `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-191">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="20adf-192">O bloco de instrução é executado quando qualquer um desses rótulos é `true`.</span><span class="sxs-lookup"><span data-stu-id="20adf-192">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="20adf-193">Neste exemplo, se a expressão `switch` é um círculo ou um quadrado com área 0, o método retorna a constante 0.</span><span class="sxs-lookup"><span data-stu-id="20adf-193">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="20adf-194">Este exemplo apresenta duas variáveis diferentes nos dois rótulos `case` para o primeiro bloco `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-194">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="20adf-195">Observe que as instruções neste bloco `switch` não usam as variáveis `c` (para o círculo) ou `s` (para o quadrado).</span><span class="sxs-lookup"><span data-stu-id="20adf-195">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="20adf-196">Nenhuma dessas variáveis é atribuída definitivamente nesse bloco `switch`.</span><span class="sxs-lookup"><span data-stu-id="20adf-196">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="20adf-197">Se algum desses casos corresponder, claramente uma das variáveis foi atribuída.</span><span class="sxs-lookup"><span data-stu-id="20adf-197">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="20adf-198">No entanto, é impossível dizer *qual* foi atribuída em tempo de compilação, porque ambos os casos poderiam corresponder em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="20adf-198">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="20adf-199">Por esse motivo, na maioria das vezes que você usar vários rótulos `case` para o mesmo bloco, não introduzirá uma nova variável na instrução `case` ou apenas usará a variável na cláusula `when`.</span><span class="sxs-lookup"><span data-stu-id="20adf-199">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="20adf-200">Depois de adicionar essas formas com a área 0, vamos adicionar mais alguns tipos de forma: um retângulo e um triângulo:</span><span class="sxs-lookup"><span data-stu-id="20adf-200">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

<span data-ttu-id="20adf-201">[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Adicionar retângulo e triângulo")]</span><span class="sxs-lookup"><span data-stu-id="20adf-201">[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]</span></span>

 <span data-ttu-id="20adf-202">Esse conjunto de alterações adiciona rótulos `case` para o caso de degeneração e rótulos e blocos para cada uma das novas formas.</span><span class="sxs-lookup"><span data-stu-id="20adf-202">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="20adf-203">Por fim, você pode adicionar um case `null` para garantir que o argumento não seja `null`:</span><span class="sxs-lookup"><span data-stu-id="20adf-203">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

<span data-ttu-id="20adf-204">[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Adicionar um case null")]</span><span class="sxs-lookup"><span data-stu-id="20adf-204">[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]</span></span>

<span data-ttu-id="20adf-205">O comportamento especial para o padrão `null` é interessante porque a constante `null` no padrão não tem um tipo, mas pode ser convertida em qualquer tipo de referência ou tipo que permite valor nulo.</span><span class="sxs-lookup"><span data-stu-id="20adf-205">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="20adf-206">Em vez de converter um `null` em qualquer tipo, a linguagem define que um `null` valor não será correspondente ao padrão de qualquer tipo, independentemente do tipo de tempo de compilação da variável.</span><span class="sxs-lookup"><span data-stu-id="20adf-206">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="20adf-207">Esse comportamento torna o novo padrão de tipo baseado em `switch` consistente com a instrução `is`: instruções `is` sempre retornam `false` quando o valor sendo verificado é `null`.</span><span class="sxs-lookup"><span data-stu-id="20adf-207">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="20adf-208">Isso também é mais simples: depois de verificar o tipo, não é necessário fazer uma verificação adicional de nulos.</span><span class="sxs-lookup"><span data-stu-id="20adf-208">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="20adf-209">Você pode ver isso pelo fato de que não há nenhuma verificação de nulos em nenhum dos blocos de casos dos exemplos acima: elas não são necessárias, já que a correspondência do padrão de tipo assegura um valor não nulo.</span><span class="sxs-lookup"><span data-stu-id="20adf-209">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="conclusions"></a><span data-ttu-id="20adf-210">Conclusões</span><span class="sxs-lookup"><span data-stu-id="20adf-210">Conclusions</span></span>

<span data-ttu-id="20adf-211">Os *constructos de correspondência de padrões* permitem que você gerencie facilmente o fluxo de controle entre diferentes tipos e variáveis que não são relacionadas por uma hierarquia de herança.</span><span class="sxs-lookup"><span data-stu-id="20adf-211">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="20adf-212">Você também pode controlar a lógica para usar qualquer condição testada na variável.</span><span class="sxs-lookup"><span data-stu-id="20adf-212">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="20adf-213">Ela habilita os padrões e expressões que você precisará com mais frequência conforme cria aplicativos mais distribuídos, no qual os dados e os métodos que manipulam esses dados são separados.</span><span class="sxs-lookup"><span data-stu-id="20adf-213">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="20adf-214">Você observará que os structs de forma usados nesse exemplo não contêm nenhum método, apenas propriedades somente leitura.</span><span class="sxs-lookup"><span data-stu-id="20adf-214">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="20adf-215">A correspondência de padrões funciona com qualquer tipo de dados.</span><span class="sxs-lookup"><span data-stu-id="20adf-215">Pattern Matching works with any data type.</span></span> <span data-ttu-id="20adf-216">Você escreve expressões que examinam o objeto e toma decisões de fluxo de controle com base nessas condições.</span><span class="sxs-lookup"><span data-stu-id="20adf-216">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="20adf-217">Compare o código deste exemplo com o design que viria após a criação de uma hierarquia de classe para um resumo de `Shape` e formas derivadas específicas, cada uma com sua própria implementação de um método virtual para calcular a área.</span><span class="sxs-lookup"><span data-stu-id="20adf-217">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="20adf-218">Muitas vezes você descobrirá que as expressões de correspondência de padrões podem ser uma ferramenta muito útil quando estiver trabalhando com os dados e desejar separar as preocupações de armazenamento de dados das preocupações de comportamento.</span><span class="sxs-lookup"><span data-stu-id="20adf-218">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>


