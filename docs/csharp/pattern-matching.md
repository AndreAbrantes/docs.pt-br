---
title: Correspondência de padrões – Guia de C#
description: Saiba mais sobre expressões de correspondência de padrões em C#
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: a0f80fc2c019cefa81506d9dcdeabc57a1e98c2b
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/26/2018
---
# <a name="pattern-matching"></a><span data-ttu-id="5df9d-104">Correspondência padrão</span><span class="sxs-lookup"><span data-stu-id="5df9d-104">Pattern Matching</span></span> #

<span data-ttu-id="5df9d-105">Os padrões testam um valor que tem uma determinada *forma* e podem *extrair* informações do valor quando ele tem a forma correspondente.</span><span class="sxs-lookup"><span data-stu-id="5df9d-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="5df9d-106">A correspondência de padrões fornece uma sintaxe mais concisa para algoritmos que você já usa atualmente.</span><span class="sxs-lookup"><span data-stu-id="5df9d-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="5df9d-107">Você já cria algoritmos de correspondência de padrões usando a sintaxe existente.</span><span class="sxs-lookup"><span data-stu-id="5df9d-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="5df9d-108">Você escreve instruções `if` ou `switch` que testam os valores.</span><span class="sxs-lookup"><span data-stu-id="5df9d-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="5df9d-109">Então, quando essas instruções correspondem, você extrai e usa informações desse valor.</span><span class="sxs-lookup"><span data-stu-id="5df9d-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="5df9d-110">Os novos elementos de sintaxe são extensões para as instruções com as quais você já está familiarizado: `is` e `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="5df9d-111">Essas novas extensões combinam o teste de um valor e a extração dessas informações.</span><span class="sxs-lookup"><span data-stu-id="5df9d-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="5df9d-112">Neste tópico, vamos examinar a nova sintaxe para mostrar a você como ela possibilita um código conciso e legível.</span><span class="sxs-lookup"><span data-stu-id="5df9d-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="5df9d-113">A correspondência de padrões habilita expressões em que os dados e o código são separados, diferente dos designs orientados a objeto em que os dados e os métodos que os manipulam estão intimamente ligados.</span><span class="sxs-lookup"><span data-stu-id="5df9d-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="5df9d-114">Para ilustrar essas novas expressões, vamos trabalhar com estruturas que representam formas geométricas usando instruções de correspondência de padrões.</span><span class="sxs-lookup"><span data-stu-id="5df9d-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="5df9d-115">Provavelmente você está familiarizado com a criação de hierarquias de classe com a criação de [métodos virtuais e métodos substituídos](methods.md#inherited) para personalizar o comportamento do objeto com base no tipo de tempo de execução do objeto.</span><span class="sxs-lookup"><span data-stu-id="5df9d-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="5df9d-116">Essas técnicas não são possíveis para dados não estruturados em uma hierarquia de classe.</span><span class="sxs-lookup"><span data-stu-id="5df9d-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="5df9d-117">Quando os dados e métodos são separados, você precisa de outras ferramentas.</span><span class="sxs-lookup"><span data-stu-id="5df9d-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="5df9d-118">Os novos constructos de *correspondência de padrões* permitem uma sintaxe mais clara para examinar dados e manipular o fluxo de controle com base em qualquer condição desses dados.</span><span class="sxs-lookup"><span data-stu-id="5df9d-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="5df9d-119">Você já escreve instruções `if` e `switch` que testam o valor da variável.</span><span class="sxs-lookup"><span data-stu-id="5df9d-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="5df9d-120">Você escreve instruções `is` que testam o tipo da variável.</span><span class="sxs-lookup"><span data-stu-id="5df9d-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="5df9d-121">A *correspondência de padrões* adiciona novos recursos a essas instruções.</span><span class="sxs-lookup"><span data-stu-id="5df9d-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="5df9d-122">Neste tópico, você criará um método que calcula a área de diferentes formas geométricas.</span><span class="sxs-lookup"><span data-stu-id="5df9d-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="5df9d-123">Mas fará isso sem recorrer às técnicas orientadas a objeto e sem criar uma hierarquia de classe para as diferentes formas.</span><span class="sxs-lookup"><span data-stu-id="5df9d-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="5df9d-124">Em vez disso, você usará *correspondência de padrões*.</span><span class="sxs-lookup"><span data-stu-id="5df9d-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="5df9d-125">Para enfatizar ainda mais que não estamos usando a herança, você fará de cada forma um `struct` em vez de uma classe.</span><span class="sxs-lookup"><span data-stu-id="5df9d-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="5df9d-126">Observe que diferentes tipos `struct` não podem especificar um tipo base definido pelo usuário comum, portanto, a herança não é um design possível.</span><span class="sxs-lookup"><span data-stu-id="5df9d-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="5df9d-127">Conforme percorrer esse exemplo, contraste esse código com como ele seria estruturado em uma hierarquia de objeto.</span><span class="sxs-lookup"><span data-stu-id="5df9d-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="5df9d-128">Quando os dados que você deve consultar e manipular não são uma hierarquia de classe, a correspondência de padrões permite designs muito elegantes.</span><span class="sxs-lookup"><span data-stu-id="5df9d-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="5df9d-129">Em vez de iniciar com uma definição de forma abstrata e adicionar classes de forma específicas diferentes, vamos começar com os dados simples, apenas definições de dados para cada uma das formas geométricas:</span><span class="sxs-lookup"><span data-stu-id="5df9d-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="5df9d-130">Dessas estruturas, vamos escrever um método que calcula a área de uma forma.</span><span class="sxs-lookup"><span data-stu-id="5df9d-130">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="5df9d-131">A expressão padrão de tipo `is`</span><span class="sxs-lookup"><span data-stu-id="5df9d-131">The `is` type pattern expression</span></span>

<span data-ttu-id="5df9d-132">Antes do C# 7.0, você precisaria testar cada tipo de uma série de instruções `if` e `is`:</span><span class="sxs-lookup"><span data-stu-id="5df9d-132">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="5df9d-133">O código acima é uma expressão clássica do *padrão de tipo*: você está testando uma variável para determinar seu tipo e adotando uma ação diferente com base no tipo.</span><span class="sxs-lookup"><span data-stu-id="5df9d-133">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="5df9d-134">Esse código se torna mais simples usando extensões para a expressão `is` para atribuir uma variável se o teste tiver êxito:</span><span class="sxs-lookup"><span data-stu-id="5df9d-134">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="5df9d-135">Nesta versão atualizadas, a expressão `is` testa a variável e a atribui a uma nova variável do tipo adequado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-135">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="5df9d-136">Além disso, observe que essa versão inclui o tipo `Rectangle`, que é um `struct`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-136">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="5df9d-137">A nova expressão `is` funciona com tipos de valor, bem como com tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="5df9d-137">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="5df9d-138">As regras da linguagem para expressões de correspondência de padrões ajudam a evitar usar incorretamente os resultados de uma expressão de correspondência.</span><span class="sxs-lookup"><span data-stu-id="5df9d-138">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="5df9d-139">No exemplo acima, as variáveis `s`, `c` e `r` estão somente no escopo e são atribuídas definitivamente quando as expressões de correspondência de padrão têm resultados `true`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-139">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="5df9d-140">Se você tentar usar qualquer variável em outro local, seu código gerará erros de compilador.</span><span class="sxs-lookup"><span data-stu-id="5df9d-140">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="5df9d-141">Vamos examinar ambas as regras detalhadamente, começando com o escopo.</span><span class="sxs-lookup"><span data-stu-id="5df9d-141">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="5df9d-142">A variável `c` está no escopo somente no branch `else` da primeira instrução `if`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-142">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="5df9d-143">A variável `s` está no escopo no método `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-143">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="5df9d-144">Isso ocorre porque cada branch de uma instrução `if` estabelece um escopo separado para as variáveis.</span><span class="sxs-lookup"><span data-stu-id="5df9d-144">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="5df9d-145">No entanto, a instrução `if` em si não.</span><span class="sxs-lookup"><span data-stu-id="5df9d-145">However, the `if` statement itself does not.</span></span> <span data-ttu-id="5df9d-146">Isso significa que as variáveis declaradas na instrução `if` estão no mesmo escopo da instrução `if` (o método nesse caso). Esse comportamento não é específico para correspondência de padrões, mas é o comportamento definido para escopos de variável e instruções `if` e `else`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-146">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="5df9d-147">As variáveis `c` e `s` são atribuídas quando as respectivas instruções `if` são verdadeiras por causa do mecanismo atribuído definitivamente quando elas são verdadeiras.</span><span class="sxs-lookup"><span data-stu-id="5df9d-147">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="5df9d-148">Os exemplos neste tópico usam o constructo recomendado quando uma expressão `is` de correspondência de padrão atribui definitivamente a variável correspondente no branch `true` da instrução `if`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-148">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="5df9d-149">Você poderia reverter a lógica dizendo que `if (!(shape is Square s))` e a variável `s` seriam definitivamente atribuídas apenas no branch `false`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-149">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="5df9d-150">Embora isso seja válido no C#, não é recomendável porque é mais confuso para acompanhar a lógica.</span><span class="sxs-lookup"><span data-stu-id="5df9d-150">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="5df9d-151">Essas regras significam que é improvável que você acesse acidentalmente o resultado de uma expressão de correspondência de padrão quando esse padrão não foi atendido.</span><span class="sxs-lookup"><span data-stu-id="5df9d-151">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="5df9d-152">Usando instruções `switch` de correspondência de padrões</span><span class="sxs-lookup"><span data-stu-id="5df9d-152">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="5df9d-153">Com o tempo, talvez seja necessário dar suporte a outros tipos de forma.</span><span class="sxs-lookup"><span data-stu-id="5df9d-153">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="5df9d-154">Conforme o número de condições sendo testadas aumenta, você descobrirá que usar as expressões de correspondência de padrões `is` pode se tornar complicado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-154">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="5df9d-155">Além de exigirem instruções `if` em cada tipo que você deseja verificar, as expressões `is` são limitadas a testar se a entrada corresponder a um único tipo.</span><span class="sxs-lookup"><span data-stu-id="5df9d-155">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="5df9d-156">Nesse caso, você descobrirá que as expressões de correspondência de padrões `switch` se tornam uma opção melhor.</span><span class="sxs-lookup"><span data-stu-id="5df9d-156">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="5df9d-157">A instrução `switch` tradicional era uma expressão padrão: ela dava suporte ao padrão de constante.</span><span class="sxs-lookup"><span data-stu-id="5df9d-157">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="5df9d-158">Você poderia comparar uma variável a qualquer constante usada em uma instrução `case`:</span><span class="sxs-lookup"><span data-stu-id="5df9d-158">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="5df9d-159">O único padrão com suporte pela instrução `switch` era o padrão de constante.</span><span class="sxs-lookup"><span data-stu-id="5df9d-159">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="5df9d-160">Ele era ainda mais limitado a tipos numéricos e ao tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-160">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="5df9d-161">Essas restrições foram removidas e agora você pode escrever uma instrução `switch` usando o padrão de tipo:</span><span class="sxs-lookup"><span data-stu-id="5df9d-161">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="5df9d-162">A instrução `switch` da correspondência de padrões usa a sintaxe familiar para os desenvolvedores que usaram a instrução `switch` de estilo C tradicional.</span><span class="sxs-lookup"><span data-stu-id="5df9d-162">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="5df9d-163">Cada `case` é avaliada e o código sob a condição que corresponde a variável de entrada é executado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-163">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="5df9d-164">A execução de código não pode "passar" de uma expressão case para a seguinte, a sintaxe da instrução `case` requer que cada `case` termine com um `break`, `return` ou `goto`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-164">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="5df9d-165">As instruções `goto` para pular para outro rótulo são válidas somente para o padrão de constante, a instrução switch clássica.</span><span class="sxs-lookup"><span data-stu-id="5df9d-165">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="5df9d-166">Há novas regras importantes regendo a instrução `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-166">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="5df9d-167">As restrições no tipo da variável na expressão `switch` foram removidas.</span><span class="sxs-lookup"><span data-stu-id="5df9d-167">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="5df9d-168">Qualquer tipo, como `object` neste exemplo, pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-168">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="5df9d-169">As expressões case não são mais limitadas a valores de constantes.</span><span class="sxs-lookup"><span data-stu-id="5df9d-169">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="5df9d-170">Remover essa limitação significa que reordenar seções `switch` pode alterar o comportamento do programa.</span><span class="sxs-lookup"><span data-stu-id="5df9d-170">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="5df9d-171">Quando limitado a valores de constantes, no máximo um rótulo `case` poderia corresponder ao valor da expressão `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-171">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="5df9d-172">Combine isso com a regra de que cada seção `switch` não deve passar para a próxima seção e isso resulta em que as seções `switch` poderiam ser reorganizadas em qualquer ordem sem afetar o comportamento.</span><span class="sxs-lookup"><span data-stu-id="5df9d-172">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="5df9d-173">Agora, com expressões `switch` mais generalizadas, a ordem de cada seção é importante.</span><span class="sxs-lookup"><span data-stu-id="5df9d-173">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="5df9d-174">As expressões `switch` são avaliadas na ordem textual.</span><span class="sxs-lookup"><span data-stu-id="5df9d-174">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="5df9d-175">A execução transfere o primeiro rótulo `switch` que corresponde à expressão `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-175">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="5df9d-176">Observe que o case `default` será executado somente se nenhum outro rótulo case corresponder.</span><span class="sxs-lookup"><span data-stu-id="5df9d-176">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="5df9d-177">O case `default` é avaliado por último, independentemente de sua ordem textual.</span><span class="sxs-lookup"><span data-stu-id="5df9d-177">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="5df9d-178">Se não houver nenhum case `default` e nenhuma das outras instruções `case` corresponder, a execução continuará na instrução após a instrução `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-178">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="5df9d-179">Nenhum dos códigos de rótulos `case` será executado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-179">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="5df9d-180">Cláusulas `when` em expressões `case`</span><span class="sxs-lookup"><span data-stu-id="5df9d-180">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="5df9d-181">Você pode criar cases especiais para essas formas que têm área 0 usando uma cláusula `when` no rótulo `case`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-181">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="5df9d-182">Um quadrado com um comprimento do lado 0 ou um círculo com um raio 0 tem uma área 0.</span><span class="sxs-lookup"><span data-stu-id="5df9d-182">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="5df9d-183">Você especifica essa condição usando uma cláusula `when` no rótulo `case`:</span><span class="sxs-lookup"><span data-stu-id="5df9d-183">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="5df9d-184">Essa alteração demonstra alguns pontos importantes sobre a nova sintaxe.</span><span class="sxs-lookup"><span data-stu-id="5df9d-184">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="5df9d-185">Primeiro, vários rótulos `case` podem ser aplicados a uma seção `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-185">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="5df9d-186">O bloco de instrução é executado quando qualquer um desses rótulos é `true`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-186">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="5df9d-187">Neste exemplo, se a expressão `switch` é um círculo ou um quadrado com área 0, o método retorna a constante 0.</span><span class="sxs-lookup"><span data-stu-id="5df9d-187">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="5df9d-188">Este exemplo apresenta duas variáveis diferentes nos dois rótulos `case` para o primeiro bloco `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-188">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="5df9d-189">Observe que as instruções neste bloco `switch` não usam as variáveis `c` (para o círculo) ou `s` (para o quadrado).</span><span class="sxs-lookup"><span data-stu-id="5df9d-189">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="5df9d-190">Nenhuma dessas variáveis é atribuída definitivamente nesse bloco `switch`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-190">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="5df9d-191">Se algum desses casos corresponder, claramente uma das variáveis foi atribuída.</span><span class="sxs-lookup"><span data-stu-id="5df9d-191">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="5df9d-192">No entanto, é impossível dizer *qual* foi atribuída em tempo de compilação, porque ambos os casos poderiam corresponder em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="5df9d-192">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="5df9d-193">Por esse motivo, na maioria das vezes que você usar vários rótulos `case` para o mesmo bloco, não introduzirá uma nova variável na instrução `case` ou apenas usará a variável na cláusula `when`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-193">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="5df9d-194">Depois de adicionar essas formas com a área 0, vamos adicionar mais alguns tipos de forma: um retângulo e um triângulo:</span><span class="sxs-lookup"><span data-stu-id="5df9d-194">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="5df9d-195">Esse conjunto de alterações adiciona rótulos `case` para o caso de degeneração e rótulos e blocos para cada uma das novas formas.</span><span class="sxs-lookup"><span data-stu-id="5df9d-195">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="5df9d-196">Por fim, você pode adicionar um case `null` para garantir que o argumento não seja `null`:</span><span class="sxs-lookup"><span data-stu-id="5df9d-196">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="5df9d-197">O comportamento especial para o padrão `null` é interessante porque a constante `null` no padrão não tem um tipo, mas pode ser convertida em qualquer tipo de referência ou tipo que permite valor nulo.</span><span class="sxs-lookup"><span data-stu-id="5df9d-197">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="5df9d-198">Em vez de converter um `null` em qualquer tipo, a linguagem define que um `null` valor não será correspondente ao padrão de qualquer tipo, independentemente do tipo de tempo de compilação da variável.</span><span class="sxs-lookup"><span data-stu-id="5df9d-198">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="5df9d-199">Esse comportamento torna o novo padrão de tipo baseado em `switch` consistente com a instrução `is`: instruções `is` sempre retornam `false` quando o valor sendo verificado é `null`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-199">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="5df9d-200">Isso também é mais simples: depois de verificar o tipo, não é necessário fazer uma verificação adicional de nulos.</span><span class="sxs-lookup"><span data-stu-id="5df9d-200">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="5df9d-201">Você pode ver isso pelo fato de que não há nenhuma verificação de nulos em nenhum dos blocos de casos dos exemplos acima: elas não são necessárias, já que a correspondência do padrão de tipo assegura um valor não nulo.</span><span class="sxs-lookup"><span data-stu-id="5df9d-201">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="5df9d-202">`var` declarações em expressões `case`</span><span class="sxs-lookup"><span data-stu-id="5df9d-202">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="5df9d-203">A introdução de `var` como uma das expressões de correspondência introduz novas regras à correspondência de padrão.</span><span class="sxs-lookup"><span data-stu-id="5df9d-203">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="5df9d-204">A primeira regra é de que a declaração `var` segue as regras de inferência de tipos normais: o tipo é inferido como tipo estático da expressão switch.</span><span class="sxs-lookup"><span data-stu-id="5df9d-204">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="5df9d-205">Com base nessa regra, o tipo sempre é correspondente.</span><span class="sxs-lookup"><span data-stu-id="5df9d-205">From that rule, the type always matches.</span></span>

<span data-ttu-id="5df9d-206">A segunda regra é que uma declaração `var` não tem a verificação de nulos que outras expressões do tipo padrão incluem.</span><span class="sxs-lookup"><span data-stu-id="5df9d-206">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="5df9d-207">Isso significa que a variável pode ser nula e uma verificação de nulos é necessária nesse caso.</span><span class="sxs-lookup"><span data-stu-id="5df9d-207">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="5df9d-208">Essas duas regras significam que, em muitos casos, uma declaração `var` em uma expressão `case` corresponde às mesmas condições que uma expressão `default`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-208">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="5df9d-209">Como um case não padrão é preferencial ao case `default`, o case `default` nunca será executado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-209">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="5df9d-210">O compilador não emite um aviso nos casos em que um case `default` foi gravado, mas nunca será executado.</span><span class="sxs-lookup"><span data-stu-id="5df9d-210">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="5df9d-211">Isso é coerente com a atual comportamento da instrução `switch`, em que todos os casos possíveis foram listados.</span><span class="sxs-lookup"><span data-stu-id="5df9d-211">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="5df9d-212">A terceira regra introduz usos em que um case `var` pode ser útil.</span><span class="sxs-lookup"><span data-stu-id="5df9d-212">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="5df9d-213">Imagine que você esteja fazendo uma correspondência de padrão em que a entrada é uma cadeia de caracteres e você está pesquisando valores de comando conhecidos.</span><span class="sxs-lookup"><span data-stu-id="5df9d-213">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="5df9d-214">Você pode escrever algo parecido com:</span><span class="sxs-lookup"><span data-stu-id="5df9d-214">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="5df9d-215">O case `var` corresponde a `null`, a cadeia de caracteres vazia ou qualquer cadeia de caracteres que contém somente espaços em branco.</span><span class="sxs-lookup"><span data-stu-id="5df9d-215">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="5df9d-216">Observe que o código anterior usa o operador `?.` para garantir que ele não gere um <xref:System.NullReferenceException>acidentalmente.</span><span class="sxs-lookup"><span data-stu-id="5df9d-216">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="5df9d-217">O case `default` lida com outros valores de cadeia de caracteres que não são entendidos pelo analisador de comando.</span><span class="sxs-lookup"><span data-stu-id="5df9d-217">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="5df9d-218">Este é um exemplo em que talvez você queira considerar uma expressão case `var` diferente de uma expressão `default`.</span><span class="sxs-lookup"><span data-stu-id="5df9d-218">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="5df9d-219">Conclusões</span><span class="sxs-lookup"><span data-stu-id="5df9d-219">Conclusions</span></span>

<span data-ttu-id="5df9d-220">Os *constructos de correspondência de padrões* permitem que você gerencie facilmente o fluxo de controle entre diferentes tipos e variáveis que não são relacionadas por uma hierarquia de herança.</span><span class="sxs-lookup"><span data-stu-id="5df9d-220">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="5df9d-221">Você também pode controlar a lógica para usar qualquer condição testada na variável.</span><span class="sxs-lookup"><span data-stu-id="5df9d-221">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="5df9d-222">Ela habilita os padrões e expressões que você precisará com mais frequência conforme cria aplicativos mais distribuídos, no qual os dados e os métodos que manipulam esses dados são separados.</span><span class="sxs-lookup"><span data-stu-id="5df9d-222">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="5df9d-223">Você observará que os structs de forma usados nesse exemplo não contêm nenhum método, apenas propriedades somente leitura.</span><span class="sxs-lookup"><span data-stu-id="5df9d-223">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="5df9d-224">A correspondência de padrões funciona com qualquer tipo de dados.</span><span class="sxs-lookup"><span data-stu-id="5df9d-224">Pattern Matching works with any data type.</span></span> <span data-ttu-id="5df9d-225">Você escreve expressões que examinam o objeto e toma decisões de fluxo de controle com base nessas condições.</span><span class="sxs-lookup"><span data-stu-id="5df9d-225">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="5df9d-226">Compare o código deste exemplo com o design que viria após a criação de uma hierarquia de classe para um resumo de `Shape` e formas derivadas específicas, cada uma com sua própria implementação de um método virtual para calcular a área.</span><span class="sxs-lookup"><span data-stu-id="5df9d-226">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="5df9d-227">Muitas vezes você descobrirá que as expressões de correspondência de padrões podem ser uma ferramenta muito útil quando estiver trabalhando com os dados e desejar separar as preocupações de armazenamento de dados das preocupações de comportamento.</span><span class="sxs-lookup"><span data-stu-id="5df9d-227">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

