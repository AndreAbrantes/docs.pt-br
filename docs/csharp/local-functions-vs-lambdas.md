---
title: "Funções locais vs. expressões lambda"
description: "Saiba porque as funções locais podem ser uma escolha melhor que as expressões lambda."
keywords: "C#, .NET, .NET Core, Últimos Recursos, Novidades, funções locais, expressões lambda"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="5c746-104">Funções locais em comparação comparadas expressões lambda</span><span class="sxs-lookup"><span data-stu-id="5c746-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="5c746-105">À primeira vista, [funções locais](programming-guide/classes-and-structs/local-functions.md) e [expressões lambda](lambda-expressions.md) são muito semelhantes.</span><span class="sxs-lookup"><span data-stu-id="5c746-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="5c746-106">Em muitos casos, a escolha entre usar expressões lambda e funções de locais é uma questão de estilo e preferência pessoal.</span><span class="sxs-lookup"><span data-stu-id="5c746-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="5c746-107">No entanto, há diferenças reais em onde você pode usar um ou outro que você deve estar atento.</span><span class="sxs-lookup"><span data-stu-id="5c746-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="5c746-108">Examinaremos as diferenças entre a função local e as implementações de expressão lambda do algoritmo fatorial.</span><span class="sxs-lookup"><span data-stu-id="5c746-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="5c746-109">Primeiro a versão usando uma função local:</span><span class="sxs-lookup"><span data-stu-id="5c746-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="5c746-110">Compare essa implementação com uma versão que usa expressões lambda:</span><span class="sxs-lookup"><span data-stu-id="5c746-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="5c746-111">As funções locais têm nomes.</span><span class="sxs-lookup"><span data-stu-id="5c746-111">The local functions have names.</span></span> <span data-ttu-id="5c746-112">As expressões lambda são métodos anônimos que são atribuídos a variáveis que são `Func` ou `Action` tipos.</span><span class="sxs-lookup"><span data-stu-id="5c746-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="5c746-113">Quando você declara uma função local, os tipos de argumento e o tipo de retorno são parte da declaração da função.</span><span class="sxs-lookup"><span data-stu-id="5c746-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="5c746-114">Em vez de ser parte do corpo do lambda da expressão, os tipos de argumento e o tipo de retorno são parte da declaração de variável de tipo da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5c746-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="5c746-115">Essas duas diferenças podem resultar em código mais claro.</span><span class="sxs-lookup"><span data-stu-id="5c746-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="5c746-116">Funções locais têm diferentes regras de atribuição definida de expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5c746-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="5c746-117">Uma declaração de função local pode ser referenciada de qualquer local de código onde ele está no escopo.</span><span class="sxs-lookup"><span data-stu-id="5c746-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="5c746-118">Uma expressão lambda deve ser atribuída a uma variável de delegado antes que ele pode ser acessado (ou chamado por meio de delgate fazendo referência a expressão lambda.) Observe que a versão usando a expressão lambda deve declarar e inicializar a expressão lambda, `nthFactorial` antes de defini-la.</span><span class="sxs-lookup"><span data-stu-id="5c746-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="5c746-119">Não fazer isso resulta em um erro em tempo de compilação para referenciar `nthFactorial` antes de atribuí-lo.</span><span class="sxs-lookup"><span data-stu-id="5c746-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="5c746-120">Essas diferenças significam que algoritmos recursivos são mais fáceis de criar usando funções locais.</span><span class="sxs-lookup"><span data-stu-id="5c746-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="5c746-121">Você pode declarar e definir uma função local que chama a mesmo.</span><span class="sxs-lookup"><span data-stu-id="5c746-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="5c746-122">Expressões lambda devem ser declaradas e atribuídas um valor padrão antes de poderem ser reatribuídas a um corpo que referencia a mesma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5c746-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="5c746-123">As regras de atribuição definido também afetam todas as variáveis que são capturadas pelo epression local de função ou lamdba.</span><span class="sxs-lookup"><span data-stu-id="5c746-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="5c746-124">Funções locais e as regras de expressões lambda exigem que todas as variáveis capturadas definitivamente são atribuídas no momento quando a expressão lambda ou de função local é convertida em um representante.</span><span class="sxs-lookup"><span data-stu-id="5c746-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="5c746-125">A diferença é que as expressões lambda são convertidas em delegates quando eles são declarados.</span><span class="sxs-lookup"><span data-stu-id="5c746-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="5c746-126">Funções locais são convertidas em delegates somente quando usado como um representante.</span><span class="sxs-lookup"><span data-stu-id="5c746-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="5c746-127">Se você declara uma função local e só referenciá-lo chamando-o como um método, ele não será convertido em um representante.</span><span class="sxs-lookup"><span data-stu-id="5c746-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="5c746-128">Essa regra permite que você declare uma função local em qualquer local conveniente em seu escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="5c746-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="5c746-129">É comum para declarar funções locais no final do método pai, após as instruções de retorno.</span><span class="sxs-lookup"><span data-stu-id="5c746-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="5c746-130">Em terceiro lugar, o compilador pode executar uma análise estática que permite que funções locais definitivamente atribuir variáveis capturadas no escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="5c746-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="5c746-131">Considere este exemplo:</span><span class="sxs-lookup"><span data-stu-id="5c746-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="5c746-132">O compilador pode determinar que `Local` definitivamente atribui `y` quando chamado.</span><span class="sxs-lookup"><span data-stu-id="5c746-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="5c746-133">Porque `Local` é chamado antes de `return` instrução, `y` definitiely que é atribuído ao `return` instrução.</span><span class="sxs-lookup"><span data-stu-id="5c746-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="5c746-134">A análise que permite que a análise permite que a diferença quarta.</span><span class="sxs-lookup"><span data-stu-id="5c746-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="5c746-135">Dependendo de seu uso, funções locais podem evitar as alocações de heap que sempre são necessárias para expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5c746-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="5c746-136">Se uma função local nunca é convertida em um delegado, e nenhuma das variáveis capturadas pela função local é capturada por outros lambdas ou funções locais que são convertidas em delegates, o compilador pode evitar alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="5c746-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="5c746-137">Considere este exemplo assíncrono:</span><span class="sxs-lookup"><span data-stu-id="5c746-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="5c746-138">O fechamento desta expressão lambda contém as variáveis `address`, `index` e `name`.</span><span class="sxs-lookup"><span data-stu-id="5c746-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="5c746-139">No caso de funções locais, o objeto que implementa o encerramento pode ser um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="5c746-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="5c746-140">Esse tipo de struct seria passado por referência à função local.</span><span class="sxs-lookup"><span data-stu-id="5c746-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="5c746-141">Essa diferença na implementação poderia economizar em uma alocação.</span><span class="sxs-lookup"><span data-stu-id="5c746-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="5c746-142">A instanciação necessária para expressões lambda significa que as alocações de memória extra, que podem ser um fator de desempenho em caminhos de código crítico em termos de tempo.</span><span class="sxs-lookup"><span data-stu-id="5c746-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="5c746-143">As funções locais não incorrem nessa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="5c746-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="5c746-144">No exemplo acima, a versão das funções locais tem 2 alocações a menos que a versão da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="5c746-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="5c746-145">A função local equivalente desse método também usa uma classe para o fechamento.</span><span class="sxs-lookup"><span data-stu-id="5c746-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="5c746-146">O fechamento de uma função local ser implementado como um `class` ou como um `struct`, trata-se de um detalhe de implementação.</span><span class="sxs-lookup"><span data-stu-id="5c746-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="5c746-147">Uma função local pode usar um `struct`, enquanto uma lambda sempre usará um `class`.</span><span class="sxs-lookup"><span data-stu-id="5c746-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="5c746-148">Uma vantagem final não demonstrada neste exemplo é que as funções locais podem ser implementadas como iteradores, usando a sintaxe `yield return` para produzir uma sequência de valores.</span><span class="sxs-lookup"><span data-stu-id="5c746-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="5c746-149">O `yield return` instrução não é permitida em expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5c746-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="5c746-150">Embora as funções locais possam parecer redundantes para expressões lambda, elas realmente têm finalidades e usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="5c746-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="5c746-151">As funções locais são mais eficientes para quando você deseja escrever uma função que é chamada apenas do contexto de outro método.</span><span class="sxs-lookup"><span data-stu-id="5c746-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
