---
title: Funções locais vs. expressões lambda
description: Saiba porque as funções locais podem ser uma escolha melhor que as expressões lambda.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 13cc3fe47bbcd6a465347a6c991b2006586c78fa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173335"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="f7f6f-103">Funções locais comparadas com expressões lambda</span><span class="sxs-lookup"><span data-stu-id="f7f6f-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="f7f6f-104">À primeira vista, [funções locais](programming-guide/classes-and-structs/local-functions.md) e [expressões lambda](./programming-guide/statements-expressions-operators/lambda-expressions.md) são muito semelhantes.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="f7f6f-105">Em muitos casos, a escolha entre usar expressões lambda e funções locais é uma questão de estilo e preferência pessoal.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="f7f6f-106">No entanto, há diferenças reais nos casos em que você pode usar uma ou outra, e é importante conhecer essas diferenças.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="f7f6f-107">Examinaremos as diferenças entre a função local e as implementações de expressão lambda do algoritmo fatorial.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="f7f6f-108">Primeiro a versão usando uma função local:</span><span class="sxs-lookup"><span data-stu-id="f7f6f-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="f7f6f-109">Compare essa implementação com uma versão que usa expressões lambda:</span><span class="sxs-lookup"><span data-stu-id="f7f6f-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="f7f6f-110">As funções locais têm nomes.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-110">The local functions have names.</span></span> <span data-ttu-id="f7f6f-111">As expressões lambda são métodos anônimos que são atribuídos a variáveis dos tipos `Func` ou `Action`.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="f7f6f-112">Quando você declara uma função local, os tipos de argumento e o tipo de retorno fazem parte da declaração da função.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="f7f6f-113">Em vez de fazer parte do corpo da expressão lambda, os tipos de argumento e o tipo de retorno são parte da declaração de tipo de variável da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="f7f6f-114">Essas duas diferenças podem resultar em um código mais claro.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="f7f6f-115">As funções locais têm diferentes regras para atribuição definida em relação às expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="f7f6f-116">Uma declaração de função local pode ser referenciada em qualquer local do código em que ela esteja no escopo.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="f7f6f-117">Uma expressão lambda deve ser atribuída a uma variável delegada antes de ser acessada (ou chamada através do delegado fazendo referência à expressão lambda.) Observe que a versão que usa a expressão lambda `nthFactorial` deve declarar e inicializar a expressão lambda, antes de defini-la.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="f7f6f-118">Não fazer isso resulta em um erro em tempo de compilação para referenciar `nthFactorial` antes de atribuí-lo.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="f7f6f-119">Essas diferenças significam que os algoritmos recursivos são mais fáceis de criar usando funções locais.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="f7f6f-120">Você pode declarar e definir uma função local que chame a si mesma.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="f7f6f-121">As expressões lambda devem ser declaradas e atribuídas a um valor padrão antes que possam ser reatribuídas a um corpo que referencie a mesma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="f7f6f-122">As regras de atribuição definidas também afetam as variáveis que são capturadas pela função local ou pela expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="f7f6f-123">As regras das funções locais e das expressões lambda exigem que as variáveis capturadas sejam definitivamente atribuídas no momento em que a expressão lambda ou a função local é convertida em um delegado.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="f7f6f-124">A diferença é que as expressões lambda são convertidas em delegados no momento em que são declaradas.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="f7f6f-125">As funções locais são convertidas em delegados somente quando usadas como um delegado.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="f7f6f-126">Se você declarar uma função local e só referenciá-la ao chamá-la como um método, ela não será convertida em um delegado.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="f7f6f-127">Essa regra permite que você declare uma função local em qualquer local conveniente no respectivo escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="f7f6f-128">É comum declarar funções locais ao final do método pai, depois das instruções de retorno.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="f7f6f-129">Em terceiro lugar, o compilador pode executar uma análise estática que permite que as funções locais atribuam definitivamente as variáveis capturadas no escopo delimitador.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="f7f6f-130">Considere este exemplo:</span><span class="sxs-lookup"><span data-stu-id="f7f6f-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="f7f6f-131">O compilador pode determinar que `LocalFunction` definitivamente atribua `y` quando chamada.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="f7f6f-132">Como a `LocalFunction` é chamada antes da instrução `return`, `y` é atribuído definitivamente na instrução `return`.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="f7f6f-133">Essa análise de exemplo permite a quarta diferença.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="f7f6f-134">Dependendo do uso, as funções locais podem evitar as alocações de heap que são sempre necessárias nas expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="f7f6f-135">Se uma função local nunca é convertida em um delegado, e nenhuma das variáveis capturadas pela função local é capturada por outros lambdas ou funções locais que são convertidas em delegados, o compilador pode evitar alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="f7f6f-136">Considere este exemplo assíncrono:</span><span class="sxs-lookup"><span data-stu-id="f7f6f-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="f7f6f-137">O fechamento desta expressão lambda contém as variáveis `address`, `index` e `name`.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="f7f6f-138">No caso de funções locais, o objeto que implementa o encerramento pode ser um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="f7f6f-139">Esse tipo de struct seria passado por referência à função local.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="f7f6f-140">Essa diferença na implementação poderia economizar em uma alocação.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="f7f6f-141">A instanciação necessária para expressões lambda ocasiona alocações adicionais de memória, tornando-se um fator de desempenho em caminhos de código com tempo crítico.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="f7f6f-142">As funções locais não incorrem nessa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="f7f6f-143">No exemplo acima, a versão das funções locais tem 2 alocações a menos que a versão da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="f7f6f-144">A função local equivalente desse método também usa uma classe para o fechamento.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="f7f6f-145">O fechamento de uma função local ser implementado como um `class` ou como um `struct`, trata-se de um detalhe de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="f7f6f-146">Uma função local pode usar um `struct`, enquanto uma lambda sempre usará um `class`.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="f7f6f-147">Uma vantagem final não demonstrada neste exemplo é que as funções locais podem ser implementadas como iteradores, usando a sintaxe `yield return` para produzir uma sequência de valores.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="f7f6f-148">A instrução `yield return` não é permitida em expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="f7f6f-149">Embora as funções locais possam parecer redundantes para expressões lambda, elas realmente têm finalidades e usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="f7f6f-150">As funções locais são mais eficientes para quando você deseja escrever uma função que é chamada apenas do contexto de outro método.</span><span class="sxs-lookup"><span data-stu-id="f7f6f-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
