---
title: Desconstruindo tuplas e outros tipos
description: Saiba como desconstruir tuplas e outros tipos.
author: rpetrusha
ms.author: ronpet
ms.date: 07/18/2016
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 48724c65de4fe71294eb5c61c1891d9d56c9b5a4
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/01/2018
ms.locfileid: "43392966"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="9d106-103">Desconstruindo tuplas e outros tipos</span><span class="sxs-lookup"><span data-stu-id="9d106-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="9d106-104">Uma tupla fornece uma maneira leve de recuperar vários valores de uma chamada de método.</span><span class="sxs-lookup"><span data-stu-id="9d106-104">A tuple provides a light-weight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="9d106-105">Mas depois de recuperar a tupla, você precisa lidar com seus elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="9d106-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="9d106-106">Fazer isso para cada elemento é incômodo, conforme mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="9d106-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="9d106-107">O método `QueryCityData` retorna uma tupla de 3 e cada um de seus elementos é atribuído a uma variável em uma operação separada.</span><span class="sxs-lookup"><span data-stu-id="9d106-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="9d106-108">Recuperar vários valores de propriedade e de campo de um objeto pode ser igualmente complicado: é necessário atribuir um valor de campo ou de propriedade a uma variável, membro por membro.</span><span class="sxs-lookup"><span data-stu-id="9d106-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="9d106-109">Começando com o C# 7.0, você pode recuperar vários elementos de uma tupla ou recuperar vários valores calculados, de campo e de propriedade de um objeto em uma única operação *deconstruct*.</span><span class="sxs-lookup"><span data-stu-id="9d106-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="9d106-110">Quando você desconstrói uma tupla, você atribui os elementos dela a variáveis individuais.</span><span class="sxs-lookup"><span data-stu-id="9d106-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="9d106-111">Quando você desconstrói um objeto, você atribui os elementos dela a variáveis individuais.</span><span class="sxs-lookup"><span data-stu-id="9d106-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="9d106-112">Desconstruir uma tupla</span><span class="sxs-lookup"><span data-stu-id="9d106-112">Deconstructing a tuple</span></span>

<span data-ttu-id="9d106-113">O C# conta com suporte interno à desconstrução de tuplas, que permite que você descompacte todos os itens em uma tupla em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="9d106-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="9d106-114">A sintaxe geral para desconstruir uma tupla é semelhante à sintaxe para definir uma: coloque as variáveis para as quais cada elemento deve ser atribuído entre parênteses no lado esquerdo de uma instrução de atribuição.</span><span class="sxs-lookup"><span data-stu-id="9d106-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="9d106-115">Por exemplo, a instrução a seguir atribui os elementos de uma tupla de 4 a quatro variáveis separadas:</span><span class="sxs-lookup"><span data-stu-id="9d106-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="9d106-116">Há três maneiras de desconstruir uma tupla:</span><span class="sxs-lookup"><span data-stu-id="9d106-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="9d106-117">Você pode declarar explicitamente o tipo de cada campo dentro de parênteses.</span><span class="sxs-lookup"><span data-stu-id="9d106-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="9d106-118">O exemplo a seguir usa essa abordagem para desconstruir a tupla de 3 retornada pelo método `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="9d106-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="9d106-119">Você pode usar a palavra-chave `var` de modo que o C# infira o tipo de cada variável.</span><span class="sxs-lookup"><span data-stu-id="9d106-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="9d106-120">Você coloca a palavra-chave `var` fora dos parênteses.</span><span class="sxs-lookup"><span data-stu-id="9d106-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="9d106-121">O exemplo a seguir usa a inferência de tipos ao desconstruir a tupla de 3 retornada pelo método `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="9d106-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="9d106-122">Você também pode usar a palavra-chave `var` individualmente com qualquer uma ou todas as declarações de variável dentro dos parênteses.</span><span class="sxs-lookup"><span data-stu-id="9d106-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="9d106-123">Isso é difícil e não é recomendado.</span><span class="sxs-lookup"><span data-stu-id="9d106-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="9d106-124">Por fim, você pode desconstruir a tupla em variáveis que já foram declaradas.</span><span class="sxs-lookup"><span data-stu-id="9d106-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="9d106-125">Observe que você não poderá especificar um tipo específico fora dos parênteses, mesmo se todos os campos na tupla tiverem o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="9d106-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="9d106-126">Isso gera o erro do compilador CS8136, "O formulário de desconstrução 'var (...)' não permite um tipo específico para 'var'.".</span><span class="sxs-lookup"><span data-stu-id="9d106-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="9d106-127">Observe que você também deve atribuir cada elemento da tupla a uma variável.</span><span class="sxs-lookup"><span data-stu-id="9d106-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="9d106-128">Se você omitir qualquer elemento, o compilador gerará o erro CS8132, "Não é possível desconstruir uma tupla de 'x' elementos em 'y' variáveis."</span><span class="sxs-lookup"><span data-stu-id="9d106-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="9d106-129">Observe que não é possível combinar declarações e as atribuições com as variáveis existentes do lado esquerdo de uma desconstrução.</span><span class="sxs-lookup"><span data-stu-id="9d106-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="9d106-130">O compilador gera o erro CS8184, "uma desconstrução não pode combinar declarações e expressões no lado esquerdo."</span><span class="sxs-lookup"><span data-stu-id="9d106-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="9d106-131">quando os membros incluem variáveis recém-declaradas e existentes.</span><span class="sxs-lookup"><span data-stu-id="9d106-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="9d106-132">Desconstruir elementos de tupla com descartes</span><span class="sxs-lookup"><span data-stu-id="9d106-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="9d106-133">Geralmente, ao desconstruir uma tupla, você está interessado nos valores de apenas alguns elementos.</span><span class="sxs-lookup"><span data-stu-id="9d106-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="9d106-134">Começando com o C# 7.0, você pode aproveitar o suporte do C# para *descartes*, que são variáveis somente gravação cujos valores você opta por ignorar.</span><span class="sxs-lookup"><span data-stu-id="9d106-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="9d106-135">Um descarte é designado por um caractere de sublinhado ("\_") em uma atribuição.</span><span class="sxs-lookup"><span data-stu-id="9d106-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="9d106-136">Você pode descartar tantos valores quantos desejar; todos são representados pelo descarte único, `_`.</span><span class="sxs-lookup"><span data-stu-id="9d106-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="9d106-137">O exemplo a seguir ilustra o uso de tuplas com descartes.</span><span class="sxs-lookup"><span data-stu-id="9d106-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="9d106-138">O método `QueryCityDataForYears` a seguir retorna uma tupla de 6 com o nome de uma cidade, sua área, um ano, a população da cidade nesse ano, um segundo ano e população da cidade nesse segundo ano.</span><span class="sxs-lookup"><span data-stu-id="9d106-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="9d106-139">O exemplo mostra a alteração na população entre esses dois anos.</span><span class="sxs-lookup"><span data-stu-id="9d106-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="9d106-140">Entre os dados disponíveis da tupla, não estamos preocupados com a área da cidade e sabemos o nome da cidade e as duas datas em tempo de design.</span><span class="sxs-lookup"><span data-stu-id="9d106-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="9d106-141">Como resultado, estamos interessados apenas nos dois valores de população armazenados na tupla e podemos lidar com seus valores restantes como descartes.</span><span class="sxs-lookup"><span data-stu-id="9d106-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="9d106-142">Desconstruindo tipos definidos pelo usuário</span><span class="sxs-lookup"><span data-stu-id="9d106-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="9d106-143">Tipos não tupla não dão suporte interno a descartes.</span><span class="sxs-lookup"><span data-stu-id="9d106-143">Non-tuple types do not offer built-in support for discards.</span></span> <span data-ttu-id="9d106-144">No entanto, como o autor de uma classe, um struct ou uma interface, você pode permitir instâncias do tipo a ser desconstruído implementando um ou mais métodos `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="9d106-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="9d106-145">O método retorna void e cada valor a ser desconstruído é indicado por um parâmetro [out](language-reference/keywords/out-parameter-modifier.md) na assinatura do método.</span><span class="sxs-lookup"><span data-stu-id="9d106-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="9d106-146">Por exemplo, o método `Deconstruct` a seguir de uma classe `Person` retorna o nome, o segundo nome e o sobrenome:</span><span class="sxs-lookup"><span data-stu-id="9d106-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="9d106-147">Em seguida, você pode desconstruir uma instância da classe `Person` denominada `p` com uma atribuição semelhante à seguinte:</span><span class="sxs-lookup"><span data-stu-id="9d106-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="9d106-148">O exemplo a seguir sobrecarrega o método `Deconstruct` para retornar várias combinações de propriedades de um objeto `Person`.</span><span class="sxs-lookup"><span data-stu-id="9d106-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="9d106-149">As sobrecargas individuais retornam:</span><span class="sxs-lookup"><span data-stu-id="9d106-149">Individual overloads return:</span></span>

- <span data-ttu-id="9d106-150">Um nome e um sobrenome.</span><span class="sxs-lookup"><span data-stu-id="9d106-150">A first and last name.</span></span>
- <span data-ttu-id="9d106-151">Um nome, um sobrenome e um segundo nome.</span><span class="sxs-lookup"><span data-stu-id="9d106-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="9d106-152">Um nome, um sobrenome, um nome de cidade e um nome de estado.</span><span class="sxs-lookup"><span data-stu-id="9d106-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="9d106-153">Já que você pode sobrecarregar o método `Deconstruct` para refletir os grupos de dados que geralmente são extraídos de um objeto, você deve ter cuidado ao definir métodos `Deconstruct` com assinaturas que são diferentes e não ambíguas.</span><span class="sxs-lookup"><span data-stu-id="9d106-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="9d106-154">Vários métodos `Deconstruct` que têm o mesmo número de parâmetros `out` ou com o mesmo número e tipo de parâmetros `out` em uma ordem diferente podem causar confusão.</span><span class="sxs-lookup"><span data-stu-id="9d106-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="9d106-155">O método `Deconstruct` sobrecarregado no exemplo a seguir ilustra uma possível fonte de confusão.</span><span class="sxs-lookup"><span data-stu-id="9d106-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="9d106-156">A primeira sobrecarga retorna o primeiro nome, o segundo nome, o sobrenome e idade de um objeto `Person`, nessa ordem.</span><span class="sxs-lookup"><span data-stu-id="9d106-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="9d106-157">A segunda sobrecarga retorna informações de nome apenas junto com a renda anual, mas o nome, o segundo nome e o sobrenome estão em uma ordem diferente.</span><span class="sxs-lookup"><span data-stu-id="9d106-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="9d106-158">Isso torna fácil confundir a ordem dos argumentos ao desconstruir uma instância de `Person`.</span><span class="sxs-lookup"><span data-stu-id="9d106-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="9d106-159">Desconstruir um tipo definido pelo usuário com descartes</span><span class="sxs-lookup"><span data-stu-id="9d106-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="9d106-160">Assim como você faria com [tuplas](#deconstructing-tuple-elements-with-discards), você pode usar descartes para ignorar os itens selecionados retornados por um método `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="9d106-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="9d106-161">Cada descarte é definido por uma variável chamada "\_" e uma única operação de desconstrução pode incluir vários descartes.</span><span class="sxs-lookup"><span data-stu-id="9d106-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="9d106-162">O exemplo a seguir desconstrói um objeto `Person` em quatro cadeias de caracteres (os nomes e sobrenomes, a cidade e o estado), mas descarta o sobrenome e o estado.</span><span class="sxs-lookup"><span data-stu-id="9d106-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="9d106-163">Desconstruir um tipo definido pelo usuário com um método de extensão</span><span class="sxs-lookup"><span data-stu-id="9d106-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="9d106-164">Se você não criar uma classe, struct ou interface, você ainda poderá decompor objetos desse tipo implementando um ou mais `Deconstruct` [métodos de extensão](programming-guide/classes-and-structs/extension-methods.md) para retornar os valores nos quais você estiver interessado.</span><span class="sxs-lookup"><span data-stu-id="9d106-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="9d106-165">O exemplo a seguir define dois métodos de extensão `Deconstruct` para a classe <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9d106-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="9d106-166">O primeiro retorna um conjunto de valores que indicam as características da propriedade, incluindo seu tipo, se ela é estática ou instância, se ela é somente leitura e se é indexada.</span><span class="sxs-lookup"><span data-stu-id="9d106-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="9d106-167">O segundo indica a acessibilidade da propriedade.</span><span class="sxs-lookup"><span data-stu-id="9d106-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="9d106-168">Já que a acessibilidade dos acessadores get e set pode ser diferente, valores boolianos indicam se a propriedade acessadores get e set separados e, em caso afirmativo, se eles têm a mesma acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="9d106-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="9d106-169">Se há apenas um acessador ou ambos os acessadores get e set têm a mesma acessibilidade, a variável `access` indica a acessibilidade da propriedade como um todo.</span><span class="sxs-lookup"><span data-stu-id="9d106-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="9d106-170">Caso contrário, a acessibilidade dos acessadores get e set é indicada pelas variáveis `getAccess` e `setAccess`.</span><span class="sxs-lookup"><span data-stu-id="9d106-170">Otherwise, the accessibility of the get and set accessors are indicated by the accessaccessibility is indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="9d106-171">Consulte também</span><span class="sxs-lookup"><span data-stu-id="9d106-171">See also</span></span>

- [<span data-ttu-id="9d106-172">Descarta</span><span class="sxs-lookup"><span data-stu-id="9d106-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="9d106-173">Tuplas</span><span class="sxs-lookup"><span data-stu-id="9d106-173">Tuples</span></span>](tuples.md)  
