---
title: Atualizar sua base de código para usar tipos de referência anuláveis
description: Escolha a melhor estratégia para atualizar sua base de código para usar tipos de referência anuláveis.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: 5909eb9ffe1f5398fc2eb74848b82f8fe9516548
ms.sourcegitcommit: fff146ba3fd1762c8c432d95c8b877825ae536fc
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/08/2020
ms.locfileid: "82975329"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="c65bb-103">Atualizar bibliotecas para usar tipos de referência anuláveis e comunicar regras anuláveis a chamadores</span><span class="sxs-lookup"><span data-stu-id="c65bb-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="c65bb-104">A adição de [tipos de referência anuláveis](nullable-references.md) significa que você pode declarar se `null` um valor é permitido ou não ou esperado para cada variável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="c65bb-105">Além disso, você pode aplicar um número de atributos: `AllowNull`, `DisallowNull` `MaybeNull` `NotNull` `NotNullWhen` `MaybeNullWhen`,,,, e `NotNullIfNotNull` para descrever completamente os Estados nulos dos valores de argumento e de retorno.</span><span class="sxs-lookup"><span data-stu-id="c65bb-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="c65bb-106">Isso fornece uma ótima experiência à medida que você escreve o código.</span><span class="sxs-lookup"><span data-stu-id="c65bb-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="c65bb-107">Você receberá avisos se uma variável não anulável puder ser definida como `null`.</span><span class="sxs-lookup"><span data-stu-id="c65bb-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="c65bb-108">Você receberá avisos se uma variável anulável não for marcada como nula antes de você desreferenciá-la.</span><span class="sxs-lookup"><span data-stu-id="c65bb-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="c65bb-109">Atualizar suas bibliotecas pode levar tempo, mas os benefícios valem a pena.</span><span class="sxs-lookup"><span data-stu-id="c65bb-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="c65bb-110">Quanto mais informações você fornecer ao compilador sobre *quando* um `null` valor é permitido ou proibido, os melhores avisos que os usuários da sua API receberão.</span><span class="sxs-lookup"><span data-stu-id="c65bb-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="c65bb-111">Vamos começar com um exemplo familiar.</span><span class="sxs-lookup"><span data-stu-id="c65bb-111">Let's start with a familiar example.</span></span> <span data-ttu-id="c65bb-112">Imagine que sua biblioteca tenha a seguinte API para recuperar uma cadeia de caracteres de recurso:</span><span class="sxs-lookup"><span data-stu-id="c65bb-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="c65bb-113">O exemplo anterior segue o padrão `Try*` familiar no .net.</span><span class="sxs-lookup"><span data-stu-id="c65bb-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="c65bb-114">Há dois argumentos de referência para essa API: o `key` e o `message` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="c65bb-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="c65bb-115">Essa API tem as seguintes regras relacionadas à nulidade desses argumentos:</span><span class="sxs-lookup"><span data-stu-id="c65bb-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="c65bb-116">Os chamadores não `null` devem passar como o `key`argumento para.</span><span class="sxs-lookup"><span data-stu-id="c65bb-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="c65bb-117">Os chamadores podem passar uma variável cujo valor `null` é como o argumento `message`para.</span><span class="sxs-lookup"><span data-stu-id="c65bb-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="c65bb-118">Se o `TryGetMessage` método retornar `true`, o valor de `message` não será nulo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="c65bb-119">Se o valor de retorno `false,` for o valor `message` de (e seu estado nulo) for NULL.</span><span class="sxs-lookup"><span data-stu-id="c65bb-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="c65bb-120">A regra para `key` pode ser totalmente expressa pelo tipo de variável: `key` deve ser um tipo de referência não anulável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="c65bb-121">O `message` parâmetro é mais complexo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="c65bb-122">Ele permite `null` como o argumento, mas garante que, em caso de sucesso `out` , esse argumento não seja nulo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="c65bb-123">Para esses cenários, você precisa de um vocabulário mais rico para descrever as expectativas.</span><span class="sxs-lookup"><span data-stu-id="c65bb-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="c65bb-124">Atualizar sua biblioteca para referências anuláveis requer mais do que `?` a inundação em algumas das variáveis e nomes de tipo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="c65bb-125">O exemplo anterior mostra que você precisa examinar suas APIs e considerar suas expectativas para cada argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="c65bb-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="c65bb-126">Considere as garantias para o valor de retorno e quaisquer `out` argumentos `ref` ou no retorno do método.</span><span class="sxs-lookup"><span data-stu-id="c65bb-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="c65bb-127">Em seguida, comunique essas regras ao compilador, e o compilador fornecerá avisos quando os chamadores não obedecem a essas regras.</span><span class="sxs-lookup"><span data-stu-id="c65bb-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="c65bb-128">Esse trabalho leva tempo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-128">This work takes time.</span></span> <span data-ttu-id="c65bb-129">Vamos começar com as estratégias para tornar sua biblioteca ou reconhecimento anulável de aplicativo, ao mesmo tempo em que equilibra outros requisitos e resultados finais.</span><span class="sxs-lookup"><span data-stu-id="c65bb-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="c65bb-130">Você verá como balancear o desenvolvimento contínuo habilitando tipos de referência anuláveis.</span><span class="sxs-lookup"><span data-stu-id="c65bb-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="c65bb-131">Você aprenderá os desafios para definições de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="c65bb-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="c65bb-132">Você aprenderá a aplicar atributos para descrever as condições anteriores e posteriores em APIs individuais.</span><span class="sxs-lookup"><span data-stu-id="c65bb-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="c65bb-133">Escolher uma estratégia para tipos de referência anuláveis</span><span class="sxs-lookup"><span data-stu-id="c65bb-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="c65bb-134">A primeira opção é se os tipos de referência anuláveis devem estar ativados ou desativados por padrão.</span><span class="sxs-lookup"><span data-stu-id="c65bb-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="c65bb-135">Você tem duas estratégias:</span><span class="sxs-lookup"><span data-stu-id="c65bb-135">You have two strategies:</span></span>

- <span data-ttu-id="c65bb-136">Habilite tipos de referência anuláveis para o projeto inteiro e desabilite-o no código que não está pronto.</span><span class="sxs-lookup"><span data-stu-id="c65bb-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="c65bb-137">Só habilite tipos de referência anuláveis para o código anotado para tipos de referência anuláveis.</span><span class="sxs-lookup"><span data-stu-id="c65bb-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="c65bb-138">A primeira estratégia funciona melhor quando você está adicionando outros recursos à biblioteca ao atualizá-los para tipos de referência anuláveis.</span><span class="sxs-lookup"><span data-stu-id="c65bb-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="c65bb-139">Todo o novo desenvolvimento tem reconhecimento anulável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-139">All new development is nullable aware.</span></span> <span data-ttu-id="c65bb-140">À medida que você atualiza o código existente, você habilita os tipos de referência anuláveis nessas classes.</span><span class="sxs-lookup"><span data-stu-id="c65bb-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="c65bb-141">Seguindo essa primeira estratégia, faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="c65bb-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="c65bb-142">Habilite tipos de referência anuláveis para todo o projeto `<Nullable>enable</Nullable>` adicionando o elemento aos seus arquivos *csproj* .</span><span class="sxs-lookup"><span data-stu-id="c65bb-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="c65bb-143">Adicione o `#nullable disable` pragma a cada arquivo de origem em seu projeto.</span><span class="sxs-lookup"><span data-stu-id="c65bb-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="c65bb-144">Conforme você trabalha em cada arquivo, remova o pragma e resolva os avisos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="c65bb-145">Essa primeira estratégia tem mais trabalho antecipado para adicionar o pragma a cada arquivo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="c65bb-146">A vantagem é que todos os novos arquivos de código adicionados ao projeto serão habilitados para permitir valor nulo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="c65bb-147">Qualquer trabalho novo terá reconhecimento de Nullable; somente o código existente deve ser atualizado.</span><span class="sxs-lookup"><span data-stu-id="c65bb-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="c65bb-148">A segunda estratégia funciona melhor se a biblioteca costuma ser estável e o foco principal do desenvolvimento é adotar tipos de referência anuláveis.</span><span class="sxs-lookup"><span data-stu-id="c65bb-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="c65bb-149">Você ativa os tipos de referência anuláveis ao anotar APIs.</span><span class="sxs-lookup"><span data-stu-id="c65bb-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="c65bb-150">Quando tiver terminado, habilite os tipos de referência anuláveis para o projeto inteiro.</span><span class="sxs-lookup"><span data-stu-id="c65bb-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="c65bb-151">Seguindo essa segunda estratégia, você faz o seguinte:</span><span class="sxs-lookup"><span data-stu-id="c65bb-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="c65bb-152">Adicione o `#nullable enable` pragma ao arquivo que você deseja que o reconheça de forma anulável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="c65bb-153">Resolva os avisos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-153">Address any warnings.</span></span>
1. <span data-ttu-id="c65bb-154">Continue essas duas primeiras etapas até que você tenha feito o reconhecimento de toda a biblioteca.</span><span class="sxs-lookup"><span data-stu-id="c65bb-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="c65bb-155">Habilite tipos anuláveis para todo o projeto adicionando `<Nullable>enable</Nullable>` o elemento aos seus arquivos *csproj* .</span><span class="sxs-lookup"><span data-stu-id="c65bb-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="c65bb-156">Remova os `#nullable enable` pragmas, pois eles não são mais necessários.</span><span class="sxs-lookup"><span data-stu-id="c65bb-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="c65bb-157">Essa segunda estratégia tem menos trabalho de antecedência.</span><span class="sxs-lookup"><span data-stu-id="c65bb-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="c65bb-158">A desvantagem é que a primeira tarefa quando você cria um novo arquivo é adicionar o pragma e torná-lo indesejado de forma anulável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="c65bb-159">Se algum desenvolvedor da sua equipe esquecer, esse novo código estará no registro posterior do trabalho para tornar todos os incompatíveis com o código anulável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="c65bb-160">Qual dessas estratégias você escolhe depende de quanto o desenvolvimento ativo está ocorrendo em seu projeto.</span><span class="sxs-lookup"><span data-stu-id="c65bb-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="c65bb-161">Quanto mais maduro e estável for seu projeto, melhor a segunda estratégia.</span><span class="sxs-lookup"><span data-stu-id="c65bb-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="c65bb-162">Quanto mais recursos estiverem sendo desenvolvidos, melhor será a primeira estratégia.</span><span class="sxs-lookup"><span data-stu-id="c65bb-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="c65bb-163">Os avisos que permitem valor nulo apresentam alterações significativas?</span><span class="sxs-lookup"><span data-stu-id="c65bb-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="c65bb-164">Antes de habilitar tipos de referência anuláveis, as variáveis são consideradas *alheios anuláveis*.</span><span class="sxs-lookup"><span data-stu-id="c65bb-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="c65bb-165">Depois de habilitar tipos de referência anuláveis, todas essas variáveis são *não anuláveis*.</span><span class="sxs-lookup"><span data-stu-id="c65bb-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="c65bb-166">O compilador emitirá avisos se essas variáveis não forem inicializadas para valores não nulos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="c65bb-167">Outra provável fonte de avisos é retornar valores quando o valor não tiver sido inicializado.</span><span class="sxs-lookup"><span data-stu-id="c65bb-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="c65bb-168">A primeira etapa para abordar os avisos do compilador é usar `?` anotações em tipos de parâmetro e de retorno para indicar quando argumentos ou valores de retorno podem ser nulos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="c65bb-169">Quando variáveis de referência não devem ser nulas, a declaração original está correta.</span><span class="sxs-lookup"><span data-stu-id="c65bb-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="c65bb-170">Como você faz isso, seu objetivo não é apenas corrigir avisos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="c65bb-171">A meta mais importante é fazer com que o compilador entenda sua intenção por possíveis valores nulos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="c65bb-172">Ao examinar os avisos, você chegará à sua próxima decisão principal para sua biblioteca.</span><span class="sxs-lookup"><span data-stu-id="c65bb-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="c65bb-173">Deseja considerar a modificação de assinaturas de API para comunicar mais claramente sua intenção de design?</span><span class="sxs-lookup"><span data-stu-id="c65bb-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="c65bb-174">Uma assinatura de API melhor para `TryGetMessage` o método examinado anteriormente poderia ser:</span><span class="sxs-lookup"><span data-stu-id="c65bb-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="c65bb-175">O valor de retorno indica êxito ou falha e transporta o valor se o valor foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="c65bb-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="c65bb-176">Em muitos casos, a alteração de assinaturas de API pode melhorar a forma como elas comunicam valores nulos.</span><span class="sxs-lookup"><span data-stu-id="c65bb-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="c65bb-177">No entanto, para bibliotecas públicas ou bibliotecas com grandes bases de usuários, você pode preferir não introduzir nenhuma alteração de assinatura de API.</span><span class="sxs-lookup"><span data-stu-id="c65bb-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="c65bb-178">Para esses casos e outros padrões comuns, você pode aplicar atributos para definir de forma mais clara quando um argumento ou valor de retorno `null`pode ser.</span><span class="sxs-lookup"><span data-stu-id="c65bb-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="c65bb-179">Se você considerar ou não a alteração da superfície de sua API, provavelmente descobrirá que as anotações de tipo sozinhas não são `null` suficientes para descrever valores para argumentos ou valores de retorno.</span><span class="sxs-lookup"><span data-stu-id="c65bb-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="c65bb-180">Nessas instâncias, você pode aplicar atributos para descrever mais claramente uma API.</span><span class="sxs-lookup"><span data-stu-id="c65bb-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="c65bb-181">Atributos estendem anotações de tipo</span><span class="sxs-lookup"><span data-stu-id="c65bb-181">Attributes extend type annotations</span></span>

<span data-ttu-id="c65bb-182">Vários atributos foram adicionados para expressar informações adicionais sobre o estado nulo de variáveis.</span><span class="sxs-lookup"><span data-stu-id="c65bb-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="c65bb-183">Todo o código que você escreveu antes do C# 8 introduziu tipos de referência anuláveis era *nulo alheios*.</span><span class="sxs-lookup"><span data-stu-id="c65bb-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="c65bb-184">Isso significa que qualquer variável de tipo de referência pode ser nula, mas verificações nulas não são necessárias.</span><span class="sxs-lookup"><span data-stu-id="c65bb-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="c65bb-185">Depois que o código estiver com *reconhecimento nulo*, essas regras serão alteradas.</span><span class="sxs-lookup"><span data-stu-id="c65bb-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="c65bb-186">Os tipos de referência nunca devem `null` ser o valor, e os tipos de referência anuláveis devem ser verificados `null` antes de serem desreferenciados.</span><span class="sxs-lookup"><span data-stu-id="c65bb-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="c65bb-187">As regras para suas APIs são provavelmente mais complicadas, como vimos com o `TryGetValue` cenário de API.</span><span class="sxs-lookup"><span data-stu-id="c65bb-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="c65bb-188">Muitas de suas APIs têm regras mais complexas para quando as variáveis podem ou não `null`ser.</span><span class="sxs-lookup"><span data-stu-id="c65bb-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="c65bb-189">Nesses casos, você usará atributos para expressar essas regras.</span><span class="sxs-lookup"><span data-stu-id="c65bb-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="c65bb-190">Os atributos que descrevem a semântica de sua API são encontrados no artigo sobre [atributos que afetam a análise anulável](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="c65bb-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="c65bb-191">Definições genéricas e nulidade</span><span class="sxs-lookup"><span data-stu-id="c65bb-191">Generic definitions and nullability</span></span>

<span data-ttu-id="c65bb-192">Comunicar corretamente o estado nulo de tipos genéricos e métodos genéricos requer um cuidado especial.</span><span class="sxs-lookup"><span data-stu-id="c65bb-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="c65bb-193">Isso deriva do fato de que um tipo de valor anulável e um tipo de referência anulável são fundamentalmente diferentes.</span><span class="sxs-lookup"><span data-stu-id="c65bb-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="c65bb-194">Um `int?` é sinônimo de `Nullable<int>`, enquanto `string?` é `string` um atributo adicionado pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="c65bb-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="c65bb-195">O resultado é que o compilador não pode gerar o código `T?` correto para sem `T` saber se `class` é um `struct`ou um.</span><span class="sxs-lookup"><span data-stu-id="c65bb-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="c65bb-196">Isso não significa que você não pode usar um tipo anulável (tipo de valor ou tipo de referência) como o argumento de tipo para um tipo genérico fechado.</span><span class="sxs-lookup"><span data-stu-id="c65bb-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="c65bb-197">`List<string?>` E `List<int?>` são instanciações válidas do `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="c65bb-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="c65bb-198">O que significa é que você não pode usar `T?` em uma classe genérica ou declaração de método sem restrições.</span><span class="sxs-lookup"><span data-stu-id="c65bb-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="c65bb-199">Por exemplo, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> não será alterado para retornar `T?`.</span><span class="sxs-lookup"><span data-stu-id="c65bb-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="c65bb-200">Você pode superar essa limitação adicionando a `struct` restrição ou. `class`</span><span class="sxs-lookup"><span data-stu-id="c65bb-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="c65bb-201">Com qualquer uma dessas restrições, o compilador sabe como gerar código para o `T` e `T?`o.</span><span class="sxs-lookup"><span data-stu-id="c65bb-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="c65bb-202">Talvez você queira restringir os tipos usados para que um argumento de tipo genérico seja de tipos não anuláveis.</span><span class="sxs-lookup"><span data-stu-id="c65bb-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="c65bb-203">Você pode fazer isso adicionando a restrição `notnull` a esse argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="c65bb-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="c65bb-204">Quando essa restrição é aplicada, o argumento de tipo não deve ser um tipo anulável.</span><span class="sxs-lookup"><span data-stu-id="c65bb-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a><span data-ttu-id="c65bb-205">Propriedades inicializadas tardias, objetos Transferência de Dados e nulidade</span><span class="sxs-lookup"><span data-stu-id="c65bb-205">Late-initialized properties, Data Transfer Objects and nullability</span></span>

<span data-ttu-id="c65bb-206">Indicando a nulidade das propriedades que são inicializadas com atraso, o que significa que definir após a construção, pode exigir uma consideração especial para garantir que sua classe continue expressando corretamente a intenção de design original.</span><span class="sxs-lookup"><span data-stu-id="c65bb-206">Indicating the nullability of properties that are late-initialized, meaning set after construction, may require special consideration to ensure that your class continues to correctly express the original design intent.</span></span>

<span data-ttu-id="c65bb-207">Os tipos que contêm propriedades de inicialização tardia, como os objetos de Transferência de Dados (DTOs), geralmente são instanciados por uma biblioteca externa, como um ORM de banco de dados (mapeador relacional de objeto), um desserializador ou algum outro componente que preenche automaticamente as propriedades de outra fonte.</span><span class="sxs-lookup"><span data-stu-id="c65bb-207">Types that contain late-initialized properties, such as Data Transfer Objects (DTOs), are often instantiated by an external library, like a database ORM (Object Relational Mapper), a deserializer, or some other component that automatically populates properties from another source.</span></span>

<span data-ttu-id="c65bb-208">Considere a seguinte classe DTO, antes de habilitar tipos de referência anuláveis, que representa um aluno:</span><span class="sxs-lookup"><span data-stu-id="c65bb-208">Consider the following DTO class, prior to enabling nullable reference types, that represents a student:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

<span data-ttu-id="c65bb-209">A intenção `Required` de design (indicada neste caso pelo atributo) sugere que, nesse sistema, as `FirstName` Propriedades e `LastName` são **obrigatórias**e, portanto, não nulas.</span><span class="sxs-lookup"><span data-stu-id="c65bb-209">The design intent (indicated in this case by the `Required` attribute) suggests that in this system, the `FirstName` and `LastName` properties are **mandatory**, and therefore not null.</span></span>

<span data-ttu-id="c65bb-210">A `VehicleRegistration` propriedade **não é obrigatória**, portanto pode ser nula.</span><span class="sxs-lookup"><span data-stu-id="c65bb-210">The `VehicleRegistration` property is **not mandatory**, so may be null.</span></span>

<span data-ttu-id="c65bb-211">Quando você habilita tipos de referência anuláveis, você deseja indicar em nosso DTO quais das propriedades podem ser anuláveis, consistentes com sua intenção original:</span><span class="sxs-lookup"><span data-stu-id="c65bb-211">When you enable nullable reference types, you want to indicate on our DTO which of the properties may be nullable, consistent with your original intent:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="c65bb-212">Para este DTO, a única propriedade que pode ser NULL é ``VehicleRegistration``.</span><span class="sxs-lookup"><span data-stu-id="c65bb-212">For this DTO, the only property that may be null is ``VehicleRegistration``.</span></span>

<span data-ttu-id="c65bb-213">No entanto, o `CS8618` compilador gera avisos `FirstName` para `LastName`e, indicando que as propriedades não anuláveis não são inicializadas.</span><span class="sxs-lookup"><span data-stu-id="c65bb-213">However, the compiler raises `CS8618` warnings for both `FirstName` and `LastName`, indicating the non-nullable properties are uninitialized.</span></span>

<span data-ttu-id="c65bb-214">Há três opções disponíveis que resolvem os avisos do compilador de uma maneira que mantém a intenção original.</span><span class="sxs-lookup"><span data-stu-id="c65bb-214">There are three options available to you that resolve the compiler warnings in a way that maintains the original intent.</span></span> <span data-ttu-id="c65bb-215">Qualquer uma dessas opções é válida; Você deve escolher aquele que melhor atenda ao seu estilo de codificação e requisitos de design.</span><span class="sxs-lookup"><span data-stu-id="c65bb-215">Any of these options are valid; you should choose the one that best suits your coding style and design requirements.</span></span>

### <a name="initialize-in-the-constructor"></a><span data-ttu-id="c65bb-216">Inicializar no Construtor</span><span class="sxs-lookup"><span data-stu-id="c65bb-216">Initialize in the constructor</span></span>

<span data-ttu-id="c65bb-217">A maneira ideal de resolver os avisos não inicializados é inicializar as propriedades no construtor:</span><span class="sxs-lookup"><span data-stu-id="c65bb-217">The ideal way to resolve the uninitialized warnings is to initialize the properties in the constructor:</span></span>

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="c65bb-218">Essa abordagem só funciona se a biblioteca que você usa para instanciar a classe dá suporte à passagem de parâmetros no construtor.</span><span class="sxs-lookup"><span data-stu-id="c65bb-218">This approach only works if the library that you use to instantiate the class supports passing parameters in the constructor.</span></span>

<span data-ttu-id="c65bb-219">Além disso, uma biblioteca pode dar suporte à passagem de *algumas* Propriedades no construtor, mas não todas.</span><span class="sxs-lookup"><span data-stu-id="c65bb-219">In addition, a library may support passing *some* properties in the constructor, but not all.</span></span>
<span data-ttu-id="c65bb-220">Por exemplo, EF Core dá suporte à [Associação de Construtor](/ef/core/modeling/constructors) para propriedades de coluna normais, mas não a propriedades de navegação.</span><span class="sxs-lookup"><span data-stu-id="c65bb-220">For example, EF Core supports [constructor binding](/ef/core/modeling/constructors) for normal column properties, but not navigation properties.</span></span>

<span data-ttu-id="c65bb-221">Verifique a documentação na biblioteca que instancia sua classe para entender a extensão para a qual ela dá suporte à associação de construtor.</span><span class="sxs-lookup"><span data-stu-id="c65bb-221">Check the documentation on the library that instantiates your class, to understand the extent to which it supports constructor binding.</span></span>

### <a name="property-with-nullable-backing-field"></a><span data-ttu-id="c65bb-222">Propriedade com campo de backup anulável</span><span class="sxs-lookup"><span data-stu-id="c65bb-222">Property with nullable backing field</span></span>

<span data-ttu-id="c65bb-223">Se a associação de construtor não funcionar para você, uma maneira de lidar com esse problema é ter uma propriedade não anulável com um campo de backup anulável:</span><span class="sxs-lookup"><span data-stu-id="c65bb-223">If constructor binding won't work for you, one way to deal with this problem is to have a non-nullable property with a nullable backing field:</span></span>

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

<span data-ttu-id="c65bb-224">Nesse cenário, se a `FirstName` propriedade for acessada antes de ser inicializada, o código lançará `InvalidOperationException`um, pois o contrato de API foi usado incorretamente.</span><span class="sxs-lookup"><span data-stu-id="c65bb-224">In this scenario, if the `FirstName` property is accessed before it has been initialized, then the code throws an `InvalidOperationException`, because the API contract has been used incorrectly.</span></span>

<span data-ttu-id="c65bb-225">Você deve considerar que algumas bibliotecas podem ter considerações especiais ao usar campos de backup.</span><span class="sxs-lookup"><span data-stu-id="c65bb-225">You should consider that some libraries may have special considerations when using backing fields.</span></span> <span data-ttu-id="c65bb-226">Por exemplo, EF Core pode precisar ser configurado para usar os [campos de backup](/ef/core/modeling/backing-field) corretamente.</span><span class="sxs-lookup"><span data-stu-id="c65bb-226">For example, EF Core may need to be configured to use [backing fields](/ef/core/modeling/backing-field) correctly.</span></span>

### <a name="initialize-the-property-to-null"></a><span data-ttu-id="c65bb-227">Inicializar a propriedade como nula</span><span class="sxs-lookup"><span data-stu-id="c65bb-227">Initialize the property to null</span></span>

<span data-ttu-id="c65bb-228">Como alternativa terser ao uso de um campo de backup anulável, ou se a biblioteca que instancia a classe não for compatível com essa abordagem, você poderá simplesmente inicializar a propriedade `null` diretamente, com a ajuda do operador NULL-tolerante (`!`):</span><span class="sxs-lookup"><span data-stu-id="c65bb-228">As a terser alternative to using a nullable backing field, or if the library that instantiates your class is not compatible with that approach, you can simply initialize the property to `null` directly, with the help of the null-forgiving operator (`!`):</span></span>

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

<span data-ttu-id="c65bb-229">Você nunca observará um valor nulo real no tempo de execução, exceto como resultado de um bug de programação, acessando a propriedade antes que ela tenha sido inicializada corretamente.</span><span class="sxs-lookup"><span data-stu-id="c65bb-229">You will never observe an actual null value at runtime except as a result of a programming bug, by accessing the property before it has been properly initialized.</span></span>

## <a name="see-also"></a><span data-ttu-id="c65bb-230">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c65bb-230">See also</span></span>

- [<span data-ttu-id="c65bb-231">Migrar uma base de código para referências que permitem valor nulo</span><span class="sxs-lookup"><span data-stu-id="c65bb-231">Migrate an existing codebase to nullable references</span></span>](tutorials/upgrade-to-nullable-references.md)
- [<span data-ttu-id="c65bb-232">Trabalhando com tipos de referência anuláveis no EF Core</span><span class="sxs-lookup"><span data-stu-id="c65bb-232">Working with Nullable Reference Types in EF Core</span></span>](/ef/core/miscellaneous/nullable-reference-types)
