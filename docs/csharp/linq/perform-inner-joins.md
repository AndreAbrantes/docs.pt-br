---
title: Executar junções internas
description: Como executar junções internas.
ms.date: 12/1/2016
ms.assetid: 45bceed6-f549-4114-a9b1-b44feb497742
ms.openlocfilehash: 9d372579e3c32964c588b6387b6d4e97f632a21f
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33289068"
---
# <a name="perform-inner-joins"></a><span data-ttu-id="0e188-103">Executar junções internas</span><span class="sxs-lookup"><span data-stu-id="0e188-103">Perform inner joins</span></span>

<span data-ttu-id="0e188-104">Em termos de banco de dados relacionais, uma *junção interna* produz um conjunto de resultados no qual cada elemento da primeira coleção aparece uma vez para todo elemento correspondente na segunda coleção.</span><span class="sxs-lookup"><span data-stu-id="0e188-104">In relational database terms, an *inner join* produces a result set in which each element of the first collection appears one time for every matching element in the second collection.</span></span> <span data-ttu-id="0e188-105">Se um elemento na primeira coleção não tiver nenhum elemento correspondente, ele não aparece no conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="0e188-105">If an element in the first collection has no matching elements, it does not appear in the result set.</span></span> <span data-ttu-id="0e188-106">O método <xref:System.Linq.Enumerable.Join%2A>, que é chamado pela cláusula `join` no C#, implementa uma junção interna.</span><span class="sxs-lookup"><span data-stu-id="0e188-106">The <xref:System.Linq.Enumerable.Join%2A> method, which is called by the `join` clause in C#, implements an inner join.</span></span>  
  
 <span data-ttu-id="0e188-107">Este tópico mostra como executar quatro variações de uma junção interna:</span><span class="sxs-lookup"><span data-stu-id="0e188-107">This topic shows you how to perform four variations of an inner join:</span></span>  
  
-   <span data-ttu-id="0e188-108">Uma junção interna simples que correlaciona os elementos de duas fontes de dados com base em uma chave simples.</span><span class="sxs-lookup"><span data-stu-id="0e188-108">A simple inner join that correlates elements from two data sources based on a simple key.</span></span>  
  
-   <span data-ttu-id="0e188-109">Uma junção interna simples que correlaciona os elementos de duas fontes de dados com base em uma chave *composta*.</span><span class="sxs-lookup"><span data-stu-id="0e188-109">An inner join that correlates elements from two data sources based on a *composite* key.</span></span> <span data-ttu-id="0e188-110">Uma chave composta, que é uma chave que consiste em mais de um valor, permite que você correlacione os elementos com base em mais de uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="0e188-110">A composite key, which is a key that consists of more than one value, enables you to correlate elements based on more than one property.</span></span>  
  
-   <span data-ttu-id="0e188-111">Uma *junção múltipla* na qual operações join sucessivas são acrescentadas umas às outras.</span><span class="sxs-lookup"><span data-stu-id="0e188-111">A *multiple join* in which successive join operations are appended to each other.</span></span>  
  
-   <span data-ttu-id="0e188-112">Uma junção interna que é implementada por meio de uma junção de grupo.</span><span class="sxs-lookup"><span data-stu-id="0e188-112">An inner join that is implemented by using a group join.</span></span>  
  
## <a name="example"></a><span data-ttu-id="0e188-113">Exemplo</span><span class="sxs-lookup"><span data-stu-id="0e188-113">Example</span></span>  
  
## <a name="simple-key-join-example"></a><span data-ttu-id="0e188-114">Exemplo de junção de chave simples</span><span class="sxs-lookup"><span data-stu-id="0e188-114">Simple key join example</span></span>  
 <span data-ttu-id="0e188-115">O exemplo a seguir cria duas coleções que contêm objetos de dois tipos definidos pelo usuário, `Person` e `Pet`.</span><span class="sxs-lookup"><span data-stu-id="0e188-115">The following example creates two collections that contain objects of two user-defined types, `Person` and `Pet`.</span></span> <span data-ttu-id="0e188-116">A consulta usa a cláusula `join` em C# para corresponder objetos `Person` com objetos `Pet` cujo `Owner` é `Person`.</span><span class="sxs-lookup"><span data-stu-id="0e188-116">The query uses the `join` clause in C# to match `Person` objects with `Pet` objects whose `Owner` is that `Person`.</span></span> <span data-ttu-id="0e188-117">A cláusula `select` em C# define a aparência dos objetos resultantes.</span><span class="sxs-lookup"><span data-stu-id="0e188-117">The `select` clause in C# defines how the resulting objects will look.</span></span> <span data-ttu-id="0e188-118">Neste exemplo, os objetos resultantes são tipos anônimos que consistem no nome do proprietário e no nome do animal de estimação.</span><span class="sxs-lookup"><span data-stu-id="0e188-118">In this example the resulting objects are anonymous types that consist of the owner's first name and the pet's name.</span></span>  
  
 [!code-csharp[CsLINQProgJoining#1](../../../samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_1.cs)]  
  
 <span data-ttu-id="0e188-119">Observe que o objeto `Person` cujo `LastName` é "Huff" não aparecerá no conjunto de resultados porque não há nenhum objeto `Pet` que tenha `Pet.Owner` igual a esse `Person`.</span><span class="sxs-lookup"><span data-stu-id="0e188-119">Note that the `Person` object whose `LastName` is "Huff" does not appear in the result set because there is no `Pet` object that has `Pet.Owner` equal to that `Person`.</span></span>  
  
## <a name="example"></a><span data-ttu-id="0e188-120">Exemplo</span><span class="sxs-lookup"><span data-stu-id="0e188-120">Example</span></span>  
  
## <a name="composite-key-join-example"></a><span data-ttu-id="0e188-121">Exemplo de junção de chave composta</span><span class="sxs-lookup"><span data-stu-id="0e188-121">Composite key join example</span></span>  
 <span data-ttu-id="0e188-122">Em vez de correlacionar os elementos com base em apenas uma propriedade, você pode usar uma chave composta para comparar elementos com base em várias propriedades.</span><span class="sxs-lookup"><span data-stu-id="0e188-122">Instead of correlating elements based on just one property, you can use a composite key to compare elements based on multiple properties.</span></span> <span data-ttu-id="0e188-123">Para fazer isso, especifique a função de seletor de chave para cada coleção retornar um tipo anônimo que consiste nas propriedades que você deseja comparar.</span><span class="sxs-lookup"><span data-stu-id="0e188-123">To do this, specify the key selector function for each collection to return an anonymous type that consists of the properties you want to compare.</span></span> <span data-ttu-id="0e188-124">Se você rotular as propriedades, elas devem ter o mesmo rótulo no tipo anônimo cada chave.</span><span class="sxs-lookup"><span data-stu-id="0e188-124">If you label the properties, they must have the same label in each key's anonymous type.</span></span> <span data-ttu-id="0e188-125">As propriedades também devem aparecer na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="0e188-125">The properties must also appear in the same order.</span></span>  
  
 <span data-ttu-id="0e188-126">O exemplo a seguir usa uma lista de objetos `Employee` e uma lista de objetos `Student` para determinar quais funcionários também são alunos.</span><span class="sxs-lookup"><span data-stu-id="0e188-126">The following example uses a list of `Employee` objects and a list of `Student` objects to determine which employees are also students.</span></span> <span data-ttu-id="0e188-127">Ambos os tipos têm uma propriedade `FirstName` e uma `LastName` do tipo <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="0e188-127">Both of these types have a `FirstName` and a `LastName` property of type <xref:System.String>.</span></span> <span data-ttu-id="0e188-128">As funções que criam as chaves de junção dos elementos de cada lista retornam um tipo anônimo que consiste nas propriedades `FirstName` e `LastName` de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="0e188-128">The functions that create the join keys from each list's elements return an anonymous type that consists of the `FirstName` and `LastName` properties of each element.</span></span> <span data-ttu-id="0e188-129">A operação join compara essas chaves compostas quanto à igualdade e retorna pares de objetos de cada lista em que o nome e o sobrenome correspondem.</span><span class="sxs-lookup"><span data-stu-id="0e188-129">The join operation compares these composite keys for equality and returns pairs of objects from each list where both the first name and the last name match.</span></span>  
  
 [!code-csharp[CsLINQProgJoining#2](../../../samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_2.cs)]  
  
## <a name="example"></a><span data-ttu-id="0e188-130">Exemplo</span><span class="sxs-lookup"><span data-stu-id="0e188-130">Example</span></span>  
  
## <a name="multiple-join-example"></a><span data-ttu-id="0e188-131">Exemplo de junção múltipla</span><span class="sxs-lookup"><span data-stu-id="0e188-131">Multiple join example</span></span>  
 <span data-ttu-id="0e188-132">Qualquer número de operações join pode ser acrescentado entre si para realizar uma junção múltipla.</span><span class="sxs-lookup"><span data-stu-id="0e188-132">Any number of join operations can be appended to each other to perform a multiple join.</span></span> <span data-ttu-id="0e188-133">Cada cláusula `join` em C# correlaciona uma fonte de dados especificada com os resultados da junção anterior.</span><span class="sxs-lookup"><span data-stu-id="0e188-133">Each `join` clause in C# correlates a specified data source with the results of the previous join.</span></span>  
  
 <span data-ttu-id="0e188-134">O exemplo a seguir cria três coleções: uma lista de objetos `Person`, uma lista de objetos `Cat` e uma lista de objetos `Dog`.</span><span class="sxs-lookup"><span data-stu-id="0e188-134">The following example creates three collections: a list of `Person` objects, a list of `Cat` objects, and a list of `Dog` objects.</span></span>  
  
 <span data-ttu-id="0e188-135">A primeira cláusula `join` em C# corresponde a pessoas e gatos com base em um objeto `Person` correspondendo a `Cat.Owner`.</span><span class="sxs-lookup"><span data-stu-id="0e188-135">The first `join` clause in C# matches people and cats based on a `Person` object matching `Cat.Owner`.</span></span> <span data-ttu-id="0e188-136">Ela retorna uma sequência de tipos anônimos que contêm o objeto `Person` e `Cat.Name`.</span><span class="sxs-lookup"><span data-stu-id="0e188-136">It returns a sequence of anonymous types that contain the `Person` object and `Cat.Name`.</span></span>  
  
 <span data-ttu-id="0e188-137">A segunda cláusula `join` em C# correlaciona os tipos anônimos retornados pela primeira junção com objetos `Dog` na lista de cães fornecida, com base em uma chave composta que consiste na propriedade `Owner` do tipo `Person` e na primeira letra do nome do animal.</span><span class="sxs-lookup"><span data-stu-id="0e188-137">The second `join` clause in C# correlates the anonymous types returned by the first join with `Dog` objects in the supplied list of dogs, based on a composite key that consists of the `Owner` property of type `Person`, and the first letter of the animal's name.</span></span> <span data-ttu-id="0e188-138">Ela retorna uma sequência de tipos anônimos que contêm as propriedades `Cat.Name` e `Dog.Name` de cada par correspondente.</span><span class="sxs-lookup"><span data-stu-id="0e188-138">It returns a sequence of anonymous types that contain the `Cat.Name` and `Dog.Name` properties from each matching pair.</span></span> <span data-ttu-id="0e188-139">Como esta é uma junção interna, apenas os objetos da primeira fonte de dados que têm uma correspondência na segunda fonte de dados são retornados.</span><span class="sxs-lookup"><span data-stu-id="0e188-139">Because this is an inner join, only those objects from the first data source that have a match in the second data source are returned.</span></span>  
  
 [!code-csharp[CsLINQProgJoining#3](../../../samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_3.cs)]  
  
## <a name="example"></a><span data-ttu-id="0e188-140">Exemplo</span><span class="sxs-lookup"><span data-stu-id="0e188-140">Example</span></span>  
  
## <a name="inner-join-by-using-grouped-join-example"></a><span data-ttu-id="0e188-141">Junção interna usando o exemplo de junção agrupada</span><span class="sxs-lookup"><span data-stu-id="0e188-141">Inner join by using grouped join example</span></span>  
 <span data-ttu-id="0e188-142">O exemplo a seguir mostra como implementar uma junção interna usando uma junção de grupo.</span><span class="sxs-lookup"><span data-stu-id="0e188-142">The following example shows you how to implement an inner join by using a group join.</span></span>  
  
 <span data-ttu-id="0e188-143">Em `query1`, a lista de objetos `Person` é unida por grupo à lista de objetos `Pet` com base no `Person` correspondente à propriedade `Pet.Owner`.</span><span class="sxs-lookup"><span data-stu-id="0e188-143">In `query1`, the list of `Person` objects is group-joined to the list of `Pet` objects based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="0e188-144">A junção de grupo cria uma coleção de grupos intermediários, em que cada grupo é composto por um objeto `Person` e uma sequência de objetos `Pet` correspondentes.</span><span class="sxs-lookup"><span data-stu-id="0e188-144">The group join creates a collection of intermediate groups, where each group consists of a `Person` object and a sequence of matching `Pet` objects.</span></span>  
  
 <span data-ttu-id="0e188-145">Ao adicionar uma segunda cláusula `from` à consulta, essa sequência de sequências é combinada (ou mesclada) na sequência mais longa.</span><span class="sxs-lookup"><span data-stu-id="0e188-145">By adding a second `from` clause to the query, this sequence of sequences is combined (or flattened) into one longer sequence.</span></span> <span data-ttu-id="0e188-146">O tipo dos elementos da sequência de final é especificado pela cláusula `select`.</span><span class="sxs-lookup"><span data-stu-id="0e188-146">The type of the elements of the final sequence is specified by the `select` clause.</span></span> <span data-ttu-id="0e188-147">Neste exemplo, o tipo é um tipo anônimo que consiste nas propriedades `Person.FirstName` e `Pet.Name` para cada par correspondente.</span><span class="sxs-lookup"><span data-stu-id="0e188-147">In this example, that type is an anonymous type that consists of the `Person.FirstName` and `Pet.Name` properties for each matching pair.</span></span>  
  
 <span data-ttu-id="0e188-148">O resultado de `query1` é equivalente ao conjunto de resultados que seria obtido usando a cláusula `join` sem a cláusula `into` para realizar uma junção interna.</span><span class="sxs-lookup"><span data-stu-id="0e188-148">The result of `query1` is equivalent to the result set that would have been obtained by using the `join` clause without the `into` clause to perform an inner join.</span></span> <span data-ttu-id="0e188-149">A variável `query2` demonstra essa consulta equivalente.</span><span class="sxs-lookup"><span data-stu-id="0e188-149">The `query2` variable demonstrates this equivalent query.</span></span>  
  
 [!code-csharp[CsLINQProgJoining#4](../../../samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_4.cs)]  
  
## <a name="see-also"></a><span data-ttu-id="0e188-150">Consulte também</span><span class="sxs-lookup"><span data-stu-id="0e188-150">See also</span></span>  
 <xref:System.Linq.Enumerable.Join%2A>  
 <xref:System.Linq.Enumerable.GroupJoin%2A>  
 [<span data-ttu-id="0e188-151">Executar junções agrupadas</span><span class="sxs-lookup"><span data-stu-id="0e188-151">Perform grouped joins</span></span>](perform-grouped-joins.md)  
 [<span data-ttu-id="0e188-152">Executar junções externas esquerdas</span><span class="sxs-lookup"><span data-stu-id="0e188-152">Perform left outer joins</span></span>](perform-left-outer-joins.md)  
 [<span data-ttu-id="0e188-153">Tipos anônimos</span><span class="sxs-lookup"><span data-stu-id="0e188-153">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)  
 
