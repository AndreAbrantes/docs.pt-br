---
title: Semântica de referência com tipos de valores
description: Compreenda os recursos de linguagem que minimizam, com segurança, a cópia de estruturas
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="4ba73-103">Semântica de referência com tipos de valores</span><span class="sxs-lookup"><span data-stu-id="4ba73-103">Reference semantics with value types</span></span>

<span data-ttu-id="4ba73-104">Uma vantagem de usar os tipos de valor é que eles normalmente evitam alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="4ba73-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="4ba73-105">A desvantagem é que eles são copiados por valor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="4ba73-106">Essa compensação dificulta a otimização de algoritmos que operam em grandes quantidades de dados.</span><span class="sxs-lookup"><span data-stu-id="4ba73-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="4ba73-107">Os novos recursos de linguagem em C# 7.2 fornecem mecanismos que habilitam a semântica de transmissão por referência com tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="4ba73-108">Use esses recursos criteriosamente para minimizar tanto as alocações quanto as operações de cópia.</span><span class="sxs-lookup"><span data-stu-id="4ba73-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="4ba73-109">Este artigo explora esses novos recursos.</span><span class="sxs-lookup"><span data-stu-id="4ba73-109">This article explores those new features.</span></span>

<span data-ttu-id="4ba73-110">Grande parte do código de exemplo neste artigo demonstra os recursos adicionados em C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="4ba73-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="4ba73-111">Para usar esses recursos, você deve configurar seu projeto para usar o C# 7.2 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="4ba73-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="4ba73-112">Você pode usar o Visual Studio para selecioná-lo.</span><span class="sxs-lookup"><span data-stu-id="4ba73-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="4ba73-113">Para cada projeto, selecione **Projeto** no menu e, em seguida, **Propriedades**.</span><span class="sxs-lookup"><span data-stu-id="4ba73-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="4ba73-114">Selecione a guia **Compilar** e clique em **Avançado**.</span><span class="sxs-lookup"><span data-stu-id="4ba73-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="4ba73-115">Nesse local, configure a versão da linguagem.</span><span class="sxs-lookup"><span data-stu-id="4ba73-115">From there, configure the language version.</span></span> <span data-ttu-id="4ba73-116">Escolha “7.2” ou “mais recente”.</span><span class="sxs-lookup"><span data-stu-id="4ba73-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="4ba73-117">Ou você pode editar o arquivo *csproj* e adicionar o seguinte nó:</span><span class="sxs-lookup"><span data-stu-id="4ba73-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="4ba73-118">Você pode usar “7.2” ou “mais recente” para o valor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="4ba73-119">Passando argumentos por referência readonly</span><span class="sxs-lookup"><span data-stu-id="4ba73-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="4ba73-120">O C# 7.2 adiciona a palavra-chave `in` para complementar as palavras-chave `ref` e `out` existente a fim de passar argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="4ba73-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="4ba73-121">A palavra-chave `in` especifica ao passar o argumento por referência, mas o método chamado não modifica o valor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="4ba73-122">Essa adição fornece um vocabulário completo para expressar sua intenção de design.</span><span class="sxs-lookup"><span data-stu-id="4ba73-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="4ba73-123">Os tipos de valor são copiados no momento em que são passados para um método chamado quando você não especifica nenhum dos modificadores a seguir na assinatura do método.</span><span class="sxs-lookup"><span data-stu-id="4ba73-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="4ba73-124">Cada um desses modificadores especifica que um tipo de valor é transmitido por referência, evitando a cópia.</span><span class="sxs-lookup"><span data-stu-id="4ba73-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="4ba73-125">Cada modificador expressa uma intenção diferente:</span><span class="sxs-lookup"><span data-stu-id="4ba73-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="4ba73-126">`out`: esse método define o valor do argumento usado como este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="4ba73-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="4ba73-127">`ref`: esse método pode definir o valor do argumento usado como este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="4ba73-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="4ba73-128">`in`: esse método não modifica o valor do argumento usado como este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="4ba73-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="4ba73-129">Adicione o modificador `in` para passar um argumento por referência e declare que sua intenção de design é passar argumentos por referência para evitar cópias desnecessárias.</span><span class="sxs-lookup"><span data-stu-id="4ba73-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="4ba73-130">Você não pretende modificar o objeto utilizado como aquele argumento.</span><span class="sxs-lookup"><span data-stu-id="4ba73-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="4ba73-131">O código a seguir mostra um exemplo de um método que calcula a distância entre dois pontos no espaço 3D.</span><span class="sxs-lookup"><span data-stu-id="4ba73-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="4ba73-132">Os argumentos são duas estruturas que contêm três duplas.</span><span class="sxs-lookup"><span data-stu-id="4ba73-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="4ba73-133">Uma dupla tem 8 bytes. Então, cada argumento tem 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="4ba73-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="4ba73-134">Ao especificar o modificador `in`, você passa uma referência de 4 ou 8 bytes para esses argumentos, dependendo da arquitetura do computador.</span><span class="sxs-lookup"><span data-stu-id="4ba73-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="4ba73-135">A diferença no tamanho é pequena, mas ela pode aumentar rapidamente quando o aplicativo chama esse método em um loop estreito, usando muitos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="4ba73-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="4ba73-136">O modificador `in` complementa `out` e `ref` de outras formas também.</span><span class="sxs-lookup"><span data-stu-id="4ba73-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="4ba73-137">Não é possível criar sobrecargas de um método que diferem somente na presença de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="4ba73-138">Essas novas regras apresentam o mesmo comportamento que sempre foi definido para os parâmetros `out` e `ref`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="4ba73-139">O modificador `in` pode ser aplicado a qualquer membro que usa os seguintes parâmetros: métodos, delegados, lambdas, funções locais, indexadores e operadores.</span><span class="sxs-lookup"><span data-stu-id="4ba73-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="4ba73-140">Ao contrário dos argumentos `ref` e `out`, você pode usar valores literais ou constantes para o argumento em um parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="4ba73-141">Além disso, ao contrário de um parâmetro `ref` ou `out`, você não precisa aplicar o modificador `in` no local da chamada.</span><span class="sxs-lookup"><span data-stu-id="4ba73-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="4ba73-142">O código a seguir mostra dois exemplos para chamar o método `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="4ba73-143">O primeiro usa duas variáveis locais transmitidas por referência.</span><span class="sxs-lookup"><span data-stu-id="4ba73-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="4ba73-144">O segundo inclui uma variável temporária criada como parte da chamada de método.</span><span class="sxs-lookup"><span data-stu-id="4ba73-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="4ba73-145">Há várias maneiras pelas quais o compilador garante que a natureza somente leitura de um argumento `in` será aplicada.</span><span class="sxs-lookup"><span data-stu-id="4ba73-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="4ba73-146">Em primeiro lugar, o método chamado não pode ser atribuído diretamente a um parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="4ba73-147">Não é possível atribuí-lo diretamente a nenhum campo de um parâmetro `in` quando esse valor é um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="4ba73-148">Além disso, você não pode passar um parâmetro `in` para nenhum método usando o modificador `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="4ba73-149">Essas regras se aplicam a qualquer campo de um parâmetro `in`, considerando que o campo seja um tipo `struct` e o parâmetro também seja um tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="4ba73-150">Na verdade, essas regras são aplicadas a várias camadas de acesso de membro, considerando que os tipos, em todos os níveis de acesso de membro, sejam `structs`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="4ba73-151">O compilador impõe que os tipos `struct` passados como argumentos `in` e seus membros `struct` sejam variáveis somente leitura quando usados como argumentos para outros métodos.</span><span class="sxs-lookup"><span data-stu-id="4ba73-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="4ba73-152">O uso de parâmetros `in` evita os possíveis custos de desempenho com a realização de cópias.</span><span class="sxs-lookup"><span data-stu-id="4ba73-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="4ba73-153">Isso não altera a semântica de nenhuma chamada de método.</span><span class="sxs-lookup"><span data-stu-id="4ba73-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="4ba73-154">Portanto, você não precisa especificar o modificador `in` no site de chamada.</span><span class="sxs-lookup"><span data-stu-id="4ba73-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="4ba73-155">No entanto, a omissão do modificador `in` no site de chamada informa ao compilador que ele tem permissão para fazer uma cópia do argumento pelos seguintes motivos:</span><span class="sxs-lookup"><span data-stu-id="4ba73-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="4ba73-156">Há uma conversão implícita, mas não uma conversão de identidade do tipo de argumento para o tipo de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="4ba73-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="4ba73-157">O argumento é uma expressão, mas não tem uma variável de armazenamento conhecida.</span><span class="sxs-lookup"><span data-stu-id="4ba73-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="4ba73-158">Há uma sobrecarga que é distinguível pela presença ou ausência de `in`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="4ba73-159">Nesse caso, a sobrecarga pelo valor é uma correspondência melhor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="4ba73-160">Essas regras são úteis conforme você atualiza o código existente para usar argumentos de referência somente leitura.</span><span class="sxs-lookup"><span data-stu-id="4ba73-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="4ba73-161">Dentro do método chamado, você pode chamar qualquer método de instância que use parâmetros por valor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="4ba73-162">Nessas instâncias, uma cópia do parâmetro `in` é criada.</span><span class="sxs-lookup"><span data-stu-id="4ba73-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="4ba73-163">Uma vez que o compilador pode criar uma variável temporária para qualquer parâmetro `in`, você também pode especificar valores padrão para qualquer parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="4ba73-164">O código a seguir especifica a origem (ponto 0,0) como o valor padrão para o segundo ponto:</span><span class="sxs-lookup"><span data-stu-id="4ba73-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="4ba73-165">Para forçar o compilador a passar argumentos somente leitura por referência, especifique o modificador `in` nos argumentos no site de chamada, conforme mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="4ba73-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="4ba73-166">Esse comportamento facilita a adoção de parâmetros `in` ao longo do tempo nas grandes bases de código em que os ganhos de desempenho são possíveis.</span><span class="sxs-lookup"><span data-stu-id="4ba73-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="4ba73-167">Primeiro você adiciona o modificador `in` às assinaturas de método.</span><span class="sxs-lookup"><span data-stu-id="4ba73-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="4ba73-168">Em seguida, você adiciona o modificador `in` em sites de chamada e cria tipos `readonly struct` para evitar que o compilador crie cópias de defesa de parâmetros `in` em mais locais.</span><span class="sxs-lookup"><span data-stu-id="4ba73-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="4ba73-169">A designação do parâmetro `in` também pode ser usada com tipos de referência ou valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="4ba73-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="4ba73-170">No entanto, os benefícios em ambos os casos serão mínimos, se houver.</span><span class="sxs-lookup"><span data-stu-id="4ba73-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="4ba73-171">Retornos de `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="4ba73-171">`ref readonly` returns</span></span>

<span data-ttu-id="4ba73-172">Talvez você queira retornar um tipo de valor por referência, mas impedir o autor da chamada de modificar esse valor.</span><span class="sxs-lookup"><span data-stu-id="4ba73-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="4ba73-173">Use o modificador `ref readonly` para expressar essa intenção de design.</span><span class="sxs-lookup"><span data-stu-id="4ba73-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="4ba73-174">Ela notifica os leitores que você está retornando uma referência aos dados existentes, mas não está permitindo a modificação.</span><span class="sxs-lookup"><span data-stu-id="4ba73-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="4ba73-175">O compilador impõe que o autor da chamada não pode modificar a referência.</span><span class="sxs-lookup"><span data-stu-id="4ba73-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="4ba73-176">As tentativas de atribuir o valor diretamente geram um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4ba73-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="4ba73-177">No entanto, o compilador não pode saber se algum método de membro modifica o estado da estrutura.</span><span class="sxs-lookup"><span data-stu-id="4ba73-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="4ba73-178">Para garantir que o objeto não será modificado, o compilador cria uma cópia e chama as referências de membro usando essa cópia.</span><span class="sxs-lookup"><span data-stu-id="4ba73-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="4ba73-179">Todas as modificações são para essa cópia de defesa.</span><span class="sxs-lookup"><span data-stu-id="4ba73-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="4ba73-180">É provável que a biblioteca que utiliza o `Point3D` normalmente usaria a origem em todo o código.</span><span class="sxs-lookup"><span data-stu-id="4ba73-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="4ba73-181">Cada instância cria um novo objeto na pilha.</span><span class="sxs-lookup"><span data-stu-id="4ba73-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="4ba73-182">Pode ser vantajoso criar uma constante e retorná-la por referência.</span><span class="sxs-lookup"><span data-stu-id="4ba73-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="4ba73-183">Mas, se retornar uma referência ao armazenamento interno, talvez você queira impor que o autor da chamada não poderá modificar o armazenamento referenciado.</span><span class="sxs-lookup"><span data-stu-id="4ba73-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="4ba73-184">O código a seguir define uma propriedade somente leitura que retorna um `readonly ref` para um `Point3D` que especifica a origem.</span><span class="sxs-lookup"><span data-stu-id="4ba73-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="4ba73-185">É fácil criar uma cópia de um retorno da referência somente leitura: basta atribui-la a uma variável não declarada com o modificador `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="4ba73-186">O compilador gera um código para copiar o objeto como parte da atribuição.</span><span class="sxs-lookup"><span data-stu-id="4ba73-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="4ba73-187">Ao atribuir uma variável a um `ref readonly return`, você pode especificar uma variável `ref readonly` ou uma cópia por valor da referência somente leitura:</span><span class="sxs-lookup"><span data-stu-id="4ba73-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="4ba73-188">A primeira atribuição no código anterior faz uma cópia da constante `Origin` e atribui essa cópia.</span><span class="sxs-lookup"><span data-stu-id="4ba73-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="4ba73-189">A segunda atribui uma referência.</span><span class="sxs-lookup"><span data-stu-id="4ba73-189">The second assigns a reference.</span></span> <span data-ttu-id="4ba73-190">Observe que o modificador `readonly` deve ser parte da declaração da variável.</span><span class="sxs-lookup"><span data-stu-id="4ba73-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="4ba73-191">A referência à qual ele se relaciona não pode ser modificada.</span><span class="sxs-lookup"><span data-stu-id="4ba73-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="4ba73-192">As tentativas de modificá-la resultam em um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="4ba73-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="4ba73-193">Tipo `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="4ba73-193">`readonly struct` type</span></span>

<span data-ttu-id="4ba73-194">A aplicação do `ref readonly` para usos de tráfego intenso de um struct pode ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="4ba73-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="4ba73-195">Em outros momentos, talvez você queira criar um struct imutável.</span><span class="sxs-lookup"><span data-stu-id="4ba73-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="4ba73-196">Então, você sempre poderá passar pela referência somente leitura.</span><span class="sxs-lookup"><span data-stu-id="4ba73-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="4ba73-197">Essa prática remove a cópia de defesa que é feita quando você acessa os métodos de um struct usado como um parâmetro `in`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="4ba73-198">Você pode fazer isso criando um tipo `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="4ba73-199">Você pode adicionar o modificador `readonly` em uma declaração de struct.</span><span class="sxs-lookup"><span data-stu-id="4ba73-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="4ba73-200">O compilador impõe que todos os membros de instância do struct são `readonly`; o `struct` deve ser imutável.</span><span class="sxs-lookup"><span data-stu-id="4ba73-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="4ba73-201">Há outras otimizações para um `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="4ba73-202">Você pode usar o modificador `in` em todos os locais em que um `readonly struct` é um argumento.</span><span class="sxs-lookup"><span data-stu-id="4ba73-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="4ba73-203">Além disso, você pode retornar um `readonly struct` como um `ref return` quando estiver devolvendo um objeto cujo tempo de vida se estende para além do escopo do método que retorna o objeto.</span><span class="sxs-lookup"><span data-stu-id="4ba73-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="4ba73-204">Por fim, o compilador gera um código mais eficiente quando você chama membros de um `readonly struct`: a referência `this`, em vez de uma cópia do destinatário, é sempre um parâmetro `in` transmitido por referência para o método de membro.</span><span class="sxs-lookup"><span data-stu-id="4ba73-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="4ba73-205">Essa otimização economiza mais cópias quando você usa um `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="4ba73-206">O `Point3D` é um ótimo candidato para essa alteração.</span><span class="sxs-lookup"><span data-stu-id="4ba73-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="4ba73-207">O código a seguir mostra uma estrutura `ReadonlyPoint3D` atualizada:</span><span class="sxs-lookup"><span data-stu-id="4ba73-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="4ba73-208">Tipo `ref struct`</span><span class="sxs-lookup"><span data-stu-id="4ba73-208">`ref struct` type</span></span>

<span data-ttu-id="4ba73-209">Outro recurso de linguagem relacionado é a capacidade de declarar um tipo de valor que deve ser alocado por pilha.</span><span class="sxs-lookup"><span data-stu-id="4ba73-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="4ba73-210">Em outras palavras, esses tipos nunca podem ser criados no heap como um membro de outra classe.</span><span class="sxs-lookup"><span data-stu-id="4ba73-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="4ba73-211">A principal motivação para esse recurso foi <xref:System.Span%601> e as estruturas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="4ba73-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="4ba73-212">O <xref:System.Span%601> pode conter um ponteiro gerenciado como um de seus membros, sendo o outro o comprimento da extensão.</span><span class="sxs-lookup"><span data-stu-id="4ba73-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="4ba73-213">Ele é implementado de modo um pouco diferente porque o C# não é compatível com ponteiros para memória gerenciada fora de um contexto sem segurança.</span><span class="sxs-lookup"><span data-stu-id="4ba73-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="4ba73-214">Qualquer gravação que altere o ponteiro e o comprimento não é atômica.</span><span class="sxs-lookup"><span data-stu-id="4ba73-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="4ba73-215">Isso significa que um <xref:System.Span%601> estaria sujeito a erros fora do intervalo ou a outras violações de segurança do tipo se não fosse restrito a um único registro de ativação.</span><span class="sxs-lookup"><span data-stu-id="4ba73-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="4ba73-216">Além disso, colocar um ponteiro gerenciado no heap de GC normalmente ocasiona uma falha no tempo de JIT.</span><span class="sxs-lookup"><span data-stu-id="4ba73-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="4ba73-217">Você pode ter requisitos semelhantes funcionando com a memória criada usando [`stackalloc`](language-reference/keywords/stackalloc.md) ou ao usar a memória das APIs de interoperabilidade.</span><span class="sxs-lookup"><span data-stu-id="4ba73-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="4ba73-218">Você pode definir seus próprios tipos `ref struct` para essas necessidades.</span><span class="sxs-lookup"><span data-stu-id="4ba73-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="4ba73-219">Neste artigo, você verá exemplos que usam `Span<T>` para manter a simplicidade.</span><span class="sxs-lookup"><span data-stu-id="4ba73-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="4ba73-220">A declaração `ref struct` declara que um struct desse tipo deve estar na pilha.</span><span class="sxs-lookup"><span data-stu-id="4ba73-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="4ba73-221">As regras da linguagem garantem o uso seguro desses tipos.</span><span class="sxs-lookup"><span data-stu-id="4ba73-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="4ba73-222">Outros tipos declarados como `ref struct` incluem <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="4ba73-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="4ba73-223">A meta de manter um tipo `ref struct` como uma variável alocada na pilha apresenta várias regras que o compilador aplica para todos os tipos `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="4ba73-224">Você não pode encaixotar um `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="4ba73-225">Você não pode atribuir um tipo `ref struct` a uma variável do tipo `object`, `dynamic` ou de qualquer tipo de interface.</span><span class="sxs-lookup"><span data-stu-id="4ba73-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="4ba73-226">Você não pode declarar um `ref struct` como um membro de uma classe ou de um struct normal.</span><span class="sxs-lookup"><span data-stu-id="4ba73-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="4ba73-227">Você não pode declarar variáveis locais que são do tipo `ref struct` em métodos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="4ba73-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="4ba73-228">Você pode declará-las em métodos síncronos que retornam `Task`, `Task<T>` ou tipos semelhantes à tarefa.</span><span class="sxs-lookup"><span data-stu-id="4ba73-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="4ba73-229">Você não pode declarar as variáveis locais `ref struct` em iteradores.</span><span class="sxs-lookup"><span data-stu-id="4ba73-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="4ba73-230">Você não pode capturar as variáveis `ref struct` em expressões lambda ou em funções locais.</span><span class="sxs-lookup"><span data-stu-id="4ba73-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="4ba73-231">Essas restrições garantem que você não use acidentalmente um `ref struct` de maneira que possa promovê-lo para o heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="4ba73-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="4ba73-232">Tipo `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="4ba73-232">`readonly ref struct` type</span></span>

<span data-ttu-id="4ba73-233">A declaração de um struct como `readonly ref` combina os benefícios e as restrições das declarações `ref struct` e `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="4ba73-234">O seguinte exemplo demonstra a declaração de `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="4ba73-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="4ba73-235">Conclusões</span><span class="sxs-lookup"><span data-stu-id="4ba73-235">Conclusions</span></span>

<span data-ttu-id="4ba73-236">Esses aprimoramentos para a linguagem C# são projetados para algoritmos de desempenho importantes, nos quais as alocações de memória podem ser fundamentais para alcançar o desempenho necessário.</span><span class="sxs-lookup"><span data-stu-id="4ba73-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="4ba73-237">Você pode achar que geralmente não usa esses recursos no código que grava.</span><span class="sxs-lookup"><span data-stu-id="4ba73-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="4ba73-238">No entanto, esses aprimoramentos foram adotados em vários locais no .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4ba73-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="4ba73-239">À medida que mais e mais APIs utilizam esses recursos, você verá o desempenho de seus próprios aplicativos melhorar.</span><span class="sxs-lookup"><span data-stu-id="4ba73-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
