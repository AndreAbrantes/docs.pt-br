---
title: "Semântica de referência com tipos de valor"
description: "Compreender os recursos de idioma que minimiza as estruturas de cópias com segurança"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="74776-103">Semântica de referência com tipos de valor</span><span class="sxs-lookup"><span data-stu-id="74776-103">Reference semantics with value types</span></span>

<span data-ttu-id="74776-104">Uma vantagem de usar tipos de valor é que eles normalmente evitam alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="74776-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="74776-105">A desvantagem correspondente é que eles são copiados por valor.</span><span class="sxs-lookup"><span data-stu-id="74776-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="74776-106">Essa compensação dificulta a otimizar os algoritmos que operam em grandes quantidades de dados.</span><span class="sxs-lookup"><span data-stu-id="74776-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="74776-107">Novos recursos de linguagem c# 7.2 fornecem mecanismos que permitem a semântica de passagem-por-referência com tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="74776-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="74776-108">Se você usar esses recursos criteriosamente pode minimizar a ambas as alocações e operações de cópia.</span><span class="sxs-lookup"><span data-stu-id="74776-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="74776-109">Este artigo explora esses novos recursos.</span><span class="sxs-lookup"><span data-stu-id="74776-109">This article explores those new features.</span></span>

<span data-ttu-id="74776-110">Grande parte do código de exemplo neste artigo demonstra os recursos adicionados no c# 7.2.</span><span class="sxs-lookup"><span data-stu-id="74776-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="74776-111">Para usar esses recursos, você precisa configurar seu projeto para usar o c# 7.2 ou posterior em seu projeto.</span><span class="sxs-lookup"><span data-stu-id="74776-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="74776-112">Você pode usar o Visual Studio para selecioná-la.</span><span class="sxs-lookup"><span data-stu-id="74776-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="74776-113">Para cada projeto, selecione **projeto** no menu, em seguida, **propriedades**.</span><span class="sxs-lookup"><span data-stu-id="74776-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="74776-114">Selecione o **criar** guia e clique em **avançado**.</span><span class="sxs-lookup"><span data-stu-id="74776-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="74776-115">A partir daí, você pode configurar a versão de idioma.</span><span class="sxs-lookup"><span data-stu-id="74776-115">From there, you can configure the language version.</span></span> <span data-ttu-id="74776-116">Escolha "7.2" ou "mais recente".</span><span class="sxs-lookup"><span data-stu-id="74776-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="74776-117">Ou você pode editar o *csproj* e adicione o seguinte nó:</span><span class="sxs-lookup"><span data-stu-id="74776-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="74776-118">Você pode usar "7.2" ou "mais recente" para o valor.</span><span class="sxs-lookup"><span data-stu-id="74776-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="74776-119">Especificando `in` parâmetros</span><span class="sxs-lookup"><span data-stu-id="74776-119">Specifying `in` parameters</span></span>

<span data-ttu-id="74776-120">7.2 c# adiciona o `in` palavra-chave para complementar existente `ref` e `out` palavras-chave quando você escreve um método que passa os argumentos por referência.</span><span class="sxs-lookup"><span data-stu-id="74776-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="74776-121">O `in` palavra-chave especifica que você está passando o parâmetro por referência e o método chamado não modifica o valor passado para ele.</span><span class="sxs-lookup"><span data-stu-id="74776-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="74776-122">Essa adição fornece um vocabulário completo para expressar sua intenção de design.</span><span class="sxs-lookup"><span data-stu-id="74776-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="74776-123">Tipos de valor são copiados quando passados para um método chamado quando você não especificar qualquer um dos seguintes modificadores.</span><span class="sxs-lookup"><span data-stu-id="74776-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="74776-124">Cada um desses modificadores de especificar se um tipo de valor é passado por referência, evitando a cópia.</span><span class="sxs-lookup"><span data-stu-id="74776-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="74776-125">Cada modificador expressa um propósito diferente:</span><span class="sxs-lookup"><span data-stu-id="74776-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="74776-126">`out`: Esse método define o valor do argumento usado como esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="74776-127">`ref`: Esse método pode definir o valor do argumento usado como esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="74776-128">`in`: Esse método não modifica o valor do argumento usado como esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="74776-129">Quando você adiciona o `in` modificador para passar um argumento por referência, você declarar sua intenção de design é passar argumentos por referência para evitar a cópia desnecessários.</span><span class="sxs-lookup"><span data-stu-id="74776-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="74776-130">Você não pretende modificar o objeto usado como argumento.</span><span class="sxs-lookup"><span data-stu-id="74776-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="74776-131">O código a seguir mostra um exemplo de um método que calcula a distância entre dois pontos no espaço 3D.</span><span class="sxs-lookup"><span data-stu-id="74776-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="74776-132">Os argumentos são duas estruturas que contêm três dobras.</span><span class="sxs-lookup"><span data-stu-id="74776-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="74776-133">Um valor double é de 8 bytes, para que cada argumento é de 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="74776-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="74776-134">Especificando o `in` modificador, passar referência de 4 ou 8 bytes para esses argumentos, dependendo da arquitetura do computador.</span><span class="sxs-lookup"><span data-stu-id="74776-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="74776-135">A diferença no tamanho é pequena, mas ela pode adicionar rapidamente quando o aplicativo chama esse método em um loop estreito, usando muitos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="74776-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="74776-136">O `in` complementa modificador `out` e `ref` de outras formas também.</span><span class="sxs-lookup"><span data-stu-id="74776-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="74776-137">Não é possível criar sobrecargas de um método que diferem somente na presença de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="74776-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="74776-138">O mesmo comportamento que sempre tivesse sido definido para estendem a essas novas regras `out` e `ref` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="74776-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="74776-139">O `in` modificador pode ser aplicado a qualquer membro que usa parâmetros: métodos, delegados, lambdas, funções locais, indexadores, operadores.</span><span class="sxs-lookup"><span data-stu-id="74776-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="74776-140">Ao contrário de `ref` e `out` argumentos, você pode usar valores literais ou constantes para o argumento para uma `in` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="74776-141">Além disso, ao contrário de um `ref` ou `out` parâmetro, você não precisa aplicar o `in` modificador no site de chamada.</span><span class="sxs-lookup"><span data-stu-id="74776-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="74776-142">O código a seguir mostra dois exemplos de chamar o `CalculateDistance` método.</span><span class="sxs-lookup"><span data-stu-id="74776-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="74776-143">O primeiro usa duas variáveis locais, passadas por referência.</span><span class="sxs-lookup"><span data-stu-id="74776-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="74776-144">O segundo inclui uma variável temporária criada como parte da chamada de método.</span><span class="sxs-lookup"><span data-stu-id="74776-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="74776-145">Há várias maneiras em que o compilador garante que, a natureza de somente leitura de um `in` argumento é imposto.</span><span class="sxs-lookup"><span data-stu-id="74776-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="74776-146">Primeiro, o método chamado não pode atribuir diretamente a um `in` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="74776-147">Não é possível atribuir diretamente para qualquer campo de um `in` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="74776-148">Além disso, você não pode passar um `in` parâmetro para qualquer método exigindo o `ref` ou `out` modificador.</span><span class="sxs-lookup"><span data-stu-id="74776-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="74776-149">O compilador impõe que o `in` argumento é uma variável somente leitura.</span><span class="sxs-lookup"><span data-stu-id="74776-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="74776-150">Você pode chamar qualquer método de instância que usa semântica de passagem-por-valor.</span><span class="sxs-lookup"><span data-stu-id="74776-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="74776-151">Nesses casos, uma cópia do `in` parâmetro é criado.</span><span class="sxs-lookup"><span data-stu-id="74776-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="74776-152">Porque o compilador pode criar uma variável temporária para qualquer `in` parâmetro, você também pode especificar valores padrão para qualquer `in` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="74776-153">O código a seguir que usa para especificar a origem (0,0 ponto) como o valor padrão para o segundo ponto:</span><span class="sxs-lookup"><span data-stu-id="74776-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="74776-154">O `in` designação de parâmetro também pode ser usada com tipos de referência ou criada em valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="74776-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="74776-155">No entanto, os benefícios em ambos os casos são mínimos, se houver.</span><span class="sxs-lookup"><span data-stu-id="74776-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="74776-156">`ref readonly`Retorna</span><span class="sxs-lookup"><span data-stu-id="74776-156">`ref readonly` returns</span></span>

<span data-ttu-id="74776-157">Talvez você queira retornar um tipo de valor por referência, mas impedir que o chamador de modificar esse valor.</span><span class="sxs-lookup"><span data-stu-id="74776-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="74776-158">Use o `ref readonly` modificador para expressar essa intenção de design.</span><span class="sxs-lookup"><span data-stu-id="74776-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="74776-159">Notifica os leitores que você está retornando uma referência aos dados existentes, mas não permitir a modificação.</span><span class="sxs-lookup"><span data-stu-id="74776-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="74776-160">O compilador impõe que o chamador não é possível modificar a referência.</span><span class="sxs-lookup"><span data-stu-id="74776-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="74776-161">Tenta atribuir diretamente para o valor gerado um erro de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="74776-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="74776-162">No entanto, o compilador não pode saber se qualquer método de membro modifica o estado da estrutura.</span><span class="sxs-lookup"><span data-stu-id="74776-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="74776-163">Para garantir que o objeto não é modificado, o compilador cria uma cópia e chama o membro referências usando essa cópia.</span><span class="sxs-lookup"><span data-stu-id="74776-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="74776-164">Todas as modificações são para a cópia defesa.</span><span class="sxs-lookup"><span data-stu-id="74776-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="74776-165">É provável que a biblioteca usando `Point3D` normalmente usaria a origem em todo o código.</span><span class="sxs-lookup"><span data-stu-id="74776-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="74776-166">Cada instância cria um novo objeto na pilha.</span><span class="sxs-lookup"><span data-stu-id="74776-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="74776-167">Pode ser vantajoso para criar uma constante e retorná-lo por referência.</span><span class="sxs-lookup"><span data-stu-id="74776-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="74776-168">Mas, se você retornar uma referência ao armazenamento interno, você pode impor que o chamador não é possível modificar o armazenamento referenciado.</span><span class="sxs-lookup"><span data-stu-id="74776-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="74776-169">O código a seguir define uma propriedade somente leitura que retorna um `readonly ref` para um `Point3D` que especifica a origem.</span><span class="sxs-lookup"><span data-stu-id="74776-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="74776-170">É fácil criar uma cópia de uma ref readonly retorno: apenas o atribui a uma variável não declarada com o `ref readonly` modificador.</span><span class="sxs-lookup"><span data-stu-id="74776-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="74776-171">O compilador gera código para copiar o objeto como parte da atribuição.</span><span class="sxs-lookup"><span data-stu-id="74776-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="74776-172">Quando você atribui uma variável para um `ref readonly return`, você pode especificar um `ref readonly` variável ou uma cópia por valor da referência somente leitura:</span><span class="sxs-lookup"><span data-stu-id="74776-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="74776-173">A primeira atribuição no código anterior faz uma cópia do `Origin` constante e atribui a copia.</span><span class="sxs-lookup"><span data-stu-id="74776-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="74776-174">O segundo atribui uma referência.</span><span class="sxs-lookup"><span data-stu-id="74776-174">The second assigns a reference.</span></span> <span data-ttu-id="74776-175">Observe que o `readonly` modificador deve ser parte da declaração da variável.</span><span class="sxs-lookup"><span data-stu-id="74776-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="74776-176">A referência ao qual se refere não pode ser modificada.</span><span class="sxs-lookup"><span data-stu-id="74776-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="74776-177">Tentativas de fazer isso resultar em um erro em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="74776-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="74776-178">Tipo `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="74776-178">`readonly struct` type</span></span>

<span data-ttu-id="74776-179">Aplicando `ref readonly` para usos de alto tráfego de uma estrutura pode ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="74776-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="74776-180">Outras vezes, você talvez queira criar uma estrutura imutável.</span><span class="sxs-lookup"><span data-stu-id="74776-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="74776-181">Em seguida, você sempre pode passar por referência somente leitura.</span><span class="sxs-lookup"><span data-stu-id="74776-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="74776-182">Prática remove defensiva copia que ocorrem quando você acessa os métodos de uma estrutura usada como um `in` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="74776-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="74776-183">Você pode fazer isso criando um `readonly struct` tipo.</span><span class="sxs-lookup"><span data-stu-id="74776-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="74776-184">Você pode adicionar o `readonly` modificador para uma declaração de estrutura.</span><span class="sxs-lookup"><span data-stu-id="74776-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="74776-185">O compilador impõe que todos os membros da estrutura são `readonly`; o `struct` deve ser imutável.</span><span class="sxs-lookup"><span data-stu-id="74776-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="74776-186">Há outras otimizações para um `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="74776-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="74776-187">Você pode usar o `in` modificador em todos os locais onde um `readonly struct` é um argumento.</span><span class="sxs-lookup"><span data-stu-id="74776-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="74776-188">Além disso, você pode retornar um `readonly struct` como um `ref return` quando você estiver retornando um objeto cujo tempo de vida se estende além do escopo do método que retornar o objeto.</span><span class="sxs-lookup"><span data-stu-id="74776-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="74776-189">Por fim, o compilador gera o código mais eficiente quando você chamar membros de um `readonly struct`: O `this` referência, em vez de uma cópia do destinatário, é sempre uma `in` parâmetro passado por referência para o método de membro.</span><span class="sxs-lookup"><span data-stu-id="74776-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="74776-190">Essa otimização salva a cópia mais quando você usar um `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="74776-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="74776-191">O `Point3D` é um ótimo candidato para que essa alteração.</span><span class="sxs-lookup"><span data-stu-id="74776-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="74776-192">O código a seguir mostra um atualizada `ReadonlyPoint3D` estrutura:</span><span class="sxs-lookup"><span data-stu-id="74776-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="74776-193">Tipo `ref struct`</span><span class="sxs-lookup"><span data-stu-id="74776-193">`ref struct` type</span></span>

<span data-ttu-id="74776-194">Outro recurso de idioma relacionados é a capacidade de declarar um tipo de valor que deve ser alocada de pilha.</span><span class="sxs-lookup"><span data-stu-id="74776-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="74776-195">Em outras palavras, esses tipos nunca podem ser criados no heap como um membro de outra classe.</span><span class="sxs-lookup"><span data-stu-id="74776-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="74776-196">A principal motivação para esse recurso foi <xref:System.Span%601> e estruturas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="74776-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="74776-197"><xref:System.Span%601>pode conter um ponteiro gerenciado como um de seus membros, o outro sendo o comprimento da extensão.</span><span class="sxs-lookup"><span data-stu-id="74776-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="74776-198">Na verdade, ele é implementado um pouco diferente porque c# não dá suporte a ponteiros para memória gerenciada fora de um contexto sem segurança.</span><span class="sxs-lookup"><span data-stu-id="74776-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="74776-199">Qualquer gravação que altera o ponteiro e o comprimento não é atômica.</span><span class="sxs-lookup"><span data-stu-id="74776-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="74776-200">Isso significa que um <xref:System.Span%601> seria sujeito a erros de intervalo insuficiente ou outras violações de segurança de tipo foram ele não restrito a um único registro de ativação.</span><span class="sxs-lookup"><span data-stu-id="74776-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="74776-201">Além disso, colocar um ponteiro gerenciado no heap de GC normalmente falha no tempo de JIT.</span><span class="sxs-lookup"><span data-stu-id="74776-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="74776-202">Você pode ter requisitos semelhantes de trabalhar com memória criada usando [ `stackalloc` ](language-reference/keywords/stackalloc.md) ou ao usar a memória de APIs de interoperabilidade.</span><span class="sxs-lookup"><span data-stu-id="74776-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="74776-203">Você pode definir suas próprias `ref struct` tipos para essas necessidades.</span><span class="sxs-lookup"><span data-stu-id="74776-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="74776-204">Neste artigo, você ver exemplos que usam `Span<T>` para manter a simplicidade.</span><span class="sxs-lookup"><span data-stu-id="74776-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="74776-205">O `ref struct` declaração declara que uma estrutura desse tipo deve ser na pilha.</span><span class="sxs-lookup"><span data-stu-id="74776-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="74776-206">As regras do idioma garantem o uso seguro desses tipos.</span><span class="sxs-lookup"><span data-stu-id="74776-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="74776-207">Outros tipos declarados como `ref struct` incluem <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="74776-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="74776-208">O objetivo de manter uma `ref struct` digite como uma variável alocado na pilha apresenta várias regras que o compilador aplica para todos os `ref struct` tipos.</span><span class="sxs-lookup"><span data-stu-id="74776-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="74776-209">Não é possível caixa um `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="74776-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="74776-210">Não é possível atribuir um `ref struct` tipo a uma variável do tipo `object`, `dynamic`, ou qualquer tipo de interface.</span><span class="sxs-lookup"><span data-stu-id="74776-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="74776-211">Você não pode declarar um `ref struct` como um membro de uma classe ou uma estrutura normal.</span><span class="sxs-lookup"><span data-stu-id="74776-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="74776-212">Não é possível declarar variáveis locais que são `ref struct` tipos de métodos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="74776-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="74776-213">Você pode declará-los em métodos síncronos que retornam `Task`, `Task<T>` ou tipos de tarefas.</span><span class="sxs-lookup"><span data-stu-id="74776-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="74776-214">Você não pode declarar `ref struct` variáveis locais em iteradores.</span><span class="sxs-lookup"><span data-stu-id="74776-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="74776-215">Não é possível capturar `ref struct` variáveis em expressões lambda ou funções locais.</span><span class="sxs-lookup"><span data-stu-id="74776-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="74776-216">Essas restrições Certifique-se de que você não os use acidentalmente um `ref struct` de forma que pôde promovê-la para o heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="74776-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="74776-217">Conclusões</span><span class="sxs-lookup"><span data-stu-id="74776-217">Conclusions</span></span>

<span data-ttu-id="74776-218">Esses aprimoramentos para a linguagem c# são projetados para algoritmos críticas de desempenho onde as alocações de memória podem ser fundamentais para alcançar o desempenho necessário.</span><span class="sxs-lookup"><span data-stu-id="74776-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="74776-219">Você pode achar que muitas vezes você não usar esses recursos no código que você escrever.</span><span class="sxs-lookup"><span data-stu-id="74776-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="74776-220">No entanto, esses aprimoramentos foram adotados em vários locais no .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="74776-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="74776-221">Como fazer mais APIs utiliza esses recursos, você verá o desempenho de seus próprios aplicativos melhorar.</span><span class="sxs-lookup"><span data-stu-id="74776-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
