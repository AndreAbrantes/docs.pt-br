---
title: Árvores de Expressão Explicadas
description: Saiba mais sobre árvores de expressão e como elas são úteis em algoritmos de conversão para execução externa e inspeção do código antes de executá-lo.
ms.date: 06/20/2016
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: c5d4b2ad54fab547567d430f11a31542a11d03f3
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/28/2019
ms.locfileid: "70104804"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="e7337-103">Árvores de Expressão Explicadas</span><span class="sxs-lookup"><span data-stu-id="e7337-103">Expression Trees Explained</span></span>

[<span data-ttu-id="e7337-104">Anterior – Visão geral</span><span class="sxs-lookup"><span data-stu-id="e7337-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="e7337-105">Uma Árvore de expressão é uma estrutura de dados que define o código.</span><span class="sxs-lookup"><span data-stu-id="e7337-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="e7337-106">Elas se baseiam nas mesmas estruturas que um compilador usa para analisar o código e gerar a saída compilada.</span><span class="sxs-lookup"><span data-stu-id="e7337-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="e7337-107">Ao ler este tutorial, você notará certa semelhança entre árvores de expressão e os tipos usados nas APIs Roslyn para criar [Analyzers e CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="e7337-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="e7337-108">(Analyzers e CodeFixes são pacotes NuGet que realizam análise estática no código e podem sugerir possíveis correções para um desenvolvedor). Os conceitos são semelhantes e o resultado final é uma estrutura de dados que permite o exame do código-fonte de uma maneira significativa.</span><span class="sxs-lookup"><span data-stu-id="e7337-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="e7337-109">No entanto, as árvores de expressão são baseadas em um conjunto de classes e APIs totalmente diferente das APIs Roslyn.</span><span class="sxs-lookup"><span data-stu-id="e7337-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="e7337-110">Vejamos um exemplo simples.</span><span class="sxs-lookup"><span data-stu-id="e7337-110">Let's look at a simple example.</span></span>
<span data-ttu-id="e7337-111">Aqui está uma linha de código:</span><span class="sxs-lookup"><span data-stu-id="e7337-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="e7337-112">Se você analisar isso como uma árvore de expressão, a árvore contém vários nós.</span><span class="sxs-lookup"><span data-stu-id="e7337-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="e7337-113">O nó mais externo é uma instrução de declaração de variável com atribuição (`var sum = 1 + 2;`). Esse nó mais externo contém vários nós filho: uma declaração de variável, um operador de atribuição e uma expressão que representa o lado direito do sinal de igual.</span><span class="sxs-lookup"><span data-stu-id="e7337-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="e7337-114">Essa expressão é ainda subdividida em expressões que representam a operação de adição e os operandos esquerdo e direito da adição.</span><span class="sxs-lookup"><span data-stu-id="e7337-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="e7337-115">Vamos detalhar um pouco mais as expressões que compõem o lado direito do sinal de igual.</span><span class="sxs-lookup"><span data-stu-id="e7337-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="e7337-116">A expressão é `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="e7337-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="e7337-117">Essa é uma expressão binária.</span><span class="sxs-lookup"><span data-stu-id="e7337-117">That's a binary expression.</span></span> <span data-ttu-id="e7337-118">Mais especificamente, ela é uma expressão de adição binária.</span><span class="sxs-lookup"><span data-stu-id="e7337-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="e7337-119">Uma expressão de adição binária tem dois filhos, que representam os nós esquerdo e direito da expressão de adição.</span><span class="sxs-lookup"><span data-stu-id="e7337-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="e7337-120">Aqui, os dois nós são expressões constantes: o operando esquerdo é o valor `1` e o operando direito é o valor `2`.</span><span class="sxs-lookup"><span data-stu-id="e7337-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="e7337-121">Visualmente, a declaração inteira é uma árvore: você pode começar no nó raiz e viajar até cada nó da árvore para ver o código que constitui a instrução:</span><span class="sxs-lookup"><span data-stu-id="e7337-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="e7337-122">Instrução de declaração de variável com atribuição (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="e7337-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="e7337-123">Declaração de tipo de variável implícita (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="e7337-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="e7337-124">Palavra-chave var implícita (`var`)</span><span class="sxs-lookup"><span data-stu-id="e7337-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="e7337-125">Declaração de nome de variável (`sum`)</span><span class="sxs-lookup"><span data-stu-id="e7337-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="e7337-126">Operador de atribuição (`=`)</span><span class="sxs-lookup"><span data-stu-id="e7337-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="e7337-127">Expressão de adição binária (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="e7337-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="e7337-128">Operando esquerdo (`1`)</span><span class="sxs-lookup"><span data-stu-id="e7337-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="e7337-129">Operador de adição (`+`)</span><span class="sxs-lookup"><span data-stu-id="e7337-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="e7337-130">Operando direito (`2`)</span><span class="sxs-lookup"><span data-stu-id="e7337-130">Right operand (`2`)</span></span>

<span data-ttu-id="e7337-131">Isso pode parecer complicado, mas é muito eficiente.</span><span class="sxs-lookup"><span data-stu-id="e7337-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="e7337-132">Seguindo o mesmo processo, você pode decompor expressões muito mais complicadas.</span><span class="sxs-lookup"><span data-stu-id="e7337-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="e7337-133">Considere esta expressão:</span><span class="sxs-lookup"><span data-stu-id="e7337-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="e7337-134">A expressão acima também é uma declaração de variável com uma atribuição.</span><span class="sxs-lookup"><span data-stu-id="e7337-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="e7337-135">Neste exemplo, o lado direito da atribuição é uma árvore muito mais complicada.</span><span class="sxs-lookup"><span data-stu-id="e7337-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="e7337-136">Eu não vou decompor essa expressão, mas considere quais seriam os diferentes nós.</span><span class="sxs-lookup"><span data-stu-id="e7337-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="e7337-137">Há chamadas de método usando o objeto atual como um receptor, uma que tem um receptor `this` explicito e outra que não.</span><span class="sxs-lookup"><span data-stu-id="e7337-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="e7337-138">Há chamadas de método usando outros objetos receptores, há argumentos constantes de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="e7337-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="e7337-139">E, finalmente, há um operador de adição binária.</span><span class="sxs-lookup"><span data-stu-id="e7337-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="e7337-140">Dependendo do tipo de retorno de `SecretSauceFunction()` ou `MoreSecretSauce()`, esse operador de adição binária pode ser uma chamada de método para um operador de adição substituído, resolvendo em uma chamada de método estático ao operador de adição binária definido para uma classe.</span><span class="sxs-lookup"><span data-stu-id="e7337-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="e7337-141">Apesar dessa complexidade, a expressão acima cria uma estrutura de árvore que pode ser percorrida tão facilmente quanto o primeiro exemplo.</span><span class="sxs-lookup"><span data-stu-id="e7337-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="e7337-142">Você pode continuar percorrendo os nós filho para encontrar os nós folha na expressão.</span><span class="sxs-lookup"><span data-stu-id="e7337-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="e7337-143">Os nós pai terão referências aos filhos e cada nó tem uma propriedade que descreve o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="e7337-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="e7337-144">A estrutura de uma árvore de expressão é muito consistente.</span><span class="sxs-lookup"><span data-stu-id="e7337-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="e7337-145">Depois de aprender os conceitos básicos, você poderá entender até mesmo o código mais complexo, quando ele for representado como uma árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="e7337-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="e7337-146">A elegância na estrutura de dados explica como o compilador do C# pode analisar os programas em C# mais complexos e criar a saída apropriada desse código-fonte complicado.</span><span class="sxs-lookup"><span data-stu-id="e7337-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="e7337-147">Uma vez que estiver familiarizado com a estrutura das árvores de expressão, você descobrirá que o conhecimento adquirido permitirá que você trabalhe com muitos outros cenários ainda mais avançados.</span><span class="sxs-lookup"><span data-stu-id="e7337-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="e7337-148">Há um poder incrível nas árvores de expressão.</span><span class="sxs-lookup"><span data-stu-id="e7337-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="e7337-149">Além de mover algoritmos para serem executados em outros ambientes, as árvores de expressão podem ser usadas para tornar mais fácil escrever algoritmos que inspecionam o código antes de executá-lo.</span><span class="sxs-lookup"><span data-stu-id="e7337-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="e7337-150">Você pode escrever um método cujos argumentos são expressões e, em seguida, examinar essas expressões antes de executar o código.</span><span class="sxs-lookup"><span data-stu-id="e7337-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="e7337-151">A árvore de expressão é uma representação completa do código: você pode ver os valores de qualquer subexpressão.</span><span class="sxs-lookup"><span data-stu-id="e7337-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="e7337-152">Você pode ver os nomes de métodos e propriedades.</span><span class="sxs-lookup"><span data-stu-id="e7337-152">You can see method and property names.</span></span> <span data-ttu-id="e7337-153">Você pode ver o valor de qualquer expressão de constante.</span><span class="sxs-lookup"><span data-stu-id="e7337-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="e7337-154">Você também pode converter uma árvore de expressão em um delegado executável e executar o código.</span><span class="sxs-lookup"><span data-stu-id="e7337-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="e7337-155">As APIs para árvores de expressão permitem criar árvores que representam quase todos os constructos de código válidos.</span><span class="sxs-lookup"><span data-stu-id="e7337-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="e7337-156">No entanto, para manter as coisas o mais simples possível, algumas expressões de C# não podem ser criadas em uma árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="e7337-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="e7337-157">Um exemplo são as expressões assíncronas (usando as palavras-chave `async` e `await`).</span><span class="sxs-lookup"><span data-stu-id="e7337-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="e7337-158">Se suas necessidades requerem algoritmos assíncronos, você precisa manipular diretamente os objetos `Task`, em vez de contar com o suporte do compilador.</span><span class="sxs-lookup"><span data-stu-id="e7337-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="e7337-159">Outro exemplo é na criação de loops.</span><span class="sxs-lookup"><span data-stu-id="e7337-159">Another is in creating loops.</span></span> <span data-ttu-id="e7337-160">Normalmente, você os cria usando loops `for`, `foreach`, `while` ou `do`.</span><span class="sxs-lookup"><span data-stu-id="e7337-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="e7337-161">Como você verá [mais adiante nesta série](expression-trees-building.md), as APIs para árvores de expressão oferecem suporte a uma única expressão de loop, com expressões `break` e `continue` que controlam a repetição do loop.</span><span class="sxs-lookup"><span data-stu-id="e7337-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="e7337-162">A única coisa que você não pode fazer é modificar uma árvore de expressão.</span><span class="sxs-lookup"><span data-stu-id="e7337-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="e7337-163">As árvores de expressão são estruturas de dados imutáveis.</span><span class="sxs-lookup"><span data-stu-id="e7337-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="e7337-164">Se quiser modificar (alterar) uma árvore de expressão, você deverá criar uma nova árvore, que seja uma cópia da original, com as alterações desejadas.</span><span class="sxs-lookup"><span data-stu-id="e7337-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="e7337-165">Próximo – Tipos de estruturas que dão suporte às árvores de expressão</span><span class="sxs-lookup"><span data-stu-id="e7337-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
