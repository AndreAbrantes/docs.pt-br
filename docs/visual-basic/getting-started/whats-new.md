---
title: Novidades do Visual Basic
ms.date: 02/15/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 09a113130d29336ecabb52095ca7f5809f5f0ade
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33592542"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="aa13e-102">Novidades do Visual Basic</span><span class="sxs-lookup"><span data-stu-id="aa13e-102">What's new for Visual Basic</span></span>

<span data-ttu-id="aa13e-103">Este tópico lista os nomes das principais funcionalidades para cada versão do Visual Basic, com descrições detalhadas das funcionalidades novas e aprimoradas na versão mais recente da linguagem.</span><span class="sxs-lookup"><span data-stu-id="aa13e-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="aa13e-104">Versão atual</span><span class="sxs-lookup"><span data-stu-id="aa13e-104">Current Version</span></span>

<span data-ttu-id="aa13e-105">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="aa13e-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="aa13e-106">Para as novas funcionalidades, consulte [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="aa13e-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="aa13e-107">Versões anteriores</span><span class="sxs-lookup"><span data-stu-id="aa13e-107">Previous versions</span></span>

<span data-ttu-id="aa13e-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="aa13e-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="aa13e-109">Para as novas funcionalidades, consulte [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="aa13e-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="aa13e-110">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="aa13e-110">Visual Basic 2017</span></span>   
<span data-ttu-id="aa13e-111">Para as novas funcionalidades, consulte [Visual Basic 2017](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="aa13e-111">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="aa13e-112">Visual Basic / Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="aa13e-112">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="aa13e-113">Para as novas funcionalidades, consulte [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="aa13e-113">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="aa13e-114">Visual Basic / Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="aa13e-114">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="aa13e-115">Visualizações de tecnologia da Plataforma do Compilador .NET (“Roslyn”)</span><span class="sxs-lookup"><span data-stu-id="aa13e-115">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="aa13e-116">Visual Basic / Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="aa13e-116">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="aa13e-117">palavras-chave `Async` e `await`, iteradores, atributos de informações do chamador</span><span class="sxs-lookup"><span data-stu-id="aa13e-117">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="aa13e-118">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="aa13e-118">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="aa13e-119">Propriedades autoimplementadas, inicializadores de coleção, continuação de linha implícita, covariância/contravariância genérica, acesso ao namespace global</span><span class="sxs-lookup"><span data-stu-id="aa13e-119">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="aa13e-120">Visual Basic / Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="aa13e-120">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="aa13e-121">LINQ (consulta integrada à linguagem), literais XML, inferência de tipos de variável local, inicializadores de objeto, tipos anônimos, métodos de extensão, inferência de tipos `var` local, expressões lambda, operador `if`, métodos parciais, tipos de valor anulável</span><span class="sxs-lookup"><span data-stu-id="aa13e-121">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="aa13e-122">Visual Basic / Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="aa13e-122">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="aa13e-123">O tipo `My` e tipos auxiliares (acesso ao aplicativo, computador, sistema de arquivos, rede)</span><span class="sxs-lookup"><span data-stu-id="aa13e-123">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="aa13e-124">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="aa13e-124">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="aa13e-125">Operadores bit shift, declaração de variável de loop</span><span class="sxs-lookup"><span data-stu-id="aa13e-125">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="aa13e-126">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="aa13e-126">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="aa13e-127">A primeira versão do Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="aa13e-127">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="aa13e-128">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="aa13e-128">Visual Basic 15.5</span></span>

[<span data-ttu-id="aa13e-129">Argumentos nomeados que não estejam à direita</span><span class="sxs-lookup"><span data-stu-id="aa13e-129">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="aa13e-130">No Visual Basic 15.3 e nas versões anteriores, quando uma chamada de método incluía argumentos por posição e por nome, os argumentos posicionais tinham que preceder os argumentos nomeados.</span><span class="sxs-lookup"><span data-stu-id="aa13e-130">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="aa13e-131">A partir do Visual Basic 15.5 os argumentos posicionais e nomeados podem aparecer em qualquer ordem, desde que todos os argumentos, até o último argumento posicional, estejam na posição correta.</span><span class="sxs-lookup"><span data-stu-id="aa13e-131">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="aa13e-132">Isso é especialmente útil quando os argumentos nomeados são usados para tornar o código mais legível.</span><span class="sxs-lookup"><span data-stu-id="aa13e-132">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="aa13e-133">Por exemplo, a seguinte chamada de método tem dois argumentos posicionais entre um argumento nomeado.</span><span class="sxs-lookup"><span data-stu-id="aa13e-133">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="aa13e-134">O argumento nomeado deixa claro que o valor 19 representa uma idade.</span><span class="sxs-lookup"><span data-stu-id="aa13e-134">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="aa13e-135">**Separador hex/binário/octal à esquerda**</span><span class="sxs-lookup"><span data-stu-id="aa13e-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="aa13e-136">O Visual Basic 2017 agora tem suporte para o caractere de sublinhado (`_`) como um separador de dígito.</span><span class="sxs-lookup"><span data-stu-id="aa13e-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="aa13e-137">A partir do Visual Basic 15.5, você pode usar o caractere de sublinhado como separador à esquerda entre o prefixo e os dígitos binários, hexadecimais ou octais.</span><span class="sxs-lookup"><span data-stu-id="aa13e-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="aa13e-138">O exemplo a seguir usa um separador de dígito à esquerda para definir 3.271.948.384 como um número hexadecimal:</span><span class="sxs-lookup"><span data-stu-id="aa13e-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="aa13e-139">Para usar o caractere de sublinhado como um separador à esquerda, você deve adicionar o seguinte elemento ao arquivo de projeto (\*.vbproj) do Visual Basic:</span><span class="sxs-lookup"><span data-stu-id="aa13e-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="aa13e-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="aa13e-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="aa13e-141">**Inferência de tupla nomeada**</span><span class="sxs-lookup"><span data-stu-id="aa13e-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="aa13e-142">Quando você atribui o valor de elementos de tupla com base em variáveis, o Visual Basic infere o nome dos elementos de tupla dos nomes de variável correspondentes; não é necessário nomear explicitamente um elemento de tupla.</span><span class="sxs-lookup"><span data-stu-id="aa13e-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="aa13e-143">O exemplo a seguir usa a inferência para criar uma tupla com três elementos nomeados, `state`, `stateName` e `capital`.</span><span class="sxs-lookup"><span data-stu-id="aa13e-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="aa13e-144">**Opções adicionais do compilador**</span><span class="sxs-lookup"><span data-stu-id="aa13e-144">**Additional compiler switches**</span></span>  

<span data-ttu-id="aa13e-145">O compilador de linha de comando do Visual Basic agora é compatível com as opções do compilador [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) e [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) para controlar a saída de assemblies de referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="aa13e-146">A **-refout** define o diretório de saída do assembly de referência e a **-refonly** especifica que somente um assembly de referência deve ser produzido pela compilação.</span><span class="sxs-lookup"><span data-stu-id="aa13e-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="aa13e-147">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="aa13e-147">Visual Basic 2017</span></span>

[<span data-ttu-id="aa13e-148">**Tuplas**</span><span class="sxs-lookup"><span data-stu-id="aa13e-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="aa13e-149">As tuplas são uma estrutura de dados leve que é mais comumente usada para retornar vários valores de uma única chamada de método.</span><span class="sxs-lookup"><span data-stu-id="aa13e-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="aa13e-150">Normalmente, para retornar vários valores de um método, você precisa realizar uma das seguintes ações:</span><span class="sxs-lookup"><span data-stu-id="aa13e-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="aa13e-151">Defina um tipo personalizado (uma `Class` ou `Structure`).</span><span class="sxs-lookup"><span data-stu-id="aa13e-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="aa13e-152">Esta é uma solução pesada.</span><span class="sxs-lookup"><span data-stu-id="aa13e-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="aa13e-153">Definir um ou mais parâmetros `ByRef`, além de retornar um valor do método.</span><span class="sxs-lookup"><span data-stu-id="aa13e-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="aa13e-154">O suporte do Visual Basic para tuplas permite definir rapidamente uma tupla, opcionalmente atribuir nomes semânticos para seus valores e recuperar rapidamente seus valores.</span><span class="sxs-lookup"><span data-stu-id="aa13e-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="aa13e-155">O exemplo a seguir encapsula uma chamada para o método <xref:System.Int32.TryParse%2A> e retorna uma tupla.</span><span class="sxs-lookup"><span data-stu-id="aa13e-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="aa13e-156">O chamador pode então chamar o método e manipular a tupla retornada com o código semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="aa13e-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="aa13e-157">**Literais binários e os separadores de dígito**</span><span class="sxs-lookup"><span data-stu-id="aa13e-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="aa13e-158">Você pode definir um literal binário usando o prefixo `&B` ou `&b`.</span><span class="sxs-lookup"><span data-stu-id="aa13e-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="aa13e-159">Além disso, você pode usar o caractere de sublinhado, `_`, como um separador de dígitos para melhorar a legibilidade.</span><span class="sxs-lookup"><span data-stu-id="aa13e-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="aa13e-160">O exemplo a seguir usa as duas funcionalidades para atribuir um valor `Byte` e exibi-lo como um número decimal, hexadecimal e binário.</span><span class="sxs-lookup"><span data-stu-id="aa13e-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="aa13e-161">Para obter mais informações, consulte a seção "Atribuições de literal" dos tipos de dados [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) e [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="aa13e-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="aa13e-162">**Suporte para valores retornados de referência do C#**</span><span class="sxs-lookup"><span data-stu-id="aa13e-162">**Support for C# reference return values**</span></span>

<span data-ttu-id="aa13e-163">Começando com o C# 7.0, o C# é compatível com valores retornados de referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="aa13e-164">Isto é, quando o método de chamada recebe um valor retornado por referência, ele pode alterar o valor da referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="aa13e-165">O Visual Basic não permite a criação de métodos com valores retornados de referência, mas isso não permite o consumo e a modificação de valores de retorno de referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="aa13e-166">Por exemplo, a classe `Sentence` a seguir escrita em C# inclui um método `FindNext` que localiza a próxima palavra em uma sentença que começa com uma subcadeia de caracteres especificada.</span><span class="sxs-lookup"><span data-stu-id="aa13e-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="aa13e-167">A cadeia de caracteres é retornada como um valor retornado de referência e uma variável `Boolean` passada pela referência para o método indica se a pesquisa foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="aa13e-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="aa13e-168">Isso significa que o chamador não pode apenas ler o valor retornado, ele também pode modificá-lo e essa modificação é refletida na classe `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="aa13e-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="aa13e-169">Em sua forma mais simples, você pode modificar a palavra encontrada na frase usando um código semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="aa13e-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="aa13e-170">Observe que você não está atribuindo um valor ao método, mas para a expressão que o método retorna, que é o valor retornado de referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="aa13e-171">Um problema com esse código, no entanto, é que, se uma correspondência não for encontrada, o método retornará a primeira palavra.</span><span class="sxs-lookup"><span data-stu-id="aa13e-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="aa13e-172">Como o exemplo não examina o valor do argumento `Boolean` para determinar se uma correspondência foi encontrada, ele modificará a primeira palavra se não houver nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="aa13e-173">O exemplo a seguir corrige isso substituindo a primeira palavra por ela mesma se não há nenhuma correspondência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="aa13e-174">Uma solução melhor é usar um método auxiliar para o qual o valor retornado de referência é passado por referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="aa13e-175">O método auxiliar pode modificar o argumento passado para ele por referência.</span><span class="sxs-lookup"><span data-stu-id="aa13e-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="aa13e-176">O exemplo a seguir faz isso.</span><span class="sxs-lookup"><span data-stu-id="aa13e-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="aa13e-177">Para obter mais informações, consulte [Reference return values](../programming-guide/language-features/procedures/ref-return-values.md) (Valores retornados de referência).</span><span class="sxs-lookup"><span data-stu-id="aa13e-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="aa13e-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="aa13e-178">Visual Basic 14</span></span>

[<span data-ttu-id="aa13e-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="aa13e-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="aa13e-180">Você pode obter o nome da cadeia de caracteres não qualificada de um tipo ou de um membro para uso em uma mensagem de erro sem realizar hard-coding de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="aa13e-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="aa13e-181">Isso permite que seu código permaneça correto ao refatorar.</span><span class="sxs-lookup"><span data-stu-id="aa13e-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="aa13e-182">Esse recurso também é útil para conectar links MVC do tipo modelo-exibição-controlador e acionar eventos de alteração de propriedade.</span><span class="sxs-lookup"><span data-stu-id="aa13e-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="aa13e-183">Interpolação de cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="aa13e-183">String Interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  
 <span data-ttu-id="aa13e-184">Você pode usar expressões de interpolação de cadeia de caracteres para construir cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="aa13e-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="aa13e-185">Uma expressão de cadeia de caracteres interpolada é semelhante a uma cadeia de caracteres de modelo que contém expressões.</span><span class="sxs-lookup"><span data-stu-id="aa13e-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="aa13e-186">Uma cadeia de caracteres interpolada é mais fácil de entender, em relação aos argumentos, do que a [formatação de composição](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="aa13e-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="aa13e-187">Acesso de membro nulo condicional e indexação</span><span class="sxs-lookup"><span data-stu-id="aa13e-187">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="aa13e-188">Você pode testar a nulidade de uma maneira sintática muito simples antes de executar uma operação de acesso de membro (`?.`) ou índice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="aa13e-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="aa13e-189">Esses operadores ajudam a escrever menos código para lidar com verificações de nulidade, especialmente para entrar em estruturas de dados.</span><span class="sxs-lookup"><span data-stu-id="aa13e-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="aa13e-190">Se a referência de objeto ou o operando esquerdo for nulo, as operações retornarão valores nulos.</span><span class="sxs-lookup"><span data-stu-id="aa13e-190">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="aa13e-191">Literais de cadeia de caracteres multilinha</span><span class="sxs-lookup"><span data-stu-id="aa13e-191">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="aa13e-192">Literais de cadeia de caracteres podem conter sequências de nova linha.</span><span class="sxs-lookup"><span data-stu-id="aa13e-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="aa13e-193">Você não precisa da solução alternativa antiga de usar `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="aa13e-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="aa13e-194">Comentários</span><span class="sxs-lookup"><span data-stu-id="aa13e-194">Comments</span></span>  
<span data-ttu-id="aa13e-195">É possível colocar comentários após continuações de linha implícitas, em expressões de inicializador e entre termos de expressão do LINQ.</span><span class="sxs-lookup"><span data-stu-id="aa13e-195">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="aa13e-196">Resolução de nome totalmente qualificado mais inteligente</span><span class="sxs-lookup"><span data-stu-id="aa13e-196">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="aa13e-197">Dado um código como `Threading.Thread.Sleep(1000)`, o Visual Basic pesquisava o namespace "Threading", descobria que ele era ambíguo entre System.Threading e System.Windows.Threading e, então, relatava um erro.</span><span class="sxs-lookup"><span data-stu-id="aa13e-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="aa13e-198">Agora, o Visual Basic considera os dois namespaces possíveis juntos.</span><span class="sxs-lookup"><span data-stu-id="aa13e-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="aa13e-199">Se você mostrar a lista de conclusão, o editor do Visual Studio listará membros dos dois tipos na lista de conclusão.</span><span class="sxs-lookup"><span data-stu-id="aa13e-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="aa13e-200">Literais de data do primeiro ano</span><span class="sxs-lookup"><span data-stu-id="aa13e-200">Year-first Date Literals</span></span>  
 <span data-ttu-id="aa13e-201">Você pode ter literais de data no formato aaaa-mm-dd, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="aa13e-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="aa13e-202">Propriedades de interface readonly</span><span class="sxs-lookup"><span data-stu-id="aa13e-202">Readonly Interface Properties</span></span>  
 <span data-ttu-id="aa13e-203">Você pode implementar propriedades de interface readonly usando uma propriedade readwrite.</span><span class="sxs-lookup"><span data-stu-id="aa13e-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="aa13e-204">A interface garante a funcionalidade mínima e não impede que uma classe de implementação permita que a propriedade seja definida.</span><span class="sxs-lookup"><span data-stu-id="aa13e-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="aa13e-205">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="aa13e-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="aa13e-206">Para facilitar a leitura do seu código, agora você pode usar `TypeOf` com `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="aa13e-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="aa13e-207">#Disable Warning \<ID> e #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="aa13e-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="aa13e-208">É possível desabilitar e habilitar avisos específicos para regiões dentro de um arquivo de origem.</span><span class="sxs-lookup"><span data-stu-id="aa13e-208">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="aa13e-209">Aprimoramentos de comentário de documento XML</span><span class="sxs-lookup"><span data-stu-id="aa13e-209">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="aa13e-210">Ao escrever comentários de documento, você obtém o editor inteligente e suporte de build para validar nomes de parâmetro, tratamento adequado de `crefs` (genéricos, operadores etc.), coloração e refatoração.</span><span class="sxs-lookup"><span data-stu-id="aa13e-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="aa13e-211">Definições de interface e módulo parcial</span><span class="sxs-lookup"><span data-stu-id="aa13e-211">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="aa13e-212">Além das classes e structs, você pode declarar interfaces e módulos parciais.</span><span class="sxs-lookup"><span data-stu-id="aa13e-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="aa13e-213">Diretivas #Region dentro de corpos de método</span><span class="sxs-lookup"><span data-stu-id="aa13e-213">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="aa13e-214">Você pode colocar delimitadores #Region...#End Region em qualquer lugar em um arquivo, dentro de funções e até mesmo estendê-los por corpos de função.</span><span class="sxs-lookup"><span data-stu-id="aa13e-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="aa13e-215">Definições de substituição são sobrecargas implicitamente</span><span class="sxs-lookup"><span data-stu-id="aa13e-215">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="aa13e-216">Se você adicionar o modificador `Overrides` a uma definição, o compilador adicionará implicitamente `Overloads`, para que você possa digitar menos código em casos comuns.</span><span class="sxs-lookup"><span data-stu-id="aa13e-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="aa13e-217">CObj permitido em argumentos de atributos</span><span class="sxs-lookup"><span data-stu-id="aa13e-217">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="aa13e-218">O compilador apresentava um erro de que CObj(...) não era uma constante quando usado em construções de atributo.</span><span class="sxs-lookup"><span data-stu-id="aa13e-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="aa13e-219">Declarando e consumindo métodos ambíguos de interfaces diferentes</span><span class="sxs-lookup"><span data-stu-id="aa13e-219">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="aa13e-220">Anteriormente, o código a seguir gerava erros que impediam você de declarar `IMock` ou chamar `GetDetails` (se eles tivessem sido declarados em C#):</span><span class="sxs-lookup"><span data-stu-id="aa13e-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="aa13e-221">Agora, o compilador usará regras de resolução de sobrecarga normais para escolher o `GetDetails` mais apropriado a ser chamado e você pode declarar relações de interface no Visual Basic, como aquelas mostradas no exemplo.</span><span class="sxs-lookup"><span data-stu-id="aa13e-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aa13e-222">Consulte também</span><span class="sxs-lookup"><span data-stu-id="aa13e-222">See also</span></span>  
 [<span data-ttu-id="aa13e-223">Novidades no Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="aa13e-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
