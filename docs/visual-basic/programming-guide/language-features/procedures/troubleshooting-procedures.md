---
title: Procedimentos de solução de problemas (Visual Basic)
ms.date: 07/20/2015
helpviewer_keywords:
- troubleshooting Visual Basic, procedures
- procedures [Visual Basic], troubleshooting
- Visual Basic code, procedures
- troubleshooting procedures
- procedures [Visual Basic], about procedures
ms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b
ms.openlocfilehash: c74947e21de8ba26ffde01f6f28aea67346c2071
ms.sourcegitcommit: eff6adb61852369ab690f3f047818c90580e7eb1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72002082"
---
# <a name="troubleshooting-procedures-visual-basic"></a><span data-ttu-id="c949d-102">Procedimentos de solução de problemas (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="c949d-102">Troubleshooting procedures (Visual Basic)</span></span>

<span data-ttu-id="c949d-103">Esta página lista alguns problemas comuns que podem ocorrer ao trabalhar com procedimentos.</span><span class="sxs-lookup"><span data-stu-id="c949d-103">This page lists some common problems that can occur when working with procedures.</span></span>  
  
## <a name="returning-an-array-type-from-a-function-procedure"></a><span data-ttu-id="c949d-104">Retornando um tipo de matriz de um procedimento de função</span><span class="sxs-lookup"><span data-stu-id="c949d-104">Returning an array type from a function procedure</span></span>

<span data-ttu-id="c949d-105">Se um procedimento `Function` retornar um tipo de dados de matriz, você não poderá usar o nome de `Function` para armazenar valores nos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="c949d-105">If a `Function` procedure returns an array data type, you cannot use the `Function` name to store values in the elements of the array.</span></span> <span data-ttu-id="c949d-106">Se você tentar fazer isso, o compilador o interpretará como uma chamada para o `Function`.</span><span class="sxs-lookup"><span data-stu-id="c949d-106">If you attempt to do this, the compiler interprets it as a call to the `Function`.</span></span> <span data-ttu-id="c949d-107">O exemplo a seguir gera erros de compilador:</span><span class="sxs-lookup"><span data-stu-id="c949d-107">The following example generates compiler errors:</span></span>
  
```vb
Function AllOnes(n As Integer) As Integer()
   For i As Integer = 1 To n - 1  
      ' The following statement generates a COMPILER ERROR.  
      AllOnes(i) = 1  
   Next  

   ' The following statement generates a COMPILER ERROR.  
   Return AllOnes()  
End Function
```

<span data-ttu-id="c949d-108">A instrução `AllOnes(i) = 1` gera um erro de compilador porque parece chamar `AllOnes` com um argumento do tipo de dados incorreto (um @no__t escalar-2, em vez de uma matriz `Integer`).</span><span class="sxs-lookup"><span data-stu-id="c949d-108">The statement `AllOnes(i) = 1` generates a compiler error because it appears to call `AllOnes` with an argument of the wrong data type (a scalar `Integer` instead of an `Integer` array).</span></span> <span data-ttu-id="c949d-109">A instrução `Return AllOnes()` gera um erro de compilador porque parece chamar `AllOnes` sem argumento.</span><span class="sxs-lookup"><span data-stu-id="c949d-109">The statement `Return AllOnes()` generates a compiler error because it appears to call `AllOnes` with no argument.</span></span>  
  
 <span data-ttu-id="c949d-110">**Abordagem correta:** Para poder modificar os elementos de uma matriz que deve ser retornada, defina uma matriz interna como uma variável local.</span><span class="sxs-lookup"><span data-stu-id="c949d-110">**Correct approach:** To be able to modify the elements of an array that is to be returned, define an internal array as a local variable.</span></span> <span data-ttu-id="c949d-111">O exemplo a seguir é compilado sem erro:</span><span class="sxs-lookup"><span data-stu-id="c949d-111">The following example compiles without error:</span></span>

 [!code-vb[VbVbcnProcedures#66](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#66)]

## <a name="argument-not-modified-by-procedure-call"></a><span data-ttu-id="c949d-112">Argumento não modificado pela chamada de procedimento</span><span class="sxs-lookup"><span data-stu-id="c949d-112">Argument not modified by procedure call</span></span>

<span data-ttu-id="c949d-113">Se você pretende permitir que um procedimento altere um elemento de programação subjacente a um argumento no código de chamada, você deve passá-lo por referência.</span><span class="sxs-lookup"><span data-stu-id="c949d-113">If you intend to allow a procedure to change a programming element underlying an argument in the calling code, you must pass it by reference.</span></span> <span data-ttu-id="c949d-114">Mas um procedimento pode acessar os elementos de um argumento de tipo de referência mesmo se você passá-lo por valor.</span><span class="sxs-lookup"><span data-stu-id="c949d-114">But a procedure can access the elements of a reference type argument even if you pass it by value.</span></span>

- <span data-ttu-id="c949d-115">**Variável subjacente**.</span><span class="sxs-lookup"><span data-stu-id="c949d-115">**Underlying variable**.</span></span> <span data-ttu-id="c949d-116">Para permitir que o procedimento substitua o valor do elemento variável subjacente, o procedimento deve declarar o parâmetro [ByRef](../../../language-reference/modifiers/byref.md).</span><span class="sxs-lookup"><span data-stu-id="c949d-116">To allow the procedure to replace the value of the underlying variable element itself, the procedure must declare the parameter [ByRef](../../../language-reference/modifiers/byref.md).</span></span> <span data-ttu-id="c949d-117">Além disso, o código de chamada não deve colocar o argumento entre parênteses, porque isso substituiria o mecanismo de passagem `ByRef`.</span><span class="sxs-lookup"><span data-stu-id="c949d-117">Also, the calling code must not enclose the argument in parentheses, because that would override the `ByRef` passing mechanism.</span></span>

- <span data-ttu-id="c949d-118">**Elementos de tipo de referência**.</span><span class="sxs-lookup"><span data-stu-id="c949d-118">**Reference type elements**.</span></span> <span data-ttu-id="c949d-119">Se você declarar um parâmetro [ByVal](../../../language-reference/modifiers/byval.md), o procedimento não poderá modificar o elemento Variable subjacente.</span><span class="sxs-lookup"><span data-stu-id="c949d-119">If you declare a parameter [ByVal](../../../language-reference/modifiers/byval.md), the procedure cannot modify the underlying variable element itself.</span></span> <span data-ttu-id="c949d-120">No entanto, se o argumento for um tipo de referência, o procedimento poderá modificar os membros do objeto para o qual ele aponta, mesmo que não possa substituir o valor da variável.</span><span class="sxs-lookup"><span data-stu-id="c949d-120">However, if the argument is a reference type, the procedure can modify the members of the object to which it points, even though it cannot replace the variable's value.</span></span> <span data-ttu-id="c949d-121">Por exemplo, se o argumento for uma variável de matriz, o procedimento não poderá atribuir uma nova matriz a ele, mas poderá alterar um ou mais de seus elementos.</span><span class="sxs-lookup"><span data-stu-id="c949d-121">For example, if the argument is an array variable, the procedure cannot assign a new array to it, but it can change one or more of its elements.</span></span> <span data-ttu-id="c949d-122">Os elementos alterados são refletidos na variável de matriz subjacente no código de chamada.</span><span class="sxs-lookup"><span data-stu-id="c949d-122">The changed elements are reflected in the underlying array variable in the calling code.</span></span>

<span data-ttu-id="c949d-123">O exemplo a seguir define dois procedimentos que usam uma variável de matriz por valor e operam em seus elementos.</span><span class="sxs-lookup"><span data-stu-id="c949d-123">The following example defines two procedures that take an array variable by value and operate on its elements.</span></span> <span data-ttu-id="c949d-124">O procedimento `increase` simplesmente adiciona um a cada elemento.</span><span class="sxs-lookup"><span data-stu-id="c949d-124">Procedure `increase` simply adds one to each element.</span></span> <span data-ttu-id="c949d-125">O procedimento `replace` atribui uma nova matriz ao parâmetro `a()` e, em seguida, adiciona uma a cada elemento.</span><span class="sxs-lookup"><span data-stu-id="c949d-125">Procedure `replace` assigns a new array to the parameter `a()` and then adds one to each element.</span></span> <span data-ttu-id="c949d-126">No entanto, a reatribuição não afeta a variável de matriz subjacente no código de chamada porque `a()` é declarado `ByVal`.</span><span class="sxs-lookup"><span data-stu-id="c949d-126">However, the reassignment does not affect the underlying array variable in the calling code because `a()` is declared `ByVal`.</span></span>

[!code-vb[VbVbcnProcedures#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#35)]

[!code-vb[VbVbcnProcedures#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#38)]

<span data-ttu-id="c949d-127">O exemplo a seguir faz chamadas para `increase` e `replace`:</span><span class="sxs-lookup"><span data-stu-id="c949d-127">The following example makes calls to `increase` and `replace`:</span></span>

[!code-vb[VbVbcnProcedures#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#37)]
  
<span data-ttu-id="c949d-128">A primeira chamada `MsgBox` exibe "após o aumento (n): 11, 21, 31, 41 ".</span><span class="sxs-lookup"><span data-stu-id="c949d-128">The first `MsgBox` call displays "After increase(n): 11, 21, 31, 41".</span></span> <span data-ttu-id="c949d-129">Como `n` é um tipo de referência, `increase` pode alterar seus membros, mesmo que seja passado `ByVal`.</span><span class="sxs-lookup"><span data-stu-id="c949d-129">Because `n` is a reference type, `increase` can change its members, even though it is passed `ByVal`.</span></span>

<span data-ttu-id="c949d-130">A segunda chamada `MsgBox` exibe "após Replace (n): 11, 21, 31, 41 ".</span><span class="sxs-lookup"><span data-stu-id="c949d-130">The second `MsgBox` call displays "After replace(n): 11, 21, 31, 41".</span></span> <span data-ttu-id="c949d-131">Como `n` é passado `ByVal`, `replace` não pode modificar a variável `n` atribuindo uma nova matriz a ela.</span><span class="sxs-lookup"><span data-stu-id="c949d-131">Because `n` is passed `ByVal`, `replace` cannot modify the variable `n` by assigning a new array to it.</span></span> <span data-ttu-id="c949d-132">Quando `replace` cria a nova instância de matriz `k` e a atribui à variável local `a`, ela perde a referência a `n` passado pelo código de chamada.</span><span class="sxs-lookup"><span data-stu-id="c949d-132">When `replace` creates the new array instance `k` and assigns it to the local variable `a`, it loses the reference to `n` passed in by the calling code.</span></span> <span data-ttu-id="c949d-133">Quando ele incrementa os membros de `a`, somente a matriz local `k` é afetada.</span><span class="sxs-lookup"><span data-stu-id="c949d-133">When it increments the members of `a`, only the local array `k` is affected.</span></span>

<span data-ttu-id="c949d-134">**Abordagem correta:** Para poder modificar um elemento variável subjacente, passe-o por referência.</span><span class="sxs-lookup"><span data-stu-id="c949d-134">**Correct approach:** To be able to modify an underlying variable element itself, pass it by reference.</span></span> <span data-ttu-id="c949d-135">O exemplo a seguir mostra a alteração na declaração de `replace` que permite substituir uma matriz por outra no código de chamada:</span><span class="sxs-lookup"><span data-stu-id="c949d-135">The following example shows the change in the declaration of `replace` that allows it to replace one array with another in the calling code:</span></span>

[!code-vb[VbVbcnProcedures#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#64)]

## <a name="unable-to-define-an-overload"></a><span data-ttu-id="c949d-136">Não é possível definir uma sobrecarga</span><span class="sxs-lookup"><span data-stu-id="c949d-136">Unable to define an overload</span></span>

<span data-ttu-id="c949d-137">Se você quiser definir uma versão sobrecarregada de um procedimento, deverá usar o mesmo nome, mas uma assinatura diferente.</span><span class="sxs-lookup"><span data-stu-id="c949d-137">If you want to define an overloaded version of a procedure, you must use the same name but a different signature.</span></span> <span data-ttu-id="c949d-138">Se o compilador não puder diferenciar a declaração de uma sobrecarga com a mesma assinatura, ele gerará um erro.</span><span class="sxs-lookup"><span data-stu-id="c949d-138">If the compiler cannot differentiate your declaration from an overload with the same signature, it generates an error.</span></span>

<span data-ttu-id="c949d-139">A *assinatura* de um procedimento é determinada pelo nome do procedimento e pela lista de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="c949d-139">The *signature* of a procedure is determined by the procedure name and the parameter list.</span></span> <span data-ttu-id="c949d-140">Cada sobrecarga deve ter o mesmo nome de todas as outras sobrecargas, mas deve ser diferente de todas elas em pelo menos um dos outros componentes da assinatura.</span><span class="sxs-lookup"><span data-stu-id="c949d-140">Each overload must have the same name as all the other overloads but must differ from all of them in at least one of the other components of the signature.</span></span> <span data-ttu-id="c949d-141">Para obter mais informações, consulte [sobrecarga de procedimento](./procedure-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="c949d-141">For more information, see [Procedure Overloading](./procedure-overloading.md).</span></span>

<span data-ttu-id="c949d-142">Os itens a seguir, embora eles pertençam à lista de parâmetros, não são componentes da assinatura de um procedimento:</span><span class="sxs-lookup"><span data-stu-id="c949d-142">The following items, even though they pertain to the parameter list, are not components of a procedure's signature:</span></span>

- <span data-ttu-id="c949d-143">Palavras-chave do modificador de procedimento, como `Public`, `Shared` e `Static`.</span><span class="sxs-lookup"><span data-stu-id="c949d-143">Procedure modifier keywords, such as `Public`, `Shared`, and `Static`.</span></span>
- <span data-ttu-id="c949d-144">Nomes de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="c949d-144">Parameter names.</span></span>
- <span data-ttu-id="c949d-145">Palavras-chave de modificador de parâmetro, como `ByRef` e `Optional`.</span><span class="sxs-lookup"><span data-stu-id="c949d-145">Parameter modifier keywords, such as `ByRef` and `Optional`.</span></span>
- <span data-ttu-id="c949d-146">O tipo de dados do valor de retorno (exceto para um operador de conversão).</span><span class="sxs-lookup"><span data-stu-id="c949d-146">The data type of the return value (except for a conversion operator).</span></span>

<span data-ttu-id="c949d-147">Não é possível sobrecarregar um procedimento, variando apenas um ou mais dos itens anteriores.</span><span class="sxs-lookup"><span data-stu-id="c949d-147">You cannot overload a procedure by varying only one or more of the preceding items.</span></span>

<span data-ttu-id="c949d-148">**Abordagem correta:** Para poder definir uma sobrecarga de procedimento, você deve variar a assinatura.</span><span class="sxs-lookup"><span data-stu-id="c949d-148">**Correct approach:** To be able to define a procedure overload, you must vary the signature.</span></span> <span data-ttu-id="c949d-149">Como você deve usar o mesmo nome, você deve variar o número, a ordem ou os tipos de dados dos parâmetros.</span><span class="sxs-lookup"><span data-stu-id="c949d-149">Because you must use the same name, you must vary the number, order, or data types of the parameters.</span></span> <span data-ttu-id="c949d-150">Em um procedimento genérico, você pode variar o número de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c949d-150">In a generic procedure, you can vary the number of type parameters.</span></span> <span data-ttu-id="c949d-151">Em um operador de conversão ([função CType](../../../language-reference/functions/ctype-function.md)), você pode variar o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="c949d-151">In a conversion operator ([CType Function](../../../language-reference/functions/ctype-function.md)), you can vary the return type.</span></span>

### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a><span data-ttu-id="c949d-152">Resolução de sobrecarga com argumentos opcional e ParamArray</span><span class="sxs-lookup"><span data-stu-id="c949d-152">Overload resolution with Optional and ParamArray arguments</span></span>

<span data-ttu-id="c949d-153">Se você estiver sobrecarregando um procedimento com um ou mais parâmetros [opcionais](../../../language-reference/modifiers/optional.md) ou um parâmetro [ParamArray](../../../language-reference/modifiers/paramarray.md) , você deve evitar duplicar qualquer uma das *sobrecargas implícitas*.</span><span class="sxs-lookup"><span data-stu-id="c949d-153">If you are overloading a procedure with one or more [Optional](../../../language-reference/modifiers/optional.md) parameters or a [ParamArray](../../../language-reference/modifiers/paramarray.md) parameter, you must avoid duplicating any of the *implicit overloads*.</span></span> <span data-ttu-id="c949d-154">Para obter informações, consulte [Considerações sobre sobrecarga de procedimentos](./considerations-in-overloading-procedures.md).</span><span class="sxs-lookup"><span data-stu-id="c949d-154">For information, see [Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md).</span></span>

## <a name="calling-the-wrong-version-of-an-overloaded-procedure"></a><span data-ttu-id="c949d-155">Chamando a versão errada de um procedimento sobrecarregado</span><span class="sxs-lookup"><span data-stu-id="c949d-155">Calling the wrong version of an overloaded procedure</span></span>

<span data-ttu-id="c949d-156">Se um procedimento tiver várias versões sobrecarregadas, você deve estar familiarizado com todas as suas listas de parâmetros e entender como Visual Basic resolve chamadas entre as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c949d-156">If a procedure has several overloaded versions, you should be familiar with all their parameter lists and understand how Visual Basic resolves calls among the overloads.</span></span> <span data-ttu-id="c949d-157">Caso contrário, você poderia chamar uma sobrecarga diferente da pretendida.</span><span class="sxs-lookup"><span data-stu-id="c949d-157">Otherwise you could call an overload other than the intended one.</span></span>

<span data-ttu-id="c949d-158">Quando você tiver determinado qual sobrecarga você deseja chamar, tenha cuidado para observar as seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="c949d-158">When you have determined which overload you want to call, be careful to observe the following rules:</span></span>

- <span data-ttu-id="c949d-159">Forneça o número correto de argumentos e na ordem correta.</span><span class="sxs-lookup"><span data-stu-id="c949d-159">Supply the correct number of arguments, and in the correct order.</span></span>  
- <span data-ttu-id="c949d-160">O ideal é que os argumentos tenham exatamente os mesmos tipos de dados que os parâmetros correspondentes.</span><span class="sxs-lookup"><span data-stu-id="c949d-160">Ideally, your arguments should have the exact same data types as the corresponding parameters.</span></span> <span data-ttu-id="c949d-161">Em qualquer caso, o tipo de dados de cada argumento deve ampliar para o parâmetro correspondente.</span><span class="sxs-lookup"><span data-stu-id="c949d-161">In any case, the data type of each argument must widen to that of its corresponding parameter.</span></span> <span data-ttu-id="c949d-162">Isso é verdadeiro mesmo com a [instrução Option Strict](../../../language-reference/statements/option-strict-statement.md) definida como `Off`.</span><span class="sxs-lookup"><span data-stu-id="c949d-162">This is true even with the [Option Strict Statement](../../../language-reference/statements/option-strict-statement.md) set to `Off`.</span></span> <span data-ttu-id="c949d-163">Se uma sobrecarga exigir qualquer conversão de restrição da sua lista de argumentos, essa sobrecarga não será qualificada para ser chamada.</span><span class="sxs-lookup"><span data-stu-id="c949d-163">If an overload requires any narrowing conversion from your argument list, that overload is not eligible to be called.</span></span>
- <span data-ttu-id="c949d-164">Se você fornecer argumentos que exigem alargamento, torne seus tipos de dados o mais próximo possível dos tipos de dados de parâmetro correspondentes.</span><span class="sxs-lookup"><span data-stu-id="c949d-164">If you supply arguments that require widening, make their data types as close as possible to the corresponding parameter data types.</span></span> <span data-ttu-id="c949d-165">Se duas ou mais sobrecargas aceitarem os tipos de dados de argumento, o compilador resolverá sua chamada para a sobrecarga que chama para a menor quantidade de alargamento.</span><span class="sxs-lookup"><span data-stu-id="c949d-165">If two or more overloads accept your argument data types, the compiler resolves your call to the overload that calls for the least amount of widening.</span></span>

<span data-ttu-id="c949d-166">Você pode reduzir a chance de incompatibilidades de tipo de dados usando a palavra-chave de conversão de [função CType](../../../language-reference/functions/ctype-function.md) ao preparar seus argumentos.</span><span class="sxs-lookup"><span data-stu-id="c949d-166">You can reduce the chance of data type mismatches by using the [CType Function](../../../language-reference/functions/ctype-function.md) conversion keyword when preparing your arguments.</span></span>

### <a name="overload-resolution-failure"></a><span data-ttu-id="c949d-167">Falha na resolução de sobrecarga</span><span class="sxs-lookup"><span data-stu-id="c949d-167">Overload resolution failure</span></span>

<span data-ttu-id="c949d-168">Quando você chama um procedimento sobrecarregado, o compilador tenta eliminar tudo, exceto uma das sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c949d-168">When you call an overloaded procedure, the compiler attempts to eliminate all but one of the overloads.</span></span> <span data-ttu-id="c949d-169">Se tiver sucesso, ele resolverá a chamada para essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="c949d-169">If it succeeds, it resolves the call to that overload.</span></span> <span data-ttu-id="c949d-170">Se ele eliminar todas as sobrecargas ou se não puder reduzir as sobrecargas qualificadas para um único candidato, ele gerará um erro.</span><span class="sxs-lookup"><span data-stu-id="c949d-170">If it eliminates all the overloads, or if it cannot reduce the eligible overloads to a single candidate, it generates an error.</span></span>

<span data-ttu-id="c949d-171">O exemplo a seguir ilustra o processo de resolução de sobrecarga:</span><span class="sxs-lookup"><span data-stu-id="c949d-171">The following example illustrates the overload resolution process:</span></span>

[!code-vb[VbVbcnProcedures#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#62)]

[!code-vb[VbVbcnProcedures#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#63)]
  
<span data-ttu-id="c949d-172">Na primeira chamada, o compilador elimina a primeira sobrecarga porque o tipo do primeiro argumento (`Short`) é limitado ao tipo do parâmetro correspondente (`Byte`).</span><span class="sxs-lookup"><span data-stu-id="c949d-172">In the first call, the compiler eliminates the first overload because the type of the first argument (`Short`) narrows to the type of the corresponding parameter (`Byte`).</span></span> <span data-ttu-id="c949d-173">Em seguida, ele elimina a terceira sobrecarga porque cada tipo de argumento na segunda sobrecarga (`Short` e `Single`) se amplia ao tipo correspondente na terceira sobrecarga (`Integer` e `Single`).</span><span class="sxs-lookup"><span data-stu-id="c949d-173">It then eliminates the third overload because each argument type in the second overload (`Short` and `Single`) widens to the corresponding type in the third overload (`Integer` and `Single`).</span></span> <span data-ttu-id="c949d-174">A segunda sobrecarga requer menos alargamento, portanto o compilador a utiliza para a chamada.</span><span class="sxs-lookup"><span data-stu-id="c949d-174">The second overload requires less widening, so the compiler uses it for the call.</span></span>

<span data-ttu-id="c949d-175">Na segunda chamada, o compilador não pode eliminar nenhuma das sobrecargas com base na restrição.</span><span class="sxs-lookup"><span data-stu-id="c949d-175">In the second call, the compiler cannot eliminate any of the overloads on the basis of narrowing.</span></span> <span data-ttu-id="c949d-176">Ele elimina a terceira sobrecarga pelo mesmo motivo que na primeira chamada, porque ela pode chamar a segunda sobrecarga com menos alargamento dos tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="c949d-176">It eliminates the third overload for the same reason as in the first call, because it can call the second overload with less widening of the argument types.</span></span> <span data-ttu-id="c949d-177">No entanto, o compilador não pode resolver entre a primeira e a segunda sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c949d-177">However, the compiler cannot resolve between the first and second overloads.</span></span> <span data-ttu-id="c949d-178">Cada tem um tipo de parâmetro definido que amplia o tipo correspondente no outro (`Byte` a `Short`, mas `Single` a `Double`).</span><span class="sxs-lookup"><span data-stu-id="c949d-178">Each has one defined parameter type that widens to the corresponding type in the other (`Byte` to `Short`, but `Single` to `Double`).</span></span> <span data-ttu-id="c949d-179">O compilador, portanto, gera um erro de resolução de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="c949d-179">The compiler therefore generates an overload resolution error.</span></span>

<span data-ttu-id="c949d-180">**Abordagem correta:** Para poder chamar um procedimento sobrecarregado sem ambigüidade, use a [função CType](../../../language-reference/functions/ctype-function.md) para corresponder os tipos de dados de argumento aos tipos de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="c949d-180">**Correct approach:** To be able to call an overloaded procedure without ambiguity, use [CType Function](../../../language-reference/functions/ctype-function.md) to match the argument data types to the parameter types.</span></span> <span data-ttu-id="c949d-181">O exemplo a seguir mostra uma chamada para `z` que força a resolução para a segunda sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="c949d-181">The following example shows a call to `z` that forces resolution to the second overload.</span></span>

[!code-vb[VbVbcnProcedures#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#65)]

### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a><span data-ttu-id="c949d-182">Resolução de sobrecarga com argumentos opcional e ParamArray</span><span class="sxs-lookup"><span data-stu-id="c949d-182">Overload resolution with Optional and ParamArray arguments</span></span>

<span data-ttu-id="c949d-183">Se duas sobrecargas de um procedimento tiverem assinaturas idênticas, exceto que o último parâmetro é declarado [opcional](../../../language-reference/modifiers/optional.md) em um e [ParamArray](../../../language-reference/modifiers/paramarray.md) no outro, o compilador resolverá uma chamada para esse procedimento de acordo com a correspondência mais próxima.</span><span class="sxs-lookup"><span data-stu-id="c949d-183">If two overloads of a procedure have identical signatures except that the last parameter is declared [Optional](../../../language-reference/modifiers/optional.md) in one and [ParamArray](../../../language-reference/modifiers/paramarray.md) in the other, the compiler resolves a call to that procedure according to the closest match.</span></span> <span data-ttu-id="c949d-184">Para obter mais informações, consulte [sobrecarga de resolução](./overload-resolution.md).</span><span class="sxs-lookup"><span data-stu-id="c949d-184">For more information, see [Overload Resolution](./overload-resolution.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c949d-185">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c949d-185">See also</span></span>

- [<span data-ttu-id="c949d-186">Procedimentos</span><span class="sxs-lookup"><span data-stu-id="c949d-186">Procedures</span></span>](index.md)
- [<span data-ttu-id="c949d-187">Subprocedimentos</span><span class="sxs-lookup"><span data-stu-id="c949d-187">Sub Procedures</span></span>](sub-procedures.md)
- [<span data-ttu-id="c949d-188">Procedimentos de Função</span><span class="sxs-lookup"><span data-stu-id="c949d-188">Function Procedures</span></span>](function-procedures.md)
- [<span data-ttu-id="c949d-189">Procedimentos de Propriedade</span><span class="sxs-lookup"><span data-stu-id="c949d-189">Property Procedures</span></span>](property-procedures.md)
- [<span data-ttu-id="c949d-190">Procedimentos de Operador</span><span class="sxs-lookup"><span data-stu-id="c949d-190">Operator Procedures</span></span>](operator-procedures.md)
- [<span data-ttu-id="c949d-191">Parâmetros e Argumentos de Procedimento</span><span class="sxs-lookup"><span data-stu-id="c949d-191">Procedure Parameters and Arguments</span></span>](procedure-parameters-and-arguments.md)
- [<span data-ttu-id="c949d-192">Sobrecarga de Procedimento</span><span class="sxs-lookup"><span data-stu-id="c949d-192">Procedure Overloading</span></span>](procedure-overloading.md)
- [<span data-ttu-id="c949d-193">Considerações sobre Procedimentos de Sobrecarga</span><span class="sxs-lookup"><span data-stu-id="c949d-193">Considerations in Overloading Procedures</span></span>](considerations-in-overloading-procedures.md)
- [<span data-ttu-id="c949d-194">Resolução de Sobrecarga</span><span class="sxs-lookup"><span data-stu-id="c949d-194">Overload Resolution</span></span>](overload-resolution.md)
