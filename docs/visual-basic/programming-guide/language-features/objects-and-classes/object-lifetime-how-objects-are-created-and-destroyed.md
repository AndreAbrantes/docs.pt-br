---
title: 'Tempo de vida do objeto: como os objetos são criados e destruídos'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: a32a5d075b5b1d02632c80216e7c2c12920bf4a2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90544135"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="20d9e-102">Tempo de vida do objeto: como os objetos são criados e destruídos (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="20d9e-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>

<span data-ttu-id="20d9e-103">Uma instância de uma classe, um objeto, é criada usando a palavra-chave `New`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="20d9e-104">Tarefas de inicialização geralmente devem ser executadas em novos objetos antes de serem usadas.</span><span class="sxs-lookup"><span data-stu-id="20d9e-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="20d9e-105">Tarefas comuns de inicialização incluem abrir arquivos, conectar-se aos bancos de dados e ler os valores das chaves do registro.</span><span class="sxs-lookup"><span data-stu-id="20d9e-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="20d9e-106">Visual Basic controla a inicialização de novos objetos usando procedimentos chamados *construtores* (métodos especiais que permitem o controle sobre a inicialização).</span><span class="sxs-lookup"><span data-stu-id="20d9e-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>

<span data-ttu-id="20d9e-107">Depois que um objeto sai do escopo, ele é liberado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="20d9e-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="20d9e-108">Visual Basic controla a versão dos recursos do sistema usando procedimentos chamados *destruidores*.</span><span class="sxs-lookup"><span data-stu-id="20d9e-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="20d9e-109">Juntos, os construtores e os destruidores oferecem suporte à criação de bibliotecas de classe robusta e previsível.</span><span class="sxs-lookup"><span data-stu-id="20d9e-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>

## <a name="using-constructors-and-destructors"></a><span data-ttu-id="20d9e-110">Usando construtores e destruidores</span><span class="sxs-lookup"><span data-stu-id="20d9e-110">Using Constructors and Destructors</span></span>

<span data-ttu-id="20d9e-111">Os construtores e os destruidores controlam a criação e a destruição de objetos.</span><span class="sxs-lookup"><span data-stu-id="20d9e-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="20d9e-112">Os `Sub New` `Sub Finalize` procedimentos e em Visual Basic inicializar e destruir objetos; eles substituem `Class_Initialize` os `Class_Terminate` métodos e usados em Visual Basic 6,0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="20d9e-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>

### <a name="sub-new"></a><span data-ttu-id="20d9e-113">Sub New</span><span class="sxs-lookup"><span data-stu-id="20d9e-113">Sub New</span></span>

<span data-ttu-id="20d9e-114">O construtor `Sub New` pode ser executado apenas uma vez quando uma classe é criada.</span><span class="sxs-lookup"><span data-stu-id="20d9e-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="20d9e-115">Não pode ser chamado explicitamente em qualquer lugar que não seja na primeira linha do código de outro construtor da mesma classe ou de uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="20d9e-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="20d9e-116">Além disso, o código no método `Sub New` sempre é executado antes de qualquer outro código em uma classe.</span><span class="sxs-lookup"><span data-stu-id="20d9e-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> <span data-ttu-id="20d9e-117">Visual Basic cria implicitamente um `Sub New` Construtor em tempo de execução se você não definir explicitamente um `Sub New` procedimento para uma classe.</span><span class="sxs-lookup"><span data-stu-id="20d9e-117">Visual Basic implicitly creates a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>

<span data-ttu-id="20d9e-118">Para criar um construtor para uma classe, crie um procedimento denominado `Sub New` em qualquer lugar na definição de classe.</span><span class="sxs-lookup"><span data-stu-id="20d9e-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="20d9e-119">Para criar um construtor com parâmetros, especifique os nomes e tipos de dados dos argumentos para `Sub New` exatamente como você faria para qualquer outro procedimento, como no seguinte código:</span><span class="sxs-lookup"><span data-stu-id="20d9e-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#42)]

<span data-ttu-id="20d9e-120">Os construtores são frequentemente sobrecarregados, como no seguinte código:</span><span class="sxs-lookup"><span data-stu-id="20d9e-120">Constructors are frequently overloaded, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#116](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#116)]

<span data-ttu-id="20d9e-121">Quando você define uma classe derivada de outra classe, a primeira linha do construtor deve ser uma chamada para o construtor da classe base, a menos que a classe base tenha um construtor acessível que não utiliza parâmetros.</span><span class="sxs-lookup"><span data-stu-id="20d9e-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="20d9e-122">Uma chamada para a classe base que contém o construtor acima, por exemplo, seria `MyBase.New(s)`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="20d9e-123">Caso contrário, `MyBase.New` é opcional e o tempo de execução de Visual Basic o chama implicitamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>

<span data-ttu-id="20d9e-124">Depois de escrever o código para chamar o construtor do objeto pai, você pode adicionar qualquer código de inicialização adicional para o procedimento `Sub New`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="20d9e-125">`Sub New` pode aceitar argumentos quando chamado como um construtor com parâmetros.</span><span class="sxs-lookup"><span data-stu-id="20d9e-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="20d9e-126">Esses parâmetros são passados do procedimento que está chamando o construtor, por exemplo, `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>

### <a name="sub-finalize"></a><span data-ttu-id="20d9e-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="20d9e-127">Sub Finalize</span></span>

<span data-ttu-id="20d9e-128">Antes da liberação de objetos, o CLR chama automaticamente o método `Finalize` para objetos que definem um procedimento `Sub Finalize`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="20d9e-129">O método `Finalize` pode conter códigos que precisam ser executados antes que um objeto seja destruído, como o código para fechar arquivos e salvar as informações de estado.</span><span class="sxs-lookup"><span data-stu-id="20d9e-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="20d9e-130">Há uma pequena perda de desempenho para executar `Sub Finalize`, portanto, você deve definir um método `Sub Finalize` somente quando precisar liberar objetos explicitamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>

> [!NOTE]
> <span data-ttu-id="20d9e-131">O coletor de lixo no CLR não (e não pode) descartar *objetos não gerenciados*, objetos que o sistema operacional executa diretamente, fora do ambiente CLR.</span><span class="sxs-lookup"><span data-stu-id="20d9e-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="20d9e-132">Isso ocorre porque diferentes objetos não gerenciados devem ser descartados de maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="20d9e-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="20d9e-133">Essas informações não estão diretamente associadas ao objeto não gerenciado; devem ser encontradas na documentação do objeto.</span><span class="sxs-lookup"><span data-stu-id="20d9e-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="20d9e-134">Uma classe que usa objetos não gerenciados deve descartá-los em seu método `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>

<span data-ttu-id="20d9e-135">O destruidor `Finalize` é um método protegido que pode ser chamado somente da classe à qual pertence ou de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="20d9e-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="20d9e-136">O sistema automaticamente chama `Finalize` quando um objeto é destruído, assim, você não deve chamar explicitamente o `Finalize` de fora de uma implementação `Finalize` de classe derivada.</span><span class="sxs-lookup"><span data-stu-id="20d9e-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>

<span data-ttu-id="20d9e-137">Diferentemente de `Class_Terminate`, que é executado assim que um objeto é definido como nada, normalmente existe um atraso entre o momento em que um objeto perde o escopo e o momento em que o Visual Basic chama o destruidor `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> <span data-ttu-id="20d9e-138">Visual Basic .NET permite um segundo tipo de destruidor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> , que pode ser chamado explicitamente a qualquer momento para liberar recursos imediatamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-138">Visual Basic .NET allows for a second kind of destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>, which can be explicitly called at any time to immediately release resources.</span></span>

> [!NOTE]
> <span data-ttu-id="20d9e-139">Um destruidor `Finalize` não deve lançar exceções, já que elas não podem ser tratadas pelo aplicativo e podem fazer com que o aplicativo seja finalizado.</span><span class="sxs-lookup"><span data-stu-id="20d9e-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>

### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="20d9e-140">Como os métodos novos e de finalização funcionam em uma hierarquia de classe</span><span class="sxs-lookup"><span data-stu-id="20d9e-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>

<span data-ttu-id="20d9e-141">Sempre que uma instância de uma classe é criada, o common language runtime (CLR) tenta executar um procedimento denominado `New`, se ele existir nesse objeto.</span><span class="sxs-lookup"><span data-stu-id="20d9e-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="20d9e-142">`New` é um tipo de procedimento denominado `constructor` que é usado para inicializar novos objetos antes que qualquer outro código em um objeto seja executado.</span><span class="sxs-lookup"><span data-stu-id="20d9e-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="20d9e-143">Um construtor `New` pode ser usado para abrir arquivos, conectar-se aos bancos de dados, inicializar variáveis e cuidar de quaisquer outras tarefas que precisam ser feitas antes que um objeto pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="20d9e-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>

<span data-ttu-id="20d9e-144">Quando uma instância de uma classe derivada é criada, o construtor `Sub New` da classe base é executado primeiro, seguido pelos construtores em classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="20d9e-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="20d9e-145">Isso acontece porque a primeira linha do código em um construtor `Sub New` usa a sintaxe `MyBase.New()` para chamar o construtor da classe imediatamente acima de si próprio na hierarquia de classe.</span><span class="sxs-lookup"><span data-stu-id="20d9e-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="20d9e-146">O construtor `Sub New` é chamado para cada classe na hierarquia de classe, até que o construtor de classe base seja atingido.</span><span class="sxs-lookup"><span data-stu-id="20d9e-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="20d9e-147">Nesse ponto, o código no construtor para a classe base é executado, seguido pelo código em cada construtor em todas as classes derivadas e o código na maioria das classes derivadas é executado por último.</span><span class="sxs-lookup"><span data-stu-id="20d9e-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>

![Captura de tela mostrando construtores e herança da hierarquia de classes.](./media/object-lifetime-how-objects-are-created-and-destroyed/subnew-constructor-inheritance.gif)

<span data-ttu-id="20d9e-149">Quando um objeto não é mais necessário, o CLR chama o método <xref:System.Object.Finalize%2A> para esse objeto antes de liberar sua memória.</span><span class="sxs-lookup"><span data-stu-id="20d9e-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="20d9e-150">O método <xref:System.Object.Finalize%2A> é denominado de `destructor` porque executa tarefas de limpeza, como salvar informações do estado, fechar arquivos e conexões ao bancos de dados e outras tarefas que devem ser executadas antes de liberar o objeto.</span><span class="sxs-lookup"><span data-stu-id="20d9e-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>

![Captura de tela mostrando o destruidor de método Finalize.](./media/object-lifetime-how-objects-are-created-and-destroyed/finalize-method-destructor.gif)

## <a name="idisposable-interface"></a><span data-ttu-id="20d9e-152">Interface IDisposable</span><span class="sxs-lookup"><span data-stu-id="20d9e-152">IDisposable Interface</span></span>

<span data-ttu-id="20d9e-153">Instâncias de classe geralmente controlam os recursos não gerenciados pelo CLR, assim como identificadores do Windows e conexões de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="20d9e-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="20d9e-154">Esses recursos devem ser descartados no método `Finalize` da classe, para que eles sejam liberados quando o objeto for destruído pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="20d9e-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="20d9e-155">No entanto, o coletor de lixo destrói objetos somente quando o CLR exige mais memória livre.</span><span class="sxs-lookup"><span data-stu-id="20d9e-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="20d9e-156">Isso significa que os recursos podem não ser liberados até muito tempo depois que o objeto sair do escopo.</span><span class="sxs-lookup"><span data-stu-id="20d9e-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>

<span data-ttu-id="20d9e-157">Para complementar a coleta de lixo, suas classes podem fornecer um mecanismo para gerenciar ativamente os recursos do sistema se eles implementarem a interface <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="20d9e-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="20d9e-158"><xref:System.IDisposable> possui um método, <xref:System.IDisposable.Dispose%2A>, o qual os clientes devem chamar ao concluir a utilização de um objeto.</span><span class="sxs-lookup"><span data-stu-id="20d9e-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="20d9e-159">Você pode usar o método <xref:System.IDisposable.Dispose%2A> para liberar recursos imediatamente e executar tarefas como fechar arquivos e conexões de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="20d9e-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="20d9e-160">Diferentemente do destruidor `Finalize`, o método <xref:System.IDisposable.Dispose%2A> não é chamado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="20d9e-161">Os clientes de uma classe devem chamar explicitamente o <xref:System.IDisposable.Dispose%2A> quando você desejar liberar recursos imediatamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>

### <a name="implementing-idisposable"></a><span data-ttu-id="20d9e-162">Implementando IDisposable</span><span class="sxs-lookup"><span data-stu-id="20d9e-162">Implementing IDisposable</span></span>

<span data-ttu-id="20d9e-163">Uma classe que implementa a interface <xref:System.IDisposable> deve incluir essas seções de código:</span><span class="sxs-lookup"><span data-stu-id="20d9e-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>

- <span data-ttu-id="20d9e-164">Um campo para controlar se o objeto foi descartado:</span><span class="sxs-lookup"><span data-stu-id="20d9e-164">A field for keeping track of whether the object has been disposed:</span></span>

  ```vb
  Protected disposed As Boolean = False
  ```

- <span data-ttu-id="20d9e-165">Uma sobrecarga de <xref:System.IDisposable.Dispose%2A> que libera recursos da classe.</span><span class="sxs-lookup"><span data-stu-id="20d9e-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="20d9e-166">Esse método deve ser chamado pelos métodos <xref:System.IDisposable.Dispose%2A> e `Finalize` da classe base:</span><span class="sxs-lookup"><span data-stu-id="20d9e-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>

  ```vb
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
          If disposing Then
              ' Insert code to free managed resources.
          End If
          ' Insert code to free unmanaged resources.
      End If
      Me.disposed = True
  End Sub
  ```

- <span data-ttu-id="20d9e-167">Uma implementação de <xref:System.IDisposable.Dispose%2A> que contém apenas o código a seguir:</span><span class="sxs-lookup"><span data-stu-id="20d9e-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>

  ```vb
  Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
  End Sub
  ```

- <span data-ttu-id="20d9e-168">Uma substituição do método `Finalize` que contém apenas o código a seguir:</span><span class="sxs-lookup"><span data-stu-id="20d9e-168">An override of the `Finalize` method that contains only the following code:</span></span>

  ```vb
  Protected Overrides Sub Finalize()
      Dispose(False)
      MyBase.Finalize()
  End Sub
  ```

### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="20d9e-169">Derivação de uma classe que implementa IDisposable</span><span class="sxs-lookup"><span data-stu-id="20d9e-169">Deriving from a Class that Implements IDisposable</span></span>

<span data-ttu-id="20d9e-170">Uma classe que é derivada de uma classe base que implementa a interface <xref:System.IDisposable> não precisa substituir nenhum dos métodos base, a menos que ele utilize recursos adicionais que precisam ser descartados.</span><span class="sxs-lookup"><span data-stu-id="20d9e-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="20d9e-171">Nessa situação, a classe derivada deve substituir o método `Dispose(disposing)` de classe base para descartar os recursos da classe derivada.</span><span class="sxs-lookup"><span data-stu-id="20d9e-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="20d9e-172">Essa substituição deve chamar o método `Dispose(disposing)` da classe base.</span><span class="sxs-lookup"><span data-stu-id="20d9e-172">This override must call the base class's `Dispose(disposing)` method.</span></span>

```vb
Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
        If disposing Then
            ' Insert code to free managed resources.
        End If
        ' Insert code to free unmanaged resources.
    End If
    MyBase.Dispose(disposing)
End Sub
```

<span data-ttu-id="20d9e-173">Uma classe derivada não deve substituir os métodos <xref:System.IDisposable.Dispose%2A> e `Finalize` da classe base.</span><span class="sxs-lookup"><span data-stu-id="20d9e-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="20d9e-174">Quando esses métodos são chamados de uma instância da classe derivada, a implementação da classe base desses métodos chamam a substituição da classe derivada do método `Dispose(disposing)`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>

## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="20d9e-175">A coleta de lixo e o destruidor de finalização</span><span class="sxs-lookup"><span data-stu-id="20d9e-175">Garbage Collection and the Finalize Destructor</span></span>

<span data-ttu-id="20d9e-176">O .NET Framework usa o sistema de *coleta de lixo de rastreamento de referência* para liberar periodicamente recursos não utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d9e-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="20d9e-177">Visual Basic 6,0 e versões anteriores usaram um sistema diferente chamado *contagem de referência* para gerenciar recursos.</span><span class="sxs-lookup"><span data-stu-id="20d9e-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="20d9e-178">Embora os dois sistemas executem a mesma função automaticamente, existem algumas diferenças importantes.</span><span class="sxs-lookup"><span data-stu-id="20d9e-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>

<span data-ttu-id="20d9e-179">O CLR destrói periodicamente objetos quando o sistema determina que esses objetos não são mais necessários.</span><span class="sxs-lookup"><span data-stu-id="20d9e-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="20d9e-180">Os objetos são liberados mais rapidamente quando os recursos de sistema estão em fornecimento pequeno e, em caso contrário, menos frequente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="20d9e-181">O atraso entre quando um objeto perde o escopo e quando o CLR libera, significa que, diferente dos objetos no Visual Basic 6.0 e versões anteriores, você não pode determinar exatamente quando o objeto será destruído.</span><span class="sxs-lookup"><span data-stu-id="20d9e-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="20d9e-182">Nessa situação, os objetos são considerados um tempo de *vida não determinístico*.</span><span class="sxs-lookup"><span data-stu-id="20d9e-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="20d9e-183">Na maioria dos casos, o tempo de vida não determinístico não altera o modo como você grava aplicativos, desde que você se lembre de que o destruidor `Finalize` pode não ser executado imediatamente quando um objeto perde o escopo.</span><span class="sxs-lookup"><span data-stu-id="20d9e-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>

<span data-ttu-id="20d9e-184">Outra diferença entre os sistemas de coleta de lixo envolve o uso de `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="20d9e-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="20d9e-185">Para aproveitar a contagem de referência no Visual Basic 6.0 e em versões anteriores, os programadores às vezes atribuem `Nothing` para as variáveis de objeto para liberar as referências que essas variáveis mantinham.</span><span class="sxs-lookup"><span data-stu-id="20d9e-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="20d9e-186">Se a variável mantiver a última referência ao objeto, os recursos do objeto são lançados imediatamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="20d9e-187">Em versões posteriores do Visual Basic, embora haja casos em que esse procedimento ainda é importante, executá-lo nunca faz com que o objeto referenciado libere seus recursos imediatamente.</span><span class="sxs-lookup"><span data-stu-id="20d9e-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="20d9e-188">Para liberar recursos imediatamente, use o método <xref:System.IDisposable.Dispose%2A> do objeto, se disponível.</span><span class="sxs-lookup"><span data-stu-id="20d9e-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="20d9e-189">A única vez em que você deve definir uma variável para `Nothing` é quando seu tempo de vida é longo em relação ao tempo que o coletor de lixo leva para detectar objetos órfãos.</span><span class="sxs-lookup"><span data-stu-id="20d9e-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="20d9e-190">Confira também</span><span class="sxs-lookup"><span data-stu-id="20d9e-190">See also</span></span>

- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="20d9e-191">[Inicialização e término de componentes](/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="20d9e-191">[Initialization and Termination of Components](/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="20d9e-192">Novo operador</span><span class="sxs-lookup"><span data-stu-id="20d9e-192">New Operator</span></span>](../../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="20d9e-193">Limpando recursos não gerenciados</span><span class="sxs-lookup"><span data-stu-id="20d9e-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="20d9e-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="20d9e-194">Nothing</span></span>](../../../language-reference/nothing.md)
