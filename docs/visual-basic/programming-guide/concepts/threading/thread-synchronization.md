---
title: Sincronização de thread (Visual Basic)
ms.date: 07/20/2015
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
ms.openlocfilehash: 3278ed1e98f71e11d47f55a0d4cb50f44ae02027
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/01/2018
ms.locfileid: "43406618"
---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="3ee7d-102">Sincronização de thread (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="3ee7d-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="3ee7d-103">As seções a seguir descrevem recursos e classes que podem ser usados para sincronizar o acesso a recursos em aplicativos multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="3ee7d-104">Um dos benefícios do usar vários threads em um aplicativo é que cada thread é executado de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="3ee7d-105">Para aplicativos do Windows, isso permite que tarefas demoradas sejam executadas em segundo plano enquanto a janela e os controles do aplicativo permanecem responsivos.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="3ee7d-106">Para aplicativos de servidor, o multithreading possibilita lidar com cada solicitação de entrada com um thread diferente.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="3ee7d-107">Caso contrário, cada nova solicitação não seria atendida antes que a solicitação anterior fosse totalmente satisfeita.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="3ee7d-108">No entanto, a natureza assíncrona dos threads significa que o acesso a recursos, como identificadores de arquivos, conexões de rede e memória, deve ser coordenado.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="3ee7d-109">Caso contrário, dois ou mais threads poderiam acessar o mesmo recurso ao mesmo tempo, cada um deles sem conhecimento das ações do outro.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="3ee7d-110">O resultado são dados corrompidos de forma imprevisível.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="3ee7d-111">Para operações simples em tipos de dados numéricos integrais, os threads de sincronização podem ser realizados com membros da classe <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="3ee7d-112">Para todos os outros tipos de dados e recursos não thread-safe, o multithreading só pode ser realizado com segurança usando os constructos neste tópico.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="3ee7d-113">Para obter informações gerais sobre a programação multi-threaded, consulte:</span><span class="sxs-lookup"><span data-stu-id="3ee7d-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="3ee7d-114">Noções básicas de threading gerenciado</span><span class="sxs-lookup"><span data-stu-id="3ee7d-114">Managed Threading Basics</span></span>](../../../../standard/threading/managed-threading-basics.md)  
  
-   [<span data-ttu-id="3ee7d-115">Usando threads e threading</span><span class="sxs-lookup"><span data-stu-id="3ee7d-115">Using Threads and Threading</span></span>](../../../../standard/threading/using-threads-and-threading.md)  
  
-   [<span data-ttu-id="3ee7d-116">Práticas recomendadas de threading gerenciado</span><span class="sxs-lookup"><span data-stu-id="3ee7d-116">Managed Threading Best Practices</span></span>](../../../../standard/threading/managed-threading-best-practices.md)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="3ee7d-117">O bloqueio e SyncLock as palavras-chave</span><span class="sxs-lookup"><span data-stu-id="3ee7d-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="3ee7d-118">O Visual Basic `SyncLock` instrução pode ser usada para garantir que um bloco de código é executado até a conclusão sem interrupção por outros threads.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="3ee7d-119">Isso é feito obtendo um bloqueio de exclusão mútua para um determinado objeto pela duração do bloco de código.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="3ee7d-120">Uma instrução `SyncLock` recebe um objeto como argumento e é seguida por um bloco de código que deve ser executado por apenas um thread por vez.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="3ee7d-121">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="3ee7d-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="3ee7d-122">O argumento fornecido à palavra-chave `SyncLock` deve ser um objeto baseado em um tipo de referência e é usado para definir o escopo do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="3ee7d-123">No exemplo acima, o escopo do bloqueio é limitado a essa função porque não há referências ao objeto `lockThis` fora da função.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="3ee7d-124">Se tal referência existisse, o escopo do bloqueio se estenderia a esse objeto.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="3ee7d-125">Falando rigorosamente, o objeto fornecido é usado apenas para identificar de forma exclusiva o recurso compartilhado entre vários threads, então ele pode ser uma instância de classe arbitrária.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="3ee7d-126">Na prática, no entanto, esse objeto normalmente representa o recurso para o qual a sincronização de threads é necessária.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="3ee7d-127">Por exemplo, se um objeto de contêiner for usado por vários threads, o contêiner poderá ser passado para o bloqueio e o bloco de código sincronizado após o bloqueio acessaria o contêiner.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="3ee7d-128">Desde que outros threads bloqueiem o mesmo contêiner antes de acessá-lo, o acesso ao objeto é sincronizado com segurança.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="3ee7d-129">Geralmente, é melhor evitar bloquear um tipo `public` ou instâncias de objeto além do controle do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="3ee7d-130">Por exemplo, `lockThis` pode ser problemático se a instância puder ser acessada publicamente, porque o código fora do seu controle também poderá bloquear o objeto.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="3ee7d-131">Isso pode criar situações de deadlock, em que dois ou mais threads esperam a liberação do mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="3ee7d-132">Bloquear um tipo de dados público, em vez de um objeto, pode causar problemas pelo mesmo motivo.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="3ee7d-133">Bloquear cadeias de caracteres literais é especialmente arriscado porque cadeias de caracteres literais são *internos* ao CLR (Common Language Runtime).</span><span class="sxs-lookup"><span data-stu-id="3ee7d-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="3ee7d-134">Isso significa que há uma instância de um determinado literal de cadeia de caracteres para todo o programa, o mesmo objeto exato representa o literal em todos os domínios de aplicativo em execução, em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="3ee7d-135">Como resultado, um bloqueio colocado em uma cadeia de caracteres com o mesmo conteúdo em qualquer parte do processo do aplicativo bloqueia todas as instâncias dessa cadeia de caracteres no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="3ee7d-136">Sendo assim, é melhor bloquear um membro particular ou protegido que não é interno.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="3ee7d-137">Algumas classes fornecem membros especificamente para o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="3ee7d-138">O tipo <xref:System.Array>, por exemplo, fornece <xref:System.Array.SyncRoot%2A>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="3ee7d-139">Muitos tipos de coleção fornecem também fornecem um membro `SyncRoot`.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="3ee7d-140">Para obter mais informações sobre a instrução `SyncLock`, consulte os tópicos a seguir:</span><span class="sxs-lookup"><span data-stu-id="3ee7d-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="3ee7d-141">Instrução SyncLock</span><span class="sxs-lookup"><span data-stu-id="3ee7d-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   <xref:System.Threading.Monitor>  
  
## <a name="monitors"></a><span data-ttu-id="3ee7d-142">Monitores</span><span class="sxs-lookup"><span data-stu-id="3ee7d-142">Monitors</span></span>  
 <span data-ttu-id="3ee7d-143">Assim como a palavra-chave `SyncLock`, os monitores impedem que blocos de código sejam executados simultaneamente por vários threads.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="3ee7d-144">O método <xref:System.Threading.Monitor.Enter%2A> permite que apenas um thread prossiga para as instruções seguintes, todos os outros threads são bloqueados até que o thread em execução chame <xref:System.Threading.Monitor.Exit%2A>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="3ee7d-145">É como usar a palavra-chave `SyncLock`.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="3ee7d-146">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="3ee7d-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="3ee7d-147">Isso é equivalente a:</span><span class="sxs-lookup"><span data-stu-id="3ee7d-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="3ee7d-148">Usar a palavra-chave `SyncLock` geralmente é preferível a usar a classe <xref:System.Threading.Monitor> diretamente, porque `SyncLock` é mais conciso e porque `SyncLock` garante que o monitor subjacente seja liberado, mesmo que o código protegido gere uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="3ee7d-149">Isso é feito com a palavra-chave `Finally`, que executa o bloco de código associado independentemente de uma exceção ser lançada.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="3ee7d-150">Eventos de sincronização e identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="3ee7d-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="3ee7d-151">Usar um monitor ou um bloqueio é útil para evitar a execução simultânea de blocos de código sensíveis ao thread, mas esses constructos não permitem que um thread comunique um evento a outro.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="3ee7d-152">Isso requer *eventos de sincronização*, que são objetos que têm um de dois estados, sinalizado e não sinalizado, que podem ser usados para ativar e suspender os threads.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="3ee7d-153">Threads podem ser suspensos tendo que aguardar um evento de sincronização não sinalizado e podem ser ativados alterando o estado do evento para sinalizado.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="3ee7d-154">Se um thread tentar aguardar um evento que já é sinalizado, então o thread continua sendo executado sem atraso.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="3ee7d-155">Há dois tipos de eventos de sincronização: <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="3ee7d-156">A única diferença entre eles é que <xref:System.Threading.AutoResetEvent> muda de sinalizado para não sinalizado automaticamente sempre que ele ativar um thread.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="3ee7d-157">Por outro lado, um <xref:System.Threading.ManualResetEvent> permite que qualquer número de threads seja ativado por seu estado sinalizado e será revertido apenas para estado não sinalizado quando seu método <xref:System.Threading.EventWaitHandle.Reset%2A> for chamado.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="3ee7d-158">É possível fazer os threads esperarem por eventos chamando um dos métodos de espera, como <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> ou <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="3ee7d-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> faz com que o thread espere até que um único evento se torne sinalizado, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> bloqueia um thread até que um ou mais eventos indicados se tornem sinalizados e <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> bloqueia o thread até que todos os eventos indicados ser tornem sinalizados.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="3ee7d-160">Um evento se torna sinalizado quando seu método <xref:System.Threading.EventWaitHandle.Set%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="3ee7d-161">No exemplo a seguir, um thread é criado e iniciado pela função `Main`.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="3ee7d-162">O novo thread aguarda um evento usando o método <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3ee7d-163">O thread é suspenso até que o evento seja sinalizado pelo thread principal que está executando a função `Main`.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="3ee7d-164">Após o evento ser sinalizado, o thread auxiliar é retornado.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="3ee7d-165">Nesse caso, como o evento é usado apenas para uma ativação de thread, as classes <xref:System.Threading.AutoResetEvent> ou <xref:System.Threading.ManualResetEvent> podem ser usadas.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="3ee7d-166">Objeto mutex</span><span class="sxs-lookup"><span data-stu-id="3ee7d-166">Mutex Object</span></span>  
 <span data-ttu-id="3ee7d-167">Um *mutex* é semelhante a um monitor; ele impede a execução simultânea de um bloco de código por mais de um thread por vez.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="3ee7d-168">Na verdade, o nome "mutex" é uma forma abreviada do termo "mutuamente exclusivo".</span><span class="sxs-lookup"><span data-stu-id="3ee7d-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="3ee7d-169">No entanto, diferente dos monitores, um mutex pode ser usado para sincronizar threads entre processos.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="3ee7d-170">Um mutex é representado pela classe <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="3ee7d-171">Quando usado para sincronização entre processos, um mutex é chamado de *mutex nomeado* porque deve ser usado em outro aplicativo e, portanto, não pode ser compartilhado por meio de uma variável global ou estática.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="3ee7d-172">Ele deve receber um nome para que ambos os aplicativos possam acessar o mesmo objeto de mutex.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="3ee7d-173">Embora um mutex possa ser usado para sincronização de threads dentro do processo, o uso de <xref:System.Threading.Monitor> normalmente é preferível, pois os monitores foram criados especificamente para o .NET Framework e, portanto, utilizam melhor os recursos.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="3ee7d-174">Por outro lado, a classe <xref:System.Threading.Mutex> é um wrapper para um constructo de Win32.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="3ee7d-175">Embora seja mais eficiente do que um monitor, um mutex requer transições de interoperabilidade que são mais dispendiosas em termos computacionais do que aquelas necessárias para a classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="3ee7d-176">Para obter um exemplo de como usar um mutex, consulte [Mutexes](../../../../standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="3ee7d-176">For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="3ee7d-177">Classe Interlocked</span><span class="sxs-lookup"><span data-stu-id="3ee7d-177">Interlocked Class</span></span>  
 <span data-ttu-id="3ee7d-178">É possível usar os métodos da classe <xref:System.Threading.Interlocked> para evitar problemas que podem ocorrer quando vários threads tentam atualizar ou comparar simultaneamente o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="3ee7d-179">Os métodos dessa classe permitem incrementar, decrementar, trocar e comparar de forma segura os valores de qualquer thread.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="3ee7d-180">Bloqueios ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="3ee7d-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="3ee7d-181">Em alguns casos, talvez você queira bloquear um recurso somente quando dados estiverem sendo gravados e permitir que vários clientes leiam simultaneamente os dados quando eles não estiverem sendo atualizados.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="3ee7d-182">A classe <xref:System.Threading.ReaderWriterLock> força o acesso exclusivo a um recurso enquanto um thread está modificando o recurso, mas permite acesso não exclusivo ao ler o recurso.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="3ee7d-183">Bloqueios ReaderWriter são uma alternativa útil a bloqueios exclusivos, fazem outros segmentos esperar, mesmo quando esses threads não precisam atualizar dados.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="3ee7d-184">Deadlocks</span><span class="sxs-lookup"><span data-stu-id="3ee7d-184">Deadlocks</span></span>  
 <span data-ttu-id="3ee7d-185">A sincronização de threads tem valor incalculável em aplicativos multi-threaded, mas sempre há o perigo de criar um `deadlock`, em que vários segmentos estão aguardando uns aos outros e o aplicativo é interrompido.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="3ee7d-186">Um deadlock é semelhante a uma situação em que carros estão parados em uma parada de quatro vias e cada pessoa está aguardando a outra prosseguir.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="3ee7d-187">Evitar deadlocks é importante; a chave é um planejamento cuidadoso.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="3ee7d-188">Geralmente, você pode prever situações de deadlock diagramando aplicativos multi-threaded antes de iniciar a codificação.</span><span class="sxs-lookup"><span data-stu-id="3ee7d-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3ee7d-189">Consulte também</span><span class="sxs-lookup"><span data-stu-id="3ee7d-189">See Also</span></span>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.WaitHandle.WaitOne%2A>  
 <xref:System.Threading.WaitHandle.WaitAny%2A>  
 <xref:System.Threading.WaitHandle.WaitAll%2A>  
 <xref:System.Threading.Thread.Join%2A>  
 <xref:System.Threading.Thread.Start%2A>  
 <xref:System.Threading.Thread.Sleep%2A>  
 <xref:System.Threading.Monitor>  
 <xref:System.Threading.Mutex>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading>  
 <xref:System.Threading.EventWaitHandle.Set%2A>  
 <xref:System.Threading.Monitor>  
 [<span data-ttu-id="3ee7d-190">Instrução SyncLock</span><span class="sxs-lookup"><span data-stu-id="3ee7d-190">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
 [<span data-ttu-id="3ee7d-191">Mutexes</span><span class="sxs-lookup"><span data-stu-id="3ee7d-191">Mutexes</span></span>](../../../../standard/threading/mutexes.md)  
 [<span data-ttu-id="3ee7d-192">Operações interconectadas</span><span class="sxs-lookup"><span data-stu-id="3ee7d-192">Interlocked Operations</span></span>](../../../../standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="3ee7d-193">AutoResetEvent</span><span class="sxs-lookup"><span data-stu-id="3ee7d-193">AutoResetEvent</span></span>](../../../../standard/threading/autoresetevent.md)  
 [<span data-ttu-id="3ee7d-194">Sincronizando dados para multithreading</span><span class="sxs-lookup"><span data-stu-id="3ee7d-194">Synchronizing Data for Multithreading</span></span>](../../../../standard/threading/synchronizing-data-for-multithreading.md)
