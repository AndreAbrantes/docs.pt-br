---
title: "Segmento de sincronização (Visual Basic) | Documentos do Microsoft"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
caps.latest.revision: 3
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 240937905254120f777ce140049084279c35005c
ms.contentlocale: pt-br
ms.lasthandoff: 04/12/2017

---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="8277d-102">Sincronização de thread (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8277d-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="8277d-103">As seções a seguir descrevem os recursos e classes que podem ser usados para sincronizar o acesso a recursos em aplicativos multithread.</span><span class="sxs-lookup"><span data-stu-id="8277d-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="8277d-104">Um dos benefícios do uso de vários threads em um aplicativo é que cada thread executa de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="8277d-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="8277d-105">Para aplicativos do Windows, isso permite tarefas demoradas ser executada em segundo plano enquanto a janela do aplicativo e os controles permaneçam responsivos.</span><span class="sxs-lookup"><span data-stu-id="8277d-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="8277d-106">Servidor de aplicativos, multithreading fornece a capacidade de lidar com cada solicitação de entrada com um thread diferente.</span><span class="sxs-lookup"><span data-stu-id="8277d-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="8277d-107">Caso contrário, cada nova solicitação não obter atendida antes que a solicitação anterior tinha sido totalmente satisfeita.</span><span class="sxs-lookup"><span data-stu-id="8277d-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="8277d-108">No entanto, a natureza assíncrona dos meios de threads que o acesso aos recursos, como identificadores de arquivos, conexões de rede e memória deve ser coordenada.</span><span class="sxs-lookup"><span data-stu-id="8277d-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="8277d-109">Caso contrário, dois ou mais threads podem acessar o mesmo recurso ao mesmo tempo, cada ciente das ações do outro.</span><span class="sxs-lookup"><span data-stu-id="8277d-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="8277d-110">O resultado é a corrupção de dados imprevisível.</span><span class="sxs-lookup"><span data-stu-id="8277d-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="8277d-111">Para operações simples em tipos de dados numéricos integral, o sincronização de threads pode ser realizado com membros de <xref:System.Threading.Interlocked>classe.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="8277d-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="8277d-112">Para todos os outros dados de tipos e recursos não thread-safe, multithreading só podem ser com segurança executados usando as construções neste tópico.</span><span class="sxs-lookup"><span data-stu-id="8277d-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="8277d-113">Para obter informações sobre a programação multithreaded, consulte:</span><span class="sxs-lookup"><span data-stu-id="8277d-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="8277d-114">Noções básicas de Threading gerenciado</span><span class="sxs-lookup"><span data-stu-id="8277d-114">Managed Threading Basics</span></span>](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)  
  
-   [<span data-ttu-id="8277d-115">Usando Threads e Threading</span><span class="sxs-lookup"><span data-stu-id="8277d-115">Using Threads and Threading</span></span>](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)  
  
-   [<span data-ttu-id="8277d-116">Práticas recomendadas de Threading gerenciado</span><span class="sxs-lookup"><span data-stu-id="8277d-116">Managed Threading Best Practices</span></span>](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="8277d-117">O bloqueio e as palavras-chave SyncLock</span><span class="sxs-lookup"><span data-stu-id="8277d-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="8277d-118">O Visual Basic `SyncLock` instrução pode ser usada para garantir que um bloco de código seja executada até a conclusão sem interrupção por outros threads.</span><span class="sxs-lookup"><span data-stu-id="8277d-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="8277d-119">Isso é feito obtendo um bloqueio de exclusão mútua para um determinado objeto para a duração do bloco de código.</span><span class="sxs-lookup"><span data-stu-id="8277d-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="8277d-120">Um `SyncLock` instrução é dado um objeto como um argumento e é seguida por um bloco de código que deve ser executado por apenas um thread por vez.</span><span class="sxs-lookup"><span data-stu-id="8277d-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="8277d-121">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="8277d-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="8277d-122">O argumento fornecido para o `SyncLock` palavra-chave deve ser um objeto com base em um tipo de referência e é usado para definir o escopo do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="8277d-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="8277d-123">No exemplo acima, o escopo de bloqueio é limitado para essa função porque nenhuma referência ao objeto `lockThis` existir fora da função.</span><span class="sxs-lookup"><span data-stu-id="8277d-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="8277d-124">Se tal referência existisse, escopo de bloqueio se estende para o objeto.</span><span class="sxs-lookup"><span data-stu-id="8277d-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="8277d-125">Estritamente falando, o objeto fornecido é usado exclusivamente para identificar exclusivamente o recurso seja compartilhado entre vários threads, assim ela pode ser uma instância da classe arbitrário.</span><span class="sxs-lookup"><span data-stu-id="8277d-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="8277d-126">Na prática, no entanto, esse objeto normalmente representa o recurso para o qual o segmento de sincronização é necessária.</span><span class="sxs-lookup"><span data-stu-id="8277d-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="8277d-127">Por exemplo, se um objeto contêiner deve ser usado por vários threads, em seguida, o contêiner pode ser passado para bloquear e bloco sincronizado após o bloqueio poderia acessar o contêiner.</span><span class="sxs-lookup"><span data-stu-id="8277d-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="8277d-128">Enquanto outros threads bloqueia no mesmo conter para acessá-lo, e com segurança o acesso ao objeto é sincronizado.</span><span class="sxs-lookup"><span data-stu-id="8277d-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="8277d-129">Geralmente, é melhor evitar o bloqueio em um `public` tipo, ou em instâncias de objeto além do controle do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="8277d-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="8277d-130">Por exemplo, `lockThis` pode ser problemático se a instância pode ser acessada publicamente, porque o código fora de seu controle, poderá bloquear o objeto.</span><span class="sxs-lookup"><span data-stu-id="8277d-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="8277d-131">Isso pode criar situações de deadlock, onde dois ou mais threads esperam para a versão do mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="8277d-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="8277d-132">O bloqueio em um tipo de dados públicos, em vez de um objeto, pode causar problemas pelo mesmo motivo.</span><span class="sxs-lookup"><span data-stu-id="8277d-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="8277d-133">O bloqueio em cadeias de caracteres literal é arriscado especialmente como cadeias de caracteres literais são *interned* pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="8277d-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="8277d-134">Isso significa que há uma instância de determinada cadeia de caracteres literal para todo o programa, o mesmo objeto exato representa o literal em todas executando domínios de aplicativo, em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="8277d-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="8277d-135">Como resultado, um bloqueio colocado em uma cadeia de caracteres com o mesmo conteúdo em qualquer lugar em que os bloqueios de processo do aplicativo todas as instâncias dessa cadeia de caracteres no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="8277d-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="8277d-136">Como resultado, é melhor bloquear um membro particular ou protegido que não é interned.</span><span class="sxs-lookup"><span data-stu-id="8277d-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="8277d-137">Algumas classes fornecem aos membros especificamente para o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="8277d-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="8277d-138">O <xref:System.Array>tipo, por exemplo, fornece <xref:System.Array.SyncRoot%2A>.</xref:System.Array.SyncRoot%2A> </xref:System.Array></span><span class="sxs-lookup"><span data-stu-id="8277d-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="8277d-139">Muitos tipos de coleção fornecem um `SyncRoot` membro também.</span><span class="sxs-lookup"><span data-stu-id="8277d-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="8277d-140">Para obter mais informações sobre o `SyncLock` instrução, consulte os seguintes tópicos:</span><span class="sxs-lookup"><span data-stu-id="8277d-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="8277d-141">Instrução SyncLock</span><span class="sxs-lookup"><span data-stu-id="8277d-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   @System.Threading.Monitor  
  
## <a name="monitors"></a><span data-ttu-id="8277d-142">Monitores</span><span class="sxs-lookup"><span data-stu-id="8277d-142">Monitors</span></span>  
 <span data-ttu-id="8277d-143">Como o `SyncLock` palavra-chave, monitores impedir blocos de código de execução simultaneamente por vários threads.</span><span class="sxs-lookup"><span data-stu-id="8277d-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="8277d-144">O <xref:System.Threading.Monitor.Enter%2A>método permite que apenas um thread prosseguir para as seguintes instruções; todos os outros threads são bloqueados até que a execução do thread chama <xref:System.Threading.Monitor.Exit%2A>.</xref:System.Threading.Monitor.Exit%2A> </xref:System.Threading.Monitor.Enter%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="8277d-145">Isso é como usar o `SyncLock` palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="8277d-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="8277d-146">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="8277d-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="8277d-147">Isso é equivalente a:</span><span class="sxs-lookup"><span data-stu-id="8277d-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="8277d-148">Usando o `SyncLock` palavra-chave é geralmente preferível usar o <xref:System.Threading.Monitor>classe diretamente, ambos porque `SyncLock` é mais conciso e porque `SyncLock` assegura que o monitor subjacente é liberado, mesmo que o código protegido lança uma exceção.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="8277d-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="8277d-149">Isso é feito com o `Finally` palavra-chave, que executa o bloco de código associado independentemente se uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8277d-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="8277d-150">Eventos de sincronização e identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="8277d-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="8277d-151">Usar um monitor ou um bloqueio é útil para evitar a execução simultânea de thread diferencia blocos de código, mas essas construções não permitem que um thread para se comunicar um evento para outro.</span><span class="sxs-lookup"><span data-stu-id="8277d-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="8277d-152">Isso requer *eventos de sincronização*, que são objetos que possuem um de dois estados, signaled e não sinalizado, que pode ser usado para ativar e suspender os threads.</span><span class="sxs-lookup"><span data-stu-id="8277d-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="8277d-153">Segmentos podem ser suspensa por sendo feitas para aguardar um evento de sincronização é sinalizado e podem ser ativados pela alteração do estado do evento para sinalizar.</span><span class="sxs-lookup"><span data-stu-id="8277d-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="8277d-154">Se um thread tentar aguardar um evento que já é sinalizado, em seguida, o segmento continua a executar sem atraso.</span><span class="sxs-lookup"><span data-stu-id="8277d-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="8277d-155">Há dois tipos de eventos de sincronização: <xref:System.Threading.AutoResetEvent>e <xref:System.Threading.ManualResetEvent>.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="8277d-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="8277d-156">Eles diferem apenas em que <xref:System.Threading.AutoResetEvent>as alterações do sinalizado para sinalizado automaticamente sempre que ele ativa um thread.</xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="8277d-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="8277d-157">Por outro lado, um <xref:System.Threading.ManualResetEvent>permite que qualquer número de threads para ser ativado por estado sinalizado e só será revertido para um sinalizado estado quando seu <xref:System.Threading.EventWaitHandle.Reset%2A>método é chamado.</xref:System.Threading.EventWaitHandle.Reset%2A> </xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="8277d-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="8277d-158">Threads podem ser feitos para esperar por eventos chamando um dos métodos de espera, como <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, ou <xref:System.Threading.WaitHandle.WaitAll%2A>.</xref:System.Threading.WaitHandle.WaitAll%2A> </xref:System.Threading.WaitHandle.WaitAny%2A> </xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="8277d-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>faz com que o thread a esperar até que um único evento se torna sinalizado, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName>bloqueia um thread até que um ou mais eventos indicados tornou-se sinalizado, e <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName>bloqueia o thread até que todos os eventos indicados tornou-se sinalizado.</xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName></xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="8277d-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="8277d-160">Um evento se torna sinalizado quando seu <xref:System.Threading.EventWaitHandle.Set%2A>método é chamado.</xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="8277d-161">No exemplo a seguir, um thread é criado e iniciado pelo `Main` função.</span><span class="sxs-lookup"><span data-stu-id="8277d-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="8277d-162">O novo thread aguarda em um evento usando o <xref:System.Threading.WaitHandle.WaitOne%2A>método.</xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="8277d-163">O thread está suspenso até que o evento torna-se sinalizado pelo thread principal que está executando o `Main` função.</span><span class="sxs-lookup"><span data-stu-id="8277d-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="8277d-164">Depois que o evento torna-se sinalizado, retorna o thread auxiliar.</span><span class="sxs-lookup"><span data-stu-id="8277d-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="8277d-165">Nesse caso, como o evento só é usado para ativação de um thread, ou o <xref:System.Threading.AutoResetEvent>ou <xref:System.Threading.ManualResetEvent>classes pode ser usadas.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="8277d-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="8277d-166">Objeto mutex</span><span class="sxs-lookup"><span data-stu-id="8277d-166">Mutex Object</span></span>  
 <span data-ttu-id="8277d-167">A *mutex* é semelhante a um monitor; ele impede a execução simultânea de um bloco de código por mais de um thread por vez.</span><span class="sxs-lookup"><span data-stu-id="8277d-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="8277d-168">Na verdade, o nome "mutex" é uma forma abreviada do termo "mutuamente".</span><span class="sxs-lookup"><span data-stu-id="8277d-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="8277d-169">Ao contrário dos monitores, no entanto, um mutex pode ser usado para sincronizar threads entre processos.</span><span class="sxs-lookup"><span data-stu-id="8277d-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="8277d-170">Um mutex é representado pela <xref:System.Threading.Mutex>classe.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="8277d-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="8277d-171">Quando usado para sincronização entre processos, um mutex é chamado um *mutex denominado* porque ele deve ser usado em outro aplicativo e, portanto, não podem ser compartilhado por meio de uma variável global ou estática.</span><span class="sxs-lookup"><span data-stu-id="8277d-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="8277d-172">Ele deve ser dado um nome para que ambos os aplicativos podem acessar o mesmo objeto de mutex.</span><span class="sxs-lookup"><span data-stu-id="8277d-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="8277d-173">Embora um mutex pode ser usado para sincronização de threads de processo interno, usando <xref:System.Threading.Monitor>é geralmente preferível, pois os monitores foram projetados especificamente para o .NET Framework e, portanto, fazer melhor uso dos recursos.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="8277d-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="8277d-174">Por outro lado, a <xref:System.Threading.Mutex>classe é um wrapper para uma construção de Win32.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="8277d-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="8277d-175">Embora seja mais eficiente do que um monitor, um mutex requer transições de interoperabilidade que são mais dispendiosa computacionalmente daqueles necessários para a <xref:System.Threading.Monitor>classe.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="8277d-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="8277d-176">Para obter um exemplo de como usar um mutex, consulte [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span><span class="sxs-lookup"><span data-stu-id="8277d-176">For an example of using a mutex, see [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="8277d-177">Classe Interlocked</span><span class="sxs-lookup"><span data-stu-id="8277d-177">Interlocked Class</span></span>  
 <span data-ttu-id="8277d-178">Você pode usar os métodos de <xref:System.Threading.Interlocked>classe para evitar problemas que podem ocorrer quando vários segmentos tentarem simultaneamente atualizar ou comparar o mesmo valor.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="8277d-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="8277d-179">Os métodos dessa classe permitem que você com segurança incremento, decremento, exchange e comparam valores de qualquer thread.</span><span class="sxs-lookup"><span data-stu-id="8277d-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="8277d-180">Bloqueios ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="8277d-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="8277d-181">Em alguns casos, você talvez queira bloquear um recurso somente quando os dados estão sendo gravados e permitir que vários clientes simultaneamente leiam os dados quando dados não está sendo atualizados.</span><span class="sxs-lookup"><span data-stu-id="8277d-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="8277d-182">O <xref:System.Threading.ReaderWriterLock>classe garante o acesso exclusivo a um recurso enquanto um segmento está modificando o recurso, mas ele permite acesso não-exclusivo ao ler o recurso.</xref:System.Threading.ReaderWriterLock></span><span class="sxs-lookup"><span data-stu-id="8277d-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="8277d-183">Bloqueios ReaderWriter são uma alternativa útil para bloqueios exclusivos que causam outros segmentos para esperar, mesmo quando esses threads não é necessário atualizar os dados.</span><span class="sxs-lookup"><span data-stu-id="8277d-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="8277d-184">Deadlocks</span><span class="sxs-lookup"><span data-stu-id="8277d-184">Deadlocks</span></span>  
 <span data-ttu-id="8277d-185">Sincronização de thread não é válida em aplicativos multissegmentados, mas há sempre o perigo de criação de um `deadlock`, onde vários segmentos estão aguardando um pelo outro e o aplicativo chega a uma interrupção.</span><span class="sxs-lookup"><span data-stu-id="8277d-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="8277d-186">Um deadlock é análogo a uma situação na qual carros são interrompidos em uma parada de quatro vias e cada pessoa está aguardando a outra para ir.</span><span class="sxs-lookup"><span data-stu-id="8277d-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="8277d-187">Evitar deadlocks é importante; a chave é um planejamento cuidadoso.</span><span class="sxs-lookup"><span data-stu-id="8277d-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="8277d-188">Geralmente você pode prever situações de bloqueio por diagramação de aplicativos multissegmentados antes de iniciar a codificação.</span><span class="sxs-lookup"><span data-stu-id="8277d-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8277d-189">Consulte também</span><span class="sxs-lookup"><span data-stu-id="8277d-189">See Also</span></span>  
 <span data-ttu-id="8277d-190"><xref:System.Threading.Thread></xref:System.Threading.Thread></span><span class="sxs-lookup"><span data-stu-id="8277d-190"><xref:System.Threading.Thread></span></span>   
 <span data-ttu-id="8277d-191"><xref:System.Threading.WaitHandle.WaitOne%2A></xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-191"><xref:System.Threading.WaitHandle.WaitOne%2A></span></span>   
 <span data-ttu-id="8277d-192"><xref:System.Threading.WaitHandle.WaitAny%2A></xref:System.Threading.WaitHandle.WaitAny%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-192"><xref:System.Threading.WaitHandle.WaitAny%2A></span></span>   
 <span data-ttu-id="8277d-193"><xref:System.Threading.WaitHandle.WaitAll%2A></xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-193"><xref:System.Threading.WaitHandle.WaitAll%2A></span></span>   
 <span data-ttu-id="8277d-194"><xref:System.Threading.Thread.Join%2A></xref:System.Threading.Thread.Join%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-194"><xref:System.Threading.Thread.Join%2A></span></span>   
 <span data-ttu-id="8277d-195"><xref:System.Threading.Thread.Start%2A></xref:System.Threading.Thread.Start%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-195"><xref:System.Threading.Thread.Start%2A></span></span>   
 <span data-ttu-id="8277d-196"><xref:System.Threading.Thread.Sleep%2A></xref:System.Threading.Thread.Sleep%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-196"><xref:System.Threading.Thread.Sleep%2A></span></span>   
 <span data-ttu-id="8277d-197"><xref:System.Threading.Monitor></xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="8277d-197"><xref:System.Threading.Monitor></span></span>   
 <span data-ttu-id="8277d-198"><xref:System.Threading.Mutex></xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="8277d-198"><xref:System.Threading.Mutex></span></span>   
 <span data-ttu-id="8277d-199"><xref:System.Threading.AutoResetEvent></xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="8277d-199"><xref:System.Threading.AutoResetEvent></span></span>   
 <span data-ttu-id="8277d-200"><xref:System.Threading.ManualResetEvent></xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="8277d-200"><xref:System.Threading.ManualResetEvent></span></span>   
 <span data-ttu-id="8277d-201"><xref:System.Threading.Interlocked></xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="8277d-201"><xref:System.Threading.Interlocked></span></span>   
 <span data-ttu-id="8277d-202"><xref:System.Threading.WaitHandle></xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="8277d-202"><xref:System.Threading.WaitHandle></span></span>   
 <span data-ttu-id="8277d-203"><xref:System.Threading.EventWaitHandle></xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="8277d-203"><xref:System.Threading.EventWaitHandle></span></span>   
 <span data-ttu-id="8277d-204"><xref:System.Threading></xref:System.Threading></span><span class="sxs-lookup"><span data-stu-id="8277d-204"><xref:System.Threading></span></span>   
 <span data-ttu-id="8277d-205"><xref:System.Threading.EventWaitHandle.Set%2A></xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="8277d-205"><xref:System.Threading.EventWaitHandle.Set%2A></span></span>   
<span data-ttu-id="8277d-206"> [Aplicativos multithread (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span><span class="sxs-lookup"><span data-stu-id="8277d-206"> [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span></span>  
<span data-ttu-id="8277d-207"> [Instrução SyncLock](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span><span class="sxs-lookup"><span data-stu-id="8277d-207"> [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span></span>  
<span data-ttu-id="8277d-208"> [Exclusões mútuas](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span><span class="sxs-lookup"><span data-stu-id="8277d-208"> [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span></span>  
 @System.Threading.Monitor   
<span data-ttu-id="8277d-209"> [Operações interconectadas](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span><span class="sxs-lookup"><span data-stu-id="8277d-209"> [Interlocked Operations](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span></span>  
<span data-ttu-id="8277d-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span><span class="sxs-lookup"><span data-stu-id="8277d-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span></span>  
<span data-ttu-id="8277d-211"> [Sincronizando dados para Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span><span class="sxs-lookup"><span data-stu-id="8277d-211"> [Synchronizing Data for Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span></span>
