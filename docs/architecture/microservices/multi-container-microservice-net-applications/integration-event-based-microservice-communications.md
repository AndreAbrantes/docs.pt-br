---
title: Implementando comunicação baseada em evento entre microsserviços (eventos de integração)
description: Arquitetura de microsserviços .NET para aplicativos .NET em contêineres | Entender eventos de integração para implementar comunicação baseada em evento entre microsserviços.
ms.date: 10/02/2018
ms.openlocfilehash: 70566745dc084ba9016a850ad749fefb958e89ec
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/07/2019
ms.locfileid: "73737134"
---
# <a name="implementing-event-based-communication-between-microservices-integration-events"></a><span data-ttu-id="c6f2d-103">Implementando comunicação baseada em evento entre microsserviços (eventos de integração)</span><span class="sxs-lookup"><span data-stu-id="c6f2d-103">Implementing event-based communication between microservices (integration events)</span></span>

<span data-ttu-id="c6f2d-104">Conforme descrito anteriormente, quando você usa comunicação baseada em evento, um microsserviço publica um evento quando algo importante acontece, como quando ele atualiza uma entidade de negócios.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-104">As described earlier, when you use event-based communication, a microservice publishes an event when something notable happens, such as when it updates a business entity.</span></span> <span data-ttu-id="c6f2d-105">Outros microsserviços assinam esses eventos.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-105">Other microservices subscribe to those events.</span></span> <span data-ttu-id="c6f2d-106">Quando um microsserviço recebe um evento, ele pode atualizar suas próprias entidades de negócios, o que pode levar à publicação de mais eventos.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-106">When a microservice receives an event, it can update its own business entities, which might lead to more events being published.</span></span> <span data-ttu-id="c6f2d-107">Essa é a essência do conceito de consistência eventual.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-107">This is the essence of the eventual consistency concept.</span></span> <span data-ttu-id="c6f2d-108">Este sistema de publicação/assinatura normalmente é executado por meio de uma implementação de um barramento de evento.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-108">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="c6f2d-109">O barramento de evento pode ser criado como uma interface com a API necessária para assinar e cancelar a assinatura de eventos e eventos de publicação.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-109">The event bus can be designed as an interface with the API needed to subscribe and unsubscribe to events and to publish events.</span></span> <span data-ttu-id="c6f2d-110">Também pode ter uma ou mais implementações com base em qualquer comunicação de mensagens ou entre processos, como uma fila de mensagens ou um barramento de serviço que seja compatível com a comunicação assíncrona e um modelo de publicação/assinatura.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-110">It can also have one or more implementations based on any inter-process or messaging communication, such as a messaging queue or a service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="c6f2d-111">Você pode usar eventos para implementar transações comerciais que abranjam vários serviços, o que lhe dá consistência eventual entre esses serviços.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-111">You can use events to implement business transactions that span multiple services, which gives you eventual consistency between those services.</span></span> <span data-ttu-id="c6f2d-112">Uma transação eventualmente consistente consiste em uma série de ações distribuídas.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-112">An eventually consistent transaction consists of a series of distributed actions.</span></span> <span data-ttu-id="c6f2d-113">Em cada ação, o microsserviço atualiza uma entidade de negócios e publica um evento que dispara a próxima ação.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-113">At each action, the microservice updates a business entity and publishes an event that triggers the next action.</span></span> <span data-ttu-id="c6f2d-114">A Figura 6-18 abaixo mostra um evento PriceUpdated publicado por meio de um barramento de evento e, portanto, a atualização de preço é propagada para a cesta e outros microserviços.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-114">Figure 6-18 below, shows a PriceUpdated event published through and event bus, so the price update is propagated to the Basket and other microservices.</span></span>

![Diagrama de comunicação assíncrona orientada por evento com um barramento de evento.](./media/integration-event-based-microservice-communications/event-driven-communication.png)

<span data-ttu-id="c6f2d-116">**Figura 6-18**.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-116">**Figure 6-18**.</span></span> <span data-ttu-id="c6f2d-117">Comunicação controlada por evento com base em um barramento de evento</span><span class="sxs-lookup"><span data-stu-id="c6f2d-117">Event-driven communication based on an event bus</span></span>

<span data-ttu-id="c6f2d-118">Esta seção descreve como você faz para implementar esse tipo de comunicação com o .NET usando uma interface de barramento de evento genérica, conforme mostra a Figura 6-18.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-118">This section describes how you can implement this type of communication with .NET by using a generic event bus interface, as shown in Figure 6-18.</span></span> <span data-ttu-id="c6f2d-119">Há várias implementações possíveis, cada uma usando uma tecnologia ou infraestrutura diferente, como RabbitMQ, Barramento de Serviço do Azure ou qualquer outro software livre de terceiros ou barramento de serviço comercial.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-119">There are multiple potential implementations, each using a different technology or infrastructure such as RabbitMQ, Azure Service Bus, or any other third-party open-source or commercial service bus.</span></span>

## <a name="using-message-brokers-and-services-buses-for-production-systems"></a><span data-ttu-id="c6f2d-120">Usando agentes de mensagem e barramentos de serviços para sistemas de produção</span><span class="sxs-lookup"><span data-stu-id="c6f2d-120">Using message brokers and services buses for production systems</span></span>

<span data-ttu-id="c6f2d-121">Conforme observado na seção de arquitetura, você pode escolher entre várias tecnologias de mensagem para implementar o barramento do evento abstrato.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-121">As noted in the architecture section, you can choose from multiple messaging technologies for implementing your abstract event bus.</span></span> <span data-ttu-id="c6f2d-122">Porém, essas tecnologias estão em diferentes níveis.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-122">But these technologies are at different levels.</span></span> <span data-ttu-id="c6f2d-123">Por exemplo, RabbitMQ, um transporte de agente de mensagens, está em um nível inferior a produtos comerciais, como o Barramento de Serviço do Azure, o NServiceBus, o MassTransit ou o Brighter.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-123">For instance, RabbitMQ, a messaging broker transport, is at a lower level than commercial products like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span> <span data-ttu-id="c6f2d-124">A maioria desses produtos pode operar sobre RabbitMQ ou Barramento de Serviço do Azure.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-124">Most of these products can work on top of either RabbitMQ or Azure Service Bus.</span></span> <span data-ttu-id="c6f2d-125">Sua escolha do produto depende de quantos recursos e quanta escalabilidade imediata você precisa para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-125">Your choice of product depends on how many features and how much out-of-the-box scalability you need for your application.</span></span>

<span data-ttu-id="c6f2d-126">Para implementar apenas uma prova de conceito de barramento de evento para seu ambiente de desenvolvimento, como fizemos no exemplo de eShopOnContainers, pode ser suficiente uma implementação simples sobre RabbitMQ em execução como um contêiner.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-126">For implementing just an event bus proof-of-concept for your development environment, as in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running as a container might be enough.</span></span> <span data-ttu-id="c6f2d-127">Porém, para sistemas críticos e de produção que precisam de alta escalabilidade, talvez você queira avaliar e usar o Barramento de Serviço do Azure.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-127">But for mission-critical and production systems that need high scalability, you might want to evaluate and use Azure Service Bus.</span></span>

<span data-ttu-id="c6f2d-128">Se você precisar de abstrações de alto nível e os recursos mais avançados, como [Sagas](https://docs.particular.net/nservicebus/sagas/), para processos de execução longa que facilitam o desenvolvimento distribuído barramentos, valerá a pena avaliar outros barramentos de serviço comerciais e de software livre como NServiceBus, MassTransit e Brighter.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-128">If you require high-level abstractions and richer features like [Sagas](https://docs.particular.net/nservicebus/sagas/) for long-running processes that make distributed development easier, other commercial and open-source service buses like NServiceBus, MassTransit, and Brighter are worth evaluating.</span></span> <span data-ttu-id="c6f2d-129">Nesse caso, as abstrações e a API a serem usadas em geral serão seriam diretamente aquelas fornecidas por esses barramentos de serviço de alto nível, em vez das suas próprias abstrações (como [abstrações de barramento de evento simples fornecidas no eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/BuildingBlocks/EventBus/EventBus/Abstractions/IEventBus.cs)).</span><span class="sxs-lookup"><span data-stu-id="c6f2d-129">In this case, the abstractions and API to use would usually be directly the ones provided by those high-level service buses instead of your own abstractions (like the [simple event bus abstractions provided at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/BuildingBlocks/EventBus/EventBus/Abstractions/IEventBus.cs)).</span></span> <span data-ttu-id="c6f2d-130">Para isso, você pode pesquisar o [eShopOnContainers bifurcado usando NServiceBus](https://go.particular.net/eShopOnContainers) (amostra derivada adicional implementada pelo Software Específico)</span><span class="sxs-lookup"><span data-stu-id="c6f2d-130">For that matter, you can research the [forked eShopOnContainers using NServiceBus](https://go.particular.net/eShopOnContainers) (additional derived sample implemented by Particular Software)</span></span>

<span data-ttu-id="c6f2d-131">Obviamente, você sempre pode criar seus próprios recursos de barramento de serviço sobre tecnologias de nível inferior, como RabbitMQ e o Docker, mas o trabalho necessário para "reinventar a roda" pode ser muito alto para um aplicativo empresarial personalizado.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-131">Of course, you could always build your own service bus features on top of lower-level technologies like RabbitMQ and Docker, but the work needed to “reinvent the wheel” might be too costly for a custom enterprise application.</span></span>

<span data-ttu-id="c6f2d-132">Para reiterar: as abstrações do barramento de evento de exemplo e a implementação apresentada no exemplo do eShopOnContainers devem ser usados apenas como uma prova de conceito.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-132">To reiterate: the sample event bus abstractions and implementation showcased in the eShopOnContainers sample are intended to be used only as a proof of concept.</span></span> <span data-ttu-id="c6f2d-133">Quando decidir que deseja ter comunicação assíncrona e controlada por evento, conforme explicado na seção atual, você deve escolher o produto de barramento de serviço que melhor atenda às suas necessidades de produção.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-133">Once you have decided that you want to have asynchronous and event-driven communication, as explained in the current section, you should choose the service bus product that best fits your needs for production.</span></span>

## <a name="integration-events"></a><span data-ttu-id="c6f2d-134">Eventos de integração</span><span class="sxs-lookup"><span data-stu-id="c6f2d-134">Integration events</span></span>

<span data-ttu-id="c6f2d-135">Eventos de integração são usados para colocar o estado de domínio em sincronia entre vários microsserviços ou sistemas externos.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-135">Integration events are used for bringing domain state in sync across multiple microservices or external systems.</span></span> <span data-ttu-id="c6f2d-136">Isso é feito ao publicar eventos de integração fora do microsserviço.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-136">This is done by publishing integration events outside the microservice.</span></span> <span data-ttu-id="c6f2d-137">Quando um evento é publicado para vários microsserviços receptores (para tantos microsserviços quantos assinarem o evento de integração), o manipulador de eventos apropriado em cada microsserviço receptor manipulará o evento.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-137">When an event is published to multiple receiver microservices (to as many microservices as are subscribed to the integration event), the appropriate event handler in each receiver microservice handles the event.</span></span>

<span data-ttu-id="c6f2d-138">Um evento de integração é basicamente uma classe de retenção de dados, como no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="c6f2d-138">An integration event is basically a data-holding class, as in the following example:</span></span>

```csharp
public class ProductPriceChangedIntegrationEvent : IntegrationEvent
{
    public int ProductId { get; private set; }
    public decimal NewPrice { get; private set; }
    public decimal OldPrice { get; private set; }

    public ProductPriceChangedIntegrationEvent(int productId, decimal newPrice,
        decimal oldPrice)
    {
        ProductId = productId;
        NewPrice = newPrice;
        OldPrice = oldPrice;
    }
}
```

<span data-ttu-id="c6f2d-139">Os eventos de integração podem ser definidos no nível do aplicativo de cada microsserviço, assim, estão separados de outros microsserviços, de modo comparável a como os ViewModels são definidos no cliente e servidor.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-139">The integration events can be defined at the application level of each microservice, so they are decoupled from other microservices, in a way comparable to how ViewModels are defined in the server and client.</span></span> <span data-ttu-id="c6f2d-140">O que não é recomendável é compartilhar uma biblioteca de eventos de integração comum com vários microsserviços; fazer isso seria acoplar esses microsserviços a uma única biblioteca de dados de definição de evento.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-140">What is not recommended is sharing a common integration events library across multiple microservices; doing that would be coupling those microservices with a single event definition data library.</span></span> <span data-ttu-id="c6f2d-141">Você não deseja fazer isso pelos mesmos motivos que não deseja compartilhar um modelo de domínio comum entre vários microsserviços: os microsserviços deve ser completamente autônomos.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-141">You do not want to do that for the same reasons that you do not want to share a common domain model across multiple microservices: microservices must be completely autonomous.</span></span>

<span data-ttu-id="c6f2d-142">Há apenas alguns tipos de bibliotecas que você deve compartilhar entre microsserviços.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-142">There are only a few kinds of libraries you should share across microservices.</span></span> <span data-ttu-id="c6f2d-143">Um são as bibliotecas que são blocos de aplicativo finais, como [API cliente do Barramento de Evento](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), conforme mostrado em eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-143">One is libraries that are final application blocks, like the [Event Bus client API](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), as in eShopOnContainers.</span></span> <span data-ttu-id="c6f2d-144">Outra vantagem são as bibliotecas que constituem ferramentas que também podem ser compartilhadas como componentes do NuGet, como serializadores JSON.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-144">Another is libraries that constitute tools that could also be shared as NuGet components, like JSON serializers.</span></span>

## <a name="the-event-bus"></a><span data-ttu-id="c6f2d-145">O barramento de evento</span><span class="sxs-lookup"><span data-stu-id="c6f2d-145">The event bus</span></span>

<span data-ttu-id="c6f2d-146">Um barramento de evento permite comunicação no estilo publicar/assinar entre microsserviços sem a necessidade de os componentes explicitamente estarem cientes uns dos outros, como mostra a Figura 6-19.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-146">An event bus allows publish/subscribe-style communication between microservices without requiring the components to explicitly be aware of each other, as shown in Figure 6-19.</span></span>

![Um diagrama que mostra o padrão de publicação/assinatura básico.](./media/integration-event-based-microservice-communications/publish-subscribe-basics.png)

<span data-ttu-id="c6f2d-148">**Figura 6-19**.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-148">**Figure 6-19**.</span></span> <span data-ttu-id="c6f2d-149">Noções básicas sobre publicação/assinatura com um barramento de evento</span><span class="sxs-lookup"><span data-stu-id="c6f2d-149">Publish/subscribe basics with an event bus</span></span>

<span data-ttu-id="c6f2d-150">O diagrama acima mostra que o microserviço A é publicado no barramento de evento, que se distribui aos microserviços de assinatura B e C, sem que o editor precise saber os assinantes.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-150">The above diagram shows that microservice A publishes to Event Bus, which distributes to subscribing microservices B and C, without the publisher needing to know the subscribers.</span></span> <span data-ttu-id="c6f2d-151">O barramento de evento está relacionado ao padrão Observador e ao padrão de publicação/assinatura.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-151">The event bus is related to the Observer pattern and the publish-subscribe pattern.</span></span>

### <a name="observer-pattern"></a><span data-ttu-id="c6f2d-152">Padrão do observador</span><span class="sxs-lookup"><span data-stu-id="c6f2d-152">Observer pattern</span></span>

<span data-ttu-id="c6f2d-153">No [padrão Observador](https://en.wikipedia.org/wiki/Observer_pattern), seu objeto primário (conhecido como o Observável) notifica outros objetos de interessados (conhecidos como Observadores) com informações relevantes (eventos).</span><span class="sxs-lookup"><span data-stu-id="c6f2d-153">In the [Observer pattern](https://en.wikipedia.org/wiki/Observer_pattern), your primary object (known as the Observable) notifies other interested objects (known as Observers) with relevant information (events).</span></span>

### <a name="publishsubscribe-pubsub-pattern"></a><span data-ttu-id="c6f2d-154">Padrão Pub/Sub (Publicar/Assinar)</span><span class="sxs-lookup"><span data-stu-id="c6f2d-154">Publish/Subscribe (Pub/Sub) pattern</span></span>

<span data-ttu-id="c6f2d-155">O objetivo do [padrão Publicar/Assinar](https://docs.microsoft.com/previous-versions/msp-n-p/ff649664(v=pandp.10)) é o mesmo que o padrão Observador: você deseja notificar outros serviços quando determinados eventos ocorrem.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-155">The purpose of the [Publish/Subscribe pattern](https://docs.microsoft.com/previous-versions/msp-n-p/ff649664(v=pandp.10)) is the same as the Observer pattern: you want to notify other services when certain events take place.</span></span> <span data-ttu-id="c6f2d-156">Mas há uma diferença importante entre os padrões de Observador e Pub/Sub.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-156">But there is an important difference between the Observer and Pub/Sub patterns.</span></span> <span data-ttu-id="c6f2d-157">No padrão de observador, a difusão é executada diretamente do observável para os observadores, de modo que eles "conhecem" uns aos outros.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-157">In the observer pattern, the broadcast is performed directly from the observable to the observers, so they “know” each other.</span></span> <span data-ttu-id="c6f2d-158">Porém, ao usar um padrão Pub/Sub, há um terceiro componente, chamado de agente, agente de mensagem ou barramento de evento, que é conhecido tanto pelo publicador quanto pelo assinante.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-158">But when using a Pub/Sub pattern, there is a third component, called broker or message broker or event bus, which is known by both the publisher and subscriber.</span></span> <span data-ttu-id="c6f2d-159">Portanto, ao usar o padrão Pub/Sub, o publicador e os assinantes são precisamente desacoplados graças ao agente de mensagem ou barramento de evento mencionado.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-159">Therefore, when using the Pub/Sub pattern the publisher and the subscribers are precisely decoupled thanks to the mentioned event bus or message broker.</span></span>

### <a name="the-middleman-or-event-bus"></a><span data-ttu-id="c6f2d-160">O barramento de evento ou intermediário</span><span class="sxs-lookup"><span data-stu-id="c6f2d-160">The middleman or event bus</span></span>

<span data-ttu-id="c6f2d-161">Como você obtém anonimato entre publicador e assinante?</span><span class="sxs-lookup"><span data-stu-id="c6f2d-161">How do you achieve anonymity between publisher and subscriber?</span></span> <span data-ttu-id="c6f2d-162">Uma maneira fácil é permitir que um intermediário cuide de toda a comunicação.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-162">An easy way is let a middleman take care of all the communication.</span></span> <span data-ttu-id="c6f2d-163">Um barramento de evento é um intermediário.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-163">An event bus is one such middleman.</span></span>

<span data-ttu-id="c6f2d-164">Um barramento de evento normalmente é composto por duas partes:</span><span class="sxs-lookup"><span data-stu-id="c6f2d-164">An event bus is typically composed of two parts:</span></span>

- <span data-ttu-id="c6f2d-165">A abstração ou interface.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-165">The abstraction or interface.</span></span>

- <span data-ttu-id="c6f2d-166">Uma ou mais implementações.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-166">One or more implementations.</span></span>

<span data-ttu-id="c6f2d-167">Na Figura 6-19, você pode ver como, de um ponto de vista de aplicativo, o barramento de evento é nada mais que um canal Pub/Sub.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-167">In Figure 6-19 you can see how, from an application point of view, the event bus is nothing more than a Pub/Sub channel.</span></span> <span data-ttu-id="c6f2d-168">A maneira como você implementa essa comunicação assíncrona pode variar.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-168">The way you implement this asynchronous communication can vary.</span></span> <span data-ttu-id="c6f2d-169">Eles podem ter várias implementações, assim, você pode alternar entre elas, dependendo dos requisitos do ambiente (por exemplo, produção versus ambientes de desenvolvimento).</span><span class="sxs-lookup"><span data-stu-id="c6f2d-169">It can have multiple implementations so that you can swap between them, depending on the environment requirements (for example, production versus development environments).</span></span>

<span data-ttu-id="c6f2d-170">Na Figura 6-20, você pode ver uma abstração de um barramento de evento com várias implementações baseadas nas tecnologias de mensagem de infraestrutura, como RabbitMQ, Barramento de Serviço do Azure ou outro agente de mensagem/evento.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-170">In Figure 6-20 you can see an abstraction of an event bus with multiple implementations based on infrastructure messaging technologies like RabbitMQ, Azure Service Bus, or another event/message broker.</span></span>

![Diagrama mostrando a adição de uma camada de abstração de barramento de evento.](./media/integration-event-based-microservice-communications/multiple-implementations-event-bus.png)

<span data-ttu-id="c6f2d-172">**Figura 6- 20.**</span><span class="sxs-lookup"><span data-stu-id="c6f2d-172">**Figure 6- 20.**</span></span> <span data-ttu-id="c6f2d-173">Várias implementações de um barramento de evento</span><span class="sxs-lookup"><span data-stu-id="c6f2d-173">Multiple implementations of an event bus</span></span>

<span data-ttu-id="c6f2d-174">É bom ter o barramento de evento definido por meio de uma interface para que ele possa ser implementado com várias tecnologias, como o Barramento de Serviço do Azure, o RabbitMQ ou outros.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-174">It's good to have the event bus defined through an interface so it can be implemented with several technologies, like RabbitMQ Azure Service bus or others.</span></span> <span data-ttu-id="c6f2d-175">No entanto, conforme mencionado anteriormente, usar suas próprias abstrações (a interface de barramento do evento) será bom somente se você precisar de recursos de barramento de evento básicos compatíveis com as suas abstrações.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-175">However, and as mentioned previously, using your own abstractions (the event bus interface) is good only if you need basic event bus features supported by your abstractions.</span></span> <span data-ttu-id="c6f2d-176">Se você precisar de recursos mais avançados de barramento de serviço, provavelmente deverá usar a API e as abstrações fornecidas pelo seu barramento de serviço comercial preferido, em vez das suas próprias abstrações.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-176">If you need richer service bus features, you should probably use the API and abstractions provided by your preferred commercial service bus instead of your own abstractions.</span></span>

### <a name="defining-an-event-bus-interface"></a><span data-ttu-id="c6f2d-177">Definir uma interface de barramento de evento</span><span class="sxs-lookup"><span data-stu-id="c6f2d-177">Defining an event bus interface</span></span>

<span data-ttu-id="c6f2d-178">Vamos começar com algum código de implementação para a interface de barramento de evento e possíveis implementações para fins de exploração.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-178">Let’s start with some implementation code for the event bus interface and possible implementations for exploration purposes.</span></span> <span data-ttu-id="c6f2d-179">A interface deve ser genérica e simples, como na interface a seguir.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-179">The interface should be generic and straightforward, as in the following interface.</span></span>

```csharp
public interface IEventBus
{
    void Publish(IntegrationEvent @event);

    void Subscribe<T, TH>()
        where T : IntegrationEvent
        where TH : IIntegrationEventHandler<T>;

    void SubscribeDynamic<TH>(string eventName)
        where TH : IDynamicIntegrationEventHandler;

    void UnsubscribeDynamic<TH>(string eventName)
        where TH : IDynamicIntegrationEventHandler;

    void Unsubscribe<T, TH>()
        where TH : IIntegrationEventHandler<T>
        where T : IntegrationEvent;
}
```

<span data-ttu-id="c6f2d-180">O método `Publish` é simples.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-180">The `Publish` method is straightforward.</span></span> <span data-ttu-id="c6f2d-181">O barramento de evento difundirá o evento de integração passado a ele para qualquer microsserviço ou até mesmo um aplicativo externo, que assine esse evento.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-181">The event bus will broadcast the integration event passed to it to any microservice, or even an external application, subscribed to that event.</span></span> <span data-ttu-id="c6f2d-182">Esse método é usado pelo microsserviço que está publicando o evento.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-182">This method is used by the microservice that is publishing the event.</span></span>

<span data-ttu-id="c6f2d-183">Os métodos `Subscribe` (você pode ter várias implementações, dependendo dos argumentos) são usados pelos microsserviços que desejam receber eventos.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-183">The `Subscribe` methods (you can have several implementations depending on the arguments) are used by the microservices that want to receive events.</span></span> <span data-ttu-id="c6f2d-184">Esse método tem dois argumentos.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-184">This method has two arguments.</span></span> <span data-ttu-id="c6f2d-185">O primeiro é o evento de integração a assinar (`IntegrationEvent`).</span><span class="sxs-lookup"><span data-stu-id="c6f2d-185">The first is the integration event to subscribe to (`IntegrationEvent`).</span></span> <span data-ttu-id="c6f2d-186">O segundo argumento é o manipulador de eventos de integração (ou método de retorno de chamada), denominado `IIntegrationEventHandler<T>`, a ser executado quando o microsserviço receptor obtiver essa mensagem de evento de integração.</span><span class="sxs-lookup"><span data-stu-id="c6f2d-186">The second argument is the integration event handler (or callback method), named `IIntegrationEventHandler<T>`, to be executed when the receiver microservice gets that integration event message.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="c6f2d-187">[Anterior](database-server-container.md)
> [Próximo](rabbitmq-event-bus-development-test-environment.md)</span><span class="sxs-lookup"><span data-stu-id="c6f2d-187">[Previous](database-server-container.md)
[Next](rabbitmq-event-bus-development-test-environment.md)</span></span>
