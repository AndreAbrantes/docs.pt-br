---
title: Padrões de dados nativos de nuvem
description: Arquitetando aplicativos .NET nativos da nuvem para o Azure | Padrões de dados nativos de nuvem
ms.date: 06/30/2019
ms.openlocfilehash: 9e90409b0b633796b452cfcfecb3896e79002d4d
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337417"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="7f91f-103">Padrões de dados nativos de nuvem</span><span class="sxs-lookup"><span data-stu-id="7f91f-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="7f91f-104">Embora os dados descentralizados possam levar a um melhor desempenho, escalabilidade e economia de custos, ele também apresenta muitos desafios.</span><span class="sxs-lookup"><span data-stu-id="7f91f-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="7f91f-105">Consultar dados em microservices é complexo.</span><span class="sxs-lookup"><span data-stu-id="7f91f-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="7f91f-106">Uma transação que abrange microservices deve ser gerenciada programaticamente, pois as transações distribuídas não têm suporte em aplicativos nativos de nuvem.</span><span class="sxs-lookup"><span data-stu-id="7f91f-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="7f91f-107">Você passa de um mundo de *consistência imediata* para *consistência eventual*.</span><span class="sxs-lookup"><span data-stu-id="7f91f-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="7f91f-108">Discutimos esses desafios agora.</span><span class="sxs-lookup"><span data-stu-id="7f91f-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="7f91f-109">Consultas entre serviços</span><span class="sxs-lookup"><span data-stu-id="7f91f-109">Cross-service queries</span></span>

<span data-ttu-id="7f91f-110">Como um aplicativo consulta dados que se espalham por muitos microservices independentes?</span><span class="sxs-lookup"><span data-stu-id="7f91f-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="7f91f-111">A Figura 5-4 mostra esse cenário.</span><span class="sxs-lookup"><span data-stu-id="7f91f-111">Figure 5-4 shows this scenario.</span></span>

![Consultando em microserviços](./media/cross-service-query.png)

<span data-ttu-id="7f91f-113">**Figura 5-4**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-113">**Figure 5-4**.</span></span> <span data-ttu-id="7f91f-114">Consultando em microserviços</span><span class="sxs-lookup"><span data-stu-id="7f91f-114">Querying across microservices</span></span>

<span data-ttu-id="7f91f-115">Observe como na figura anterior, vemos um microserviço de cesta de compras que adiciona um item ao carrinho de compras de um usuário.</span><span class="sxs-lookup"><span data-stu-id="7f91f-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="7f91f-116">Embora o armazenamento de dados da cesta de compras contenha uma tabela basket e lineItem, ela não contém dados de produtos ou preços, pois esses itens são encontrados nos microserviços de produto e preço.</span><span class="sxs-lookup"><span data-stu-id="7f91f-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="7f91f-117">Para adicionar um item, o microserviço da cesta de compras precisa de dados de produtos e dados de preços.</span><span class="sxs-lookup"><span data-stu-id="7f91f-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="7f91f-118">Quais são as opções para obter os dados de produto e preço?</span><span class="sxs-lookup"><span data-stu-id="7f91f-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="7f91f-119">A Figura 5-5 mostra o microserviço da cesta de compras fazendo uma chamada HTTP direta para o catálogo de produtos e os microserviços de preços.</span><span class="sxs-lookup"><span data-stu-id="7f91f-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Comunicação direta de http](./media/direct-http-communication.png)

<span data-ttu-id="7f91f-121">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-121">**Figure 5-5**.</span></span> <span data-ttu-id="7f91f-122">Comunicação direta de HTTP</span><span class="sxs-lookup"><span data-stu-id="7f91f-122">Direct HTTP communication</span></span>

<span data-ttu-id="7f91f-123">Embora seja possível implementar, no capítulo 4, discutimos como chamadas HTTP diretas em todos os microserviços associam o sistema e não são consideradas uma boa prática.</span><span class="sxs-lookup"><span data-stu-id="7f91f-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="7f91f-124">Poderíamos implementar um microserviço agregador mostrado na Figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="7f91f-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Microserviço agregador](./media/aggregator-microservice.png)

<span data-ttu-id="7f91f-126">**Figura 5-6.**</span><span class="sxs-lookup"><span data-stu-id="7f91f-126">**Figure 5-6.**</span></span> <span data-ttu-id="7f91f-127">Microserviço agregador</span><span class="sxs-lookup"><span data-stu-id="7f91f-127">Aggregator microservice</span></span>

<span data-ttu-id="7f91f-128">Embora essa abordagem encapsula o fluxo de trabalho de operações de negócios em um microserviço individual, ela adiciona complexidade e ainda resulta em chamadas HTTP diretas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="7f91f-129">Uma abordagem comum para executar consultas entre serviços usa o [padrão de exibição materializado](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), mostrado na Figura 5-7.</span><span class="sxs-lookup"><span data-stu-id="7f91f-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Padrão de exibição materializada](./media/materialized-view-pattern.png)

<span data-ttu-id="7f91f-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-131">**Figure5-7**.</span></span> <span data-ttu-id="7f91f-132">Padrão de exibição materializada</span><span class="sxs-lookup"><span data-stu-id="7f91f-132">Materialized View Pattern</span></span>

<span data-ttu-id="7f91f-133">Com esse padrão, você coloca diretamente uma tabela local (conhecida como *modelo de leitura*) no serviço de cesta de compras que contém uma cópia desnormalizada dos dados necessários dos microserviços de produto e preço.</span><span class="sxs-lookup"><span data-stu-id="7f91f-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="7f91f-134">Colocar esses dados dentro do microserviço da cesta de compras elimina a necessidade de invocar chamadas caras entre serviços.</span><span class="sxs-lookup"><span data-stu-id="7f91f-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="7f91f-135">Com os dados locais para o serviço, você melhora o tempo de resposta e a confiabilidade.</span><span class="sxs-lookup"><span data-stu-id="7f91f-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="7f91f-136">O problema dessa abordagem é que agora você tem dados duplicados em seu sistema.</span><span class="sxs-lookup"><span data-stu-id="7f91f-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="7f91f-137">Em sistemas nativos de nuvem, os dados duplicados não são considerados um [antipadrão](https://en.wikipedia.org/wiki/Anti-pattern) e normalmente são implementados em sistemas nativos de nuvem.</span><span class="sxs-lookup"><span data-stu-id="7f91f-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="7f91f-138">No entanto, um e apenas um sistema pode ser o proprietário de qualquer conjunto de dados, e você precisará implementar um mecanismo de sincronização para o sistema de registro para atualizar todos os modelos de leitura associados, sempre que ocorrer uma alteração em seus dados subjacentes.</span><span class="sxs-lookup"><span data-stu-id="7f91f-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="7f91f-139">Suporte transacional</span><span class="sxs-lookup"><span data-stu-id="7f91f-139">Transactional support</span></span>

<span data-ttu-id="7f91f-140">Embora as consultas em microserviço sejam desafiadoras, a implementação de uma transação em microserviços pode ser complexa.</span><span class="sxs-lookup"><span data-stu-id="7f91f-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="7f91f-141">O desafio inerente de manter a consistência de dados entre fontes de dados que residem em diferentes microservices não pode ser subestado.</span><span class="sxs-lookup"><span data-stu-id="7f91f-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="7f91f-142">A Figura 5-8 mostra o problema.</span><span class="sxs-lookup"><span data-stu-id="7f91f-142">Figure 5-8 shows the problem.</span></span>

![Transação no padrão saga](./media/saga-transaction-operation.png)

<span data-ttu-id="7f91f-144">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-144">**Figure 5-8**.</span></span> <span data-ttu-id="7f91f-145">Implementando uma transação em microserviços</span><span class="sxs-lookup"><span data-stu-id="7f91f-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="7f91f-146">Observe como na figura anterior, cinco microserviços independentes participam de uma transação de *ordem de criação* distribuída.</span><span class="sxs-lookup"><span data-stu-id="7f91f-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="7f91f-147">No entanto, a transação para cada um dos cinco microserviços individuais deve ter sucesso ou todas devem abortar e reverter a operação.</span><span class="sxs-lookup"><span data-stu-id="7f91f-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll back the operation.</span></span> <span data-ttu-id="7f91f-148">Embora o suporte interno transacional esteja disponível dentro de cada um dos microserviços, não há suporte para uma transação distribuída em todos os cinco serviços.</span><span class="sxs-lookup"><span data-stu-id="7f91f-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="7f91f-149">Como o suporte transacional é essencial para essa operação manter os dados consistentes em cada um dos microserviços, você precisa construir programaticamente uma transação distribuída.</span><span class="sxs-lookup"><span data-stu-id="7f91f-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="7f91f-150">Um padrão popular para adicionar programaticamente suporte transacional é o [padrão saga](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="7f91f-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="7f91f-151">Ele é implementado por meio do agrupamento de transações locais e invocada sequencialmente cada uma delas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="7f91f-152">Se uma transação local falhar, o saga anulará a operação e invocará um conjunto de [Transações de compensação](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) para desfazer as alterações feitas pelas transações locais anteriores.</span><span class="sxs-lookup"><span data-stu-id="7f91f-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="7f91f-153">A Figura 5-9 mostra uma transação com falha com o padrão saga.</span><span class="sxs-lookup"><span data-stu-id="7f91f-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Reverter no padrão saga](./media/saga-rollback-operation.png)

<span data-ttu-id="7f91f-155">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-155">**Figure 5-9**.</span></span> <span data-ttu-id="7f91f-156">Reverter uma transação</span><span class="sxs-lookup"><span data-stu-id="7f91f-156">Rolling back a transaction</span></span>

<span data-ttu-id="7f91f-157">Observe como, na figura anterior, a operação *GenerateContent* falhou no microserviço Music.</span><span class="sxs-lookup"><span data-stu-id="7f91f-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="7f91f-158">O saga invoca transações de compensação (em vermelho) para remover o conteúdo, cancelar o pagamento e cancelar o pedido, retornando os dados para cada microserviço de volta para um estado consistente.</span><span class="sxs-lookup"><span data-stu-id="7f91f-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="7f91f-159">Os padrões de Saga geralmente são coreografado como uma série de eventos relacionados ou orquestrados como um conjunto de comandos relacionados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="7f91f-160">Padrão CQRS</span><span class="sxs-lookup"><span data-stu-id="7f91f-160">CQRS pattern</span></span>

<span data-ttu-id="7f91f-161">O CQRS, ou [separação das operações de comando e de consulta](https://docs.microsoft.com/azure/architecture/patterns/cqrs), é um padrão de arquitetura que separa as operações que lêem os dados daqueles que gravam dados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="7f91f-162">Esse padrão pode ajudar a maximizar o desempenho, a escalabilidade e a segurança.</span><span class="sxs-lookup"><span data-stu-id="7f91f-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="7f91f-163">Em cenários de acesso a dados normais, você implementa um modelo único (objeto de entidade e de repositório) *que executa operações* de leitura e gravação de dados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="7f91f-164">No entanto, um cenário de acesso a dados mais avançado pode se beneficiar de modelos e tabelas de dados separados para leituras e gravações.</span><span class="sxs-lookup"><span data-stu-id="7f91f-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="7f91f-165">Para melhorar o desempenho, a operação de leitura, conhecida como *consulta*, pode consultar uma representação altamente desnormalizada dos dados para evitar junções de tabela repetitivas dispendiosas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="7f91f-166">Enquanto a operação de *gravação* , conhecida como um *comando*, pode ser atualizada em uma representação totalmente normalizada dos dados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="7f91f-167">Em seguida, você precisaria implementar um mecanismo para manter ambas as representações em sincronia. Normalmente, sempre que a tabela de gravação é modificada, ela gera um evento que Replica a modificação de dados para a tabela de leitura.</span><span class="sxs-lookup"><span data-stu-id="7f91f-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="7f91f-168">A Figura 5-10 mostra uma implementação do padrão CQRS.</span><span class="sxs-lookup"><span data-stu-id="7f91f-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Implementação de CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="7f91f-170">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-170">**Figure 5-10**.</span></span> <span data-ttu-id="7f91f-171">Implementação de CQRS</span><span class="sxs-lookup"><span data-stu-id="7f91f-171">CQRS implementation</span></span>

<span data-ttu-id="7f91f-172">Observe como, na figura anterior, os modelos de comando e consulta separados são implementados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="7f91f-173">Além disso, cada operação de gravação de dados é salva no armazenamento de gravação e, em seguida, propagada para o repositório de leitura.</span><span class="sxs-lookup"><span data-stu-id="7f91f-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="7f91f-174">Preste muita atenção à forma como o processo de propagação opera no princípio da [consistência eventual](https://www.cloudcomputingpatterns.org/eventual_consistency/), enquanto o modelo de leitura eventualmente sincroniza com o modelo de gravação, mas pode haver algum atraso no processo.</span><span class="sxs-lookup"><span data-stu-id="7f91f-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="7f91f-175">Ao implementar a separação, você tem a capacidade de dimensionar leituras e gravações separadamente.</span><span class="sxs-lookup"><span data-stu-id="7f91f-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="7f91f-176">Além de isso, você pode impor uma segurança mais rígida em operações de gravação do que aquelas relacionadas a leituras.</span><span class="sxs-lookup"><span data-stu-id="7f91f-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="7f91f-177">Normalmente, os padrões de CQRS são aplicados a seções limitadas do seu sistema com base em necessidades específicas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="7f91f-178">Relacional vs NoSQL</span><span class="sxs-lookup"><span data-stu-id="7f91f-178">Relational vs NoSQL</span></span>

<span data-ttu-id="7f91f-179">O impacto das tecnologias [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) não pode ser sobredimensionado, especialmente para sistemas nativos de nuvem distribuída.</span><span class="sxs-lookup"><span data-stu-id="7f91f-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="7f91f-180">A proliferação de novas tecnologias de dados neste espaço interrompeu as soluções que, uma vez, contavam exclusivamente com os bancos dados relacionais.</span><span class="sxs-lookup"><span data-stu-id="7f91f-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="7f91f-181">Por outro lado, os bancos de dados relacionais têm sido uma tecnologia predominante há décadas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="7f91f-182">Eles são maduros, comprovados e amplamente implementados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="7f91f-183">Produtos de banco de dados concorrentes, experiência e abounds de ferramentas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="7f91f-184">Os bancos de dados relacionais fornecem um armazenamento de tabelas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="7f91f-185">Essas tabelas têm um esquema fixo, usam o SQL (linguagem SQL) para gerenciar dados e têm garantias de [Acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (também conhecido como atomicidade, consistência, isolamento e durabilidade).</span><span class="sxs-lookup"><span data-stu-id="7f91f-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="7f91f-186">Os bancos de dados não SQL, por outro lado, referem-se a armazenamentos não relacionais de alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="7f91f-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="7f91f-187">Eles se destacam em suas características de facilidade de uso, escalabilidade, resiliência e disponibilidade.</span><span class="sxs-lookup"><span data-stu-id="7f91f-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="7f91f-188">Em vez de unir tabelas de dados normalizados, o NoSQL armazena dados autodescritivos (sem esquema) normalmente em documentos JSON.</span><span class="sxs-lookup"><span data-stu-id="7f91f-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="7f91f-189">Eles não oferecem garantias [Acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="7f91f-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="7f91f-190">Uma maneira de entender as diferenças entre esses tipos de bancos de dados pode ser encontrada no [Cap teorema](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), um conjunto de princípios que pode ser aplicado a sistemas distribuídos que armazenam o estado.</span><span class="sxs-lookup"><span data-stu-id="7f91f-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="7f91f-191">A Figura 5-11 mostra as três propriedades do CAP teorema.</span><span class="sxs-lookup"><span data-stu-id="7f91f-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![Teorema CAP](./media/cap-theorem.png)

<span data-ttu-id="7f91f-193">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="7f91f-193">**Figure 5-11**.</span></span> <span data-ttu-id="7f91f-194">Teorema CAP</span><span class="sxs-lookup"><span data-stu-id="7f91f-194">The CAP theorem</span></span>

<span data-ttu-id="7f91f-195">O teorema afirma que qualquer sistema de dados distribuído oferecerá uma compensação entre consistência, disponibilidade e tolerância de partição, e que qualquer banco de dado só poderá garantir duas das três propriedades:</span><span class="sxs-lookup"><span data-stu-id="7f91f-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="7f91f-196">*Consistência*: cada nó no cluster responderá com os dados mais recentes, mesmo que ele exija o bloqueio de uma solicitação até que todas as réplicas sejam atualizadas corretamente.</span><span class="sxs-lookup"><span data-stu-id="7f91f-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="7f91f-197">*Disponibilidade*: cada nó retornará uma resposta em um período razoável, mesmo se essa resposta não for a data mais recente.</span><span class="sxs-lookup"><span data-stu-id="7f91f-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="7f91f-198">*Tolerância a partição*: garante que o sistema continuará operando se um nó falhar ou perder a conectividade com outra.</span><span class="sxs-lookup"><span data-stu-id="7f91f-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="7f91f-199">Bancos de dados relacionais exibem consistência e disponibilidade, mas não a tolerância de partição.</span><span class="sxs-lookup"><span data-stu-id="7f91f-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="7f91f-200">O particionamento de um banco de dados relacional, como fragmentação, é difícil e pode impactar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="7f91f-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="7f91f-201">Por outro lado, os bancos de dados NoSQL normalmente exibem a tolerância de partição, conhecida como escalabilidade horizontal e alta disponibilidade.</span><span class="sxs-lookup"><span data-stu-id="7f91f-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="7f91f-202">Como a extremidade teorema especifica, você só pode ter dois dos três princípios e perde a propriedade de consistência.</span><span class="sxs-lookup"><span data-stu-id="7f91f-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="7f91f-203">Os bancos de dados NoSQL são distribuídos e geralmente dimensionados em servidores de mercadoria.</span><span class="sxs-lookup"><span data-stu-id="7f91f-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="7f91f-204">Isso pode fornecer grande disponibilidade, tanto dentro quanto entre regiões geográficas a um custo reduzido.</span><span class="sxs-lookup"><span data-stu-id="7f91f-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="7f91f-205">Os dados podem ser particionados e replicados entre esses computadores, ou nós, fornecendo redundância e tolerância a falhas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="7f91f-206">A desvantagem é a consistência.</span><span class="sxs-lookup"><span data-stu-id="7f91f-206">The downside is consistency.</span></span> <span data-ttu-id="7f91f-207">Uma alteração nos dados em um nó NoSQL pode levar algum tempo para ser propagada para outros nós.</span><span class="sxs-lookup"><span data-stu-id="7f91f-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="7f91f-208">Normalmente, um nó de banco de dados NoSQL fornecerá uma resposta imediata a uma consulta, mesmo se os dados que ele está apresentando estiverem obsoletos e ainda não tiverem sido atualizados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="7f91f-209">Essa é uma [consistência eventual](https://www.cloudcomputingpatterns.org/eventual_consistency/)conhecida, uma característica de sistemas de dados distribuídos em que não há suporte para transações ACID.</span><span class="sxs-lookup"><span data-stu-id="7f91f-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="7f91f-210">É um breve atraso entre a atualização de um item de dados e o tempo necessário para propagar essa atualização para cada um dos nós de réplica.</span><span class="sxs-lookup"><span data-stu-id="7f91f-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="7f91f-211">Se você atualizar um item de produto em um banco de dados NoSQL no Estados Unidos, mas, ao mesmo tempo, consultar o mesmo item de dado de um nó de réplica na Europa, você poderá recuperar as informações anteriores do produto-até que o nó Europeu tenha sido atualizado com a alteração do produto.</span><span class="sxs-lookup"><span data-stu-id="7f91f-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="7f91f-212">A desvantagem é que, ao fornecer uma [consistência forte](https://en.wikipedia.org/wiki/Strong_consistency), aguardando a atualização de todos os nós de réplica antes de retornar um resultado da consulta, você pode oferecer suporte a enorme escala e volume de tráfego, mas com a possibilidade de apresentar dados mais antigos.</span><span class="sxs-lookup"><span data-stu-id="7f91f-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="7f91f-213">Os bancos de dados NoSQL podem ser categorizados pelos quatro modelos a seguir:</span><span class="sxs-lookup"><span data-stu-id="7f91f-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="7f91f-214">*Repositório de documentos* (MongoDB, CouchDB, Couchbase): os dados (e metadados correspondentes) são armazenados de forma não relacional em documentos desnormalizados baseados em JSON dentro do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="7f91f-215">*Repositório de chave/valor* (Redis, Riak, memcached): os dados são armazenados em pares chave-valor simples com operações do sistema executadas em uma chave de acesso exclusiva que é mapeada para um valor de dados do usuário.</span><span class="sxs-lookup"><span data-stu-id="7f91f-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="7f91f-216">*Repositório de coluna larga* (HBase, Cassandra): os dados relacionados são armazenados em um formato de coluna como um conjunto de pares de chave/valor aninhados em uma única coluna com dados normalmente recuperados como uma única unidade sem a necessidade de unir várias tabelas.</span><span class="sxs-lookup"><span data-stu-id="7f91f-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="7f91f-217">*Repositórios de grafo* (neo4j, Titan): os dados são armazenados como uma representação gráfica em um nó junto com as bordas que especificam a relação entre os nós.</span><span class="sxs-lookup"><span data-stu-id="7f91f-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="7f91f-218">Os bancos de dados NoSQL podem ser otimizados para lidar com grandes escalas, especialmente quando os dados são relativamente simples.</span><span class="sxs-lookup"><span data-stu-id="7f91f-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="7f91f-219">Considere um banco de dados NoSQL quando:</span><span class="sxs-lookup"><span data-stu-id="7f91f-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="7f91f-220">Sua carga de trabalho requer uma grande escala e alta simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="7f91f-220">Your workload requires a large scale and high concurrency.</span></span>
- <span data-ttu-id="7f91f-221">Você tem um grande número de usuários.</span><span class="sxs-lookup"><span data-stu-id="7f91f-221">You have large numbers of users.</span></span>
- <span data-ttu-id="7f91f-222">Seus dados podem ser expressos simplesmente sem relações.</span><span class="sxs-lookup"><span data-stu-id="7f91f-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="7f91f-223">Você precisa distribuir geograficamente seus dados.</span><span class="sxs-lookup"><span data-stu-id="7f91f-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="7f91f-224">Você não precisa de garantias de ACID.</span><span class="sxs-lookup"><span data-stu-id="7f91f-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="7f91f-225">Será implantado no hardware de mercadoria.</span><span class="sxs-lookup"><span data-stu-id="7f91f-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="7f91f-226">Em seguida, considere um banco de dados relacional quando:</span><span class="sxs-lookup"><span data-stu-id="7f91f-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="7f91f-227">Suas cargas de trabalho exigem escala de médio a grande porte.</span><span class="sxs-lookup"><span data-stu-id="7f91f-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="7f91f-228">A simultaneidade não é uma preocupação importante.</span><span class="sxs-lookup"><span data-stu-id="7f91f-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="7f91f-229">Garantias de ACID são necessárias.</span><span class="sxs-lookup"><span data-stu-id="7f91f-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="7f91f-230">Os dados são mais bem expressos de forma relacional.</span><span class="sxs-lookup"><span data-stu-id="7f91f-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="7f91f-231">Seu aplicativo será implantado em hardware grande e high-end.</span><span class="sxs-lookup"><span data-stu-id="7f91f-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="7f91f-232">Em seguida, examinaremos o armazenamento de dados na nuvem do Azure.</span><span class="sxs-lookup"><span data-stu-id="7f91f-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7f91f-233">[Anterior](distributed-data.md)
>[Próximo](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="7f91f-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
