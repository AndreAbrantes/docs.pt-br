---
title: Apêndice-gRPC para desenvolvedores do WCF
description: Discussão sobre transações distribuídas e sua implementação em arquiteturas de microserviços modernas.
ms.date: 09/02/2019
ms.openlocfilehash: 061aef016fd0e4303e1bbcbf0e73cec2b0c54f74
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/12/2019
ms.locfileid: "73968214"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="e2edc-103">Apêndice A – transações</span><span class="sxs-lookup"><span data-stu-id="e2edc-103">Appendix A - Transactions</span></span>

<span data-ttu-id="e2edc-104">Windows Communication Foundation (WCF) com suporte a transações distribuídas, permitindo que operações atômicas sejam executadas em vários serviços.</span><span class="sxs-lookup"><span data-stu-id="e2edc-104">Windows Communication Foundation (WCF) supported distributed transactions, allowing atomic operations to be performed across multiple services.</span></span> <span data-ttu-id="e2edc-105">Essa funcionalidade foi baseada no [Microsoft coordenador de transações distribuídas](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span><span class="sxs-lookup"><span data-stu-id="e2edc-105">This functionality was based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="e2edc-106">No cenário de microserviços modernos, esse tipo de processamento automatizado de transações distribuídas não é possível.</span><span class="sxs-lookup"><span data-stu-id="e2edc-106">In the modern microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="e2edc-107">Há muitas tecnologias diferentes em jogo, incluindo bancos de dados relacionais, armazenamentos de dado NoSQL e sistemas de mensagens, sem mencionar a combinação de sistemas operacionais, linguagens de programação e estruturas que podem ser usadas em um único ambiente.</span><span class="sxs-lookup"><span data-stu-id="e2edc-107">There are too many different technologies at play, including relational databases, NoSQL data stores, and messaging systems, not to mention the mix of operating systems, programming languages and frameworks that may be used in a single environment.</span></span>

<span data-ttu-id="e2edc-108">A transação distribuída do WCF é uma implementação do que é conhecido como uma [confirmação de duas fases (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span><span class="sxs-lookup"><span data-stu-id="e2edc-108">The WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="e2edc-109">É possível implementar transações 2PC manualmente coordenando mensagens entre serviços, criando transações abertas dentro de cada serviço e enviando mensagens de "confirmação" ou "reversão", dependendo do êxito ou da falha.</span><span class="sxs-lookup"><span data-stu-id="e2edc-109">It's possible to implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service and sending "commit" or "rollback" messages depending upon success or failure.</span></span> <span data-ttu-id="e2edc-110">No entanto, a complexidade envolvida no gerenciamento de 2PC pode aumentar exponencialmente à medida que os sistemas evoluem, e as transações abertas mantêm bloqueios de banco de dados que podem afetar negativamente o desempenho ou, pior, causar deadlocks entre serviços.</span><span class="sxs-lookup"><span data-stu-id="e2edc-110">However, the complexity that is involved in managing 2PC can increase exponentially as systems evolve, and open transactions hold database locks that can negatively impact performance or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="e2edc-111">Se possível, é melhor evitar totalmente as transações distribuídas.</span><span class="sxs-lookup"><span data-stu-id="e2edc-111">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="e2edc-112">Se dois itens de dados estiverem tão vinculados quanto exigirem atualizações atômicas, considere tratá-los com o mesmo serviço e aplicar essas alterações atômicas usando uma única solicitação ou mensagem para esse serviço.</span><span class="sxs-lookup"><span data-stu-id="e2edc-112">If two items of data are so linked as to require atomic updates, consider handling them both with the same service, and applying those atomic changes using a single request or message to that service.</span></span>

<span data-ttu-id="e2edc-113">Se isso não for possível, então uma alternativa é usar o [padrão saga](https://microservices.io/patterns/data/saga.html).</span><span class="sxs-lookup"><span data-stu-id="e2edc-113">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="e2edc-114">Em um saga, as atualizações são processadas sequencialmente; à medida que cada atualização é realizada com sucesso, a próxima é disparada.</span><span class="sxs-lookup"><span data-stu-id="e2edc-114">In a saga, updates are processing sequentially; as each update succeeds the next one is triggered.</span></span> <span data-ttu-id="e2edc-115">Esses gatilhos podem ser propagados do serviço para o serviço ou gerenciados por um coordenador de Saga ou "Orchestrator".</span><span class="sxs-lookup"><span data-stu-id="e2edc-115">These triggers can be propagated from service to service, or managed by a saga coordinator or "orchestrator".</span></span> <span data-ttu-id="e2edc-116">Se uma atualização falhar em qualquer ponto durante o processo, os serviços que já concluíram suas atualizações aplicarão uma lógica específica para invertê-las.</span><span class="sxs-lookup"><span data-stu-id="e2edc-116">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="e2edc-117">Outra opção é usar o DDD (design controlado por domínio) e o CQRS (segregação de responsabilidade de comando/consulta), conforme descrito no [livro eletrônico de microservices do .net](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span><span class="sxs-lookup"><span data-stu-id="e2edc-117">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="e2edc-118">Em particular, o uso de eventos de domínio ou [fornecimento de eventos](https://martinfowler.com/eaaDev/EventSourcing.html) pode ajudar a garantir que as atualizações sejam&mdash;de forma consistente se não&mdash;aplicadas imediatamente.</span><span class="sxs-lookup"><span data-stu-id="e2edc-118">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently&mdash;if not immediately&mdash;applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="e2edc-119">Anterior</span><span class="sxs-lookup"><span data-stu-id="e2edc-119">Previous</span></span>](application-performance-management.md)
