<Type Name="InheritanceMappingAttribute" FullName="System.Data.Linq.Mapping.InheritanceMappingAttribute">
  <TypeSignature Language="C#" Value="public sealed class InheritanceMappingAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit InheritanceMappingAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.Mapping.InheritanceMappingAttribute" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Mapeia uma hierarquia de herança em um LINQ para aplicativos do SQL.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.Linq.Mapping.InheritanceMappingAttribute> é especificado por classe mapeada.  
  
 Ao mapear hierarquias de herança, observe o seguinte:  
  
-   Todas as classes em uma hierarquia devem ser mapeadas para uma única tabela.  
  
-   A tabela para uma hierarquia de herança deve ser declarada no tipo mapeado que está no topo da hierarquia. Você não pode especificar os atributos de mapeamento ou de tabela em uma classe que é derivada da classe superior.  
  
-   Você pode usar uma interface em uma hierarquia, mas [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] não é mapeado.  
  
-   Quando você mapear classes, mas você pode consultar somente as classes mapeadas, você pode ignorar uma classe na hierarquia.  
  
 Para a materialização correta, valores de discriminador de código devem ser exclusivos e correspondem aos valores no banco de dados. Uma linha com um valor de código do discriminador corresponde exatamente (até mesmo em maiusculas e minúsculas) cria uma instância da classe usando <xref:System.Data.Linq.Mapping.InheritanceMappingAttribute.IsDefault%2A> definido como `true`.  
  
   
  
## Examples  
 Este exemplo mostra o mapeamento de herança de uma hierarquia onde mapeada a parte superior, classe (`Shape`) é abstrato.  
  
 [!code-csharp[System.Data.Linq.Mapping.InheritanceMappingAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.Mapping.InheritanceMappingAttribute/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.Mapping.InheritanceMappingAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.Mapping.InheritanceMappingAttribute/vb/Module1.vb#1)]  
  
 O exemplo a seguir mostra a inclusão de classes não mapeados. Você pode colocar classes não mapeados em qualquer lugar na hierarquia.  
  
 [!code-csharp[System.Data.Linq.Mapping.InheritanceMappingAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.Mapping.InheritanceMappingAttribute/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.Mapping.InheritanceMappingAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.Mapping.InheritanceMappingAttribute/vb/Module1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InheritanceMappingAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Mapping.InheritanceMappingAttribute.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.Linq.Mapping.InheritanceMappingAttribute" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Code">
      <MemberSignature Language="C#" Value="public object Code { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Code" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Mapping.InheritanceMappingAttribute.Code" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor Discriminatório de código em uma hierarquia de herança mapeada.</summary>
        <value>Deve ser especificado pelo usuário. Nenhum valor padrão.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public bool IsDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Mapping.InheritanceMappingAttribute.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se um objeto deste tipo em instanciado quando o valor Discriminatório não coincide com um valor especificado.</summary>
        <value>Padrão = <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Exatamente um o <xref:System.Data.Linq.Mapping.InheritanceMappingAttribute> atributos devem ser declarados com <xref:System.Data.Linq.Mapping.InheritanceMappingAttribute.IsDefault%2A> como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Type Type { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Mapping.InheritanceMappingAttribute.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo da classe na hierarquia.</summary>
        <value>Deve ser especificado pelo usuário. Nenhum valor padrão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use qualquer tipo não abstrato na hierarquia de herança, incluindo o tipo de raiz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
