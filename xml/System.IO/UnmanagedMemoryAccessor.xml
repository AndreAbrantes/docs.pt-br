<Type Name="UnmanagedMemoryAccessor" FullName="System.IO.UnmanagedMemoryAccessor">
  <TypeSignature Language="C#" Value="public class UnmanagedMemoryAccessor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UnmanagedMemoryAccessor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.UnmanagedMemoryAccessor" />
  <AssemblyInfo>
    <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece acesso aleatório aos blocos de memória não gerenciados a partir de código gerenciado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor%2A> método de um <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> object retorna os blocos de memória para trabalhar com modos de exibição de arquivos mapeados na memória não gerenciados.  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnmanagedMemoryAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.UnmanagedMemoryAccessor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryAccessor (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para conter o acessador.</param>
        <param name="offset">Bytes no qual iniciar o acessador.</param>
        <param name="capacity">O tamanho, em bytes, da memória para alocar.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.UnmanagedMemoryAccessor" /> classe com um buffer especificado, o deslocamento e a capacidade.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />Além de <paramref name="capacity" /> é maior do que <paramref name="buffer" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="capacity" /> é menor que zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="offset" />Além de <paramref name="capacity" /> encapsularia a extremidade alta do espaço de endereço.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryAccessor (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para conter o acessador.</param>
        <param name="offset">Bytes no qual iniciar o acessador.</param>
        <param name="capacity">O tamanho, em bytes, da memória para alocar.</param>
        <param name="access">O tipo de acesso permitido para a memória. O padrão é <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.UnmanagedMemoryAccessor" /> com um buffer especificado, o deslocamento e a capacidade de classe e o direito de acesso.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />Além de <paramref name="capacity" /> é maior do que <paramref name="buffer" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="capacity" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="access" /> não é um valor de enumeração <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="offset" />Além de <paramref name="capacity" /> encapsularia a extremidade alta do espaço de endereço.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryAccessor.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se o acessador é legível.</summary>
        <value>
          <see langword="true" />Se o acessador está legível; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryAccessor.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se o acessório é gravável.</summary>
        <value>
          <see langword="true" />Se o acessador for gravável; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public long Capacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryAccessor.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a capacidade do acessador.</summary>
        <value>A capacidade do acessador.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.IO.UnmanagedMemoryAccessor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.IO.UnmanagedMemoryAccessor" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose()` e pelo método <xref:System.Object.Finalize%2A>. `Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro for true, este método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.UnmanagedMemoryAccessor> referências. Este método invoca o método `Dispose()` de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see langword="Dispose(Boolean)" /> cuidado para não fazer referência a objetos que têm foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para conter o acessador.</param>
        <param name="offset">Bytes no qual iniciar o acessador.</param>
        <param name="capacity">O tamanho, em bytes, da memória para alocar.</param>
        <param name="access">O tipo de acesso permitido para a memória. O padrão é <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Define os valores iniciais do acessador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelos construtores para esta classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />Além de <paramref name="capacity" /> é maior do que <paramref name="buffer" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="capacity" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="access" /> não é um valor de enumeração <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="offset" />Além de <paramref name="capacity" /> encapsularia a extremidade alta do espaço de endereço.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="protected bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryAccessor.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se o acessador é aberto por um processo.</summary>
        <value>
          <see langword="true" />Se o acessador está aberto. Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Read&lt;T&gt; (long position, out T structure) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Read&lt;struct .ctor (class System.ValueType) T&gt;(int64 position, [out] !!T&amp; structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Read``1(System.Int64,``0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="structure" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de estrutura.</typeparam>
        <param name="position">A posição no acessador na qual a leitura começará.</param>
        <param name="structure">A estrutura para conter os dados lidos.</param>
        <summary>Lê uma estrutura do tipo <paramref name="T" /> do acessador em uma referência fornecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler de médio a grandes estruturas que não são facilmente acomodados por outros métodos de leitura nessa classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não há bytes suficiente após <paramref name="position" /> a serem lidos em uma estrutura do tipo <paramref name="T" />.  
  
 - ou -  
  
 <see langword="T" /> é um tipo de valor que contém um ou mais tipos de referência.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public int ReadArray&lt;T&gt; (long position, T[] array, int offset, int count) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadArray&lt;struct .ctor (class System.ValueType) T&gt;(int64 position, !!T[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadArray``1(System.Int64,``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de estrutura.</typeparam>
        <param name="position">O número de bytes no acessador no qual a leitura começará.</param>
        <param name="array">A matriz para conter as estruturas lidas do acessador.</param>
        <param name="offset">O índice em <c>matriz</c> na qual colocar a primeira estrutura copiada.</param>
        <param name="count">O número de estruturas de tipo <c>T</c> leiam o acessador.</param>
        <summary>Lê as estruturas do tipo <paramref name="T" /> do acessador em uma matriz do tipo <paramref name="T" />.</summary>
        <returns>O número de estruturas lidas no <paramref name="array" />. Esse valor poderá ser menor que <paramref name="count" /> se houver menos estruturas disponíveis ou zero se o final do acessador for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não é seguro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> não é grande o suficiente para conter <paramref name="count" /> de estruturas (começando em <paramref name="position" />).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public bool ReadBoolean (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReadBoolean(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadBoolean(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um valor booliano do acessador.</summary>
        <returns>
          <see langword="true" /> ou <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public byte ReadByte (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8 ReadByte(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadByte(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um valor de byte do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public char ReadChar (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char ReadChar(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadChar(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um caractere de acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDecimal">
      <MemberSignature Language="C#" Value="public decimal ReadDecimal (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal ReadDecimal(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadDecimal(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um valor decimal do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.  
  
 -ou-  
  
 Decimal ler é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDouble">
      <MemberSignature Language="C#" Value="public double ReadDouble (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 ReadDouble(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadDouble(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um valor de ponto flutuante de precisão dupla do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public short ReadInt16 (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int16 ReadInt16(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadInt16(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro de 16 bits do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public int ReadInt32 (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadInt32(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadInt32(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro de 32 bits do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public long ReadInt64 (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ReadInt64(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadInt64(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro de 64 bits do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSByte">
      <MemberSignature Language="C#" Value="public sbyte ReadSByte (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int8 ReadSByte(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadSByte(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro assinado de 8 bits do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Int16" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingle">
      <MemberSignature Language="C#" Value="public float ReadSingle (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 ReadSingle(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadSingle(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um valor de ponto flutuante de precisão simples do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16">
      <MemberSignature Language="C#" Value="public ushort ReadUInt16 (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int16 ReadUInt16(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadUInt16(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro de 16 bits sem sinal de acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Int32" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32">
      <MemberSignature Language="C#" Value="public uint ReadUInt32 (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 ReadUInt32(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadUInt32(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro não assinado de 32 bits do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Int64" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64">
      <MemberSignature Language="C#" Value="public ulong ReadUInt64 (long position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 ReadUInt64(int64 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.ReadUInt64(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual começar a ler.</param>
        <summary>Lê um inteiro não assinado de 64 bits do acessador.</summary>
        <returns>O valor que foi lido.</returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Decimal" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para ler um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à leitura.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor booleano para o acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor de byte para o acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um caractere no acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor decimal para o acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.  
  
 -ou-  
  
 Decimal é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um <see langword="Double" /> valor no acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro de 16 bits para o acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro de 32 bits no acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro de 64 bits no acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não há suficiente bytes após a posição para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro de 8 bits para o acessador.</summary>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Int16" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um <see langword="Single" /> no acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro de 16 bits sem sinal para o acessador.</summary>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Int32" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro de 32 bits sem sinal para o acessador.</summary>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Int64" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (long position, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(int64 position, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write(System.Int64,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um inteiro não assinado de 64 bits no acessador.</summary>
        <remarks>To be added.</remarks>
        <altCompliant cref="T:System.Decimal" />
        <exception cref="T:System.ArgumentException">Não existem bytes suficientes após <paramref name="position" /> para gravar um valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (long position, ref T structure) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;struct .ctor (class System.ValueType) T&gt;(int64 position, !!T&amp; structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.Write``1(System.Int64,``0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="structure" Type="T&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de estrutura.</typeparam>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="structure">A estrutura a ser gravada.</param>
        <summary>Grava uma estrutura no acessador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar médias e grandes estruturas que não são facilmente acomodadas por outros <xref:System.IO.UnmanagedMemoryAccessor.Write%2A> métodos dessa classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não há bytes suficientes no acessador após <paramref name="position" /> para gravar uma estrutura do tipo <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void WriteArray&lt;T&gt; (long position, T[] array, int offset, int count) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteArray&lt;struct .ctor (class System.ValueType) T&gt;(int64 position, !!T[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryAccessor.WriteArray``1(System.Int64,``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de estrutura.</typeparam>
        <param name="position">O número de bytes no acessador no qual a gravação começará.</param>
        <param name="array">A matriz para gravar no acessador.</param>
        <param name="offset">O índice em <c>matriz</c> a gravação de ser iniciada.</param>
        <param name="count">O número de estruturas no <c>matriz</c> para gravação.</param>
        <summary>Grava estruturas de uma matriz do tipo <paramref name="T" /> no acessador.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Não há bytes suficientes no acessador após <paramref name="position" /> para gravar o número de estruturas especificadas por <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> é menor que zero ou maior que a capacidade do acessador.  
  
 -ou-  
  
 <paramref name="offset" /> ou <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O acessador não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O acessador foi descartado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
