<Type Name="Timer" FullName="System.Threading.Timer">
  <TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece um mecanismo para executar um método em um pool de threads em intervalos especificados. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/threading/timer.cs#051a39d380760b26). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Use um <xref:System.Threading.TimerCallback> delegado para especificar o método que você deseja o <xref:System.Threading.Timer> para executar. A assinatura do <xref:System.Threading.TimerCallback> delegado é:  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 O representante de timer é especificado quando o timer é construído e não pode ser alterado. O método não é executado no thread que criou o timer; ele é executado em um <xref:System.Threading.ThreadPool> thread fornecido pelo sistema.  
  
> [!TIP]
>  A biblioteca de classes do .NET Framework inclui quatro classes chamadas `Timer`, cada um de que oferece funcionalidades diferentes:  
>   
>  -   <xref:System.Timers.Timer?displayProperty=nameWithType>, que dispara um evento e executa o código em um ou mais eventos coletores em intervalos regulares. A classe é destinada para uso como um servidor com base em ou componente de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não fica visível no tempo de execução.  
> -   <xref:System.Threading.Timer?displayProperty=nameWithType>, que executa um método de retorno de chamada única em um pool de threads em intervalos regulares. O método de retorno de chamada é definido quando o timer é instanciado e não pode ser alterado. Como o <xref:System.Timers.Timer?displayProperty=nameWithType> classe, essa classe é destinada para uso como um componente baseado em servidor ou serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não fica visível no tempo de execução.  
> -   <xref:System.Windows.Forms.Timer?displayProperty=nameWithType>, um componente de Windows Forms que dispara um evento e executa o código em um ou mais Coletores de eventos em intervalos regulares. O componente não tem nenhuma interface do usuário e é projetado para uso em um ambiente de thread único; ele executa no thread da interface do usuário.  
> -   <xref:System.Web.UI.Timer?displayProperty=nameWithType>, um componente do ASP.NET que executa a página da web assíncrona ou síncrona postbacks em intervalos regulares.  
  
 Quando você cria um temporizador, você pode especificar um período de tempo de espera antes da primeira execução do método (tempo) e um valor de tempo de espera entre as execuções subsequentes (período). O <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema. Isso significa que, se o período for menor do que a resolução do relógio do sistema, o <xref:System.Threading.TimerCallback> representante será executado em intervalos definidos pela resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8. Você pode alterar o devido tempo e período ou desabilitar o timer, usando o <xref:System.Threading.Timer.Change%2A> método.  
  
> [!NOTE]
>  Enquanto você estiver usando um <xref:System.Threading.Timer>, você deve manter uma referência a ele. Assim como acontece com qualquer objeto gerenciado, uma <xref:System.Threading.Timer> está sujeito a coleta de lixo quando não houver nenhuma referência a ele. O fato de que um <xref:System.Threading.Timer> é ativo ainda não impede que ele sendo coletados.  
  
 Quando um timer não é mais necessário, use o <xref:System.Threading.Timer.Dispose%2A> método para liberar os recursos mantidos pelo timer. Observe que os retornos de chamada podem ocorrer após a <xref:System.Threading.Timer.Dispose> sobrecarga do método foi chamada, porque o timer de filas de retornos de chamada para execução por threads de pool. Você pode usar o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método Aguarde até que todos os retornos de chamada de tem concluído.  
  
 O método de retorno de chamada executado pelo temporizador deve ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads. O retorno de chamada pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o retorno de chamada, ou se todos os threads de pool estão em uso e o retorno de chamada é enfileirado várias vezes.  
  
> [!NOTE]
>  <xref:System.Threading.Timer?displayProperty=nameWithType>é um temporizador leve e simple que usa métodos de retorno de chamada e é fornecido por threads de pool. Não é recomendável para uso com o Windows Forms, porque seus retornos de chamada não ocorrem no thread de interface do usuário. <xref:System.Windows.Forms.Timer?displayProperty=nameWithType>é uma opção melhor para uso com o Windows Forms. Para a funcionalidade de temporizador com base em servidor, você pode considerar o uso <xref:System.Timers.Timer?displayProperty=nameWithType>, que gera eventos e tem recursos adicionais.  
  
   
  
## Examples  
 O exemplo a seguir define uma `StatusChecker` classe que inclui um `CheckStatus` método cuja assinatura é o mesmo como o <xref:System.Threading.TimerCallback> delegate. O `state` argumento o `CheckStatus` método é um <xref:System.Threading.AutoResetEvent> objeto que é usado para sincronizar o thread de aplicativo e o pool de threads que executa o representante de retorno de chamada. O `StatusChecker` classe também inclui duas variáveis de estado:  
  
 `invokeCount`  
 Indica o número de vezes que o método de retorno de chamada foi invocado.  
  
 `maxCount`  
 Determina o número máximo de vezes que o método de retorno de chamada deve ser invocado.  
  
 O thread de aplicativo cria o timer, que aguarda um segundo e, em seguida, executa o `CheckStatus` método de retorno de chamada cada 250 milissegundos. O thread de aplicativo, em seguida, bloqueia até o <xref:System.Threading.AutoResetEvent> objeto é sinalizado. Quando o `CheckStatus` executa o método de retorno de chamada `maxCount` vezes, ele chama o `AutoResetEvent.Set` método para definir o estado do <xref:System.Threading.AutoResetEvent> objeto sinalizado. Na primeira vez isso acontecer, o thread de aplicativo chama o <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> método para que o método de retorno de chamada agora executa cada meio segundo. Bloqueia novamente até que o <xref:System.Threading.AutoResetEvent> objeto é sinalizado. Quando isso acontece, o timer é destruído chamando seu <xref:System.Threading.Timer.Dispose%2A> método e o aplicativo será encerrado.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Timer" /> com um período infinito e um tempo de validade infinito usando o objeto <see cref="T:System.Threading.Timer" /> recém-criado como o objeto de estado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar este construtor quando você deseja usar o <xref:System.Threading.Timer> próprio objeto como o objeto de estado. Depois de criar o timer, use o <xref:System.Threading.Timer.Change%2A> método para definir o intervalo e a hora de vencimento.  
  
 Este construtor Especifica um infinito devido tempo antes do retorno de chamada primeiro e um intervalo de infinito entre retornos de chamada, para impedir o retorno de chamada primeiro antes do <xref:System.Threading.Timer> objeto é atribuído ao objeto de estado.  
  
 O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo timer, usando o temporizador de si mesmo como o objeto de estado. O <xref:System.Threading.Timer.Change%2A> método é usado para iniciar o timer. Quando o retorno de chamada timer ocorre, o objeto de estado é usado para desativar o timer.  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de espera antes de <c>retorno de chamada</c> é invocado, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de <c>retorno de chamada</c>, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é chamado imediatamente. Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema se `period` é menor do que a resolução do relógio do sistema. Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar um `TimerCallback` delegar e inicializar uma nova instância do `Timer` classe.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de espera antes de <c>retorno de chamada</c> é invocado, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de <c>retorno de chamada</c>, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando um inteiro com sinal de 64 bits para medir intervalos de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é chamado imediatamente. Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema se `period` é menor do que a resolução do relógio do sistema. Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é maior que 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de espera antes do <c>retorno de chamada</c> parâmetro chama seus métodos. Especifique um milissegundo negativo (-1) para impedir que o temporizador seja iniciado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de métodos referenciadas por <c>retorno de chamada</c>. Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando valores <see cref="T:System.TimeSpan" /> para medir intervalos de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é chamado imediatamente. Se `dueTime` é negativo um (-1) milissegundos, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema se `period` é menor do que a resolução do relógio do sistema. Se `period` é zero (0) ou negativo um (-1) milissegundos e `dueTime` for positivo, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar um `TimerCallback` delegar e inicializar uma nova instância do `Timer` classe.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de milissegundos no valor de <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de espera antes de <c>retorno de chamada</c> é invocado, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de <c>retorno de chamada</c>, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é chamado imediatamente. Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema se `period` é menor do que a resolução do relógio do sistema. Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer de reinicialização. Especifica zero (0) para reiniciar o timer imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 32 bits para medir intervalos de tempo.</summary>
        <returns>
          <see langword="true" />Se o timer foi atualizado com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como iniciar um `Timer` e, após um determinado número de chamadas, altere o período.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dueTime">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer de reinicialização. Especifica zero (0) para reiniciar o timer imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 64 bits para medir intervalos de tempo.</summary>
        <returns>
          <see langword="true" />Se o timer foi atualizado com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é maior que 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime">O <see cref="T:System.TimeSpan" /> que representa o período de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído. Especifique negativo um (-1) milissegundos para impedir que o timer de reinicialização. Especifica zero (0) para reiniciar o timer imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído. Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando valores de <see cref="T:System.TimeSpan" /> para medir os intervalos de tempo.</summary>
        <returns>
          <see langword="true" />Se o timer foi atualizado com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` é negativo um (-1) milissegundos, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou negativo um (-1) milissegundos, e `dueTime` for positivo, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor maior que zero para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como iniciar um `Timer` e, após um determinado número de chamadas, altere o período.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" />, em milissegundos, é menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" />, em milissegundos, é maior que 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dueTime">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer de reinicialização. Especifica zero (0) para reiniciar o timer imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método de um temporizador, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</summary>
        <returns>
          <see langword="true" />Se o timer foi atualizado com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.Timer> para ser realocada para outros fins. Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).  
  
> [!NOTE]
>  Retornos de chamada podem ocorrer após a <xref:System.Threading.Timer.Dispose> sobrecarga do método foi chamada, porque o timer de filas de retornos de chamada para execução por threads de pool. Você pode usar o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método Aguarde até que todos os retornos de chamada de tem concluído.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como liberar os recursos mantidos por um `Timer`.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="notifyObject">O <see cref="T:System.Threading.WaitHandle" /> a ser sinalizado quando o <see langword="Timer" /> for descartado.</param>
        <summary>Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" /> e indica quando o temporizador for descartado.</summary>
        <returns>
          <see langword="true" /> se a função for bem-sucedida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.Timer> para ser realocada para outros fins. Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).  
  
 Quando esse método é concluído, ele sinaliza o <xref:System.Threading.WaitHandle> especificado pelo `notifyObject` parâmetro. Use essa sobrecarga de <xref:System.Threading.Timer.Dispose%2A> método se você deseja bloquear até ter certeza de que o temporizador foi descartado. O timer não é descartado até que todos os retornos de chamada atualmente na fila tenham concluído.  
  
> [!NOTE]
>  Se usar o retorno de chamada a <xref:System.Threading.Timer.Change%2A> método para definir o `dueTime` parâmetro como zero, uma condição de corrida pode ocorrer quando o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método é chamada: se o timer enfileira um retorno de chamada novo antes do <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método detecta que não há nenhum retorno de chamada na fila, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> continue a bloquear; caso contrário, o temporizador é descartado enquanto o retorno de chamada novo está sendo enfileirado e um <xref:System.ObjectDisposedException> é gerada quando o retorno de chamada novo chama o <xref:System.Threading.Timer.Change%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="notifyObject" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
