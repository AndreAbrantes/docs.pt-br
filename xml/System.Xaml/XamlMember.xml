<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece o identificador do sistema de tipo XAML para membros de tipos XAML. O identificador é usado por leitores XAML e autores de XAML durante o processamento de nós de membro (quando o leitor XAML está posicionado em um <see cref="F:System.Xaml.XamlNodeType.StartMember" />) e também para lógica geral do sistema de tipo XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember>pode usar as metodologias de três para retornar informações sobre um membro XAML: padrão reflexão comum de tempo de execução (CLR) do idioma; uma técnica de reflexão somente para referência interna ao chamar esse bit de otimização do uso de APIs sinalizadores; ou chamar virtual substituições do `Lookup*` API fornecida pelo possível <xref:System.Xaml.XamlMember> subclasses. Para a maioria dos usos de APIs de serviços XAML do .NET Framework e o <xref:System.Xaml.XamlMember> API, você usa o contexto do esquema XAML padrão. O contexto do esquema padrão XAML para serviços XAML do .NET Framework usa backup para o sistema de tipo CLR. Isso permite que os leitores XAML e gravadores XAML trabalhar com qualquer tipo ou membro que é definido em ou não disponível para, o CLR e suas técnicas de reflexão.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Classes derivadas do XamlMember e APIs de pesquisa *  
 <xref:System.Xaml.XamlMember>define vários membros virtuais que classes derivadas podem substituir. Esses membros com nomes que iniciam sempre com a cadeia de caracteres `Lookup`. O restante da API de referências, em seguida, o propriedade name que influencia o método virtual. Por exemplo, um <xref:System.Xaml.XamlMember> classe derivada pode substituir <xref:System.Xaml.XamlMember.LookupTargetType%2A> para influenciar que a base de dados de propriedade <xref:System.Xaml.XamlMember.TargetType%2A> retorna em uma classe derivada. Você pode prever valores de retorno para essas propriedades no <xref:System.Xaml.XamlMember> ou existente classes derivadas lendo a documentação relevante `Lookup*` métodos.  
  
 A finalidade de `Lookup*` métodos é fornecer uma técnica de extensão de sistema de tipo XAML que incorpora o <xref:System.Xaml.XamlMember> classe base. Derivando de <xref:System.Xaml.XamlMember> e substituindo o `Lookup` membros virtuais, você pode definir o conceito de um membro XAML para um esquema XAML em um sistema de tipo XAML sem ser vinculado às especificações de um sistema de tipos de backup ou uma tecnologia. Você pode também usar um contexto de esquema XAML fornecido sob esse esquema e ainda retornará os resultados desejados.  
  
 Por exemplo, considere o <xref:System.Xaml.XamlMember> propriedade <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Essa propriedade informa os chamadores que operações como usando um <xref:System.Xaml.XamlWriter> para serialização pode gravar um valor para esse membro em um objeto de destino. Na implementação do padrão, a determinação se o membro é gravável é feita usando técnicas de reflexão em relação a CLR de apoio <xref:System.Type> e seus membros (o <xref:System.Reflection.MemberInfo>). Portanto, por padrão, o sistema de tipo XAML depende do sistema de tipo CLR. No entanto, você pode remover essa dependência para o seu sistema de tipo XAML relatório de <xref:System.Xaml.XamlMember.IsWritePublic%2A> , substituindo a API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. Dentro de sua substituição, você pode usar outras decisões, como metadados específicos para sua tecnologia, de uma tabela de pesquisa principal que é otimizada para um vocabulário XAML fixado ou uma variedade de outras estratégias para determinar se um membro XAML é gravável no seu vocabulário XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Construindo XamlMember sem contexto do esquema XAML  
 A maioria dos construtores de <xref:System.Xaml.XamlMember> exigem um <xref:System.Xaml.XamlSchemaContext> como parte da sua inicialização. O <xref:System.Xaml.XamlSchemaContext> também é necessária para muitos interno <xref:System.Xaml.XamlSchemaContext> operações, como obter as informações que está sendo encaminhadas do tipo de backup. Quando você estiver trabalhando com o <xref:System.Xaml.XamlMember> API, geralmente precisam ter um <xref:System.Xaml.XamlSchemaContext> que está disponível a partir de uma construção ao redor, como um <xref:System.Xaml.XamlWriter>. Nesse caso, você pode passar o <xref:System.Xaml.XamlSchemaContext> referência por meio de todas as chamadas de sistema de tipo XAML que exigem um contexto de esquema XAML.  
  
 Um construtor específico, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, não requer um <xref:System.Xaml.XamlSchemaContext>. No entanto, um <xref:System.Xaml.XamlMember> que é construído com a <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> assinatura retorna `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, esse membro não pode ser gravado em um gráfico de objeto. Com a implementação de serviços XAML do .NET Framework, o <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> chamar lança um <xref:System.Xaml.XamlObjectWriterException> quando relevante <xref:System.Xaml.XamlMember> relatórios `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Você não deve criar um <xref:System.Xaml.XamlMember> que tem um valor de `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> , a menos que sua implementação pode manipular as exceções de <xref:System.Xaml.XamlObjectWriter>, ou você tiver outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento. Por exemplo, um ou mais dos itens a seguir podem ser verdadeiro para sua implementação:  
  
-   O contexto do esquema XAML está disponível mais tarde.  
  
-   Você usar um padrão de chamador do membro.  
  
-   Substituir deliberadamente <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> em um gravador XAML personalizado.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">O sistema de tipos CLR <see cref="T:System.Reflection.EventInfo" /> que representa o membro de evento.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> classe usando o sistema de tipos CLR <see cref="T:System.Reflection.EventInfo" /> e um <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um evento (propriedade de ponto de conexão de manipulador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">O sistema de tipos CLR <see cref="T:System.Reflection.PropertyInfo" /> que representa o membro de propriedade.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> classe usando o sistema de tipos CLR <see cref="T:System.Reflection.PropertyInfo" /> e um <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa uma propriedade (e especificamente não é uma conexão de manipulador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">O sistema de tipos CLR <see cref="T:System.Reflection.EventInfo" /> que representa o membro de evento.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <param name="invoker">A implementação de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que manipula a reflexão de chamadas do tempo de execução em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> classe usando o sistema de tipos CLR <see cref="T:System.Reflection.EventInfo" /> e um <see cref="T:System.Xaml.XamlSchemaContext" />, incluindo <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um evento (ou uma propriedade de ponto de conexão do manipulador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">O sistema de tipos CLR <see cref="T:System.Reflection.PropertyInfo" /> que representa o membro de propriedade.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <param name="invoker">O <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementação que manipula a invocação de tempo de execução chama em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> classe usando a reflexão <see cref="T:System.Reflection.PropertyInfo" /> e um <see cref="T:System.Xaml.XamlSchemaContext" />, incluindo <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor somente se o membro representa uma propriedade e se não for uma conexão de manipulador de eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">O nome da cadeia de caracteres do evento anexável.</param>
        <param name="adder">O sistema de tipos CLR <see cref="T:System.Reflection.MethodInfo" /> para o manipulador <see langword="Add" /> método do membro anexável do fazendo a implementação.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> de classe para um <see cref="T:System.Xaml.XamlMember" /> que representa um evento anexável.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um membro de evento anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome da cadeia de caracteres do membro.</param>
        <param name="declaringType">O <see cref="T:System.Xaml.XamlType" /> informações para o tipo de declaração.</param>
        <param name="isAttachable">
          <see langword="true" />para indicar que o membro anexável; Caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> usando um nome de cadeia de caracteres e a declaração de classe <see cref="T:System.Xaml.XamlType" /> informações. Um <see cref="T:System.Xaml.XamlMember" /> que é construído com esta assinatura apresenta limitações significativas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xaml.XamlMember> que é construído com a <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> assinatura retorna `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, esse membro não pode ser gravado em um gráfico de objeto. Com a implementação de serviços XAML do .NET Framework, o <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> chamar lança um <xref:System.Xaml.XamlObjectWriterException> quando relevante <xref:System.Xaml.XamlMember> relatórios `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Você não deve criar um <xref:System.Xaml.XamlMember> com <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` , a menos que sua implementação pode manipular as exceções de <xref:System.Xaml.XamlObjectWriter>, ou você tiver outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento. Por exemplo, um ou mais dos itens a seguir podem ser verdadeiro para sua implementação:  
  
-   O contexto do esquema XAML está disponível mais tarde.  
  
-   Você usar um padrão de chamador do membro.  
  
-   Substituir deliberadamente <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> em um gravador XAML personalizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="declaringType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">O nome da cadeia de caracteres da propriedade anexável.</param>
        <param name="getter">O sistema de tipos CLR <see cref="T:System.Reflection.MethodInfo" /> para o <see langword="get" /> acessador do membro anexável do fazendo a implementação.</param>
        <param name="setter">O sistema de tipos CLR <see cref="T:System.Reflection.MethodInfo" /> para o <see langword="set" /> acessador do membro anexável do fazendo a implementação.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> de classe para um <see cref="T:System.Xaml.XamlMember" /> que representa uma propriedade anexável.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa uma propriedade anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">O nome da cadeia de caracteres do evento anexável.</param>
        <param name="adder">O sistema de tipos CLR <see cref="T:System.Reflection.MethodInfo" /> para o manipulador <see langword="Add" /> método do membro anexável do fazendo a implementação.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <param name="invoker">O <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementação que manipula a invocação de tempo de execução chama em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> de classe para um <see cref="T:System.Xaml.XamlMember" /> que representa um evento anexável, incluindo <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um membro de evento anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">O nome da cadeia de caracteres da propriedade anexável.</param>
        <param name="getter">O sistema de tipos CLR <see cref="T:System.Reflection.MethodInfo" /> para o <see langword="get" /> acessador do membro anexável do fazendo a implementação.</param>
        <param name="setter">O sistema de tipos CLR <see cref="T:System.Reflection.MethodInfo" /> para o <see langword="set" /> acessador do membro anexável do fazendo a implementação.</param>
        <param name="schemaContext">O <see cref="T:System.Xaml.XamlSchemaContext" /> contexto que qualifica o membro.</param>
        <param name="invoker">O <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementação que manipula a invocação de tempo de execução chama em relação a <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Xaml.XamlMember" /> de classe para um <see cref="T:System.Xaml.XamlMember" /> que representa uma propriedade anexável, incluindo <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor se o membro representa um membro de uma propriedade anexável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> para o tipo que declara o membro que é associado a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O <see cref="T:System.Xaml.XamlType" /> para o tipo que declara o membro que é associado a essa <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor normalmente é definida durante a inicialização e não costuma ser `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A>informações podem ser passadas por construtores para inicialização. Chamando diretamente construtores base, a inicialização para <xref:System.Xaml.XamlMember> classes derivadas podem omitir alguns as verificações de valor que são feitas na classe base. Portanto, a inicialização derivada pode alterar as informações de relação de membro de tipo relatado de um membro XAML para que ele não se alinha de forma esperada com as informações de sua declaração de CLR subjacente do sistema de tipo. Para verificações da declaração de tipo informações críticas de segurança, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> objeto, que é usado para carregamento adiado dos XAML declarado objetos.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com <see cref="T:System.Xaml.XamlDeferringLoader" /> restrição genérica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.DeferringLoader%2A> invoca <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> ou uma substituição específica desse método. Esse comportamento ocorre nos casos em que a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de <see cref="T:System.Xaml.XamlMember" /> objetos. Eles reportam os membros em que relações de dependência para ordem de inicialização existem em relação a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Uma lista de <see cref="T:System.Xaml.XamlMember" /> objetos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.DependsOn%2A> invoca <xref:System.Xaml.XamlMember.LookupDependsOn%2A> ou uma substituição específica desse método. Esse comportamento ocorre nos casos em que a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 O `DependsOn` padrão pode ser aplicado a casos de modelo de objeto que deliberadamente contradigam a regra XAML geral. A regra XAML geral é que os membros de um tipo que não são transmitidos como texto de inicialização (ou por um método de fábrica em XAML 2009) devem poder ser atribuídas em qualquer ordem. Aplicando um `DependsOn` padrão para um membro, você pode instruir gravadores XAML para processar sempre o membro referenciado antes desse membro. Você pode aplicar esse padrão em situações em que o valor do membro atual requer contexto ou outras informações que está disponíveis somente depois de outro membro é definido.  
  
 O `DependsOn` padrão deve ser aplicado criteriosamente e reservado para cenários de propriedade em que ele tem uma finalidade de arquitetura. Grandes números de dependências têm potencial para reduzir a velocidade de processamento de XAML. Além disso, é possível produzir dependências circulares, caso em que o comportamento de processamento de XAML é indefinido.  
  
 Exemplo `DependsOn` cenários do WPF incluem determinadas propriedades em <xref:System.Windows.Controls.ControlTemplate> e <xref:System.Windows.DataTemplate>, na <xref:System.Windows.Trigger>e em <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado com este objeto.</param>
        <summary>Indica se o objeto atual é igual a outro objeto.</summary>
        <returns>
          <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="obj" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Um objeto para comparação com esse objeto.</param>
        <summary>Indica se o objeto atual é igual a outro objeto do mesmo tipo.</summary>
        <returns>
          <see langword="true" /> se o objeto atual for igual ao parâmetro <paramref name="other" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para este objeto.</summary>
        <returns>Um código de hash de número inteiro.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de namespaces XAML onde esse membro XAML pode existir.</summary>
        <returns>Uma lista de identificadores de namespace XAML como cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna o <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> chamar resultado da <xref:System.Xaml.XamlMember.DeclaringType%2A> que é associada a essa <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementação que está associada a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementação que está associada a essa <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Invoker` padrão é uma técnica de extensão do sistema de tipo XAML avançada. O `Invoker` padrão fornece uma maneira de inserir o comportamento de mapeamento de tipo de esquema diferente, enquanto estiver usando definições de sistema de tipo XAML de serviços XAML do .NET Framework.  
  
 Se um <xref:System.Xaml.XamlMember.LookupInvoker%2A> substituir retorna `null`, ou se a implementação padrão retorna `null` porque ele não tem o <xref:System.Xaml.XamlMember.UnderlyingMember%2A> para este <xref:System.Xaml.XamlMember>, o <xref:System.Xaml.XamlMember.Invoker%2A> propriedade retorna <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> é o padrão. Isso é verdadeiro para a maioria das operações que usam serviços XAML do .NET Framework e o contexto do esquema XAML padrão e em nenhum específicos substituir `Invoker` padrões são passados para a construção de entidades do sistema de tipo XAML.  
  
 Chamando <xref:System.Xaml.XamlMember.Invoker%2A> invoca <xref:System.Xaml.XamlMember.LookupInvoker%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> será relatado como uma propriedade de ambiente.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> relatados como uma propriedade de ambiente; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsAmbient%2A> invoca <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> ou uma substituição específica desse método. Esse comportamento ocorre em implementações onde a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 Verificando para propriedades de ambiente é geralmente fazem parte da lógica de processamento de XAML para certificar-se de que os objetos e os valores que se baseiam no uso de ambiente para a qualificação do tipo podem funcionar corretamente. APIs de serviços XAML do .NET Framework e o contexto do esquema padrão XAML preenche esse valor com base na atribuição com <xref:System.Windows.Markup.AmbientAttribute>. A implementação padrão de <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> usa esse existente <xref:System.Windows.Markup.AmbientAttribute> técnica e retornará `true` se <xref:System.Windows.Markup.AmbientAttribute> existe em uma declaração de membro.  
  
 <xref:System.Windows.Markup.AmbientAttribute>foi encontrado em membros de vários tipos WPF, que incluem <xref:System.Windows.Application>, <xref:System.Windows.Setter>, e <xref:System.Windows.Style>. Ele também é encontrado na <xref:System.Windows.ResourceDictionary> tipo, que dá a ideia de que qualquer membro que usa <xref:System.Windows.ResourceDictionary> como seu tipo deve ser considerado ambiente mesmo se o membro não é especificamente atribuído.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é um membro anexável.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> é um membro anexável; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsAttachable%2A> o valor é inicializado com base em qual construtor foi usado para construir um <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é uma diretiva XAML.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> é uma XAML diretiva; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsDirective%2A> o valor é inicializado com base em qual construtor foi usado para construir um <xref:System.Xaml.XamlMember>. A base de <xref:System.Xaml.XamlMember> inicializar construtores para que <xref:System.Xaml.XamlMember.IsDirective%2A> é `false`. No entanto, o <xref:System.Xaml.XamlDirective> classe (um <xref:System.Xaml.XamlMember> classe derivada) inicializa para que <xref:System.Xaml.XamlMember.IsDirective%2A> é `true`.  
  
 Se você deseja relatar <xref:System.Xaml.XamlMember.IsDirective%2A> como `true` para chamadores de uma classe personalizada de esquema XAML para membros XAML, verifique se você derivar da <xref:System.Xaml.XamlDirective> porque é a única maneira de habilitar esse comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro de evento.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um evento; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsEvent%2A> invoca <xref:System.Xaml.XamlMember.LookupIsEvent%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> é inicializada com uma validade <see langword="xamlName" /> de cadeia de caracteres como seu <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> é inicializada com uma validade <see langword="xamlName" /> de cadeia de caracteres; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro somente leitura.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um membro somente leitura; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsReadOnly%2A> invoca <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro com um público que pode ser chamado <see langword="get" /> acessador.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um público que pode ser chamado <see langword="get" /> acessador; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsReadPublic%2A> valor verifica se o <xref:System.Xaml.XamlMember.DeclaringType%2A> é público. Se <xref:System.Xaml.XamlMember.DeclaringType%2A> é não público, o `get` acessador não é chamado de um modo prático, e <xref:System.Xaml.XamlMember.IsReadPublic%2A> retorna `false`.  
  
 Chamando <xref:System.Xaml.XamlMember.IsReadPublic%2A> invoca <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> ou uma substituição específica desse método.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o membro não é resolvido pelo sistema de backup que é usado para resolução de tipo e membro.</summary>
        <value>
          <see langword="true" />Se o membro não pode ser resolvido; <see langword="false" /> se o membro puder ser resolvido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xaml.XamlMember> que é construído com a <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> assinatura retorna `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para um caminho de carga que envolve <xref:System.Xaml.XamlObjectWriter>, um <xref:System.Xaml.XamlMember> com `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> não pode ser gravado em um gráfico de objeto. Sob as implementações padrão de APIs de serviços de XAML do .NET Framework, o <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> chamar lança um <xref:System.Xaml.XamlObjectWriterException> quando relevante <xref:System.Xaml.XamlMember> relatórios `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Você não deve criar um <xref:System.Xaml.XamlMember> que tem um valor de `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> , a menos que sua implementação pode manipular as exceções de <xref:System.Xaml.XamlObjectWriter>, ou você tiver outras maneiras de ajustar o <xref:System.Xaml.XamlObjectWriter> comportamento.  
  
 Chamando <xref:System.Xaml.XamlMember.IsUnknown%2A> invoca <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro de somente gravação.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um membro somente gravação; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.IsWriteOnly%2A> invoca <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.Xaml.XamlMember" /> representa um membro que tem um público que pode ser chamado <see langword="set" /> acessador.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um público que pode ser chamado <see langword="set" /> acessador; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.IsWritePublic%2A> valor considera se o <xref:System.Xaml.XamlMember.DeclaringType%2A> é público como parte da determinação. Se <xref:System.Xaml.XamlMember.DeclaringType%2A> é não público, o `set` acessador não é chamado de um modo prático, e <xref:System.Xaml.XamlMember.IsWritePublic%2A> retorna `false`.  
  
 Chamando <xref:System.Xaml.XamlMember.IsWritePublic%2A> invoca <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> ou uma substituição específica desse método.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementada em uma classe derivada, retorna um <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementação.</summary>
        <returns>Um <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método para fornecer a reflexão interna com uma maneira alternativa para obter valores de atributo do CLR. Na ausência de uma substituição, o reflector interno usa a lógica de reflexão típica do CLR como chamadas ao <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 A implementação padrão retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> objeto, que é usado para carregamento adiado dos XAML declarado objetos.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tem um <see cref="T:System.Xaml.XamlDeferringLoader" /> restrição genérica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um chamador obtém um valor da <xref:System.Xaml.XamlMember.DeferringLoader%2A> propriedade. Substitua este método se desejar <xref:System.Xaml.XamlMember.DeferringLoader%2A> para retornar um valor diferente do valor que é habilitado por reflexão interno do padrão, e se você estiver fornecendo também personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> informações.  
  
 A implementação padrão retorna um objeto lendo <xref:System.Windows.Markup.XamlDeferLoadAttribute> ou usando um <xref:System.Xaml.XamlDeferringLoader> do tipo de declaração. Se nenhum objeto estiver disponível, esse método pode retornar `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma lista de objetos <see cref="T:System.Xaml.XamlMember" />. Relatam de itens na lista os membros em que relações de dependência para ordem de inicialização existem em relação a esse <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Uma lista de <see cref="T:System.Xaml.XamlMember" /> objetos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um chamador obtém um valor da <xref:System.Xaml.XamlMember.DependsOn%2A> propriedade. Substitua este método se desejar <xref:System.Xaml.XamlMember.DependsOn%2A> para retornar um valor diferente do valor que é habilitado por reflexão interno do padrão, e se você estiver fornecendo também personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> informações.  
  
 As implementações de leitor e gravador do WPF XAML atributo nesse caso com <xref:System.Windows.Markup.DependsOnAttribute>. A implementação padrão usa esse existente <xref:System.Windows.Markup.DependsOnAttribute> técnica.  
  
 Substitua este método se você não estiver usando <xref:System.Windows.Markup.DependsOnAttribute> para essa finalidade e a intenção de substituir essa técnica para indicar a ordem de processamento de propriedade com sua própria técnica. Se você não pretende dar suporte a uma ordem de processamento de propriedade, você pode usar a implementação padrão porque ele não retorna nenhum resultado, que é apropriado.  
  
 A lista é somente leitura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que é associada a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>O <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informações para este <see cref="T:System.Xaml.XamlMember" />; ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é invocado por chamadas para <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 A implementação padrão não requer que um <xref:System.Xaml.XamlMember> ser construídas usando um dos construtores que passam um inicial <xref:System.Xaml.Schema.XamlMemberInvoker>. No entanto, um <xref:System.Xaml.XamlMember.UnderlyingMember%2A> valor deve existir para o <xref:System.Xaml.XamlMember>; caso contrário, retorna a implementação padrão `null`.  
  
 Substitua este método se você também derivar de <xref:System.Xaml.Schema.XamlMemberInvoker> e pretendia retornar classe derivada. Se você retornar `null`, <xref:System.Xaml.XamlMember.Invoker%2A> retorna <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> para chamadores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> será relatado como uma propriedade de ambiente.</summary>
        <returns>
          <see langword="true" />relate isto <see cref="T:System.Xaml.XamlMember" /> como uma propriedade de ambiente; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é invocado por chamadas internas que verificar se há informações de propriedade do ambiente XAML. Comportamento de propriedade de ambiente é contabilizado no comportamento de API público de leitores XAML e gravadores XAML. As chamadas internas que fazem referência a <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> geralmente fazem parte da lógica de processamento de XAML para certificar-se de que os objetos e os valores que se baseiam no uso de ambiente para a qualificação do tipo podem funcionar corretamente. A implementação de serviços XAML do .NET Framework padrão usa a atribuição para obter essas informações de reflexão fazendo tipos CLR. Especificamente, a implementação padrão procura <xref:System.Windows.Markup.AmbientAttribute> e retorna `true` para <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> se <xref:System.Windows.Markup.AmbientAttribute> existe em uma definição de membro.  
  
 Substitua este método se você não estiver usando <xref:System.Windows.Markup.AmbientAttribute> para essa finalidade e a intenção de substituir essa técnica para indicar propriedades XAML ambiente com sua própria técnica.  
  
 Exemplo APIs do WPF esse atributo com <xref:System.Windows.Markup.AmbientAttribute> são <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> e <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> representa um evento.</summary>
        <returns>
          <see langword="true" />para relatórios que este <see cref="T:System.Xaml.XamlMember" /> representa um evento; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As verificações de implementação padrão se <xref:System.Xaml.XamlMember.UnderlyingMember%2A> é do tipo <xref:System.Reflection.EventInfo>e se for, retornará `true`.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsEvent%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis que podem ser interpretados para determinar o XAML tipo representações de sistema em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> representa uma propriedade somente leitura pretendida.</summary>
        <returns>
          <see langword="true" />relate isto <see cref="T:System.Xaml.XamlMember" /> como uma propriedade somente leitura pretendida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna `true` se <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe, mas um público `set` acessador não existe para ele, conforme determinado pela reflexão interno.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis que podem ser interpretados para determinar o XAML tipo representações de sistema em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> representa uma propriedade que tem um público <see langword="get" /> acessador.</summary>
        <returns>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa uma propriedade que tem um público <see langword="get" /> acessador; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna resultados com base em reflexão interno ou a negação de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, o processamento nessa ordem.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>Retorna se o próprio membro é público; ele retorna `true` para um membro público em um confidenciais tipo declarativo. Use <xref:System.Xaml.XamlMember.IsReadPublic%2A> em vez disso, se você também queira considerar a visibilidade do tipo declarativo.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> representa um membro que não pode ser resolvido pelo sistema de backup que é usado para resolução de tipo e membro.</summary>
        <returns>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um membro não pode ser resolvido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsUnknown%2A>. A implementação padrão retorna resultados com base em qualquer reflexão interno ou verificando um `null` valor <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, o processamento nessa ordem.  
  
 Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> representa um membro que tem um público <see langword="set" /> acessador mas não um público <see langword="get" /> acessador.</summary>
        <returns>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um membro somente gravação; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna `true` se um <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe que tem um público `set` acessador e um confidenciais `get` acessador, conforme determinado pela reflexão interno.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna se isso <see cref="T:System.Xaml.XamlMember" /> representa um membro que tem um público <see langword="set" /> acessador.</summary>
        <returns>
          <see langword="true" />Se este <see cref="T:System.Xaml.XamlMember" /> representa um membro gravável; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna resultados com base em reflexão interno ou a negação de <xref:System.Xaml.XamlMember.IsReadOnly%2A>, o processamento nessa ordem.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
> [!IMPORTANT]
>  O <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> método é virtual e, portanto, pode ser substituído. A substituição tem o potencial de mudar (maliciosamente ou não) as informações de acesso reportadas de um membro XAML para que ele não alinhe de forma esperada com as informações de acesso de sua declaração de CLR subjacente do tipo system. Para qualquer verificação de segurança crítica dos níveis de acesso, use o tipo CLR subjacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os caracteres de colchete de abertura e fechamento de uma extensão de marcação.</summary>
        <returns>Uma coleção que contém os caracteres de colchete de abertura e fechamento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> do tipo onde o <see cref="T:System.Xaml.XamlMember" /> podem existir.</summary>
        <returns>O tipo de onde o <see cref="T:System.Xaml.XamlMember" /> podem existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão faz distinção entre os membros anexáveis e não anexável. Para membros não anexável, <xref:System.Xaml.XamlMember.LookupTargetType%2A> sempre retorna <xref:System.Xaml.XamlMember.DeclaringType%2A>. Para membros anexáveis, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retorna um resultado com base em examinar o <xref:System.Xaml.XamlMember.UnderlyingMember%2A> tipo de parâmetro do acessador e interpreta que tipo com base no contexto do esquema XAML.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.TargetType%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</summary>
        <returns>O <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.Type%2A>. Substitua este método se desejar <xref:System.Xaml.XamlMember.Type%2A> para retornar um valor diferente do valor que é habilitado por reflexão interno do padrão, e se você estiver fornecendo também personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> informações.  
  
 A implementação padrão usa caminhos de código diferentes e significados conceituais para retornado <xref:System.Xaml.XamlType> que baseia-se isso <xref:System.Xaml.XamlMember> representa uma propriedade, método ou evento.  
  
-   Para uma propriedade, retornada <xref:System.Xaml.XamlType> é o tipo que define a propriedade ou é retornado pela propriedade.  
  
-   Para um evento, retornado <xref:System.Xaml.XamlType> é o tipo de manipulador de eventos necessários (um delegado em uma implementação de CLR).  
  
-   Para um método, <xref:System.Xaml.XamlType> é o tipo de retorno.  
  
 Em cada caso, o contexto do esquema XML é usado para avaliar o tipo XAML do tipo de sistema subjacente.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.Type%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma implementação de conversor de tipo que é associada a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> instância com <see cref="T:System.ComponentModel.TypeConverter" /> restrição; ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão usa a seguinte lógica e a ordem de processamento:  
  
-   Se a atribuição existe no nível de membro (<xref:System.ComponentModel.TypeConverterAttribute>), as informações de atributo são usadas para chamar <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> em relação ao contexto de esquema XAML.  
  
-   Se <xref:System.Xaml.XamlMember.Type%2A> for válido, um conversor de tipo que está associado com o tipo será retornado.  
  
-   Se o membro é um evento, um conversor de tipo de evento específico será retornado.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.TypeConverter%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see langword="get" /> acessador que está associado a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>O <see cref="T:System.Reflection.MethodInfo" /> associados <see langword="get" /> acessador; ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão interpreta o <xref:System.Xaml.XamlMember.UnderlyingMember%2A> a propriedade como <xref:System.Reflection.PropertyInfo> e retorna o valor de <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (com o parâmetro definido `true`), que significa que o método retornado pode ser confidenciais. Esse comportamento pode resultar em `null` para determinados casos. incluindo casos em que nenhum acessador associado existe ou o membro não é uma propriedade.  
  
 Esse método é chamado quando um chamador obtém um valor da <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> propriedade em um tipo de <xref:System.Xaml.Schema.XamlMemberInvoker>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso. Certifique-se de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, e <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que retornem resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um sistema de tipos CLR <see cref="T:System.Reflection.MemberInfo" /> que é associada a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Um sistema de tipos CLR <see cref="T:System.Reflection.MemberInfo" /> objeto que está associado com esta <see cref="T:System.Xaml.XamlMember" />; ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna as informações de membro subjacente, que se baseia em construção. Se o <xref:System.Reflection.MemberInfo> objeto for construído com uma assinatura que não fornece informações suficientes para definir o membro base, esse método retornará `null`.  
  
 Se um membro subjacente foi definido durante a construção, você não precisará chamar esse método.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso. Certifique-se de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, e <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que retornem resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see langword="set" /> acessador que está associado a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>O <see cref="T:System.Reflection.MethodInfo" /> associados <see langword="set" /> acessador; ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão interpreta <xref:System.Xaml.XamlMember.UnderlyingMember%2A> como <xref:System.Reflection.PropertyInfo> e retorna o valor de <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (com o parâmetro definido `true`), que significa que o método retornado pode ser confidenciais. Isso pode resultar em `null` para certos casos, inclusive os casos em que não há nenhum tal acessador ou o membro não é uma propriedade.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> em um tipo de <xref:System.Xaml.Schema.XamlMemberInvoker>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso. Certifique-se de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, e <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que retornem resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma implementação de serializador de valor que é associada a essa <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> instância com <see cref="T:System.Windows.Markup.ValueSerializer" /> restrição, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão usa a seguinte lógica e a ordem de processamento:  
  
-   Se a atribuição existe no nível de membro (<xref:System.Windows.Markup.ValueSerializerAttribute>), as informações de atributo são usadas para chamar <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> em relação ao contexto de esquema XAML.  
  
-   Se <xref:System.Xaml.XamlMember.Type%2A> for válido, um conversor de valor que está associado com o tipo será retornado.  
  
-   Se não se aplicam as condições anteriores, `null` será retornado.  
  
 Esse método é chamado quando um chamador obtém um valor de <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Substitua este método se você deseja relatar resultados uniforme para toda uma <xref:System.Xaml.XamlMember> derivado da classe, ou se você tiver um especializado metadados disponíveis para determinar isso em uma base por caso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define os caracteres de colchete de abertura e fechamento de uma extensão de marcação.</summary>
        <value>Uma coleção que contém os caracteres de colchete de abertura e fechamento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see langword="xamlName" /> nome de cadeia de caracteres que declara isso <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O <see langword="xamlName" /> nome de cadeia de caracteres que declara isso <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor é sempre definido durante a construção. Os construtores que são implementados por <xref:System.Xaml.XamlMember> normalmente lançar uma exceção se não for especificado um nome inicial; portanto, não espere essa propriedade para ser `null` ou uma cadeia de caracteres vazia, se você estiver usando as implementações padrão de serviços XAML do .NET Framework.  
  
 [Gramática XamlName](~/docs/framework/xaml-services/xamlname-grammar.md) e as regras de nomenclatura para o tipo CLR e os membros não são uma interseção exata. É possível declarar um nome de membro que é válido em CLR, mas não é válido em XAML de nomenclatura. Você deve evitar essa situação, se possível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.Xaml.XamlMember" /> especificados têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="xamlMember1" /> for o mesmo que o valor de <paramref name="xamlMember2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Determina se duas especificadas <see cref="T:System.Xaml.XamlMember" /> objetos têm valores diferentes.</summary>
        <returns>
          <see langword="true" />Se o valor de <paramref name="xamlMember1" /> difere do valor de <paramref name="xamlMember2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o namespace XAML URI que identifica o namespace XAML primário para esse único <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>O identificador do namespace XAML primário para este <see cref="T:System.Xaml.XamlMember" />, como uma cadeia de caracteres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> propriedade fornece o mesmo valor que a chamada <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> e, em seguida, obter a primeira cadeia de caracteres do valor da lista retornada. O namespace XAML preferencial deve ser usado ao gravar o membro de volta para o texto ou outras representações que preservam as informações de namespace XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> valor que indica como um designer visual deve processar o membro.</summary>
        <value>Um valor de <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> enumeração. O padrão é <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> do tipo onde o <see cref="T:System.Xaml.XamlMember" /> podem existir.</summary>
        <value>O tipo de onde o <see cref="T:System.Xaml.XamlMember" /> podem existir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado é diferente para membros anexáveis e não anexável. Para membros não anexável, <xref:System.Xaml.XamlMember.TargetType%2A> retorna <xref:System.Xaml.XamlMember.DeclaringType%2A>. Para membros anexáveis, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retorna um resultado com base em lógica:  
  
-   Se a reflexão não é possível resolver um backup (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), esse método retorna uma constante interna que representa um tipo de objeto genérico.  
  
-   Se a condição anterior não se aplica, <xref:System.Xaml.XamlMember.LookupTargetType%2A> é chamado. A implementação padrão retorna um <xref:System.Xaml.XamlType> que se baseia no examinando os métodos que implementam o `get` e `set` acessadores. Uma classe pode substituir <xref:System.Xaml.XamlMember.LookupTargetType%2A> usar um comportamento diferente, como outros metadados de formulários que poderá reportar os tipos de destino para membros anexáveis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma representação de cadeia de caracteres deste <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Uma representação de cadeia de caracteres deste <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação retorna <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</summary>
        <value>O <see cref="T:System.Xaml.XamlType" /> do tipo que é usado pelo membro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.Type%2A> invoca <xref:System.Xaml.XamlMember.LookupType%2A> ou uma substituição específica desse método. Isso ocorre quando a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 No comportamento padrão (nenhuma <xref:System.Xaml.XamlMember.LookupType%2A> substituir), retornado <xref:System.Xaml.XamlType> pode ter diferentes significados conceituais. Aplica-se qual significado depende se isso <xref:System.Xaml.XamlMember> representa uma propriedade, método ou evento, como mostra a lista a seguir:  
  
-   Para uma propriedade, retornada <xref:System.Xaml.XamlType> é o tipo que define a propriedade ou é retornado pela propriedade.  
  
-   Para um evento, retornado <xref:System.Xaml.XamlType> é o tipo de manipulador de eventos necessários (um delegado em uma implementação de CLR).  
  
-   Para um método, <xref:System.Xaml.XamlType> é o tipo de retorno desse método, o que pode ser `null`.  
  
 Em cada caso, o contexto do esquema XAML é usado para avaliar o tipo XAML do tipo de backup.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> objeto, que pode ser usado para a construção de conversão de tipo de XAML declarado objetos.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> valor, com um <see cref="T:System.ComponentModel.TypeConverter" /> restrição genérica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.TypeConverter%2A> invoca <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> ou uma substituição específica desse método. Esse comportamento ocorre quando a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 Valor de implementações que retornam uma propriedade não nula para <xref:System.Xaml.XamlMember.TypeConverter%2A> não são necessariamente um trabalho <xref:System.ComponentModel.TypeConverter>. A seguir está uma lista de possíveis valores de retorno não nulo para <xref:System.Xaml.XamlMember.TypeConverter%2A> e esses valores representam:  
  
-   O valor de retorno relata um conversor de tipo é atribuído especificamente para esse membro ou de forma geral para o tipo de destino do conversor. Normalmente, esse comportamento é que a maioria dos sistemas de tipo XAML e procure processadores XAML para instanciar um conversor de tipo e chamar seus métodos.  
  
-   O valor de retorno relata um conversor de valor interno. Esses conversores existem para determinadas operações internas que são executadas por um autor XAML. Em particular, esses conversores de valor interno converter os valores de cadeia de caracteres bruta de atributo para os primitivos de nível de linguagem XAML. Para a implementação de serviços XAML do .NET Framework, essas conversões de tipo interno geralmente encaminham para um conversor de tipo é definido no assembly System. Por exemplo, uma conversão para um <xref:System.Int32> valor tem interno encaminhado conversão e, portanto, o <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> valor referências <xref:System.ComponentModel.Int32Converter>.  
  
-   O valor de retorno relatórios caso especial de um modelo de objeto irrestrita; ou seja, o <xref:System.Xaml.XamlMember> tem um <xref:System.Xaml.XamlMember.Type%2A> valor <xref:System.Object>. Nesse caso, o <xref:System.Xaml.Schema.XamlValueConverter%601> relata que o <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> é {`Object}`. No entanto, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> é `null` porque nenhum tipo real ou a instância está disponível para realizar essa conversão. Em vez disso, o comportamento do modelo de objeto não pode ser determinado até o tempo de execução, quando o tempo de execução da tecnologia específica determina a manipulação de seu gráfico de objeto.  
  
 Se você puder acessar um trabalho <xref:System.ComponentModel.TypeConverter> de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, você pode chamar seus métodos de conversão. No entanto, vários métodos de conversão confiam no contexto do serviço. Se você não tem o mesmo contexto de serviço disponível que o conversor de tipo de espera para sua função típica de gravação de objetos para gráficos de objeto, os métodos de conversor podem gerar exceções.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o sistema de tipos CLR <see cref="T:System.Reflection.MemberInfo" /> que está disponível para um membro que é criado por <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" />, ou <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Sistema de tipos CLR <see cref="T:System.Reflection.MemberInfo" /> informações, como conversão de parâmetros de construtor inicial. Um <see cref="T:System.Xaml.XamlMember" /> que é construído com a <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> assinatura retorna <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.UnderlyingMember%2A> invoca <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> ou uma substituição específica desse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> objeto, que é usado para serialização de valor de XAML declarado objetos.</summary>
        <value>Um <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> com <see cref="T:System.Windows.Markup.ValueSerializer" /> restrição genérica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Xaml.XamlMember.ValueSerializer%2A> invoca <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> ou uma substituição específica desse método. Esse comportamento ocorre quando a lógica de reflexão interno inicial ainda não tiver definido as informações.  
  
 Valor de nem todos os casos que retornam uma propriedade não nula para <xref:System.Xaml.XamlMember.ValueSerializer%2A> são necessariamente um trabalho <xref:System.Windows.Markup.ValueSerializer>. Consulte <xref:System.Xaml.XamlMember.TypeConverter%2A>; as mesmas considerações se aplicam a <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
