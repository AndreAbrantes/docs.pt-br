<Type Name="TypeDescriptor" FullName="System.ComponentModel.TypeDescriptor">
  <TypeSignature Language="C#" Value="public sealed class TypeDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TypeDescriptor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptor" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece informações sobre as características de um componente, como atributos, propriedades e eventos. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework fornece duas maneiras de acessar os metadados em um tipo: a reflexão API fornecida a <xref:System.Reflection?displayProperty=nameWithType> namespace e o <xref:System.ComponentModel.TypeDescriptor> classe. Reflexão é um mecanismo geral disponível a todos os tipos porque sua base é estabelecida a <xref:System.Object.GetType%2A> método da raiz <xref:System.Object> classe. As informações que ele retorna para um tipo não são extensíveis, em que ele não pode ser modificado após a compilação do tipo de destino. Para obter mais informações, consulte os tópicos [reflexão](~/docs/framework/reflection-and-codedom/reflection.md).  
  
 Por outro lado, <xref:System.ComponentModel.TypeDescriptor> é um mecanismo de inspeção extensível para componentes: as classes que implementam o <xref:System.ComponentModel.IComponent> interface. Ao contrário de reflexão, ele não inspeciona para métodos. <xref:System.ComponentModel.TypeDescriptor>pode ser estendido dinamicamente por vários serviços disponíveis por meio do componente de destino <xref:System.ComponentModel.Component.Site%2A>. A tabela a seguir mostra esses serviços.  
  
|Nome do serviço|Descrição|  
|------------------|-----------------|  
|<xref:System.ComponentModel.IExtenderProvider>|Permite que a outra classe, como <xref:System.Windows.Forms.ToolTip>, para fornecer propriedades adicionais para um componente.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Permite que outro objeto para modificar os metadados padrão que é exposto por um componente.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor>|Permite que uma classe completamente e dinamicamente especificar seus próprios metadados, substituindo o mecanismo de inspeção de padrão de <xref:System.ComponentModel.TypeDescriptor>.|  
  
 A extensibilidade fornecida pelo <xref:System.ComponentModel.TypeDescriptor> permite a representação de tempo de design de um componente seja diferente da sua representação de tempo de execução real, o que torna <xref:System.ComponentModel.TypeDescriptor> úteis para a criação da infraestrutura de tempo de design.  
  
 Todos os métodos no <xref:System.ComponentModel.TypeDescriptor> são `static`. Não é possível criar uma instância dessa classe, e essa classe não pode ser herdada.  
  
 Você pode definir a propriedade e evento valores de duas maneiras diferentes: especificá-los na classe de componente ou alterá-los em tempo de design. Porque você pode definir esses valores de duas maneiras, os métodos sobrecarregados de <xref:System.ComponentModel.TypeDescriptor> levar dois tipos diferentes de parâmetros: um tipo de classe ou uma instância do objeto.  
  
 Quando você deseja acessar <xref:System.ComponentModel.TypeDescriptor> informações e você tiver uma instância do objeto, use o método que chama um componente. Use o método que chama para o tipo de classe somente quando você não tem uma instância do objeto.  
  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se esse for o caso, o <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método deve ser chamado para atualizar o cache.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (object instance, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(object instance, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Object,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Uma instância do componente de destino.</param>
        <param name="attributes">Uma matriz de objetos <see cref="T:System.Attribute" /> a serem adicionados à classe do componente.</param>
        <summary>Adiciona os atributos de nível de classe à instância de componente de destino.</summary>
        <returns>O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> recém-criado que foi usado para adicionar os atributos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Object%2CSystem.Attribute%5B%5D%29> método adiciona os atributos de nível de classe para a instância especificada de um componente. Como esse é um requisito comum de aplicativos usando o [!INCLUDE[vsprvs](~/includes/vsprvs-md.md)] Windows Forms Designer e a janela Propriedades, esse método fornece um atalho, criando um provedor de descrição de tipo que mescla os atributos fornecidos com os atributos que já existem na classe. O valor de retorno é o provedor de descrição de tipo que foi usado para adicionar os atributos. Este provedor posteriormente pode ser passado para o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método quando os atributos adicionados não são mais necessários.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Type,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="attributes">Uma matriz de objetos <see cref="T:System.Attribute" /> a serem adicionados à classe do componente.</param>
        <summary>Adiciona atributos de nível de classe ao tipo de componente de destino.</summary>
        <returns>O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> recém-criado que foi usado para adicionar os atributos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Type%2CSystem.Attribute%5B%5D%29> método adiciona os atributos de nível de classe para o tipo de um componente especificado. Como esse é um requisito comum de aplicativos usando o [!INCLUDE[vsprvs](~/includes/vsprvs-md.md)] Windows Forms Designer e a janela Propriedades, esse método fornece um atalho, criando um provedor de descrição de tipo que mescla os atributos fornecidos com os atributos que já existem na classe. O valor de retorno é o provedor de descrição de tipo que foi usado para adicionar os atributos. Este provedor posteriormente pode ser passado para o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método quando os atributos adicionados não são mais necessários.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="AddEditorTable">
      <MemberSignature Language="C#" Value="public static void AddEditorTable (Type editorBaseType, System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddEditorTable(class System.Type editorBaseType, class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">O tipo base editor para adicionar a tabela de editor para. Se uma tabela já existe para este tipo, esse método não fará nada.</param>
        <param name="table">O <see cref="T:System.Collections.Hashtable" /> a ser adicionado.</param>
        <summary>Adiciona uma tabela de editor para o tipo base do editor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddEditorTable%2A> método adiciona uma tabela de editor para o tipo base do editor especificado. Normalmente, os editores são especificados como metadados em um componente. No entanto, se nenhum metadado editor solicitado base de tipo pode ser encontrado no componente, associado <xref:System.ComponentModel.TypeDescriptor> irá procurar uma tabela de editor para o tipo de editor, se pode ser encontrado. Após a adição de uma tabela de editor para um descritor de tipo, ele não pode ser removido e pertence ao descritor de tipo. O descritor de tipo livremente pode fazer modificações nesta tabela.  
  
 O formato de uma tabela de editor usa tipos de dados como chaves e editores como valores. A parte do valor de uma entrada na tabela representa uma instância do editor. Ele pode ter um dos três valores. Se ele contém uma cadeia de caracteres, o descritor de tipo assumirá que este é um nome totalmente qualificado de um tipo e, em seguida, carregar o tipo do objeto. Se ele contém um tipo, uma instância desse tipo será criada para obter um editor. Por fim, a parte de valor pode conter uma instância do editor real. Se o descritor de tipo resolve um editor para uma instância, ele armazena a instância de volta na tabela para uso futuro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo de uma única instância de um componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método adiciona um provedor de descrição de tipo que fornece informações de tipo para uma única instância de um componente. Se um provedor é adicionado por esse método, o provedor <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> método não será chamado porque a instância já existe.  
  
 Esse método não mantém uma referência de disco rígida para o componente, para que ela não impede que o componente finalizando.  
  
 É possível adicionar vários provedores de descrição de tipo para o mesmo tipo ou objeto. Se isso ocorrer, o primeiro tipo descrição provedor encontrado que fornece informações de tipo será usado exclusivamente. Como provedores de informações de tipo são armazenadas em uma pilha, o último provedor adicionado será o primeiro deles consultada. Esse comportamento permite que o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> e <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> provedor de descrição de tipos de métodos a serem usados para enviar por push e pop conforme necessário para cenários específicos.  
  
 Se for bem-sucedida, este método chama o <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Object%29> método sobre o `instance` parâmetro.  
  
> [!NOTE]
>  As duas versões do método produzem resultados com escopos diferentes. O <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> método que utiliza um <xref:System.Object> parâmetro afeta somente uma instância única do componente especificado. Por outro lado, a outra sobrecarga, que usa um <xref:System.Type> parâmetro afeta todas as instâncias do componente descrita por tipo.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo de uma classe de componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método adiciona um provedor de descrição de tipo que fornece informações de tipo para a classe especificada, as classes derivadas e todas as instâncias desses tipos.  
  
> [!NOTE]
>  O `type` parâmetro pode ser qualquer tipo, incluindo uma interface. Por exemplo, para fornecer informações de instância para todos os componentes e tipo personalizado, você especificaria `typeof(IComponent)`. Passando `typeof(object)` chamará o provedor para fornecer informações de tipo para todos os tipos.  
  
 Esse método não manter uma referência de disco rígida para qualquer objeto, para que ela não impede que objetos finalizando.  
  
 É possível adicionar vários provedores de descrição de tipo para o mesmo tipo ou objeto. Se isso ocorrer, o primeiro tipo descrição provedor encontrado que fornece informações de tipo será usado exclusivamente. Como provedores de informações de tipo são armazenadas em uma pilha, o último provedor adicionado será o primeiro deles consultada. Esse comportamento permite que o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> e <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> provedor de descrição de tipos de métodos a serem usados para enviar por push e pop conforme necessário para cenários específicos.  
  
 Se for bem-sucedida, este método chama o <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Type%29> método sobre o `type` parâmetro.  
  
> [!NOTE]
>  As duas versões do método produzem resultados com escopos diferentes. O <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> método que utiliza um <xref:System.Object> parâmetro afeta somente uma instância única do componente especificado. Por outro lado, a outra sobrecarga, que usa um <xref:System.Type> parâmetro afeta todas as instâncias do componente descrita por tipo.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo de uma única instância de um componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode registrar um provedor para a instância especificada se seu tipo também é parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define o <paramref name="instance" /> tipo do parâmetro.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo de uma classe de componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode registrar um provedor para o tipo especificado se também for parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ComNativeDescriptorHandler">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComNativeDescriptorHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o provedor para as informações de tipo de modelo de objeto de componente (COM) para o componente de destino.</summary>
        <value>Um <see cref="T:System.ComponentModel.IComNativeDescriptorHandler" /> que representa o provedor de informações COM tipo de instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler%2A> propriedade e o <xref:System.ComponentModel.IComNativeDescriptorHandler> interface está obsoleta. Para obter mais informações, consulte a propriedade <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="ComObjectType">
      <MemberSignature Language="C#" Value="public static Type ComObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type ComObjectType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do objeto de modelo de objeto de componente (COM) representado pelo componente de destino.</summary>
        <value>O <see cref="T:System.Type" /> do objeto COM representado por esse componente, ou <see langword="null" /> para objetos COM não.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propriedade retorna um tipo que pode ser passado para o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método para definir um provedor de descrição de tipo para tipos COM.  
  
 O <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propriedade e outros membros dessa classe substituem a funcionalidade de obsoleto <xref:System.ComponentModel.IComNativeDescriptorHandler> interface. Para implementar uma camada de mapeamento entre um objeto COM e <xref:System.ComponentModel.TypeDescriptor>, adicione um <xref:System.ComponentModel.TypeDescriptionProvider> para lidar com tipo <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAssociation">
      <MemberSignature Language="C#" Value="public static void CreateAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">O principal <see cref="T:System.Object" />.</param>
        <param name="secondary">O secundário <see cref="T:System.Object" />.</param>
        <summary>Cria uma associação primário secundário entre dois objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método cria uma associação entre um principal e um objeto secundário. Quando uma associação é criada, um designer ou outro mecanismo de filtragem pode adicionar propriedades roteiam para qualquer objeto no conjunto de propriedades do objeto principal. Quando é feita uma chamada de propriedade do objeto principal, o <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> método será chamado para resolver a instância do objeto real que está relacionada ao seu parâmetro de tipo.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não impede que qualquer objeto que está sendo finalizado e recuperada pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="primary" /> é igual a <paramref name="secondary" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, Type designerBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, class System.Type designerBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="designerBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">Um <see cref="T:System.ComponentModel.IComponent" /> que especifica o componente para associar com o designer.</param>
        <param name="designerBaseType">Um <see cref="T:System.Type" /> que representa o tipo de designer para criar.</param>
        <summary>Cria uma instância do designer associado ao componente especificado e do tipo especificado do designer.</summary>
        <returns>Um <see cref="T:System.ComponentModel.Design.IDesigner" /> que é uma instância do designer para o componente, ou <see langword="null" /> se nenhum designer pode ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método não é possível localizar um válido <xref:System.ComponentModel.DesignerAttribute>, ele procura a hierarquia de classe para um designer. Se ele não é possível localizar um designer na hierarquia de classe, ele retorna `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, System.ComponentModel.EventDescriptor oldEventDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, class System.ComponentModel.EventDescriptor oldEventDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.ComponentModel.EventDescriptor,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldEventDescriptor" Type="System.ComponentModel.EventDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O tipo do componente para o qual criar o novo evento.</param>
        <param name="oldEventDescriptor">As informações de evento existente.</param>
        <param name="attributes">Os novos atributos.</param>
        <summary>Cria um novo descritor de evento que é idêntico a um descritor de eventos existentes, quando passado existente <see cref="T:System.ComponentModel.EventDescriptor" />.</summary>
        <returns>Um novo <see cref="T:System.ComponentModel.EventDescriptor" /> que foi mesclado os atributos de metadados especificado com os atributos de metadados existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O tipo do evento componente reside.</param>
        <param name="name">O nome do evento.</param>
        <param name="type">O tipo de representante que manipula o evento.</param>
        <param name="attributes">Os atributos para este evento.</param>
        <summary>Cria um novo descritor de evento que é idêntico a um descritor de evento existente Gerando informações de descritor dinamicamente de um evento específico em um tipo.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> que está associado a um tipo.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">O provedor de serviços que fornece um serviço <see cref="T:System.ComponentModel.TypeDescriptionProvider" />. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="objectType">O <see cref="T:System.Type" /> do objeto a ser criado.</param>
        <param name="argTypes">Uma matriz opcional de tipos de parâmetro a serem passados para o construtor do objeto. Esse parâmetro pode ser <see langword="null" /> ou uma matriz de tamanho zero.</param>
        <param name="args">Uma matriz opcional de valores de parâmetro a serem passados para o construtor do objeto. Se não <see langword="null" />, o número de elementos deve ser o mesmo que <c>argTypes</c>.</param>
        <summary>Cria um objeto que pode ser substituído em outro tipo de dados.</summary>
        <returns>Uma instância do tipo de dados substituto se um <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associado for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> método irá procurar uma <xref:System.ComponentModel.TypeDescriptionProvider> associado especificado `objectType` tipo de dados. Esse método primeiro tenta obter um provedor de descrição de tipo do `provider` parâmetro. Se isso falhar, ele procura suas próprias tabelas internas por um provedor (essas entradas foram criadas por meio de chamadas anteriores para <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>). Se ele encontrar um provedor, esse método delegará a chamada de criação para o objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> é <see langword="null" /> ou <paramref name="args" /> é <see langword="null" /> quando <paramref name="argTypes" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argTypes" /> e <paramref name="args" /> têm quantidades diferentes de elementos.</exception>
        <block subset="none" type="overrides">
          <para>Se a classe derivada não fornecer uma instância de substituição, esse método deve chamar a implementação base.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, class System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.ComponentModel.PropertyDescriptor,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldPropertyDescriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do que a propriedade é um membro do componente.</param>
        <param name="oldPropertyDescriptor">O descritor de propriedade existente.</param>
        <param name="attributes">Os novos atributos para essa propriedade.</param>
        <summary>Cria um novo descritor de propriedade de um descritor de propriedade existente, com o uso especificado <see cref="T:System.ComponentModel.PropertyDescriptor" /> e matriz de atributos.</summary>
        <returns>Um novo <see cref="T:System.ComponentModel.PropertyDescriptor" /> com os atributos de metadados especificado mesclados com os atributos de metadados existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do que a propriedade é um membro do componente.</param>
        <param name="name">O nome da propriedade.</param>
        <param name="type">O <see cref="T:System.Type" /> da propriedade.</param>
        <param name="attributes">Os novos atributos para essa propriedade.</param>
        <summary>Cria e associa dinamicamente um descritor de propriedade para um tipo, usando o nome da propriedade especificado, o tipo e a matriz de atributos.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> que está associado ao tipo especificado e com os atributos de metadados especificado mesclados com os atributos de metadados existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssociation">
      <MemberSignature Language="C#" Value="public static object GetAssociation (Type type, object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAssociation(class System.Type type, object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="primary">O objeto principal da associação.</param>
        <summary>Retorna uma instância do tipo associado ao objeto principal especificado.</summary>
        <returns>Uma instância do tipo secundário que foi associado ao objeto principal se existir uma associação. Caso contrário, <paramref name="primary" /> se não for especificado existe associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma associação anterior foi feita o `type` parâmetro usando o <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método, então o <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> método retorna o objeto correto secundário chamar para o tipo solicitado. Caso contrário, <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> procura um designer compatível para `type` e retorna o designer, caso seja encontrado. Este método nunca retorna `null`.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não impede que o objeto primário ou secundário que está sendo finalizado e recuperada pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual você deseja obter atributos.</param>
        <summary>Retorna a coleção de atributos para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.AttributeCollection" /> que contém os atributos do componente. Se <paramref name="component" /> for <see langword="null" />, esse método retornará uma coleção vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os atributos retornados pelo <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> método pode ser modificado dinamicamente de fonte do componente original listando por provedores de extensor (<xref:System.ComponentModel.IExtenderProvider>), serviços de filtro (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) e filtros de atributo.  
  
 Quando você define um atributo personalizado com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, você deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade para torná-lo exclusivo. Se todas as instâncias do seu atributo forem exclusivas, substituir <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para retornar a identidade do objeto do seu atributo. Se apenas algumas instâncias do seu atributo são exclusivas, retornar um valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que retornaria igualdade nesses casos. Por exemplo, alguns atributos tem um parâmetro de construtor que atua como uma chave exclusiva. Para esses atributos, retornar o valor do parâmetro de construtor do <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  A implementação padrão de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retorna a identidade de tipo independentemente do valor de <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriedade. Para retornar várias instâncias de um <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> de atributo do <xref:System.ComponentModel.AttributeCollection>, o atributo deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 Para obter um exemplo desse método, consulte o <xref:System.ComponentModel.AttributeCollection.Matches%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna uma coleção de atributos para o tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.AttributeCollection" /> com os atributos do tipo de componente. Se o componente for <see langword="null" />, esse método retornará uma coleção vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Para atributos com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, a coleção de atributos remove instâncias duplicadas. Essas são as instâncias em que o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade retorna valores iguais.  
  
 Quando você define um atributo personalizado com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, você deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade para torná-lo exclusivo. Se todas as instâncias do seu atributo forem exclusivas, substituir <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para retornar a identidade do objeto do seu atributo. Se apenas algumas instâncias do seu atributo são exclusivas, retornar um valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que retornaria igualdade nesses casos. Por exemplo, alguns atributos tem um parâmetro de construtor que atua como uma chave exclusiva. Para esses atributos, retornar o valor do parâmetro de construtor do <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  A implementação padrão de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retorna a identidade de tipo independentemente do valor de <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriedade. Para retornar várias instâncias de um <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> de atributo do <xref:System.ComponentModel.AttributeCollection>, o atributo deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual você deseja obter atributos.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" />Para usar um conjunto de linha de base de atributos do descritor de tipo personalizado se <c>componente</c> é do tipo <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />; caso contrário, <see langword="false" />.</param>
        <summary>Retorna uma coleção de atributos para o componente especificado e um valor booleano que indica que um descritor de tipo personalizado foi criado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.AttributeCollection" /> com os atributos para o componente. Se o componente for <see langword="null" />, esse método retornará uma coleção vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os atributos retornados pelo <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> método pode ser modificado dinamicamente do original componentes listando por provedores de extensor (<xref:System.ComponentModel.IExtenderProvider>), serviços de filtro (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) e filtros de atributo.  
  
 Quando você define um atributo personalizado com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, você deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade para torná-lo exclusivo. Se todas as instâncias do seu atributo forem exclusivas, substituir <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para retornar a identidade do objeto do seu atributo. Se apenas algumas instâncias do seu atributo são exclusivas, retornar um valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que retornaria igualdade nesses casos. Por exemplo, alguns atributos tem um parâmetro de construtor que atua como uma chave exclusiva. Para esses atributos, retornar o valor do parâmetro de construtor do <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  A implementação padrão de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retorna a identidade de tipo independentemente do valor de <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriedade. Para retornar várias instâncias de um <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> de atributo do <xref:System.ComponentModel.AttributeCollection>, o atributo deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <summary>Retorna o nome da classe para o componente especificado usando o descritor de tipo padrão.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o nome da classe para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método retorna o total <xref:System.Type> nome para o `component` tipo de parâmetro. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button". Se `component` implementa <xref:System.ComponentModel.ICustomTypeDescriptor>, ele pode retornar um nome alternativo.  
  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetClassName%28System.Object%2CSystem.Boolean%29> método com um segundo parâmetro do `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna o nome da classe para o tipo especificado.</summary>
        <returns>Uma <see cref="T:System.String" /> que contém o nome da classe para o tipo de componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o descritor de tipo personalizado em cache para o tipo especificado para descobrir o nome da classe associada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna o nome da classe para o componente especificado usando um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o nome da classe para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método retorna o total <xref:System.Type> nome para o `component` tipo de parâmetro. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button". Se o `component` parâmetro implementa <xref:System.ComponentModel.ICustomTypeDescriptor>, ele pode retornar um nome alternativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <summary>Retorna o nome do componente especificado usando o descritor de tipo padrão.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o nome do componente especificado, ou <see langword="null" /> se não houver nenhum nome de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método retorna o nome para o site do componente, se houver. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button".  
  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetComponentName%28System.Object%2CSystem.Boolean%29> método com um segundo parâmetro do `false`.  
  
 Esse método é usado em tempo de design para recuperar o nome de uma instância de um componente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna o nome do componente especificado usando um descritor de tipo personalizado.</summary>
        <returns>O nome da classe para o componente especificado, ou <see langword="null" /> se não houver nenhum nome de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado em tempo de design para recuperar o nome de uma instância de um componente. Normalmente, esse método retorna o nome para o site do componente, se houver. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button". Se o componente implementa o <xref:System.ComponentModel.ICustomTypeDescriptor> interface, ele pode retornar um nome alternativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter o conversor.</param>
        <summary>Retorna um conversor de tipo para o tipo do componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeConverter" /> para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método localiza um conversor de tipo apropriado, procurando um <xref:System.ComponentModel.TypeConverterAttribute>. Se ele não encontrar um <xref:System.ComponentModel.TypeConverterAttribute>, ele percorre a hierarquia de classe base da classe até encontrar um tipo primitivo.  
  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetConverter%2A> método com um segundo parâmetro do `false`.  
  
   
  
## Examples  
 Para obter um exemplo de como usar esse método, consulte o <xref:System.ComponentModel.TypeConverter> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna um conversor de tipo para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeConverter" /> para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Esse método procura o conversor de tipo apropriado, procurando um <xref:System.ComponentModel.TypeConverterAttribute>. Se ele não encontrar um <xref:System.ComponentModel.TypeConverterAttribute>, ele percorre a hierarquia de classe base da classe até encontrar um tipo primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter o conversor.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna um conversor de tipo para o tipo do componente especificado com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeConverter" /> para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método procura o conversor de tipo apropriado ao tentar localizar um <xref:System.ComponentModel.TypeConverterAttribute>. Se ele não encontrar um <xref:System.ComponentModel.TypeConverterAttribute>, ele percorre a hierarquia de classe base da classe até encontrar um tipo primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O componente para obter o evento.</param>
        <summary>Retorna o evento padrão para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> com o evento padrão, ou <see langword="null" /> se não houver nenhum evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetDefaultEvent%28System.Object%2CSystem.Boolean%29> método com um segundo parâmetro do `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna o evento padrão para o tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> com o evento padrão, ou <see langword="null" /> se não houver nenhum evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para obter o evento.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna o evento padrão de um componente com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> com o evento padrão, ou <see langword="null" /> se não houver nenhum evento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O componente para obter a propriedade padrão.</param>
        <summary>Retorna a propriedade padrão para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> com a propriedade padrão, ou <see langword="null" /> se não houver nenhuma propriedade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `component` parâmetro é `null`, esse método retornará `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Um <see cref="T:System.Type" /> que representa a classe para obter a propriedade.</param>
        <summary>Retorna a propriedade padrão para o tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> com a propriedade padrão, ou <see langword="null" /> se não houver nenhuma propriedade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Se o `componentType` parâmetro é `null`, esse método retornará `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para obter a propriedade padrão.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a propriedade padrão para o componente especificado com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> com a propriedade padrão, ou <see langword="null" /> se não houver nenhuma propriedade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `component` parâmetro é `null`, esse método retornará `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">O componente para obter o editor.</param>
        <param name="editorBaseType">Um <see cref="T:System.Type" /> que representa o tipo base do editor que você deseja localizar.</param>
        <summary>Obtém um editor com o tipo base especificado para o componente especificado.</summary>
        <returns>Uma instância do editor que pode ser convertido para o tipo de editor especificado, ou <see langword="null" /> se nenhum editor do tipo solicitado pode ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de `editorBaseType` é geralmente <xref:System.Drawing.Design.UITypeEditor>, mas você também pode usar outros tipos (por exemplo, <xref:System.ComponentModel.ComponentEditor> e <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Você pode definir vários editores para uma propriedade. Você pode usar esse método para selecionar o editor que você deseja usar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> ou <paramref name="editorBaseType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (Type type, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(class System.Type type, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="editorBaseType">Um <see cref="T:System.Type" /> que representa o tipo base do editor que você está tentando localizar.</param>
        <summary>Retorna um editor com o tipo base especificado para o tipo especificado.</summary>
        <returns>Uma instância do objeto editor que pode ser convertido para o tipo de base fornecido, ou <see langword="null" /> se nenhum editor do tipo solicitado pode ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de `editorBaseType` é geralmente <xref:System.Drawing.Design.UITypeEditor>, mas você também pode usar outros tipos (por exemplo <xref:System.ComponentModel.ComponentEditor> e <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Você pode definir vários editores de um tipo. Você pode usar esse método para selecionar o que você deseja usar.  
  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="editorBaseType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para obter o editor.</param>
        <param name="editorBaseType">Um <see cref="T:System.Type" /> que representa o tipo base do editor que você deseja localizar.</param>
        <param name="noCustomTypeDesc">Um sinalizador que indica se as informações de descrição de tipo personalizado devem ser consideradas.</param>
        <summary>Retorna um editor com o tipo base especificado e com um descritor de tipo personalizado para o componente especificado.</summary>
        <returns>Uma instância do editor que pode ser convertido para o tipo de editor especificado, ou <see langword="null" /> se nenhum editor do tipo solicitado pode ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de `editorBaseType` é geralmente <xref:System.Drawing.Design.UITypeEditor>, mas você também pode usar outros tipos (por exemplo <xref:System.ComponentModel.ComponentEditor> e <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Você pode definir vários editores para uma propriedade. Você pode usar esse método para selecionar o editor que você deseja usar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> ou <paramref name="editorBaseType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para obter os eventos.</param>
        <summary>Retorna a coleção de eventos para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupera uma coleção de eventos que o determinado `component` parâmetro instância fornece. Essa coleção pode ser diferente do conjunto de eventos que fornece a classe. Se o `component` parâmetro é localizado, o site pode adicionar ou remover eventos adicionais.  
  
 Se `component` é `null`, em seguida, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 Para obter um exemplo desse método, consulte o <xref:System.ComponentModel.EventDescriptorCollection.Count%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna a coleção de eventos para um tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para obter os eventos.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> que você pode usar como um filtro.</param>
        <summary>Retorna a coleção de eventos para um componente especificado usando uma matriz de atributos especificada como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os eventos para o `component` parâmetro pode ser diferente dos eventos de uma classe, porque o site pode adicionar ou remover eventos, se o `component` parâmetro é localizado.  
  
 O `attributes` matriz pode ter uma mistura de <xref:System.Type> e <xref:System.Attribute> objetos. A filtragem é definida pelas seguintes regras:  
  
-   Um <xref:System.Type> é tratado como um curinga; ele corresponde a qualquer evento que tem o <xref:System.Type> em seu conjunto de atributos.  
  
-   Se um evento não tem um <xref:System.Attribute> da mesma classe, o evento não está incluído na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, o evento deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é o evento padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> no evento.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para obter os eventos.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de eventos para um componente especificado com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna uma coleção de eventos que o determinado `component` parâmetro instância fornece. Isso pode ser diferente do conjunto de eventos que fornece a classe. Se o `component` parâmetro é localizado, o site pode adicionar ou remover eventos adicionais.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> que você pode usar como um filtro.</param>
        <summary>Retorna a coleção de eventos para um tipo de componente usando uma matriz de atributos especificada como um filtro especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 O `attributes` matriz de parâmetro pode ter uma mistura de <xref:System.Type> e <xref:System.Attribute> objetos. A filtragem é definida pelas seguintes regras:  
  
-   Um <xref:System.Type> é tratado como um curinga; ele corresponde a qualquer evento que tem o <xref:System.Type> em seu conjunto de atributos.  
  
-   Se um evento não tem um <xref:System.Attribute> da mesma classe, o evento não está incluído na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, o evento deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é o evento padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> no evento.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[],System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para obter os eventos.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de eventos para um componente especificado usando uma matriz de atributos especificada como um filtro e um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os eventos para o `component` parâmetro pode ser diferente dos eventos de uma classe, porque o site pode adicionar ou remover eventos, se o `component` parâmetro é localizado.  
  
 O `attributes` matriz de parâmetro pode ter uma mistura de <xref:System.Type> e <xref:System.Attribute> objetos. A filtragem é definida pelas seguintes regras:  
  
-   Um <xref:System.Type> é tratado como um curinga; ele corresponde a qualquer evento que tem o <xref:System.Type> em seu conjunto de atributos.  
  
-   Se um evento não tem um <xref:System.Attribute> da mesma classe, o evento não está incluído na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, o evento deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é o evento padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> no evento.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public static string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.ComponentModel.Component" /> para localizar o nome.</param>
        <summary>Retorna o nome totalmente qualificado do componente.</summary>
        <returns>O nome totalmente qualificado do componente especificado, ou <see langword="null" /> se o componente não tem nome.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em muitos casos, o <xref:System.ComponentModel.TypeDescriptor.GetFullComponentName%2A> método retornará o mesmo valor que o <xref:System.ComponentModel.TypeDescriptor.GetComponentName%2A> método. No entanto, se o componente reside em um contêiner aninhado ou se tiver outras semânticas aninhadas, poderá retornar um nome totalmente qualificado diferente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <summary>Retorna a coleção de propriedades de um componente especificado.</summary>
        <returns>Uma <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades do componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades de um componente podem ser diferente das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o componente está localizado.  
  
 Se o `component` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para acessar as propriedades de um controle. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.Design.ComponentDesigner> classe.  
  
 [!code-csharp[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/CS/Form1.cs#8)]
 [!code-vb[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Um <see cref="T:System.Type" /> que representa o componente para o qual obter as propriedades.</param>
        <summary>Retorna a coleção de propriedades de um tipo de componente especificado.</summary>
        <returns>Uma <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades de um tipo de componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <summary>Retorna a coleção de propriedades de um componente especificado usando uma matriz de atributos especificada como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades que correspondem aos atributos especificados para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades para o `component` parâmetro pode ser diferentes das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o `component` parâmetro é localizado.  
  
 O `attributes` matriz de parâmetros é usada para filtrar a matriz. A filtragem é definida pelas seguintes regras:  
  
-   Se uma propriedade não tem um <xref:System.Attribute> da mesma classe, a propriedade não está incluída na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, a propriedade deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é a propriedade padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> na propriedade.  
  
-   Se `attributes` tem um atributo padrão, o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método corresponde o caso quando a propriedade não tem o atributo aplicado.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como implementar o <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Windows.Forms.Design.PropertyTab> classe.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" />não considere informações de descrição de tipo personalizado; Caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de propriedades de um componente especificado usando o descritor de tipo padrão.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades de um componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades para o `component` parâmetro pode ser diferentes das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o `component` parâmetro é localizado.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type,System.Attribute[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <summary>Retorna a coleção de propriedades de um tipo de componente especificado usando uma matriz especificada de atributos como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades que correspondem aos atributos especificados para esse tipo de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 O `attributes` matriz de parâmetros é usada para filtrar a matriz. A filtragem é definida pelas seguintes regras:  
  
-   Se uma propriedade não tem um <xref:System.Attribute> da mesma classe, a propriedade não está incluída na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, a propriedade deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é a propriedade padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> na propriedade.  
  
-   Se `attributes` tem um atributo padrão, o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método corresponde o caso quando a propriedade não tem o atributo aplicado.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como implementar o <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Windows.Forms.Design.PropertyTab> classe.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[],System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de propriedades de um componente especificado usando uma matriz de atributos especificada como um filtro e um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades de um `component` podem diferir das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o `component` está localizado.  
  
 O `attributes` matriz de parâmetros é usada para filtrar a matriz. A filtragem é definida pelas seguintes regras:  
  
-   Se uma propriedade não tem um <xref:System.Attribute> da mesma classe, a propriedade não está incluída na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, a propriedade deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é a propriedade padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> na propriedade.  
  
-   Se `attributes` tem um atributo padrão, o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método corresponde o caso quando a propriedade não tem o atributo aplicado.  
  
 Se o `component` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Retorna o provedor de descrição de tipo para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associado ao componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> método sempre retornará um provedor de descrição de tipo. Até mesmo o padrão <xref:System.ComponentModel.TypeDescriptor> implementação é criada em um <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna o provedor de descrição de tipo para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associado ao tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> método sempre retornará um provedor de descrição de tipo. Até mesmo o padrão <xref:System.ComponentModel.TypeDescriptor> implementação é criada em um <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Retorna um <see cref="T:System.Type" /> que pode ser usado para executar a reflexão, considerando um objeto.</summary>
        <returns>Um <see cref="T:System.Type" /> para o objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> método é uma versão de nível baixo do <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A>normalmente é usado para executar a reflexão padrão em um objeto quando nenhum descritor de tipo personalizado pode ser localizado para ele.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna um <see cref="T:System.Type" /> que pode ser usado para executar a reflexão, recebe um tipo de classe.</summary>
        <returns>Um <see cref="T:System.Type" /> da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> método é uma versão de nível baixo do <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A>normalmente é usado para executar reflexão padrão em uma classe quando nenhum descritor de tipo personalizado pode ser localizado para ele.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InterfaceType">
      <MemberSignature Language="C#" Value="public static Type InterfaceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type InterfaceType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um tipo que representa um provedor de descrição de tipo para todos os tipos de interface.</summary>
        <value>Um <see cref="T:System.Type" /> que representa um provedor de descrição de tipo personalizado para todos os tipos de interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.InterfaceType%2A> propriedade obtém um <xref:System.Type> objeto que você pode passar para o <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> métodos para definir um provedor de descrição de tipo para tipos de interface.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual as propriedades ou eventos foram alterados.</param>
        <summary>Limpa as propriedades e eventos para o componente especificado do cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles devem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente em tempo de design. Ele não é usado durante o tempo de execução.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ao alteram as propriedades ou eventos de um componente. Esse evento é gerado apenas se não houver uma chamada anterior para o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> ou <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> método que as informações armazenadas em cache.  
  
   
  
## Examples  
 Para obter um exemplo de como usar esse método, consulte o <xref:System.ComponentModel.RefreshEventHandler> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">O <see cref="T:System.Reflection.Assembly" /> que representa o assembly para atualizar. Cada <see cref="T:System.Type" /> neste assembly serão atualizados.</param>
        <summary>Limpa as propriedades e eventos para o assembly especificado do cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles podem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente em tempo de design. Ele não é usado durante o tempo de execução.  
  
 Antes de fazer uma chamada para o <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método para limpar o cache, você precisa chamar o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para o assembly específico para armazenar em cache as informações primeiro.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos para notificar a todas as classes que deseja ser notificado quando a propriedade de conjunto de alterações de um componente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Module module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Module module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="module">O <see cref="T:System.Reflection.Module" /> que representa o módulo para atualizar. Cada <see cref="T:System.Type" /> neste módulo, serão atualizados.</param>
        <summary>Limpa as propriedades e eventos para o módulo especificado do cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles podem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente em tempo de design. Ele não é usado durante o tempo de execução.  
  
 Antes de fazer uma chamada para o <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método para limpar o cache, você precisa chamar o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para o módulo específico ao armazenar em cache as informações primeiro.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos para notificar a todas as classes que deseja ser notificado quando a propriedade de conjunto de alterações de um componente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Limpa as propriedades e eventos para o tipo de componente do cache especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles podem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente em tempo de design. Ele não é usado durante o tempo de execução.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ao alteram as propriedades ou eventos de um componente. Esse evento é gerado apenas se não houver uma chamada anterior para o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> ou <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> método que as informações armazenadas em cache.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refreshed">
      <MemberSignature Language="C#" Value="public static event System.ComponentModel.RefreshEventHandler Refreshed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RefreshEventHandler Refreshed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RefreshEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o cache para um componente é limpo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 Para obter um exemplo de como usar esse evento, consulte o <xref:System.ComponentModel.RefreshEventHandler> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociation">
      <MemberSignature Language="C#" Value="public static void RemoveAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">O principal <see cref="T:System.Object" />.</param>
        <param name="secondary">O secundário <see cref="T:System.Object" />.</param>
        <summary>Remove uma associação entre dois objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.RemoveAssociation%2A> método Remove uma associação entre dois objetos formado pelo <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não influencia quando o objeto é finalizado ou recuperado pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociations">
      <MemberSignature Language="C#" Value="public static void RemoveAssociations (object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociations(object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociations(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">O principal <see cref="T:System.Object" /> em uma associação.</param>
        <summary>Remove todas as associações de um objeto principal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.RemoveAssociations%2A> método Remove todas as associações entre um objeto principal e todos os seus objetos secundários, criados por chamadas para o <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não influencia quando primário dos objetos secundários são finalizadas ou recuperada pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="primary" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente que está associado ao objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o objeto associado.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente que está associado com o tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o tipo associado.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente que está associado ao objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o objeto associado.  
  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode registrar um provedor para a instância especificada se seu tipo também é parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define o <paramref name="instance" /> tipo do parâmetro.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente que está associado com o tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o tipo associado.  
  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode cancelar o registro de um provedor para o tipo especificado se também for parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptorArray">
      <MemberSignature Language="C#" Value="public static void SortDescriptorArray (System.Collections.IList infos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SortDescriptorArray(class System.Collections.IList infos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.SortDescriptorArray(System.Collections.IList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="infos" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="infos">Um <see cref="T:System.Collections.IList" /> que contém os descritores de classificação.</param>
        <summary>Descritores de classificações usando o nome do descritor.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="infos" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
