<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece a classe base da qual são derivadas as classes que representam nós de árvore de expressão. Também contém métodos de fábrica <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para criar os diferentes tipos de nós. Esta é uma classe <see langword="abstract" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão de bloco. A expressão de bloco consiste em dois <xref:System.Linq.Expressions.MethodCallExpression> objetos e um <xref:System.Linq.Expressions.ConstantExpression> objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> para definir como tipo de nó.</param>
        <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> desse <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado a partir de construtores em classes derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">O visitante com o qual visitar esse nó.</param>
        <summary>Expede o método específico de visita para esse tipo de nó. Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
        <returns>O resultado de visitar esse nó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementação padrão para <xref:System.Linq.Expressions.ExpressionType.Extension> chamadas nós <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>. Substitua este método para chamar um método mais específico em uma classe derivada de visitante do <xref:System.Linq.Expressions.ExpressionVisitor> classe. No entanto, ele ainda deve suportar visitantes desconhecidos chamando <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de adição predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de adição predefinidos.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que adiciona dois números inteiros.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de adição predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de adição predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de adição não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que adiciona um valor a uma variável de inteiro e, em seguida, atribui o resultado da operação para a variável.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de adição aritmética com a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de adição predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de adição predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de adição aritmética com a verificação de estouro. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 O método de implementação para a operação é escolhido com base nas seguintes regras:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de adição predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de adição predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de adição não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiro ou boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado de predefinida bit a bit `AND` operador.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo anulável correspondente para o tipo de resultado de predefinida bit a bit `AND` operador.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa uma operação AND lógica em dois valores Boolean.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 O método de implementação para a operação é escolhido com base nas seguintes regras:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiro ou boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado de predefinida bit a bit `AND` operador.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo anulável correspondente para o tipo de resultado de predefinida bit a bit `AND` operador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
    > [!NOTE]
    >  A condicional `AND` operador não pode ser sobrecarregado em c# ou [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. No entanto, a condicional `AND` operador é avaliado usando o bit a bit `AND` operador. Portanto, uma sobrecarga definido pelo usuário de bit a bit `AND` operador pode ser o método de implementação para esse tipo de nó.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   `left`. Tipo e `right`. Tipo são do mesmo tipo booliano.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó não é eliminado. O tipo do nó é o tipo de resultado da condicional predefinido `AND` operador.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado da condicional predefinido `AND` operador.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que executa uma operação lógica e operação em suas que somente dois operandos o primeiro operando é avaliada como `true`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
 -ou-  
  
 <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é resolvido para verdadeiro. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 O método de implementação para a operação é escolhido com base nas seguintes regras:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
    > [!NOTE]
    >  A condicional `AND` operador não pode ser sobrecarregado em c# ou [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. No entanto, a condicional `AND` operador é avaliado usando o bit a bit `AND` operador. Portanto, uma sobrecarga definido pelo usuário de bit a bit `AND` operador pode ser o método de implementação para esse tipo de nó.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   `left`. Tipo e `right`. Tipo são do mesmo tipo booliano.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó não é eliminado. O tipo do nó é o tipo de resultado da condicional predefinido `AND` operador.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado da condicional predefinido `AND` operador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
 -ou-  
  
 <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Uma expressão que representa a matriz multidimensional.</param>
        <param name="indexes">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém as expressões usadas para a matriz de índice.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz multidimensional.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A expressão que representa a matriz pode ser obtida usando o <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, ou por meio <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como alterar o valor de um elemento em uma matriz multidimensional usando o `ArrayAccess` método.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Uma expressão que representa a matriz a ser indexada.</param>
        <param name="indexes">Uma matriz que contém as expressões usadas para indexar a matriz.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A expressão que representa a matriz pode ser obtida usando o <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, ou por meio <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
 Para matrizes multidimensionais, use o <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como alterar um valor de um elemento de matriz usando o `ArrayAccess` método.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a ele.</param>
        <param name="indexes">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz para uma matriz de classificação mais de um.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de `indexes` deve ter <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `array` deve representar um tipo de matriz cuja posição corresponde ao número de elementos no `indexes`.  
  
 Se a classificação de `array`. Tipo é 1, esse método retorna um <xref:System.Linq.Expressions.BinaryExpression>. O <xref:System.Linq.Expressions.BinaryExpression.Left%2A> está definida como `array` e <xref:System.Linq.Expressions.BinaryExpression.Right%2A> propriedade é definida como o único elemento de `indexes`. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade o <xref:System.Linq.Expressions.BinaryExpression> representa o tipo de elemento de `array`. Tipo.  
  
 Se a classificação de `array`. Tipo é a mais de um, este método retorna um <xref:System.Linq.Expressions.MethodCallExpression>. O <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> está definida como o <xref:System.Reflection.MethodInfo> que descreve o método de instância pública `Get` no tipo representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MethodCallExpression> que representa a indexação em uma matriz bidimensional.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type não representa um tipo de matriz.  
  
 -ou-  
  
 A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.  
  
 - ou -  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="index">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a aplicação de um operador de índice de matriz para uma matriz de classificação de um.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`deve representar um índice de tipo <xref:System.Int32>.  
  
 O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.BinaryExpression> é `null`e ambos <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de elemento do `array`. Tipo. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ou <paramref name="index" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type não representa um tipo de matriz.  
  
 -ou-  
  
 <paramref name="array" />. Tipo representa um tipo de matriz cuja classificação não é 1.  
  
 -ou-  
  
 <paramref name="index" />. Tipo não representam o <see cref="T:System.Int32" /> tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Uma matriz de instâncias <see cref="T:System.Linq.Expressions.Expression" />/índices para a operação de índice da matriz.</param>
        <param name="indexes">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz multidimensional.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de `indexes` deve ter <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `array` deve representar um tipo de matriz cuja posição corresponde ao número de elementos no `indexes`.  
  
 Se a classificação de `array`. Tipo é 1, esse método retorna um <xref:System.Linq.Expressions.BinaryExpression>. O <xref:System.Linq.Expressions.BinaryExpression.Left%2A> está definida como `array` e <xref:System.Linq.Expressions.BinaryExpression.Right%2A> propriedade é definida como o único elemento de `indexes`. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade o <xref:System.Linq.Expressions.BinaryExpression> representa o tipo de elemento de `array`. Tipo.  
  
 Se a classificação de `array`. Tipo é a mais de um, este método retorna um <xref:System.Linq.Expressions.MethodCallExpression>. O <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> está definida como o <xref:System.Reflection.MethodInfo> que descreve o método de instância pública `Get` no tipo representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MethodCallExpression> que representa a indexação em uma matriz bidimensional.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type não representa um tipo de matriz.  
  
 -ou-  
  
 A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.  
  
 - ou -  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão para obter o comprimento de uma matriz unidimensional.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual da propriedade <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `array` deve representar um tipo de matriz.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é igual a <xref:System.Int32>. O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> é de propriedade `null`e ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> são definidos como `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />.Type não representa um tipo de matriz.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Assign` expressão copia um valor para tipos de valor e, em seguida, copia uma referência para tipos de referência.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que represente uma operação de atribuição.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">Um <see cref="T:System.Reflection.MemberInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual a ele.</param>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um campo ou propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `expression` deve ser atribuível ao tipo representado pelo <xref:System.Reflection.FieldInfo.FieldType%2A> ou <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade de `member`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ou <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> não representa um campo ou propriedade.  
  
 -ou-  
  
 A propriedade representada por <paramref name="member" /> não tem um acessador <see langword="set" />.  
  
 -ou-  
  
 <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro, usando um método de acessador de propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem o <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> propriedade igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />e o <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> propriedade definida como <paramref name="expression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `expression` deve ser atribuível ao tipo representado pelo <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade da propriedade acessada em `propertyAccessor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ou <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" />não representa um método de acessador de propriedade.  
  
 -ou-  
  
 A propriedade acessada por <paramref name="propertyAccessor" /> não tem um <see langword="set" /> acessador.  
  
 -ou-  
  
 <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão de bloco. A expressão de bloco consiste em dois <xref:System.Linq.Expressions.MethodCallExpression> objetos e um <xref:System.Linq.Expressions.ConstantExpression> objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">As variáveis no bloco.</param>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como passar um parâmetro para uma expressão de bloco e processar esse parâmetro em um bloco.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">As variáveis no bloco.</param>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">A primeira expressão no bloco.</param>
        <param name="arg1">A segunda expressão no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém duas expressões e não tem variáveis.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado do bloco.</param>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas, não tem variáveis e tem o tipo de resultado específico.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado do bloco.</param>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas, não tem variáveis e tem o tipo de resultado específico.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">A primeira expressão no bloco.</param>
        <param name="arg1">A segunda expressão no bloco.</param>
        <param name="arg2">A terceira expressão no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém três expressões e não tem variáveis.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado do bloco.</param>
        <param name="variables">As variáveis no bloco.</param>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado do bloco.</param>
        <param name="variables">As variáveis no bloco.</param>
        <param name="expressions">As expressões no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">A primeira expressão no bloco.</param>
        <param name="arg1">A segunda expressão no bloco.</param>
        <param name="arg2">A terceira expressão no bloco.</param>
        <param name="arg3">A quarta expressão no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém quatro expressões e não tem variáveis.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">A primeira expressão no bloco.</param>
        <param name="arg1">A segunda expressão no bloco.</param>
        <param name="arg2">A terceira expressão no bloco.</param>
        <param name="arg3">A quarta expressão no bloco.</param>
        <param name="arg4">A expressão quinto no bloco.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém cinco expressões e não tem variáveis.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a expressão de bloco é executado, ele retorna o valor da última expressão no bloco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a quebra, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que contém uma <xref:System.Linq.Expressions.LoopExpression> objeto que usa o <xref:System.Linq.Expressions.Expression.Break%2A> método.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break. O valor passado para o rótulo no salto pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a quebra, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a quebra, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />e o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a quebra, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />, e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que não aceita argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar este método.  
  
 Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.  
  
 O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> está vazio. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de retorno do método representado por `method`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que chama um método sem argumentos.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
        <param name="arguments">Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos de chamada.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático (compartilhado no Visual Basic).</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que aceita um argumento.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que chama uma `static` (`Shared` no Visual Basic) método que usa um argumento.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) igual ao qual definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que tem argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `arguments` não é `null`, ele deve ter o mesmo número de elementos como o número de parâmetros para o método representado pela `method`. Cada elemento na `arguments` não deve ser `null` e deve ser atribuível para o parâmetro correspondente de `method`, possivelmente após *citando*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
 O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`. Caso contrário, ele contém os mesmos elementos `arguments`, algumas das quais podem ser colocado entre aspas.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`. A propriedade <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> é `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
 -ou-  
  
 Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a (passar <see langword="null" /> para um método <see langword="static" /> [<see langword="Shared" /> no Visual Basic]).</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro quando você chamar esse método, ou chamar <xref:System.Linq.Expressions.Expression.Call%2A> em vez disso.  
  
 Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.  
  
 Se `arguments` não é `null`, ele deve ter o mesmo número de elementos como o número de parâmetros para o método representado pela `method`. Cada elemento na `arguments` não deve ser `null` e deve ser atribuível para o parâmetro correspondente de `method`, possivelmente após *citando*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
 O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`. Caso contrário, ele contém os mesmos elementos `arguments`, algumas das quais podem ser colocado entre aspas.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.  
  
 -ou-  
  
 O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
 -ou-  
  
 Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro quando você chamar esse método, ou chamar <xref:System.Linq.Expressions.Expression.Call%2A> em vez disso.  
  
 Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.  
  
 Se `arguments` não é `null`, ele deve ter o mesmo número de elementos como o número de parâmetros para o método representado pela `method`. Cada elemento na `arguments` não deve ser `null` e deve ser atribuível para o parâmetro correspondente de `method`, possivelmente após *citando*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
 O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`. Caso contrário, ele contém os mesmos elementos `arguments`, algumas das quais podem ser colocado entre aspas.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.  
  
 -ou-  
  
 <paramref name="arguments" /> não é <see langword="null" /> e um ou mais dos seus elementos é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.  
  
 -ou-  
  
 O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.  
  
 -ou-  
  
 Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita dois argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância. (passar nulo para um método estático [compartilhado no Visual Basic]).</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita dois argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que chama um método de instância que tem dois argumentos.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo valor da propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> será pesquisado quanto a um método específico.</param>
        <param name="methodName">O nome do método.</param>
        <param name="typeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico. Esse argumento deve ser nulo quando methodName especifica um método não genérico.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos para o método.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método chamando o método de fábrica apropriado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definido como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método de instância especificado e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definido como os argumentos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método indicado por `methodName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.  
  
 - ou -  
  
 Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
        <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que usa três argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> que especifica o tipo que contém o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic).</param>
        <param name="methodName">O nome do método.</param>
        <param name="typeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico. Esse argumento deve ser nulo quando methodName especifica um método não genérico.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos para o método.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) chamando o método de fábrica apropriado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definida como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic) e a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definida como os argumentos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método indicado por `methodName`. A propriedade <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> é `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.  
  
 -ou-  
  
 Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância. (passar nulo para um método estático [compartilhado no Visual Basic]).</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
        <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que usa três argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
        <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
        <param name="arg3">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que usa quatro argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</param>
        <param name="arg0">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</param>
        <param name="arg1">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</param>
        <param name="arg2">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</param>
        <param name="arg3">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</param>
        <param name="arg4">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quinto argumento.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que utiliza cinco argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que o nó pode ser reduzido a um nó mais simples. Se isso retornar verdadeiro, Reduce() poderá ser chamado para produzir a forma reduzida.</summary>
        <value>True se o nó puder ser reduzido; caso contrário, false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o <see cref="T:System.Exception" /> capturado por este manipulador de objeto.</param>
        <param name="body">O corpo da instrução catch.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com uma referência para o capturada <see cref="T:System.Exception" /> objeto para uso no corpo do manipulador.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> isso <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
        <param name="body">O corpo da instrução catch.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> de <xref:System.Exception> capturada pode ser especificada mas nenhuma referência para o <xref:System.Exception> objeto estará disponível para uso no <xref:System.Linq.Expressions.CatchBlock>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o <see cref="T:System.Exception" /> capturado por este manipulador de objeto.</param>
        <param name="body">O corpo da instrução catch.</param>
        <param name="filter">O corpo do <see cref="T:System.Exception" /> filtro.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um <see cref="T:System.Exception" /> filtro e uma referência para o capturada <see cref="T:System.Exception" /> objeto.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> isso <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
        <param name="body">O corpo da instrução catch.</param>
        <param name="filter">O corpo do <see cref="T:System.Exception" /> filtro.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um <see cref="T:System.Exception" /> filtro, mas nenhuma referência para o capturada <see cref="T:System.Exception" /> objeto.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpando um ponto de sequência.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.BinaryExpression> é `null` e <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de resultado da operação de união. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
#### <a name="result-type"></a>Tipo de resultado  
 As regras a seguir determinam o tipo de resultado:  
  
-   If `left`. Tipo representa um tipo anulável e `right`. O tipo é implicitamente conversível para o tipo não anulável correspondente, o tipo de resultado é o equivalente não anuláveis `left`. Tipo.  
  
-   Caso contrário, se `right`. O tipo é implicitamente conversível em `left`. O tipo, o tipo de resultado é `left`. Tipo.  
  
-   Caso contrário, se o equivalente não anuláveis `left`. O tipo é implicitamente conversível em `right`. O tipo, o tipo de resultado é `right`. Tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união, dada uma função de conversão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.BinaryExpression> é `null` e <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.BinaryExpression> é igual ao tipo de resultado da operação de união.  
  
 As regras a seguir determinam o tipo de resultado:  
  
-   If `left`. Tipo representa um tipo anulável e `right`. O tipo é implicitamente conversível para o tipo não anulável correspondente, o tipo de resultado é o equivalente não anuláveis `left`. Tipo.  
  
-   Caso contrário, se `right`. O tipo é implicitamente conversível em `left`. O tipo, o tipo de resultado é `left`. Tipo.  
  
-   Caso contrário, se o equivalente não anuláveis `left`. O tipo é implicitamente conversível em `right`. O tipo, o tipo de resultado é `right`. Tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.  
  
 -ou-  
  
 <paramref name="conversion" />is not <see langword="null" /> and <paramref name="conversion" />. Tipo é um tipo delegado que não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade <paramref name="left" /> representa um tipo que não é atribuível ao tipo de parâmetro do tipo delegado <paramref name="conversion" />. Tipo.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade <paramref name="right" /> não é igual ao tipo de retorno do tipo delegado <paramref name="conversion" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
        <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
        <param name="ifFalse">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ConditionalExpression> é igual de <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `ifTrue`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa uma instrução condicional. Se o primeiro argumento for avaliado como `true`, o segundo argumento é executado; caso contrário, o terceiro argumento é executado.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="test" />, <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="test" />.Type não é <see cref="T:System.Boolean" />.  
  
 -ou-  
  
 <paramref name="ifTrue" />.Type não é igual a <paramref name="ifFalse" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
        <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
        <param name="ifFalse">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
        <param name="type">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite unificar explicitamente o tipo de resultado da expressão condicional em casos em que os tipos de `ifTrue` e `ifFalse` expressões não são iguais. Tipos de ambos `ifTrue` e `ifFalse` deve ser implicitamente referência pode ser atribuído para o tipo de resultado. O `type` tem permissão para ser <xref:System.Void>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ConstantExpression> é igual ao tipo de `value`. Se `value` é `null`, <xref:System.Linq.Expressions.Expression.Type%2A> é igual a <xref:System.Object>.  
  
 Para representar `null`, você também pode usar o <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> método, com a qual você pode especificar explicitamente o tipo.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa um valor constante.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser útil para representar valores de tipos anuláveis.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa uma constante do tipo anulável e defina seu valor como `null`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> não é <see langword="null" /> e <paramref name="type" /> não pode ser atribuído do tipo dinâmico de <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a continuar, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão de loop que usa o <xref:System.Linq.Expressions.Expression.Continue%2A> método.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue com o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a continuar, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`. Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`. Caso contrário, será `false`.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário:  
  
    -   Se ambos os `expression`. Tipo e `type` representar tipos numéricos ou booleanos ou tipos de enumeração anulável ou não nulo, o método de implementação é `null`.  
  
    -   Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão explícita, desconversão ou existe conversão de referência do `expression`. Digite a `type`, a implementação de método é `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método implementação é atribuível ao `type`, o nó não é eliminado.  
  
-   Se uma ou ambas as de `expression`. Tipo ou `type` é um tipo de valor anuláveis e os tipos de valor não nulo correspondentes são iguais para o tipo de argumento e o tipo de retorno do método implementação respectivamente, o nó é eliminado.  
  
 Se o método de implementação é `null`:  
  
-   Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é eliminado.  
  
-   Caso contrário, o nó é eliminado.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que represente uma operação de conversão de tipo.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão para a qual o método de implementação é especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`. Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`. Caso contrário, será `false`.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o método não é `null`, é o método de implementação. Ele deve representar um não-nulo, `static` (`Shared` no Visual Basic) método que usa um argumento.  
  
-   Caso contrário, se `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário:  
  
    -   Se ambos os `expression`. Tipo e `type` representar tipos numéricos ou booleanos ou tipos de enumeração anulável ou não nulo, o método de implementação é `null`.  
  
    -   Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão explícita, desconversão ou existe conversão de referência do `expression`. Digite a `type`, a implementação de método é `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método implementação é atribuível ao `type`, o nó não é eliminado.  
  
-   Se uma ou ambas as de `expression`. Tipo ou `type` são um tipo de valor anuláveis e os tipos de valor não nulo correspondentes são iguais para o tipo de argumento e o tipo de retorno do método implementação respectivamente, o nó é eliminado.  
  
 Se o método de implementação é `null`:  
  
-   Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é eliminado.  
  
-   Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.  
  
 -ou-  
  
 <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.  
  
 -ou-  
  
 O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.  
  
 - ou -  
  
 <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção é estourou o tipo de destino.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`. Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`. Caso contrário, será `false`.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário:  
  
    -   Se ambos os `expression`. Tipo e `type` representar tipos numéricos ou booleanos ou tipos de enumeração anulável ou não nulo, o método de implementação é `null`.  
  
    -   Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão explícita, desconversão ou existe conversão de referência do `expression`. Digite a `type`, a implementação de método é `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método implementação é atribuível ao `type`, o nó não é eliminado.  
  
-   Se uma ou ambas as de `expression`. Tipo ou `type` são um tipo de valor anuláveis e os tipos de valor não nulo correspondentes são iguais para o tipo de argumento e o tipo de retorno do método implementação respectivamente, o nó é eliminado.  
  
 Se o método de implementação é `null`:  
  
-   Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é eliminado.  
  
-   Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino é estourou e para que o método de implementação é especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`. Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`. Caso contrário, será `false`.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o método não é `null`, é o método de implementação. Ele deve representar um não-nulo, `static` (`Shared` no Visual Basic) método que usa um argumento.  
  
-   Caso contrário, se `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário:  
  
    -   Se ambos os `expression`. Tipo e `type` representar tipos numéricos ou booleanos ou tipos de enumeração anulável ou não nulo, o método de implementação é `null`.  
  
    -   Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão explícita, desconversão ou existe conversão de referência do `expression`. Digite a `type`, a implementação de método é `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método implementação é atribuível ao `type`, o nó não é eliminado.  
  
-   Se uma ou ambas as de `expression`. Tipo ou `type` são um tipo de valor anuláveis e os tipos de valor não nulo correspondentes são iguais para o tipo de argumento e o tipo de retorno do método implementação respectivamente, o nó é eliminado.  
  
 Se o método de implementação é `null`:  
  
-   Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é eliminado.  
  
-   Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.  
  
 -ou-  
  
 <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.  
  
 -ou-  
  
 O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.  
  
 - ou -  
  
 <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</param>
        <param name="startLine">A linha de início deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior que 0.</param>
        <param name="startColumn">A coluna de início deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior que 0.</param>
        <param name="endLine">A linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Deve ser maior ou igual a da linha de início.</param>
        <param name="endColumn">A coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Se a linha final é o mesmo que a linha de início, ele deve ser maior ou igual que a coluna de início. Em qualquer caso, deve ser maior que 0.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> com o alcance especificado.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a diminuição da expressão em 1.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão diminuída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa expressão é funcional e não altera o valor do objeto passado para ele.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que substracts 1 de um determinado valor.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a diminuição da expressão em 1.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão diminuída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa expressão é funcional e não altera o valor do objeto passado para ele.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa um valor padrão para um determinado tipo.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir o <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> propriedade.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir o <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> propriedade.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão aritmética.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de divisão, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de divisão predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de divisão predefinidos.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que divide divide seu primeiro argumento, o segundo argumento.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de divisão não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão aritmética. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de divisão, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de divisão predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de divisão predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de divisão não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de divisão que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de divisão que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de divisão que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
        <param name="arguments">Os argumentos para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos de argumentos e tipo de retorno especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos de argumentos e tipo de retorno especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
        <param name="arguments">Os argumentos para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos de argumentos e tipo de retorno especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <param name="arg1">O segundo argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos de argumentos e tipo de retorno especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <param name="arg1">O segundo argumento para a operação dinâmica.</param>
        <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos de argumentos e tipo de retorno especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="returnType">O tipo de resultado da expressão dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <param name="arg1">O segundo argumento para a operação dinâmica.</param>
        <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
        <param name="arg3">O quarto argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos de argumentos e tipo de retorno especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém <see cref="T:System.Linq.Expressions.Expression" /> objetos para definir o <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> igual da propriedade.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ElementInit" />, dado um <see cref="T:System.Collections.Generic.IEnumerable`1" /> como o segundo argumento.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem o <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `addMethod` parâmetro deve representar um método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas). O método add deve ter o mesmo número de parâmetros como o número de elementos em `arguments`. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento na `arguments` deve ser atribuível ao tipo do parâmetro correspondente do método add, possivelmente após *citando*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ElementInit> que representa a chamada a <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar um elemento de uma coleção de dicionário.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O método que <paramref name="addMethod" /> representa não é chamado de "Adicionar" (não diferencia maiusculas de minúsculas).  
  
 -ou-  
  
 O método que <paramref name="addMethod" /> representa não é um método de instância.  
  
 -ou-  
  
 <paramref name="arguments" />não tem o mesmo número de elementos como o número de parâmetros para o método que <paramref name="addMethod" /> representa.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um ou mais elementos de <paramref name="arguments" /> não é atribuível ao tipo do parâmetro correspondente do método que <paramref name="addMethod" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</param>
        <param name="arguments">Uma matriz de <see cref="T:System.Linq.Expressions.Expression" /> objetos para definir o <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> igual da propriedade.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ElementInit" />, dada uma matriz de valores como o segundo argumento.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem o <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `addMethod` parâmetro deve representar um método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas). O método add deve ter o mesmo número de parâmetros como o número de elementos em `arguments`. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento na `arguments` deve ser atribuível ao tipo do parâmetro correspondente do método add, possivelmente após *citando*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ElementInit> que representa a chamada a <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar um elemento de uma coleção de dicionário.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O método que representa addMethod não é chamado de "Adicionar" (não diferencia maiusculas de minúsculas).  
  
 -ou-  
  
 O método addMethod representa não é um método de instância.  
  
 -ou-  
  
 argumentos não tem o mesmo número de elementos como o número de parâmetros para o método que addMethod representa.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um ou mais elementos de <paramref name="arguments" /> não é atribuível ao tipo do parâmetro correspondente do método que <paramref name="addMethod" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma expressão vazia com o tipo <see cref="T:System.Void" />.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida como <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma expressão vazia pode ser usada onde uma expressão é esperada, mas nenhuma ação é desejada. Por exemplo, você pode usar uma expressão vazia como a última expressão em uma expressão de bloco. Nesse caso, o valor de retorno da expressão do bloco será nulo.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão vazia e adicioná-lo a uma expressão de bloco.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`. Caso contrário, será `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`. As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de igualdade, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é <xref:System.Boolean>:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que verifica se os valores dos dois argumentos são iguais.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`. Caso contrário, eles são ambos `false`. As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de igualdade, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> é <see langword="null" /> e o operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa um bit a bit <see langword="XOR" /> operação, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega a `XOR` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiro ou boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado de predefinida `XOR` operador.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado de predefinida `XOR` operador.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa a operação XOR lógica.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador <see langword="XOR" /> não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa um bit a bit <see langword="XOR" /> operação, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam a escolhida Implementando o método para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega a `XOR` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiro ou boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado de predefinida `XOR` operador.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado de predefinida `XOR` operador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e <see langword="XOR" /> operador não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Para <see langword="static" /> (<see langword="Shared" /> no Visual Basic), <c>expressão</c> devem ser <see langword="null" />.</param>
        <param name="field">O <see cref="T:System.Reflection.FieldInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberExpression> é igual de <xref:System.Reflection.FieldInfo.FieldType%2A> propriedade `field`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> é <see langword="null" />.  
  
 -ou-  
  
 O campo representado por <paramref name="field" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type não pode ser atribuído ao tipo declarativo do campo representado por <paramref name="field" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém um campo chamado <c>fieldName</c>. Pode ser nulo para campos estáticos.</param>
        <param name="fieldName">O nome de um campo a ser acessado.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo dado o nome do campo.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.FieldInfo" /> que representa o campo indicado por <paramref name="fieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberExpression> é igual de <xref:System.Reflection.FieldInfo.FieldType%2A> propriedade do <xref:System.Reflection.FieldInfo> que representa o campo indicado por `fieldName`.  
  
 Este método pesquisa `expression`. Tipo e seus tipos base para um campo que tem o nome `fieldName`. Campos públicos terá preferência sobre campos não públicos. Se um campo de correspondência for encontrado, esse método passa `expression` e <xref:System.Reflection.FieldInfo> que representa o campo para <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa a acessar um campo.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="fieldName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nenhum campo nomeado <paramref name="fieldName" /> é definido no tipo <paramref name="expression" /> ou em seus tipos base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">O objeto que contém o campo. Pode ser nulo para campos estáticos.</param>
        <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém o campo.</param>
        <param name="fieldName">O campo a ser acessado.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Uma matriz de até dezesseis <see cref="T:System.Type" /> objetos que especifica os argumentos de tipo para o <see langword="System.Action" /> tipo delegado.</param>
        <summary>Cria um <see cref="T:System.Type" /> objeto que representa um genérico <c>Action</c> tipo com argumentos de tipo específico de delegado.</summary>
        <returns>O tipo de um <c>Action</c> delegado que tenha os argumentos de tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, se os elementos de `typeArgs` representam os tipos de `T1…Tn`, resultante <xref:System.Type> objeto representa o tipo de delegado construído `System.Action<T1,…,Tn>` em c# ou `System.Action(Of T1,…,Tn)` no Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> contém mais de dezesseis elementos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Os argumentos de tipo do delegado.</param>
        <summary>Obtém um <see cref="P:System.Linq.Expressions.Expression.Type" /> objeto que representa um genérico <c>System.Func</c> ou <c>Action</c> tipo com argumentos de tipo específico de delegado.</summary>
        <returns>O tipo de delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O último argumento de tipo determina o tipo de retorno do delegado. Se nenhuma função ou ação é grande o suficiente, ele irá gerar um tipo de representante personalizado.  
  
 Assim como acontece com Func, o último argumento é o tipo de retorno. Ele pode ser definido como void para produzir uma ação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Uma matriz de um a dezessete objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Func" />.</param>
        <summary>Cria um <see cref="P:System.Linq.Expressions.Expression.Type" /> objeto que representa um genérico <c>System.Func</c> tipo com argumentos de tipo específico de delegado. O último argumento de tipo especifica o tipo de retorno do delegado criado.</summary>
        <returns>O tipo de um <c>System.Func</c> delegado que tenha os argumentos de tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs`deve conter pelo menos um e no máximo dezessete elementos.  
  
 Por exemplo, se os elementos de `typeArgs` representam os tipos de `T1…Tn`, resultante <xref:System.Type> objeto representa o tipo de delegado construído `System.Func<T1,…,Tn>` em c# ou `System.Func(Of T1,…,Tn)` no Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> contém menos de um ou mais de dezessete elementos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "Vá para".</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, os <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como o valor especificado e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que contém uma <xref:System.Linq.Expressions.GotoExpression> objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "Vá para". O valor passado para o rótulo no salto pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "Vá para" com o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como o valor especificado, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "Vá para" com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />, e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`. Caso contrário, será `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que", o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é <xref:System.Boolean>:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador “maior que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que". O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`. Caso contrário, eles são ambos `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que", o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador "maior que" não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`. Caso contrário, será `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que ou igual", o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é <xref:System.Boolean>:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador “maior ou igual a” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`. Caso contrário, eles são ambos `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que ou igual", o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador "maior que ou igual" não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
        <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com uma instrução <see langword="if" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> definidas como os valores especificados. A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> foi definida como a expressão padrão e o tipo do <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa um bloco condicional.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</param>
        <param name="ifTrue">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</param>
        <param name="ifFalse">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com as instruções <see langword="if" /> e <see langword="else" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados. O tipo de <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa um bloco condicional.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa expressão é funcional e não altera o valor do objeto que é passado para ele.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que represente uma operação de incremento.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento da expressão em 1.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa expressão é funcional e não altera o valor do objeto que é passado para ele.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o delegado ou expressão lambda a ser aplicado à.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém <see cref="T:System.Linq.Expressions.Expression" /> objetos que representam os argumentos que o delegado ou expressão lambda é aplicada ao.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.InvocationExpression> representa o tipo de retorno do representante que é representado por `expression`. Tipo.  
  
 O <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.InvocationExpression> está vazia se `arguments` é `null`. Caso contrário, ele contém os mesmos elementos `arguments` , exceto que algumas dessas <xref:System.Linq.Expressions.Expression> objetos podem ser *entre aspas*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro correspondente do representante representados por `expression` é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.InvocationExpression> que representa a invocação de uma expressão lambda com os argumentos especificados.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda a ser aplicada.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais que a expressão de delegado ou lambda são aplicados.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.InvocationExpression> representa o tipo de retorno do representante que é representado por `expression`. Tipo.  
  
 O <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.InvocationExpression> está vazia se `arguments` é `null`. Caso contrário, ele contém os mesmos elementos `arguments` , exceto que algumas dessas <xref:System.Linq.Expressions.Expression> objetos podem ser *entre aspas*.  
  
> [!NOTE]
>  Um elemento será cotado somente se o parâmetro correspondente do representante representados por `expression` é do tipo <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.InvocationExpression> que representa a invocação de uma expressão lambda com os argumentos especificados.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
        <summary>Retorna se a expressão é avaliada como false.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Retorna se a expressão é avaliada como false.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
        <summary>Retorna se a expressão é avaliada como true.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Retorna se a expressão é avaliada como true.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e nenhum nome.</summary>
        <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que contém uma <xref:System.Linq.Expressions.LabelTarget> objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> que esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo sem um valor padrão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LabelExpression" /> sem um valor padrão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do rótulo.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o nome fornecido e o tipo void.</summary>
        <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de valor que é passado ao saltar para o rótulo.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo de dado.</summary>
        <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar um <xref:System.Linq.Expressions.LabelTarget> objeto em uma expressão de loop.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> que esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</param>
        <param name="defaultValue">O valor deste <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é alcançado por meio do fluxo de controle normal.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com o valor padrão fornecido.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LabelExpression" /> com o valor padrão fornecido.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de valor que é passado ao saltar para o rótulo.</param>
        <param name="name">O nome do rótulo.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o nome e o tipo em questão.</summary>
        <returns>O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="parameters">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `parameters` parâmetro não deve ter mais de oito elementos.  
  
 Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.  
  
 Esse método cria um tipo de delegado apropriado de uma da `System.Func` delegados genéricos. Ele passa o tipo delegado para uma da <xref:System.Linq.Expressions.ExpressionType.Lambda> métodos de fábrica para criar um <xref:System.Linq.Expressions.LambdaExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> é <see langword="null" />.  
  
 - ou -  
  
 Um ou mais elementos de <paramref name="parameters" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> contém mais de dezesseis elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</param>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
        <returns>Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O objeto que é retornado por essa função é do tipo <xref:System.Linq.Expressions.Expression%601>. O <xref:System.Linq.Expressions.LambdaExpression> tipo é usado para representar o objeto retornado porque o tipo concreto da expressão lambda não é conhecido em tempo de compilação.  
  
 O número de parâmetros para o tipo de delegado representado por`delegateType` deve ser igual o comprimento de `parameters`.  
  
 Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante é igual a `delegateType`. Se `parameters` é `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que representa uma expressão lambda que adiciona 1 para o argumento passado.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> não representa um tipo de delegado.  
  
 -ou-  
  
 <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.  
  
 -ou-  
  
 <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</param>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="parameters">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado. Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</summary>
        <returns>Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O objeto que é retornado por essa função é do tipo <xref:System.Linq.Expressions.Expression%601>. O <xref:System.Linq.Expressions.LambdaExpression> tipo é usado para representar o objeto retornado porque o tipo concreto da expressão lambda não é conhecido em tempo de compilação.  
  
 O número de parâmetros para o tipo de delegado representado por `delegateType` deve ser igual o comprimento de `parameters`.  
  
 Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante é igual a `delegateType`. Se `parameters` é `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> não representa um tipo de delegado.  
  
 -ou-  
  
 <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.  
  
 -ou-  
  
 <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura do delegado para o lambda.</param>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura do delegado para o lambda.</param>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura do delegado para o lambda.</param>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura do delegado para o lambda.</param>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="name">O nome para o lambda. Usada para emitir informações de depuração.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria uma LambdaExpression criando primeiro um tipo delegado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Um tipo de delegado.</typeparam>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de parâmetros para o tipo de delegado `TDelegate` deve ser igual ao número de elementos em `parameters`.  
  
 Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante representa o tipo `TDelegate`. Se `parameters` é `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> não é um tipo de delegado.  
  
 - ou -  
  
 <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.  
  
 -ou-  
  
 <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.  
  
 - ou -  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Um tipo de delegado.</typeparam>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="parameters">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de parâmetros para o tipo de delegado `TDelegate` deve ser igual ao número de elementos em `parameters`.  
  
 Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência`body`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante representa o tipo `TDelegate`. Se `parameters` é `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> não é um tipo de delegado.  
  
 - ou -  
  
 <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.  
  
 -ou-  
  
 <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.  
  
 - ou -  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">O tipo de delegado.</typeparam>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">O tipo de delegado.</typeparam>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">O tipo de delegado.</typeparam>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="name">O nome do lambda. Usado para gerar informações de depuração.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">O tipo de delegado.</typeparam>
        <param name="body">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</param>
        <param name="name">O nome do lambda. Usado para gerar informações de depuração.</param>
        <param name="tailCall">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</param>
        <param name="parameters">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação bit a bit de deslocamento à esquerda.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à esquerda, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. É um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou tipos anuláveis correspondentes) e `right`. O tipo é <xref:System.Int32>, a implementação de método é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador left shift predefinido.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador left shift predefinido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador left shift não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação bit a bit de deslocamento à esquerda.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à esquerda, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. É um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou tipos anuláveis correspondentes) e `right`. O tipo é <xref:System.Int32>, a implementação de método é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador left shift predefinido.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador left shift predefinido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador left shift não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de left shift bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de left shift bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de left shift bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`. Caso contrário, será `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 O método de implementação para a operação é escolhido com base nas seguintes regras:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que" o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é <xref:System.Boolean>:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador “menor que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`. Caso contrário, eles são ambos `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que" o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> é <see langword="null" /> e o operador "menor que" não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma "menor que ou igual" comparação numérica.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`. Caso contrário, será `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que ou igual", o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é <xref:System.Boolean>:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador "menor que ou igual" não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma "menor que ou igual" comparação numérica.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`. Caso contrário, eles são ambos `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que ou igual", o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador "menor que ou igual" não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade para definir o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual da propriedade.</param>
        <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> onde o membro é um campo ou propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> é <see langword="null" />.  
  
 - ou -  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> não representa um campo ou propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade que <paramref name="member" /> representa não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade para definir o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual da propriedade.</param>
        <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> onde o membro é um campo ou propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> é <see langword="null" />.  
  
 - ou -  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> não representa um campo ou propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade que <paramref name="member" /> representa não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
        <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificada.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem o <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> propriedade igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade definida como o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />, e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populado com os elementos de <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
 - ou -  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" />não representa um método de acessador de propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade que o método representado pela <paramref name="propertyAccessor" /> acessos não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
        <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> objeto com base em um método de acessador de propriedade especificada.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem o <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> propriedade igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade definida como o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />, e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populado com os elementos de <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
 - ou -  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" />não representa um método de acessador de propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade que o método representado pela <paramref name="propertyAccessor" /> acessos não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
        <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa especificado <see cref="T:System.Linq.Expressions.ElementInit" /> objetos para inicializar uma coleção.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ListInitExpression> que representa a inicialização de uma nova instância de dicionário com dois pares de chave-valor.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. O tipo não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
        <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Adicionar" para adicionar elementos a uma coleção.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.  
  
 Para usar essa sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Tipo ou seu tipo base deve declarar um único método chamado "Adicionar" (não diferencia maiusculas de minúsculas) que tem exatamente um argumento. O tipo do argumento deve ser atribuível do tipo representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> o primeiro elemento da propriedade `initializers`.  
  
 O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornado <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`. O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`. O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa o método add que foi descoberto no `newExpression`. Tipo ou seu tipo base.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. O tipo não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas) declarado em <paramref name="newExpression" />. Tipo ou seu tipo base.  
  
 -ou-  
  
 O método add no <paramref name="newExpression" />. Tipo ou seu tipo base não tem exatamente um argumento.  
  
 -ou-  
  
 O tipo representado pelo <see cref="P:System.Linq.Expressions.Expression.Type" /> o primeiro elemento da propriedade <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add no <paramref name="newExpression" />. Tipo ou seu tipo base.  
  
 -ou-  
  
 Existe mais de um método compatível com o argumento nomeado "Adicionar" (diferencia maiusculas de minúsculas) em <paramref name="newExpression" />. Tipo de e/ou seu tipo base.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
        <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa especificado <see cref="T:System.Linq.Expressions.ElementInit" /> objetos para inicializar uma coleção.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ListInitExpression> que representa a inicialização de uma nova instância de dicionário com dois pares de chave-valor.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. O tipo não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
        <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Adicionar" para adicionar elementos a uma coleção.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.  
  
 Para usar essa sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Tipo ou seu tipo base deve declarar um único método chamado "Adicionar" (não diferencia maiusculas de minúsculas) que tem exatamente um argumento. O tipo do argumento deve ser atribuível do tipo representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> o primeiro elemento da propriedade `initializers`.  
  
 O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornado <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`. O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`. O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa o método add que foi descoberto no `newExpression`. Tipo ou seu tipo base.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. O tipo não implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas) declarado em <paramref name="newExpression" />. Tipo ou seu tipo base.  
  
 -ou-  
  
 O método add no <paramref name="newExpression" />. Tipo ou seu tipo base não tem exatamente um argumento.  
  
 -ou-  
  
 O tipo representado pelo <see cref="P:System.Linq.Expressions.Expression.Type" /> o primeiro elemento da propriedade <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add no <paramref name="newExpression" />. Tipo ou seu tipo base.  
  
 -ou-  
  
 Existe mais de um método compatível com o argumento nomeado "Adicionar" (diferencia maiusculas de minúsculas) em <paramref name="newExpression" />. Tipo de e/ou seu tipo base.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
        <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância nomeado "Adicionar" (maiusculas de minúsculas), que adiciona um elemento em uma coleção.</param>
        <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.  
  
 If `addMethod` is `null`, `newExpression`. Tipo ou seu tipo base deve declarar um único método chamado "Adicionar" (não diferencia maiusculas de minúsculas) que tem exatamente um argumento. Se `addMethod` não é `null`, ele deve representar um método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas) e que tenha exatamente um parâmetro. O tipo representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve ser atribuível ao tipo de argumento do método add.  
  
 O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornado <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`. O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`. O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é igual a `addMethod`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. O tipo não implementa <see cref="T:System.Collections.IEnumerable" />.  
  
 -ou-  
  
 <paramref name="addMethod" />não é <see langword="null" /> e ele não representa um método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas) que tem exatamente um argumento.  
  
 -ou-  
  
 <paramref name="addMethod" />não é <see langword="null" /> e o tipo representado pelo <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um ou mais elementos de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método que <paramref name="addMethod" /> representa.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" />é <see langword="null" /> e nenhum método de instância nomeado "Add", que usa um argumento de tipo compatível existe no <paramref name="newExpression" />. Tipo ou seu tipo base.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</param>
        <param name="addMethod">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que usa um argumento, o que adiciona um elemento em uma coleção.</param>
        <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.  
  
 If `addMethod` is `null`, `newExpression`. Tipo ou seu tipo base deve declarar um único método chamado "Adicionar" (não diferencia maiusculas de minúsculas) que tem exatamente um argumento. Se `addMethod` não é `null`, ele deve representar um método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas) e que tenha exatamente um parâmetro. O tipo representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve ser atribuível ao tipo de argumento do método add.  
  
 O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornado <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`. O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`. O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é igual a `addMethod`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. O tipo não implementa <see cref="T:System.Collections.IEnumerable" />.  
  
 -ou-  
  
 <paramref name="addMethod" />não é <see langword="null" /> e ele não representa um método de instância nomeado "Adicionar" (não diferencia maiusculas de minúsculas) que tem exatamente um argumento.  
  
 -ou-  
  
 <paramref name="addMethod" />não é <see langword="null" /> e o tipo representado pelo <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um ou mais elementos de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método que <paramref name="addMethod" /> representa.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" />é <see langword="null" /> e nenhum método de instância nomeado "Add", que usa um argumento de tipo compatível existe no <paramref name="newExpression" />. Tipo ou seu tipo base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">O corpo do loop.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">O corpo do loop.</param>
        <param name="break">O destino de interrupção usado pelo corpo do loop.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o destino corpo e interrupção determinado.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão de bloco que contém um <xref:System.Linq.Expressions.LoopExpression> objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">O corpo do loop.</param>
        <param name="break">O destino de interrupção usado pelo corpo do loop.</param>
        <param name="continue">O destino continuar usado pelo corpo do loop.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, considerando os operandos esquerdos e direito, chamando um método de fábrica apropriado.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> chama esse método de método de fábrica. Por exemplo, se `binaryType` é <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método chama <xref:System.Linq.Expressions.Expression.Subtract%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> método para criar um <xref:System.Linq.Expressions.BinaryExpression> que representa a subtração de um número de outro.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, fornecido o operando da esquerda, direita operando e implementando o método, chamando o método de fábrica apropriada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> será de chamada do método de fábrica esse método. Por exemplo, se `binaryType` é <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método chama <xref:System.Linq.Expressions.Expression.Subtract%2A>. O `liftToNull` e `method` parâmetros são ignorados se o método de fábrica apropriado não tem um parâmetro correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</param>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo. Esse parâmetro é usado somente se <c>binaryType</c> é <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou atribuição composta.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, fornecido o operando da esquerda, direita operando, Implementando o método e função de conversão de tipo chamando o método de fábrica apropriada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> será de chamada do método de fábrica esse método. Por exemplo, se `binaryType` é <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método chama <xref:System.Linq.Expressions.Expression.Subtract%2A>. O `liftToNull`, `method` e `conversion` parâmetros são ignorados se o método de fábrica apropriado não tem um parâmetro correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> isso <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</param>
        <param name="variable">Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o <see cref="T:System.Exception" /> capturado por este manipulador de objeto.</param>
        <param name="body">O corpo da instrução catch.</param>
        <param name="filter">O corpo do <see cref="T:System.Exception" /> filtro.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com os elementos especificados.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type`deve ser não nulos e corresponder ao tipo de `variable` (se ele é fornecido).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="arguments">Os argumentos para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="arg0">O argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> e um argumento.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="arguments">Os argumentos para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <param name="arg1">O segundo argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> e dois argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <param name="arg1">O segundo argumento para a operação dinâmica.</param>
        <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> e três argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">O associador de tempo de execução para a operação dinâmica.</param>
        <param name="arg0">O primeiro argumento para a operação dinâmica.</param>
        <param name="arg1">O segundo argumento para a operação dinâmica.</param>
        <param name="arg2">O terceiro argumento para a operação dinâmica.</param>
        <param name="arg3">O quarto argumento para a operação dinâmica.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada por fornecido <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> e quatro argumentos.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> com <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem o <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definir os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> do <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um salto de especificado <see cref="T:System.Linq.Expressions.GotoExpressionKind" />. O valor passado para o rótulo após saltando também pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />, e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">O objeto ao qual a propriedade pertence. Deve ser nulo se a propriedade for <see langword="static" /> (<see langword="shared" /> no Visual Basic).</param>
        <param name="indexer">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a propriedade de índice.</param>
        <param name="arguments">Um <c>IEnumerable&lt;expressão&gt; </c> (<c>IEnumerable (de expressão)</c> no Visual Basic) que contém os argumentos que serão usados para a propriedade de índice.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada em um objeto.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto ao qual o membro pertence. Isso pode ser nulo para membros estáticos.</param>
        <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> que descreve a propriedade ou o campo a ser acessado.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo ou uma propriedade.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar um <xref:System.Linq.Expressions.MemberExpression> que representa o acesso a um campo ou uma propriedade, dependendo do tipo de `member`. Se `member` é do tipo <xref:System.Reflection.FieldInfo>, este método chama <xref:System.Linq.Expressions.Expression.Field%2A> para criar o <xref:System.Linq.Expressions.MemberExpression>. Se `member` é do tipo <xref:System.Reflection.PropertyInfo>, este método chama <xref:System.Linq.Expressions.Expression.Property%2A> para criar o <xref:System.Linq.Expressions.MemberExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> não representa um campo ou propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado da expressão try. Se for null, bodh e todos os manipuladores devem ter tipo idêntico.</param>
        <param name="body">O corpo do bloco try.</param>
        <param name="finally">O corpo do bloco finally. Passe null se o bloco try finally não tem bloco associado a ele.</param>
        <param name="fault">O corpo do bloco de falha. Passe null se o bloco try não tenha nenhum bloco de falha associado a ele.</param>
        <param name="handlers">Uma coleção de <see cref="T:System.Linq.Expressions.CatchBlock" />s que representa as instruções de captura a ser associado ao bloco try.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com os elementos especificados.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo da operação unária.</param>
        <param name="operand">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</param>
        <param name="type">O <see cref="T:System.Type" /> que especifica o tipo a ser convertido em (passar <see langword="null" /> se não for aplicável).</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado um operando, chamando o método de fábrica apropriada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `unaryType` parâmetro determina quais <xref:System.Linq.Expressions.UnaryExpression> chama esse método de método de fábrica. Por exemplo, se `unaryType` é igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método chama <xref:System.Linq.Expressions.Expression.Convert%2A>. O `type`parâmetro será ignorado se ele não se aplica ao método de fábrica que é chamado.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" />não corresponde a um nó de expressão unária.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo da operação unária.</param>
        <param name="operand">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</param>
        <param name="type">O <see cref="T:System.Type" /> que especifica o tipo a ser convertido em (passar <see langword="null" /> se não for aplicável).</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado um operando e implementando o método, chamando o método de fábrica apropriada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `unaryType` parâmetro determina quais <xref:System.Linq.Expressions.UnaryExpression> chama esse método de método de fábrica. Por exemplo, se `unaryType` é igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método chama <xref:System.Linq.Expressions.Expression.Convert%2A>. O `type` e `method` parâmetros são ignorados se eles não se aplicam ao método de fábrica que é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" />não corresponde a um nó de expressão unária.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</param>
        <param name="bindings">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva dos membros de um campo ou propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `member` parâmetro deve representar um campo ou propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> não representa um campo ou propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade de um elemento de <paramref name="bindings" /> não representa um membro do tipo de campo ou propriedade que <paramref name="member" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</param>
        <param name="bindings">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva dos membros de um campo ou propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `member` parâmetro deve representar um campo ou propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> não representa um campo ou propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade de um elemento de <paramref name="bindings" /> não representa um membro do tipo de campo ou propriedade que <paramref name="member" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
        <param name="bindings">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva dos membros de um membro que é acessada por meio de um método de acessador de propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem o <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> propriedade igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />, e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> propriedades definidas para os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" />não representa um método de acessador de propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método que <paramref name="propertyAccessor" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
        <param name="bindings">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva dos membros de um membro que é acessada por meio de um método de acessador de propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem o <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> propriedade igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, o <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />, e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> propriedades definidas para os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" />não representa um método de acessador de propriedade.  
  
 -ou-  
  
 O <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método que <paramref name="propertyAccessor" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</param>
        <param name="bindings">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
        <summary>Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberInitExpression> é igual de <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</param>
        <param name="bindings">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberInitExpression> é igual de <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MemberInitExpression> que representa a inicialização de dois membros de um novo objeto.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de módulo, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de módulo predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de módulo predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador modulus não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 O método de implementação para a operação é escolhido com base nas seguintes regras:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de módulo, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de módulo predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de módulo predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de módulo não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição restante.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição restante.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição restante.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, os <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que multiplica dois valores.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, os <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de multiplicação não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de multiplicação aritmética com a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, os <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de multiplicação aritmética com a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, os <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de multiplicação não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são falsos.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador unário menos operador, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que represente uma operação aritmética de negação.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de menos unário não está definido para <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são falsos.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa um argumento, ele é o método de implementação para o nó.  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador unário menos operador, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador unário menos operador não está definido para <paramref name="expression" />. Tipo.  
  
 -ou-  
  
 <paramref name="expression" />. Não é atribuível ao tipo de argumento do método representado pelo tipo (ou seu tipo não anulável correspondente se ele é um tipo de valor anuláveis) <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética negação com verificação de estouro.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são falsos.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador unário menos operador, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de menos unário não está definido para <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética negação com verificação de estouro. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são falsos.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa um argumento, ele é o método de implementação para o nó.  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador unário menos operador, o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador unário menos operador não está definido para <paramref name="expression" />. Tipo.  
  
 -ou-  
  
 <paramref name="expression" />. Não é atribuível ao tipo de argumento do método representado pelo tipo (ou seu tipo não anulável correspondente se ele é um tipo de valor anuláveis) <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa a chamada do construtor especificado que não usa nenhum argumento.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.NewExpression.Arguments%2A> e <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedades de resultante <xref:System.Linq.Expressions.NewExpression> são coleções vazias. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade representa o tipo de declaração de construtor representado por `constructor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O construtor que <paramref name="constructor" /> representa tem pelo menos um parâmetro.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> contém um construtor que não aceita argumentos.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada para o construtor sem parâmetro do tipo especificado.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida como o <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor sem parâmetros para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `type` parâmetro deve representar um tipo que tem um construtor sem parâmetros.  
  
 O <xref:System.Linq.Expressions.NewExpression.Arguments%2A> e <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedades de resultante <xref:System.Linq.Expressions.NewExpression> são coleções vazias. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual a `type`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.New%28System.Type%29> método para criar um <xref:System.Linq.Expressions.NewExpression> que representa construindo uma nova instância de um objeto de dicionário chamando o construtor sem parâmetros.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O tipo que <paramref name="type" /> representa não tem um construtor sem parâmetros.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `arguments` parâmetro deve conter o mesmo número de elementos como o número de parâmetros para o construtor representado por `constructor`. Se `arguments` é `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração de construtor representado por `constructor`. O <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade é uma coleção vazia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="arguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="arguments" /> parâmetro não tem o mesmo número de elementos como o número de parâmetros para o construtor que <paramref name="constructor" /> representa.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `arguments` parâmetro deve conter o mesmo número de elementos como o número de parâmetros para o construtor representado por `constructor`. Se `arguments` é `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração de construtor representado por `constructor`. O <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade é uma coleção vazia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="arguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="arguments" /> corresponde ao número de parâmetros do construtor representado por <paramref name="constructor" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <param name="members">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados. Os membros que acessam os campos do construtor inicializado são especificados.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `arguments` parâmetro deve conter o mesmo número de elementos como o número de parâmetros para o construtor representado por `constructor`. Se `arguments` é `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.  
  
 Se `members` é `null`, o <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia. Se `members` não é `null`, ele deve ter o mesmo número de elementos como `arguments` e cada elemento não deve ser `null`. Cada elemento de `members` deve ser um <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> que representa um membro de instância no tipo de declaração de construtor representado por `constructor`. Se ele representa uma propriedade, a propriedade deve ter um `get` acessador. O elemento correspondente de `arguments` para cada elemento de `members` deve ter um <xref:System.Linq.Expressions.Expression.Type%2A> propriedade que representa um tipo que pode ser atribuído ao tipo do membro que o `members` elemento representa.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração de construtor que `constructor` representa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="arguments" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="members" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="arguments" /> parâmetro não tem o mesmo número de elementos como o número de parâmetros para o construtor que <paramref name="constructor" /> representa.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.  
  
 -ou-  
  
 O <paramref name="members" /> parâmetro não tem o mesmo número de elementos como <paramref name="arguments" />.  
  
 -ou-  
  
 Um elemento de <paramref name="arguments" /> tem um <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente da <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
        <param name="members">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados. Os membros que acessam os campos do construtor inicializado são especificados como uma matriz.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> propriedades definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `arguments` parâmetro deve conter o mesmo número de elementos como o número de parâmetros para o construtor representado por `constructor`. Se `arguments` é `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.  
  
 Se `members` é `null`, o <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia. Se `members` não é `null`, ele deve ter o mesmo número de elementos como `arguments` e cada elemento não deve ser `null`. Cada elemento de `members` deve ser um <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> que representa um membro de instância no tipo de declaração de construtor representado por `constructor`. Se ele representa uma propriedade, a propriedade deve ser capaz de recuperar o valor do campo associado. O elemento correspondente de `arguments` para cada elemento de `members` deve ter um <xref:System.Linq.Expressions.Expression.Type%2A> propriedade que representa um tipo que pode ser atribuído ao tipo do membro que o `members` elemento representa.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração de construtor que `constructor` representa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="arguments" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="members" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="arguments" /> parâmetro não tem o mesmo número de elementos como o número de parâmetros para o construtor que <paramref name="constructor" /> representa.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.  
  
 -ou-  
  
 O <paramref name="members" /> parâmetro não tem o mesmo número de elementos como <paramref name="arguments" />.  
  
 -ou-  
  
 Um elemento de <paramref name="arguments" /> tem um <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente da <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
        <param name="bounds">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewArrayExpression> representa um tipo de matriz cuja classificação é igual ao comprimento da `bounds` e cujo tipo de elemento é `type`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `bounds` deve representar um tipo integral.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para criar uma árvore de expressão que representa a criação de uma matriz de cadeia de caracteres que tem uma classificação de 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="bounds" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um elemento de <paramref name="bounds" /> não representa um tipo integral.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
        <param name="bounds">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewArrayExpression> representa um tipo de matriz cuja classificação é igual ao comprimento da `bounds` e cujo tipo de elemento é `type`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `bounds` deve representar um tipo integral.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para criar uma árvore de expressão que representa a criação de uma matriz de cadeia de caracteres que tem uma classificação de 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="bounds" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um elemento de <paramref name="bounds" /> não representa um tipo integral.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
        <param name="initializers">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve representar um tipo que pode ser atribuído ao tipo representado pela `type`, possivelmente depois que ele *entre aspas*.  
  
> [!NOTE]
>  Um elemento será cotado somente se `type` é <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `initializers`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewArrayExpression> representa uma matriz de tipo cuja posição é 1 e cujo tipo de elemento é `type`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para criar uma árvore de expressão que representa a criação de uma matriz unidimensional de cadeia de caracteres que é inicializado com uma lista de expressões de cadeia de caracteres.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="initializers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade de um elemento de <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo que <paramref name="type" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</param>
        <param name="initializers">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve representar um tipo que pode ser atribuído ao tipo representado pela `type`, possivelmente depois que ele *entre aspas*.  
  
> [!NOTE]
>  Um elemento será cotado somente se `type` é <xref:System.Linq.Expressions.Expression>. Delimitar significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó. O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `initializers`.  
  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.NewArrayExpression> representa uma matriz de tipo cuja posição é 1 e cujo tipo de elemento é `type`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para criar uma árvore de expressão que representa a criação de uma matriz unidimensional de cadeia de caracteres que é inicializado com uma lista de expressões de cadeia de caracteres.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="initializers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <value>Um dos valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.NodeType%2A> propriedade fornece uma descrição mais especializada de um <xref:System.Linq.Expressions.Expression> que apenas seu tipo derivado. Por exemplo, um <xref:System.Linq.Expressions.BinaryExpression> pode ser usado para representar vários tipos diferentes de expressões binárias, como uma operação de divisão ou uma operação de "maior que". O <xref:System.Linq.Expressions.Expression.NodeType%2A> propriedade seria descrevem essas expressões binárias como <xref:System.Linq.Expressions.ExpressionType.Divide> e <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectivamente.  
  
 O tipo CLR estático da expressão que o <xref:System.Linq.Expressions.Expression> representa de objeto é representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador not, operador unário o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico ou booleano, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo não anulável correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que representa uma operação não.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O não operador unário não é definido para <paramref name="expression" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit. O método de implementação pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa um argumento, ele é o método de implementação para o nó.  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador not, operador unário o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador unário não operador não está definido para <paramref name="expression" />. Tipo.  
  
 -ou-  
  
 <paramref name="expression" />. Não é atribuível ao tipo de argumento do método representado pelo tipo (ou seu tipo não anulável correspondente se ele é um tipo de valor anuláveis) <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`. Caso contrário, será `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de desigualdade, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é <xref:System.Boolean>:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de desigualdade não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="liftToNull">
          <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`. Caso contrário, eles são ambos `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de desigualdade, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   É o tipo de retorno do método implementação <xref:System.Boolean>.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é <xref:System.Boolean>.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de desigualdade não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Retorna a expressão que representa os complemento.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Retorna a expressão que representa os complemento.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiro ou boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado de predefinida bit a bit `OR` operador.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo anulável correspondente para o tipo de resultado de predefinida bit a bit `OR` operador.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa uma operação OR lógica.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiro ou boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado de predefinida bit a bit `OR` operador.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo anulável correspondente para o tipo de resultado de predefinida bit a bit `OR` operador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
    > [!NOTE]
    >  A condicional `OR` operador não pode ser sobrecarregado em c# ou [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. No entanto, a condicional `OR` operador é avaliado usando o bit a bit `OR` operador. Portanto, uma sobrecarga definido pelo usuário de bit a bit `OR` operador pode ser o método de implementação para esse tipo de nó.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   `left`. Tipo e `right`. Tipo são do mesmo tipo booliano.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó não é eliminado. O tipo do nó é o tipo de resultado da condicional predefinido `OR` operador.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado da condicional predefinido `OR` operador.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que representa uma operação lógica `OR` operação que avalia o segundo operando somente se o primeiro operando é avaliado como `false`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
 -ou-  
  
 <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
    > [!NOTE]
    >  A condicional `OR` operador não pode ser sobrecarregado em c# ou [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. No entanto, a condicional `OR` operador é avaliado usando o bit a bit `OR` operador. Portanto, uma sobrecarga definido pelo usuário de bit a bit `OR` operador pode ser o método de implementação para esse tipo de nó.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   `left`. Tipo e `right`. Tipo são do mesmo tipo booliano.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó não é eliminado. O tipo do nó é o tipo de resultado da condicional predefinido `OR` operador.  
  
-   If `left`. Tipo e `right`. Tipo não são nulas, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado da condicional predefinido `OR` operador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.  
  
 -ou-  
  
 <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do parâmetro ou da variável.</param>
        <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
        <returns>Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.MethodCallExpression> objeto que imprime o valor de uma <xref:System.Linq.Expressions.ParameterExpression> objeto.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do parâmetro ou da variável.</param>
        <param name="name">O nome do parâmetro ou variável, usado para fins de depuração ou impressão apenas.</param>
        <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e as propriedades <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguido por um decremento subsequente 1 da expressão original.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguido por um decremento subsequente 1 da expressão original.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguido por um incremento subsequente 1 da expressão original.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguido por um incremento subsequente 1 da expressão original.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de exponenciação, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são ambos <xref:System.Double>, a implementação de método é <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de exponenciação não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.  
  
 -ou-  
  
 <paramref name="left" />. Tipo de e/ou <paramref name="right" />. Tipo não são <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de exponenciação, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são ambos <xref:System.Double>, a implementação de método é <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de exponenciação não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.  
  
 -ou-  
  
 <paramref name="method" />is <see langword="null" /> and <paramref name="left" />. Tipo de e/ou <paramref name="right" />. Tipo não são <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de uma expressão a uma potência e atribuir o resultado de volta a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de uma expressão a uma potência e atribuir o resultado de volta a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de uma expressão a uma potência e atribuir o resultado de volta a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que diminui a expressão em 1 e atribui o resultado de volta para a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que diminui a expressão em 1 e atribui o resultado de volta para a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que a expressão é incrementado em 1 e atribui o resultado para a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para aplicar as operações.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que a expressão é incrementado em 1 e atribui o resultado para a expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Pode ser nulo para propriedades estáticas.</param>
        <param name="propertyAccessor">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade usando um método de acessador de propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberExpression> é igual de <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Se o método representado por `propertyAccessor` é `static` (`Shared` no Visual Basic), `expression` pode ser `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> é <see langword="null" />.  
  
 -ou-  
  
 O método representado por <paramref name="propertyAccessor" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="propertyAccessor" />.  
  
 -ou-  
  
 O método representado por <paramref name="propertyAccessor" /> não é um método de acessador de propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele. Pode ser nulo para propriedades estáticas.</param>
        <param name="property">O <see cref="T:System.Reflection.PropertyInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberExpression> é igual de <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Se a propriedade representada por `property` é `static` (`Shared` no Visual Basic), `expression` pode ser `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="property" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade que o <paramref name="property" /> representa não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e o <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type não é atribuível ao tipo de declaração da propriedade que o <paramref name="property" /> representa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade chamada <c>propertyName</c>. Pode ser <see langword="null" /> para propriedades estáticas.</param>
        <param name="propertyName">O nome de uma propriedade a ser acessada.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade indicada por <paramref name="propertyName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberExpression> é igual de <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade do <xref:System.Reflection.PropertyInfo> que representa a propriedade indicada por `propertyName`.  
  
 Este método pesquisa `expression`. Tipo e seus tipos base para uma propriedade que tem o nome `propertyName`. Propriedades públicas terá preferência sobre as propriedades não-públicos. Se uma propriedade correspondente for encontrada, esse método passa `expression` e <xref:System.Reflection.PropertyInfo> que representa a propriedade <xref:System.Linq.Expressions.Expression.Property%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar uma expressão que representa o acesso a uma propriedade.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="propertyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nenhuma propriedade nomeada <paramref name="propertyName" /> é definida no tipo <paramref name="expression" /> ou em seus tipos base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
        <param name="indexer">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</param>
        <param name="arguments">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de <see cref="T:System.Linq.Expressions.Expression" /> objetos que são usados para a propriedade de índice.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
        <param name="indexer">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">O objeto ao qual a propriedade pertence. Se a propriedade for estática/compartilhada, ela deverá ser nula.</param>
        <param name="propertyName">O nome do indexador.</param>
        <param name="arguments">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">O objeto recipiente da propriedade. Pode ser nulo para propriedades estáticas.</param>
        <param name="type">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém a propriedade.</param>
        <param name="propertyName">A propriedade a ser acessada.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> acessando uma propriedade.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade ou campo denominado <c>propertyOrFieldName</c>. Isso pode ser nulo para membros estáticos.</param>
        <param name="propertyOrFieldName">O nome de uma propriedade ou campo a ser acessado.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade ou campo.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> ou <see cref="T:System.Reflection.FieldInfo" /> que representa a propriedade indicada por <paramref name="propertyOrFieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.MemberExpression> é igual de <xref:System.Reflection.PropertyInfo.PropertyType%2A> ou <xref:System.Reflection.FieldInfo.FieldType%2A> propriedades do <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo>, respectivamente, que representa a propriedade ou campo indicado por `propertyOrFieldName`.  
  
 Este método pesquisa `expression`. Tipo e seus tipos base para uma propriedade ou campo que tem o nome `propertyOrFieldName`. Campos e propriedades públicas terá preferência sobre os campos e propriedades não-públicos. Além disso, propriedades terá preferência sobre campos. Se um campo ou propriedade correspondente for encontrado, esse método passa `expression` e <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo> que representa essa propriedade ou campo para <xref:System.Linq.Expressions.Expression.Property%2A> ou <xref:System.Linq.Expressions.Expression.Field%2A>, respectivamente.  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar uma expressão que representa o acesso a uma propriedade ou campo.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nenhuma propriedade nomeado <paramref name="propertyOrFieldName" /> é definido em <paramref name="expression" />.Type ou em seus tipos base.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> representa o tipo construído <xref:System.Linq.Expressions.Expression%601>, em que o argumento de tipo é o tipo representado pelo `expression`. Tipo. A propriedade <xref:System.Linq.Expressions.UnaryExpression.Method%2A> é `null`. Ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> são `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduz esse nó a uma expressão mais simples. Se CanReduce retornar true, ele deverá retornar uma expressão válida. Esse método pode retornar outro nó que também precisa ser reduzido.</summary>
        <returns>A expressão reduzida.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduz esse nó a uma expressão mais simples. Se CanReduce retornar true, ele deverá retornar uma expressão válida. Esse método pode retornar outro nó que também precisa ser reduzido.</summary>
        <returns>A expressão reduzida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao contrário de redução, esse método verifica que o nó reduzido de acordo com determinadas invariáveis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduz a expressão a um tipo de nó conhecidos (que não é um nó de extensão) ou apenas retorna a expressão se ele já é um tipo conhecido.</summary>
        <returns>A expressão reduzida.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade de referência.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade de referência.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O novo <see cref="T:System.Type" /> da expressão.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção com um determinado tipo.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual ao retorno, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno. O valor passado para o rótulo no salto pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continuar, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida como <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que contém o <xref:System.Linq.Expressions.Expression.Return%2A> método.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual ao retorno, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />e um valor nulo a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</param>
        <param name="value">O valor que será passado para o rótulo associado ao saltar.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado. O valor passado para o rótulo no salto pode ser especificado.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a continuar, o <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> propriedade definida como <paramref name="target" />, o <see cref="P:System.Linq.Expressions.Expression.Type" /> propriedade definida como <paramref name="type" />, e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação bit a bit de deslocamento à direita.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à direita, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. É um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou tipos anuláveis correspondentes) e `right`. O tipo é <xref:System.Int32>, a implementação de método é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador right shift predefinido.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador right shift predefinido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador right shift não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação bit a bit de deslocamento à direita.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à direita, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. É um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou tipos anuláveis correspondentes) e `right`. O tipo é <xref:System.Int32>, a implementação de método é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador right shift predefinido.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador right shift predefinido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador right shift não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de right-shift bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de right-shift bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de right-shift bit a bit.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Uma coleção de <see cref="T:System.Linq.Expressions.ParameterExpression" /> objetos a ser usado para popular o <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> coleção.</param>
        <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> propriedade definida como o valor especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
        <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> propriedade definida como o valor especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de subtração predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma expressão que subtrai o argumento do primeiro argumento.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de subtração predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de subtração não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <param name="conversion">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração com verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de subtração aritmético com a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As regras a seguir determinam o método de implementação selecionado para a operação:  
  
-   Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de subtração predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</param>
        <param name="right">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de subtração aritmético com a verificação de estouro.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida para o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são `false`. A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.  
  
 As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é eliminado.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que leva dois argumentos, é o método de implementação para o nó.  
  
-   Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa o que é o método de implementação.  
  
-   Caso contrário, se `left`. Tipo e `right`. Tipo são tipos numéricos, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `left`. Tipo e `right`. Tipo pode ser atribuído para os tipos de argumento correspondente do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos de não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`:  
  
-   If `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é eliminado. O tipo do nó é o tipo de resultado do operador de subtração predefinidos.  
  
-   If `left`. Tipo e `right`. Tipo são anuláveis, o nó é eliminado. O tipo do nó é o tipo nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de subtração não está definido para <paramref name="left" />. Tipo e <paramref name="right" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">O valor a ser testado para cada caso.</param>
        <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
        <summary>Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> sem um caso padrão.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.  
  
 Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícita `break` instrução, o que significa que não há nenhum outono implícita por meio de um rótulo case para outro.  
  
 Se `switchValue` não corresponde a nenhum dos casos, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que representa uma instrução switch sem um caso padrão.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">O valor a ser testado para cada caso.</param>
        <param name="defaultBody">O resultado do comutador se <c>switchValue</c> não corresponde a nenhum dos casos.</param>
        <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.  
  
 Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícita `break` instrução, o que significa que não há nenhum outono implícita por meio de um rótulo case para outro.  
  
 Se `switchValue` não corresponde a nenhum dos casos, o caso padrão representado por `defaultBody` é executado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que representa uma instrução switch que tem um caso padrão.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">O valor a ser testado para cada caso.</param>
        <param name="defaultBody">O resultado do comutador se <c>switchValue</c> não corresponde a nenhum dos casos.</param>
        <param name="comparison">O método de comparação de igualdade para usar.</param>
        <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">O valor a ser testado para cada caso.</param>
        <param name="defaultBody">O resultado do comutador se <c>switchValue</c> não corresponde a nenhum dos casos.</param>
        <param name="comparison">O método de comparação de igualdade para usar.</param>
        <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado do comutador.</param>
        <param name="switchValue">O valor a ser testado para cada caso.</param>
        <param name="defaultBody">O resultado do comutador se <c>switchValue</c> não corresponde a nenhum dos casos.</param>
        <param name="comparison">O método de comparação de igualdade para usar.</param>
        <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O tipo de resultado do comutador.</param>
        <param name="switchValue">O valor a ser testado para cada caso.</param>
        <param name="defaultBody">O resultado do comutador se <c>switchValue</c> não corresponde a nenhum dos casos.</param>
        <param name="comparison">O método de comparação de igualdade para usar.</param>
        <param name="cases">O conjunto de casos para esta expressão de comutador.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa um <see langword="switch" /> instrução que tenha um caso padrão.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">O corpo do caso.</param>
        <param name="testValues">Os valores de teste do caso.</param>
        <summary>Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.  
  
 Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícita `break` instrução, o que significa que não há nenhum outono implícita por meio de um rótulo case para outro.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como criar uma expressão que representa uma instrução switch que tem um caso padrão.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">O corpo do caso.</param>
        <param name="testValues">Os valores de teste do caso.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.SwitchCase" /> para uso em um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Um <see cref="T:System.String" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> igual a.</param>
        <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> propriedade definida como o valor especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">Um <see cref="T:System.String" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> igual a.</param>
        <param name="language">Um <see cref="T:System.Guid" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> igual a.</param>
        <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> propriedades definidas para o valor especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">Um <see cref="T:System.String" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> igual a.</param>
        <param name="language">Um <see cref="T:System.Guid" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> igual a.</param>
        <param name="languageVendor">Um <see cref="T:System.Guid" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> igual a.</param>
        <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> propriedades definidas para o valor especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">Um <see cref="T:System.String" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> igual a.</param>
        <param name="language">Um <see cref="T:System.Guid" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> igual a.</param>
        <param name="languageVendor">Um <see cref="T:System.Guid" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> igual a.</param>
        <param name="documentType">Um <see cref="T:System.Guid" /> para definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> igual a.</param>
        <summary>Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> propriedades definidas para o valor especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que usa o <xref:System.Linq.Expressions.Expression.Throw%2A> método.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Um <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="type">O novo <see cref="T:System.Type" /> da expressão.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um lançamento de uma exceção com um determinado tipo.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>Uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">O corpo do bloco try.</param>
        <param name="handlers">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e nem um bloco fault nem finally.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que contém uma instrução catch.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">O corpo do bloco try.</param>
        <param name="finally">O corpo do bloco finally.</param>
        <param name="handlers">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com qualquer número de instruções de captura e um bloco finally.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que contém uma instrução catch e uma instrução finally.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">O corpo do bloco try.</param>
        <param name="fault">O corpo do bloco de falha.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com um bloco de falha e nenhum instruções catch.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">O corpo do bloco try.</param>
        <param name="finally">O corpo do bloco finally.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com uma finalmente bloco e nenhum instruções catch.</summary>
        <returns>O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Uma matriz de objetos de tipo que especifica os argumentos de tipo para o tipo de delegado Action.</param>
        <param name="actionType">Quando este método retorna, contém o tipo de delegado genérico Action com argumentos de tipo específico. Conterá null se não houver nenhum delegado Action genérico que corresponde a <c>typeArgs</c>. Esse parâmetro é passado não inicializado.</param>
        <summary>Cria um <see cref="P:System.Linq.Expressions.Expression.Type" /> objeto que representa um tipo de delegado genérico Action com argumentos de tipo específico.</summary>
        <returns>True se o tipo de delegado genérico Action foi criado para determinado <paramref name="typeArgs" />; FALSO caso contrário.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Uma matriz de objetos de tipo que especifica os argumentos de tipo para o tipo de delegado System.Func.</param>
        <param name="funcType">Quando este método retorna, contém o tipo de delegado genérico System.Func que tem argumentos de tipo específico. Conterá null se não houver nenhum delegado System.Func genérico que corresponde a <c>typeArgs</c>. Esse parâmetro é passado não inicializado.</param>
        <summary>Cria um <see cref="P:System.Linq.Expressions.Expression.Type" /> objeto que representa um tipo de delegado genérico System.Func que tem argumentos de tipo específico. O último argumento de tipo especifica o tipo de retorno do delegado criado.</summary>
        <returns>True se o tipo de delegado genérico System.Func foi criado para determinado <paramref name="typeArgs" />; FALSO caso contrário.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
        <value>O <see cref="T:System.Type" /> que representa o tipo estático da expressão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.NodeType%2A> é o tipo de nó de árvore de expressão, enquanto o <xref:System.Linq.Expressions.Expression.Type%2A> representa o estático tipo common language runtime (CLR) da expressão que representa o nó. Por exemplo, dois nós com tipos de nós diferentes podem ter o mesmo <xref:System.Linq.Expressions.Expression.Type%2A>, conforme mostrado no exemplo de código a seguir.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="type">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão boxing ou de referência explícita em que <see langword="null" /> será fornecido se a conversão falhar.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é `null`. O <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> propriedades estiverem `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para criar um <xref:System.Linq.Expressions.UnaryExpression> que representa a conversão de referência de uma expressão de inteiro não nulo para o tipo de inteiro anulável.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="T:System.Linq.Expressions.Expression" /> igual a ele.</param>
        <param name="type">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara a identidade de tipo de tempo de execução.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para o qual o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade é igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e para o qual o <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> propriedades são definidas para os valores especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> igual a ele.</param>
        <param name="type">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para o qual o <see cref="P:System.Linq.Expressions.Expression.NodeType" /> propriedade é igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e para o qual o <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> propriedades são definidas para os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> representa <xref:System.Boolean>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para criar um <xref:System.Linq.Expressions.TypeBinaryExpression> que representa um teste de tipo de um valor de cadeia de caracteres em relação a <xref:System.Int32> tipo.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de adição unária.</summary>
        <returns>Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são falsos.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador de adição unária o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O operador de adição unária não está definido para <paramref name="expression" />. Tipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</param>
        <param name="method">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de adição unária.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultante <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação. O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é definida como o tipo do nó. Se o nó é eliminado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`. Caso contrário, eles são falsos.  
  
#### <a name="implementing-method"></a>Implementando método  
 As seguintes regras de determinam o método de implementação para a operação:  
  
-   Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa um argumento, ele é o método de implementação para o nó.  
  
-   If `expression`. É um tipo definido pelo usuário que define o operador de adição unária o <xref:System.Reflection.MethodInfo> que representa que operador é o método de implementação.  
  
-   Caso contrário, se `expression`. É um tipo numérico, o método de implementação é `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Tipo de nó e versão com comparação de precisão x sem comparação de precisão  
 Se o método de implementação não é `null`:  
  
-   If `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é eliminado. O tipo do nó é o tipo de retorno do método de implementação.  
  
-   Se as seguintes condições forem atendidas, o nó é eliminado e o tipo do nó é o tipo nulo que corresponde ao tipo de retorno do método de implementação:  
  
    -   `expression`. É um tipo de valor nulo e o tipo de valor não nulo correspondente é igual ao tipo de argumento do método de implementação.  
  
    -   O tipo de retorno do método de implementação é um tipo de valor não nulo.  
  
 Se o método de implementação é `null`, o tipo do nó é `expression`. Tipo. If `expression`. Tipo não anulável, o nó não é eliminado. Caso contrário, o nó é eliminado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />é <see langword="null" /> e o operador de adição unária não está definido para <paramref name="expression" />. Tipo.  
  
 -ou-  
  
 <paramref name="expression" />. Não é atribuível ao tipo de argumento do método representado pelo tipo (ou seu tipo não anulável correspondente se ele é um tipo de valor anuláveis) <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Um <see cref="T:System.Linq.Expressions.Expression" /> para converter.</param>
        <param name="type">O novo <see cref="T:System.Type" /> da expressão.</param>
        <summary>Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um unboxing explícita.</summary>
        <returns>Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do parâmetro ou da variável.</param>
        <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
        <returns>Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> nó com o nome especificado e o tipo</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do parâmetro ou da variável.</param>
        <param name="name">O nome do parâmetro ou da variável. Esse nome é usado apenas para finalidades de depuração ou de impressão.</param>
        <summary>Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</summary>
        <returns>Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Uma instância de <see cref="T:System.Func`2" />.</param>
        <summary>Reduz o nó e, em seguida, chama o representante de visitante na expressão reduzida. O método gera uma exceção se o nó não é reduzível.</summary>
        <returns>A expressão que está sendo visitado, ou uma expressão que deve substituí-lo na árvore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método para fornecer a lógica para percorrer os filhos do nó. Uma implementação típica chamará o visitante. Visite em cada um dos seus filhos, e se qualquer um dos-los alterar, deve retornar uma nova cópia de si mesmo com os filhos modificados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
