<Type Name="WriteableBitmap" FullName="System.Windows.Media.Imaging.WriteableBitmap">
  <TypeSignature Language="C#" Value="public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WriteableBitmap extends System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Imaging.WriteableBitmap" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Imaging.BitmapSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> que pode ser gravado e atualizado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Windows.Media.Imaging.WriteableBitmap> classe para atualizar e renderizar um bitmap em uma base por quadro. Isso é útil para gerar o conteúdo de algoritmo, como uma imagem fractal e para visualização de dados, como um visualizador de música.  
  
 O <xref:System.Windows.Media.Imaging.WriteableBitmap> classe usa dois buffers. O *buffer de fundo* é alocado na memória do sistema e acumula conteúdo que não é exibido no momento. O *buffer frontal* é alocado na memória do sistema e contém o conteúdo que está sendo exibido. O sistema de processamento copia front buffer de memória de vídeo para exibição.  
  
 Dois threads usam esses buffers. O *thread de interface do usuário* gera a interface do usuário, mas não o exibe na tela. O thread de interface do usuário responde à entrada do usuário, timers e outros eventos. Um aplicativo pode ter vários threads de interface do usuário. O *renderizar thread* compõe e processa as alterações do thread da interface do usuário. Há apenas uma renderização thread por aplicativo.  
  
 O thread de interface do usuário grava o conteúdo para o buffer de fundo. O thread de processamento lê o conteúdo do buffer frontal e copiá-lo para a memória de vídeo. As alterações para o buffer de fundo são rastreadas com regiões retangulares alteradas.  
  
 Chame um do <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> sobrecargas para atualizar e exibir o conteúdo de buffer de fundo automaticamente.  
  
 Para maior controle sobre atualizações e para acesso multithread para o buffer de fundo, use o seguinte fluxo de trabalho.  
  
1.  Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> método para reservar o buffer de fundo para as atualizações.  
  
2.  Obter um ponteiro para o buffer de fundo, acessando o <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> propriedade.  
  
3.  Grave alterações para o buffer de fundo. Outros threads podem gravar alterações para trás buffer quando o <xref:System.Windows.Media.Imaging.WriteableBitmap> está bloqueado.  
  
4.  Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> método para indicar áreas que foram alterados.  
  
5.  Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> método para liberar o buffer de fundo e permitir a apresentação na tela.  
  
 Quando as atualizações são enviadas para o thread de processamento, o thread de processamento copia os retângulos alterados do buffer de fundo no buffer frontal. O sistema de processamento controla essa troca para evitar deadlocks e redesenhar artefatos, como "divisão".  
  
   
  
## Examples  
 O exemplo a seguir demonstra como um <xref:System.Windows.Media.Imaging.WriteableBitmap> pode ser usado como a origem de um <xref:System.Windows.Controls.Image> para desenhar pixels quando o mouse é movido.  
  
 [!code-csharp[WriteableBitmap2#WriteableBitmapFullPage](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#writeablebitmapfullpage)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Imaging.BitmapSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Media.Imaging.BitmapSource" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> a ser usada para inicialização.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> usando a <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> fornecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> construtor é preferível usando este construtor.  
  
 Se `source` não usa um formato de bitmap suportados nativamente, formato conversões são aplicadas para cada atualização de quadro, o que reduz o desempenho.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 pixelWidth, int32 pixelHeight, float64 dpiX, float64 dpiY, valuetype System.Windows.Media.PixelFormat pixelFormat, class System.Windows.Media.Imaging.BitmapPalette palette) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pixelWidth" Type="System.Int32" />
        <Parameter Name="pixelHeight" Type="System.Int32" />
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
        <Parameter Name="pixelFormat" Type="System.Windows.Media.PixelFormat" />
        <Parameter Name="palette" Type="System.Windows.Media.Imaging.BitmapPalette" />
      </Parameters>
      <Docs>
        <param name="pixelWidth">A largura desejada do bitmap.</param>
        <param name="pixelHeight">A altura desejada do bitmap.</param>
        <param name="dpiX">Horizontal [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] do bitmap.</param>
        <param name="dpiY">Vertical [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] do bitmap.</param>
        <param name="pixelFormat">O <see cref="T:System.Windows.Media.PixelFormat" /> do bitmap.</param>
        <param name="palette">O <see cref="T:System.Windows.Media.Imaging.BitmapPalette" /> do bitmap.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> com os parâmetros especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os valores preferenciais para `pixelFormat` são <xref:System.Windows.Media.PixelFormats.Bgr32%2A> e <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. Esses formatos são suportados nativamente e não exigem uma conversão de formato. Outros `pixelFormat` valores exigem uma conversão de formato para cada atualização de quadro, o que reduz o desempenho.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">Um <see cref="T:System.Windows.Int32Rect" /> que representa a área que foi alterada. Dimensões estão em pixels.</param>
        <summary>Especifica a área do bitmap que foi alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> método para indicar as alterações que seu código tenha feito para o buffer de fundo.  
  
 Quando você chamar esse método várias vezes, as áreas alteradas são acumuladas em uma representação suficiente, mas não necessariamente mínima. Para eficiência, apenas as áreas que são marcadas como sujos são garantidas para ser copiado para a frente no buffer frontal. No entanto, qualquer parte do bitmap pode ser copiado para a frente, portanto certifique-se de que o buffer de fundo inteiro sempre será válido.  
  
 Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> método apenas entre as chamadas para o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> métodos, conforme descrito no <xref:System.Windows.Media.Imaging.WriteableBitmap> classe comentários.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como especificar a área da parte de trás de buffers que foram alteradas usando o <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> método.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O bitmap não foi bloqueado por uma chamada para o <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> ou <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" /> métodos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dirtyRect" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BackBuffer">
      <MemberSignature Language="C#" Value="public IntPtr BackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int BackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um ponteiro para o buffer de fundo.</summary>
        <value>Um <see cref="T:System.IntPtr" /> que aponta para o endereço básico do buffer de fundo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O buffer de fundo contém o conteúdo de bitmap no formato de pixel solicitado pelo usuário.  
  
 Atualizar o buffer de fundo somente entre as chamadas para o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> métodos. Se você não seguir o fluxo de trabalho de Bloquear/desbloquear descrito o <xref:System.Windows.Media.Imaging.WriteableBitmap> classe comentários indefinidos comportamentos, como divisão, podem ocorrer.  
  
 O endereço do buffer de fundo não é alterado.  
  
## <a name="thread-safety"></a>Segurança de threads  
 Você pode passar o <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> ponteiro para componentes externos e outros threads de processamento, mas se você fizer isso, você deve fornecer você coordenação próprio thread. Em particular, você deve garantir que o thread de interface do usuário Especifica áreas alteradas chamando o <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> método, e que o thread de interface do usuário desbloqueia o buffer ao chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackBufferStride">
      <MemberSignature Language="C#" Value="public int BackBufferStride { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BackBufferStride" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o número de bytes em uma única linha de dados de pixel.</summary>
        <value>Um inteiro que indica o número de bytes em uma única linha de dados de pixel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável desse <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />, fazendo cópias em profundidade dos valores do objeto. Ao copiar as propriedades de dependência, esse método copia associações de dados e referências de recurso (mas eles não podem mais resolver), mas não animações ou seus valores atuais.</summary>
        <returns>Um clone modificável do objeto atual. O objeto clonado <see cref="P:System.Windows.Freezable.IsFrozen" /> propriedade será <see langword="false" /> mesmo se a fonte <see cref="P:System.Windows.Freezable.IsFrozen" /> era de propriedade<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado para produzir cópias modificáveis de congelada <xref:System.Windows.Freezable> objetos (ou qualquer <xref:System.Windows.Freezable> objeto). Para sua conveniência, este método sombreia a versão herdada com uma implementação fortemente tipada.  
  
 Para obter mais informações, consulte <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável desse objeto <see cref="T:System.Windows.Media.Animation.ByteAnimationUsingKeyFrames" />, fazendo cópias em profundidade dos valores do objeto atual. Referências a recursos, vinculações de dados e animações não são copiadas, mas seus valores atuais são.</summary>
        <returns>Um clone modificável do objeto atual. O objeto clonado <see cref="P:System.Windows.Freezable.IsFrozen" /> propriedade será <see langword="false" /> mesmo se a fonte <see cref="P:System.Windows.Freezable.IsFrozen" /> propriedade era <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado para produzir cópias modificáveis de congelada <xref:System.Windows.Freezable> objetos (ou qualquer <xref:System.Windows.Freezable> objeto). Para sua conveniência, este método sombreia a versão herdada com uma implementação fortemente tipada.  
  
 Para obter mais informações, consulte <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reserva o buffer de fundo para atualizações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> método incrementa a contagem de bloqueio. Quando um <xref:System.Windows.Media.Imaging.WriteableBitmap> é bloqueado, o sistema de processamento não enviar atualizações até que o <xref:System.Windows.Media.Imaging.WriteableBitmap> é totalmente desbloqueado por chamadas para o <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> método.  
  
 Você pode usar o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> método para dar suporte a implementações multi-threads. Nesses cenários, o thread de interface do usuário bloqueia o bitmap e expõe o buffer de fundo para outros threads. Quando o thread de trabalho termina um quadro, o thread de interface do usuário adiciona a retângulos alterados e desbloqueia o buffer.  
  
 O thread de interface do usuário pode bloquear quando o thread de processamento adquire um bloqueio no buffer de fundo para copiá-lo para a frente no buffer frontal. Se a latência desse bloco é muito longa, use o <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> método Aguarde um pouco e, em seguida, desbloquear o thread de interface do usuário para executar outras tarefas enquanto o buffer de fundo está bloqueado.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como reservar o buffer de fundo usando o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> método.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.Windows.Duration" /> que representa o tempo de espera. Um valor de 0 retorna imediatamente. Um valor de <see cref="P:System.Windows.Duration.Forever" /> bloqueia indefinidamente.</param>
        <summary>Tenta bloquear o bitmap, aguardando não mais do que o tempo especificado.</summary>
        <returns>
          <see langword="true" />Se o bloqueio foi adquirido; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um bloqueio é adquirido, o comportamento do <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> método é o mesmo que o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é definido como <see cref="P:System.Windows.Duration.Automatic" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera o buffer de fundo para torná-lo disponível para exibição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> diminui de método a contagem de bloqueio. Quando a contagem de bloqueios atinge 0, uma passagem de renderização é solicitada se o <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> método foi chamado.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como liberar o buffer de fundo usando o <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> método.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O bitmap não foi bloqueado por uma chamada para o <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> ou <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" /> métodos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array pixels, int32 stride, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="pixels" Type="System.Array" />
        <Parameter Name="stride" Type="System.Int32" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">O retângulo do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> a ser atualizado.</param>
        <param name="pixels">A matriz de pixel usada para atualizar o bitmap.</param>
        <param name="stride">A distância da região de atualização na <c>pixels</c>.</param>
        <param name="offset">O deslocamento do buffer de entrada.</param>
        <summary>Atualiza os pixels na região especificada do bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> sobrecargas têm preferência sobre usando esse método.  
  
> [!NOTE]
>  Em confiança parcial, use o <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de sobrecarga.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como atualizar um pixel no buffer de fundo usando o <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> método.  
  
 [!code-csharp[WriteableBitmap2#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uma ou mais das seguintes condições é verdadeira.  
  
 <paramref name="sourceRect" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="stride" /> &lt; 1  
  
 <paramref name="offset" /> &lt; 0</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pixels" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pixels" /> tem uma classificação diferente de 1 ou 2 ou seu tamanho é menor ou igual a 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int buffer, int32 bufferSize, int32 stride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="buffer" Type="System.IntPtr" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="stride" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">O retângulo do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> a ser atualizado.</param>
        <param name="buffer">O buffer de entrada usado para atualizar o bitmap.</param>
        <param name="bufferSize">O tamanho do buffer de entrada.</param>
        <param name="stride">A distância da região de atualização na <c>buffer</c>.</param>
        <summary>Atualiza os pixels na região especificada do bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> sobrecargas têm preferência sobre usando esse método.  
  
> [!NOTE]
>  Em confiança parcial, use o <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uma ou mais das seguintes condições é verdadeira.  
  
 <paramref name="sourceRect" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="bufferSize" /> &lt; 1  
  
 <paramref name="stride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array sourceBuffer, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.Array" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">O retângulo em <c>sourceBuffer</c> para copiar.</param>
        <param name="sourceBuffer">O buffer de entrada usado para atualizar o bitmap.</param>
        <param name="sourceBufferStride">A distância do buffer de entrada, em bytes.</param>
        <param name="destinationX">A destino coordenada x do pixel mais à esquerda no buffer de fundo.</param>
        <param name="destinationY">A destino coordenada y do pixel mais alto no buffer de fundo.</param>
        <summary>Atualiza os pixels na região especificada do bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> para atualizar o <xref:System.Windows.Media.Imaging.WriteableBitmap> automaticamente com o conteúdo de `sourceBuffer`. Chamar esse método é o equivalente a usar o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> fluxo de trabalho descrito no <xref:System.Windows.Media.Imaging.WriteableBitmap> classe comentários.  
  
> [!NOTE]
>  Use essa sobrecarga em confiança parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uma ou mais das seguintes condições é verdadeira.  
  
 <paramref name="sourceRect" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" />ou <paramref name="destinationY" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceBuffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceBuffer" /> tem uma classificação diferente de 1 ou 2 ou seu tamanho é menor ou igual a 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int sourceBuffer, int32 sourceBufferSize, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.IntPtr" />
        <Parameter Name="sourceBufferSize" Type="System.Int32" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">O retângulo em <c>sourceBuffer</c> para copiar.</param>
        <param name="sourceBuffer">O buffer de entrada usado para atualizar o bitmap.</param>
        <param name="sourceBufferSize">O tamanho do buffer de entrada.</param>
        <param name="sourceBufferStride">A distância do buffer de entrada, em bytes.</param>
        <param name="destinationX">A destino coordenada x do pixel mais à esquerda no buffer de fundo.</param>
        <param name="destinationY">A destino coordenada y do pixel mais alto no buffer de fundo.</param>
        <summary>Atualiza os pixels na região especificada do bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> para atualizar o <xref:System.Windows.Media.Imaging.WriteableBitmap> automaticamente com o conteúdo de `sourceBuffer`. Chamar esse método é o equivalente a usar o <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> fluxo de trabalho descrito no <xref:System.Windows.Media.Imaging.WriteableBitmap> classe comentários.  
  
> [!NOTE]
>  Em confiança parcial, use o <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uma ou mais das seguintes condições é verdadeira.  
  
 <paramref name="sourceRect" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" />ou <paramref name="destinationY" /> está fora dos limites do <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferSize" /> &lt; 1  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceBuffer" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar os recursos não gerenciados. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
