<Type Name="ControlStyles" FullName="System.Windows.Forms.ControlStyles">
  <TypeSignature Language="C#" Value="public enum ControlStyles" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ControlStyles extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ControlStyles" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica o estilo e comportamento de um controle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de usam essa enumeração em várias propriedades e métodos para especificar a funcionalidade. Um controle pode habilitar um estilo chamando o <xref:System.Windows.Forms.Control.SetStyle%2A> método e passando apropriada <xref:System.Windows.Forms.ControlStyles> bit (ou bits) e o valor booliano para definir o ão para. Por exemplo, a seguinte linha de código do Visual Basic deve habilitar o buffer duplo.  
  
```  
myControl.SetStyle(UserPaint Or AllPaintingInWmPaint Or DoubleBuffer, True)  
```  
  
 Se o bit AllPaintingInWmPaint é definido como `true`, a mensagem de janela WM_ERASEBKGND é ignorado e ambos <xref:System.Windows.Forms.Control.OnPaintBackground%2A> e <xref:System.Windows.Forms.Control.OnPaint%2A> métodos são chamados diretamente da mensagem de janela WM_PAINT. Isso geralmente reduz a cintilação, a menos que outros controles de enviar a mensagem de janela WM_ERASEBKGND para o controle. Você pode enviar a mensagem de janela WM_ERASEBKGRND para atingir um efeito de transparência pseudo semelhante a SupportsTransparentBackColor; Por exemplo, um <xref:System.Windows.Forms.ToolBar> com aparência simples faz isso.  
  
 Para habilitar completamente o buffer duplo, você pode definir os bits OptimizedDoubleBuffer e AllPaintingInWmPaint para `true`. No entanto, o método preferencial para habilitar o buffer duplo, o que produz o mesmo resultado, é definir o <xref:System.Windows.Forms.Control.DoubleBuffered%2A> propriedade para o controle `true`.  
  
 Se o bit SupportsTransparentBackColor é definido como `true`e o <xref:System.Windows.Forms.Control.BackColor%2A> é definido como uma cor cujo componente alfa é menor que 255 <xref:System.Windows.Forms.Control.OnPaintBackground%2A> simulará transparência solicitando controle pai para pintar o plano de fundo. Isso não é verdadeira transparência.  
  
> [!NOTE]
>  Se houver outro controle entre o controle e seu pai, o controle atual não mostrará o controle no meio.  
  
 Quando o bit UserMouse é definido como `true`, ainda são chamados de métodos a seguir: <xref:System.Windows.Forms.Control.OnMouseDown%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.OnMouseUp%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.OnMouseEnter%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.OnMouseMove%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.OnMouseHover%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.OnMouseLeave%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.Control.OnMouseWheel%2A?displayProperty=nameWithType>.  
  
 Quando o controle é clicado, se o bit StandardClick é definido como `true` o <xref:System.Windows.Forms.Control.OnClick%2A?displayProperty=nameWithType> é chamado de método e gera o <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> evento. Quando o controle é clicado duas vezes, e o StandardClick e StandardDoubleClick bits são definidos como `true`, clique em é passado para o <xref:System.Windows.Forms.Control.DoubleClick> evento. Em seguida, o <xref:System.Windows.Forms.Control.OnDoubleClick%2A?displayProperty=nameWithType> é chamado de método e gera o <xref:System.Windows.Forms.Control.DoubleClick?displayProperty=nameWithType> evento. No entanto, o controle pode chamar <xref:System.Windows.Forms.Control.OnClick%2A> ou <xref:System.Windows.Forms.Control.OnDoubleClick%2A> diretamente, independentemente do StandardClick e StandardDoubleClick valores de bit. Para obter mais informações sobre o controle clique e clique duas vezes em comportamentos, consulte o <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> e <xref:System.Windows.Forms.Control.DoubleClick?displayProperty=nameWithType> tópicos.  
  
 Quando o bit UseTextForAccessibility é definido e houver um valor no controle do `Text` propriedade, o valor desse controle `Text` determina de propriedade do controle padrão acessibilidade ativa nome e tecla de atalho. Caso contrário, o texto dos <xref:System.Windows.Forms.Label> controle será usado. Este estilo é definido por padrão. Tipos de determinado controle interno, como <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.ComboBox>, redefinir esse estilo para que o `Text` propriedade desses controles não será usada pela acessibilidade ativa.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso de <xref:System.Windows.Forms.ControlStyles> com o <xref:System.Windows.Forms.Control.StyleChanged> evento.  
  
 [!code-cpp[Control_StyleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_StyleChanged/CPP/control_stylechanged.cpp#1)]
 [!code-csharp[Control_StyleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_StyleChanged/CS/control_stylechanged.cs#1)]
 [!code-vb[Control_StyleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_StyleChanged/VB/control_stylechanged.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Herdando um controle de formulários do Windows padrão e alterando o <see cref="F:System.Windows.Forms.ControlStyles.StandardClick" /> ou <see cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" /> bit valores <see langword="true" /> pode causar um comportamento inesperado ou pode não ter nenhum efeito de se o controle não oferece suporte a <see cref="E:System.Windows.Forms.Control.Click" /> ou <see cref="E:System.Windows.Forms.Control.DoubleClick" /> eventos.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="AllPaintingInWmPaint">
      <MemberSignature Language="C#" Value="AllPaintingInWmPaint" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles AllPaintingInWmPaint = int32(8192)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.AllPaintingInWmPaint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle ignorará a mensagem da janela WM_ERASEBKGND para reduzir a cintilação. Esse estilo deverá ser aplicado somente se o bit <see cref="F:System.Windows.Forms.ControlStyles.UserPaint" /> for definido como <see langword="true" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="CacheText">
      <MemberSignature Language="C#" Value="CacheText" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles CacheText = int32(16384)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.CacheText" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle manterá uma cópia do texto, em vez de obtê-lo do <see cref="P:System.Windows.Forms.Control.Handle" /> sempre que necessário. Esse estilo usa <see langword="false" /> como padrão. Esse comportamento melhora o desempenho, mas dificulta manter o texto sincronizado.</summary>
      </Docs>
    </Member>
    <Member MemberName="ContainerControl">
      <MemberSignature Language="C#" Value="ContainerControl" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles ContainerControl = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.ContainerControl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle será um controle semelhante ao contêiner.</summary>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffer">
      <MemberSignature Language="C#" Value="DoubleBuffer" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles DoubleBuffer = int32(65536)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.DoubleBuffer" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, um desenho será feito em um buffer e, após sua conclusão, o resultado será gerado na tela. O buffer duplo impede a cintilação causada pelo redesenho do controle. Se você definir <see cref="F:System.Windows.Forms.ControlStyles.DoubleBuffer" /> como <see langword="true" />, também deverá definir <see cref="F:System.Windows.Forms.ControlStyles.UserPaint" /> e <see cref="F:System.Windows.Forms.ControlStyles.AllPaintingInWmPaint" /> como <see langword="true" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="EnableNotifyMessage">
      <MemberSignature Language="C#" Value="EnableNotifyMessage" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles EnableNotifyMessage = int32(32768)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.EnableNotifyMessage" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o método <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> será chamado para cada mensagem enviada para o <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> do controle. Esse estilo usa <see langword="false" /> como padrão. <see cref="F:System.Windows.Forms.ControlStyles.EnableNotifyMessage" /> não funciona em uma relação de confiança parcial.</summary>
      </Docs>
    </Member>
    <Member MemberName="FixedHeight">
      <MemberSignature Language="C#" Value="FixedHeight" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles FixedHeight = int32(64)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.FixedHeight" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle terá uma altura fixa quando sua escala for ajustada automaticamente. Por exemplo, se uma operação de layout tentar ajustar a escala do controle para acomodar um novo <see cref="T:System.Drawing.Font" />, o <see cref="P:System.Windows.Forms.Control.Height" /> do controle permanecerá inalterado.</summary>
      </Docs>
    </Member>
    <Member MemberName="FixedWidth">
      <MemberSignature Language="C#" Value="FixedWidth" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles FixedWidth = int32(32)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.FixedWidth" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle terá uma largura fixa quando sua escala for ajustada automaticamente. Por exemplo, se uma operação de layout tentar ajustar a escala do controle para acomodar um novo <see cref="T:System.Drawing.Font" />, o <see cref="P:System.Windows.Forms.Control.Width" /> do controle permanecerá inalterado.</summary>
      </Docs>
    </Member>
    <Member MemberName="Opaque">
      <MemberSignature Language="C#" Value="Opaque" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles Opaque = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.Opaque" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle será desenhado opaco e a tela de fundo não será pintada.</summary>
      </Docs>
    </Member>
    <Member MemberName="OptimizedDoubleBuffer">
      <MemberSignature Language="C#" Value="OptimizedDoubleBuffer" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles OptimizedDoubleBuffer = int32(131072)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle será desenhado primeiro em um buffer, em vez de diretamente na tela, o que poderá reduzir a cintilação. Se você definir essa propriedade como <see langword="true" />, também deverá definir o <see cref="F:System.Windows.Forms.ControlStyles.AllPaintingInWmPaint" /> como <see langword="true" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="ResizeRedraw" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles ResizeRedraw = int32(16)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle será redesenhado quando for redimensionado.</summary>
      </Docs>
    </Member>
    <Member MemberName="Selectable">
      <MemberSignature Language="C#" Value="Selectable" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles Selectable = int32(512)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.Selectable" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle poderá receber o foco.</summary>
      </Docs>
    </Member>
    <Member MemberName="StandardClick">
      <MemberSignature Language="C#" Value="StandardClick" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles StandardClick = int32(256)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.StandardClick" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle implementará o comportamento <see cref="E:System.Windows.Forms.Control.Click" /> padrão.</summary>
      </Docs>
    </Member>
    <Member MemberName="StandardDoubleClick">
      <MemberSignature Language="C#" Value="StandardDoubleClick" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles StandardDoubleClick = int32(4096)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle implementará o comportamento <see cref="E:System.Windows.Forms.Control.DoubleClick" /> padrão. Esse estilo será ignorado se o bit <see cref="F:System.Windows.Forms.ControlStyles.StandardClick" /> não for definido como <see langword="true" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="SupportsTransparentBackColor">
      <MemberSignature Language="C#" Value="SupportsTransparentBackColor" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles SupportsTransparentBackColor = int32(2048)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.SupportsTransparentBackColor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle aceitará um <see cref="P:System.Windows.Forms.Control.BackColor" /> com um componente alfa de menos de 255 para simular a transparência. A transparência será simulada somente se o bit <see cref="F:System.Windows.Forms.ControlStyles.UserPaint" /> for definido como <see langword="true" /> e o controle pai for derivado de <see cref="T:System.Windows.Forms.Control" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="UserMouse">
      <MemberSignature Language="C#" Value="UserMouse" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles UserMouse = int32(1024)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.UserMouse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle fará seu próprio processamento de mouse e os eventos do mouse não serão manipulados pelo sistema operacional.</summary>
      </Docs>
    </Member>
    <Member MemberName="UserPaint">
      <MemberSignature Language="C#" Value="UserPaint" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles UserPaint = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.UserPaint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se for <see langword="true" />, o controle pintará a si próprio em vez de ser pintado pelo sistema operacional. Se for <see langword="false" />, o evento <see cref="E:System.Windows.Forms.Control.Paint" /> não será gerado. Esse estilo se aplica apenas às classes derivadas de <see cref="T:System.Windows.Forms.Control" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="UseTextForAccessibility">
      <MemberSignature Language="C#" Value="UseTextForAccessibility" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Windows.Forms.ControlStyles UseTextForAccessibility = int32(262144)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ControlStyles.UseTextForAccessibility" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o valor do controle <c>texto</c> propriedade, se definido, determina a chave de nome e o atalho de acessibilidade ativa de padrão do controle.</summary>
      </Docs>
    </Member>
  </Members>
</Type>
