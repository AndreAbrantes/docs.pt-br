<Type Name="DbExpressionBuilder" FullName="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder">
  <TypeSignature Language="C#" Value="public static class DbExpressionBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DbExpressionBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece uma API para construir <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s e permite que essa API para ser acessado como métodos de extensão do tipo de expressão em si.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">A função que define a operação de agregação.</param>
        <param name="argument">O argumento durante o qual a função de agregação deve ser calculada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" />.</summary>
        <returns>Uma nova função de agregação com uma referência para a função fornecida e o argumento. Propriedade distinta da agregação de função terá o valor <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" />ou <paramref name="argument" /> nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" />não é uma função de agregação ou tem mais de um argumento ou o tipo de resultado de <paramref name="argument" /> não é passível de promoção ou igual ao tipo de parâmetro do <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateDistinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">A função que define a operação de agregação.</param>
        <param name="argument">O argumento durante o qual a função de agregação deve ser calculada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" /> que é aplicada de modo distinto.</summary>
        <returns>Uma nova função de agregação com uma referência para a função fornecida e o argumento. Propriedade distinta da agregação de função terá o valor <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> ou <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" />não é uma função de agregação ou tem mais de um argumento ou o tipo de resultado de <paramref name="argument" /> não é passível de promoção ou igual ao tipo de parâmetro do <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="predicate">Um método que representa um predicado a ser avaliada para cada membro do conjunto de entrada.    Esse método deve produzir uma expressão com um tipo de resultado booleano que fornece a lógica de predicado.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina se o predicado em questão mantém todos os elementos do conjunto de entrada.</summary>
        <returns>Um novo DbQuantifierExpression que representa a operação de todos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="predicate" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="Predicate" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Uma expressão de associação que especifica o conjunto de entrada.</param>
        <param name="predicate">Uma expressão que representa um predicado a ser avaliada para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina se o predicado em questão mantém todos os elementos do conjunto de entrada.</summary>
        <returns>Um novo DbQuantifierExpression que representa a operação de todos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="predicate" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" />não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbAndExpression And (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbAndExpression And(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbAndExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão booleana que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão booleana que especifica o argumento da direita.</param>
        <summary>Cria um <see cref="T:System.Data.Common.CommandTrees.DbAndExpression" /> que executa a lógica e os argumentos esquerdo e direito.</summary>
        <returns>Um novo DbAndExpression com os argumentos especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />e <paramref name="right" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Any (this System.Data.Common.CommandTrees.DbExpression source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Any(class System.Data.Common.CommandTrees.DbExpression source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que determina se o argumento do conjunto especificado não está vazio.</summary>
        <returns>Um novo <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> aplicada a um novo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> com o argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="predicate">Um método que representa o predicado a ser avaliada para cada membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo de resultado booleano que fornece a lógica de predicado.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina se o predicado em questão se qualquer elemento do conjunto de entrada.</summary>
        <returns>Um novo DbQuantifierExpression que representa a qualquer operação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="predicate" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="predicate" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Uma expressão de associação que especifica o conjunto de entrada.</param>
        <param name="predicate">Uma expressão que representa um predicado a ser avaliada para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina se o predicado em questão se qualquer elemento do conjunto de entrada.</summary>
        <returns>Um novo DbQuantifierExpression que representa a qualquer operação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="predicate" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="predicate" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt; As (this System.Data.Common.CommandTrees.DbAggregate value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt; As(class System.Data.Common.CommandTrees.DbAggregate value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbAggregate,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbAggregate" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">O valor no par chave/valor.</param>
        <param name="alias">A chave do par chave/valor.</param>
        <summary>Retorna os argumentos especificados como um objeto do par chave/valor.</summary>
        <returns>Um objeto do par chave/valor.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt; As (this System.Data.Common.CommandTrees.DbExpression value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt; As(class System.Data.Common.CommandTrees.DbExpression value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">O valor no par chave/valor.</param>
        <param name="alias">A chave do par chave/valor.</param>
        <summary>Retorna os argumentos especificados como um objeto do par chave/valor.</summary>
        <returns>Um objeto do par chave/valor.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding Bind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding Bind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">A expressão para associar.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que usa um nome de variável gerado para associar a expressão especificada.</summary>
        <returns>Uma nova associação de expressão com a expressão especificada e um nome de variável gerado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />não tem um resultado de coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding BindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding BindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A expressão para associar.</param>
        <param name="varName">O nome da variável deve ser usado para a associação.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que usa o nome da variável especificado para associar a expressão especificada</summary>
        <returns>Uma nova associação de expressão com a expressão especificada e o nome da variável.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="varName" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />não tem um resultado de coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="Case">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCaseExpression Case (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, System.Data.Common.CommandTrees.DbExpression elseExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCaseExpression Case(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, class System.Data.Common.CommandTrees.DbExpression elseExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCaseExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="whenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="thenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="elseExpression" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="whenExpressions">Uma lista de expressões que forneçam a condicional para de cada caso.</param>
        <param name="thenExpressions">Uma lista de expressões que forneçam o resultado de cada caso.</param>
        <param name="elseExpression">Uma expressão que define o resultado quando nenhuma ocorrência for correspondida.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbCaseExpression" />.</summary>
        <returns>Um novo DbCaseExpression com os casos especificados e o resultado de padrão.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="whenExpressions" />ou <paramref name="thenExpressions" /> é nulo ou contém nulo, ou <paramref name="elseExpression" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="whenExpressions" />ou <paramref name="thenExpressions" /> está vazio ou <paramref name="whenExpressions" /> contém uma expressão com um tipo de resultado não boolianos, ou nenhum tipo de resultado comum existe para todas as expressões na <paramref name="thenExpressions" /> e <paramref name="elseExpression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CastTo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCastExpression CastTo (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage toType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCastExpression CastTo(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage toType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCastExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="toType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">O argumento para o qual a conversão deve ser aplicada.</param>
        <param name="toType">Metadados do tipo que especifica o tipo a ser convertido.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbCastExpression" /> que se aplica a uma operação de conversão de um argumento polimórficas.</summary>
        <returns>Um novo DbCastExpression com o tipo de argumento e de destino especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> ou <paramref name="toType" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A conversão especificada não é válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor constante a ser representado.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> com o valor constante fornecido.</summary>
        <returns>Uma novo DbConstantExpression com o valor especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />não é uma instância de um tipo de constante válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (this System.Data.Metadata.Edm.TypeUsage constantType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(class System.Data.Metadata.Edm.TypeUsage constantType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Data.Metadata.Edm.TypeUsage,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constantType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="constantType">O tipo do valor constante.</param>
        <param name="value">O valor constante a ser representado.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> do tipo primitivo especificado com o valor constante fornecido.</summary>
        <returns>Um novo DbConstantExpression com o valor especificado e um tipo de resultado de <paramref name="constantType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ou <paramref name="constantType" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> não é uma instância de um tipo de constante válido, <paramref name="constantType" /> não representa um tipo primitivo ou <paramref name="value" /> é de um tipo primitivo diferente daquele representado por <paramref name="constantType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">O conjunto de entidades em que reside o elemento referenciado.</param>
        <param name="keyValues">Uma coleção de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />que fornecem os valores de chave. Essas expressões devem corresponder (em número, tipo e ordem) as propriedades de chave do tipo de entidade referenciada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica uma referência a uma entidade específica com base em valores de chave.</summary>
        <returns>Um novo DbRefExpression que referencia o elemento com os valores de chave especificados no conjunto de entidades determinado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />é nulo, ou <paramref name="keyValues" /> é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="keyValues" /> não coincide com a contagem de membros de chave declaradas pelo <paramref name="entitySet" />do tipo de elemento ou <paramref name="keyValues" /> contém uma expressão com um tipo de resultado que não é compatível com o tipo do membro de chave correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">O conjunto de entidades em que reside o elemento referenciado.</param>
        <param name="keyValues">Uma coleção de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />que fornecem os valores de chave. Essas expressões devem corresponder (em número, tipo e ordem) as propriedades de chave do tipo de entidade referenciada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica uma referência a uma entidade específica com base em valores de chave.</summary>
        <returns>Um novo DbRefExpression que referencia o elemento com os valores de chave especificados no conjunto de entidades determinado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />é nulo, ou <paramref name="keyValues" /> é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="keyValues" /> não coincide com a contagem de membros de chave declaradas pelo <paramref name="entitySet" />do tipo de elemento ou <paramref name="keyValues" /> contém uma expressão com um tipo de resultado que não é compatível com o tipo do membro de chave correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">O conjunto de entidades em que reside o elemento referenciado.</param>
        <param name="entityType">O tipo específico da entidade referenciada. Isso deve ser um tipo de entidade da mesma hierarquia como tipo de elemento do conjunto de entidades.</param>
        <param name="keyValues">Uma coleção de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />que fornecem os valores de chave. Essas expressões devem corresponder (em número, tipo e ordem) as propriedades de chave do tipo de entidade referenciada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica uma referência a uma entidade específica de um determinado tipo com base em valores de chave.</summary>
        <returns>Um novo DbRefExpression que referencia o elemento com os valores de chave especificados no conjunto de entidades determinado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />ou <paramref name="entityType" /> é nulo, ou <paramref name="keyValues" /> é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="keyValues" /> não coincide com a contagem de membros de chave declaradas pelo <paramref name="entitySet" />do tipo de elemento ou <paramref name="keyValues" /> contém uma expressão com um tipo de resultado que não é compatível com o tipo do membro de chave correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">O conjunto de entidades em que reside o elemento referenciado.</param>
        <param name="entityType">O tipo específico da entidade referenciada. Isso deve ser um tipo de entidade da mesma hierarquia como tipo de elemento do conjunto de entidades.</param>
        <param name="keyValues">Uma coleção de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />que fornecem os valores de chave. Essas expressões devem corresponder (em número, tipo e ordem) as propriedades de chave do tipo de entidade referenciada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica uma referência a uma entidade específica de um determinado tipo com base em valores de chave.</summary>
        <returns>Um novo DbRefExpression que referencia o elemento com os valores de chave especificados no conjunto de entidades determinado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />ou <paramref name="entityType" /> é nulo, ou <paramref name="keyValues" /> é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="keyValues" /> não coincide com a contagem de membros de chave declaradas pelo <paramref name="entitySet" />do tipo de elemento ou <paramref name="keyValues" /> contém uma expressão com um tipo de resultado que não é compatível com o tipo do membro de chave correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o conjunto de entrada.</param>
        <param name="apply">Um método que especifica a lógica para avaliar uma vez para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que avalia a determinado <paramref name="apply" /> expressão uma vez para cada elemento de uma determinada entrada definida, produzindo um conjunto de linhas com entradas correspondentes e se aplicam a colunas. Linhas para as quais <paramref name="apply" /> é avaliada para um conjunto vazio não são incluídos.</summary>
        <returns>Um novo DbApplyExpression com especificado de entrada e aplicação de associações e um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O resultado de <paramref name="apply" /> contém um nome ou uma expressão que é nulo.</exception>
        <exception cref="T:System.ArgumentException">O resultado de <paramref name="apply" /> contém um nome ou uma expressão que não é válido em uma associação de expressão.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o conjunto de entrada.</param>
        <param name="apply">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica a lógica para avaliar uma vez para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que avalia a determinado <paramref name="apply" /> expressão uma vez para cada elemento de uma determinada entrada definida, produzindo um conjunto de linhas com entradas correspondentes e se aplicam a colunas. Linhas para as quais <paramref name="apply" /> é avaliada para um conjunto vazio não são incluídos.</summary>
        <returns>Um novo DbApplyExpression com especificado de entrada e aplicação de associações e um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="apply" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpressionBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCrossJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Uma lista de associações de expressão que especifica os conjuntos de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbCrossJoinExpression" /> que incondicionalmente une os conjuntos especificados pela lista de associações de expressão de entrada.</summary>
        <returns>Um novo DbCrossJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de junção cruzada, que representa a junção incondicional dos conjuntos de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputs" />é nulo ou contém elemento nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputs" />contém menos de 2 associações de expressão.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deref">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDerefExpression Deref (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDerefExpression Deref(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDerefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que fornece a referência. Essa expressão deve ter um tipo de referência.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression" /> que recupera uma entidade específica, considerando uma expressão de referência.</summary>
        <returns>Um novo DbDerefExpression que recupera a entidade especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado de referência.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDistinctExpression Distinct (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDistinctExpression Distinct(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDistinctExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que define o conjunto em que para executar a operação distinta.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbDistinctExpression" /> que remove duplicatas do argumento de determinado conjunto.</summary>
        <returns>Um novo DbDistinctExpression que representa a operação distinta aplicada para o argumento do conjunto especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Divide (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Divide(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que divide o argumento da esquerda, o argumento da direita.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação de divisão.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico comum entre <paramref name="left" /> ou <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbElementExpression Element (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbElementExpression Element(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbElementExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica o conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbElementExpression" /> que converte um conjunto em um singleton.</summary>
        <returns>Um DbElementExpression que representa a conversão do conjunto de argumento em um singleton.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression Equal (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression Equal(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que compara os argumentos esquerdo e direito de igualdade.</summary>
        <returns>Um novo DbComparisonExpression que representa a comparação de igualdade.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado comparável por igualdade comuns entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExceptExpression Except (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExceptExpression Except(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExceptExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que define esquerda defina um argumento.</param>
        <param name="right">Uma expressão que define o direito de define o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbExceptExpression" /> que calcula a subtração do argumento à direita do conjunto do argumento de conjunto à esquerda.</summary>
        <returns>Uma nova DbExceptExpression que representa a diferença entre o argumento esquerdo do argumento à direita.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado de coleção comuns entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Exists (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Exists(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica o conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que determina se o argumento do conjunto especificado não está vazio.</summary>
        <returns>Um novo <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> aplicada a um novo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> com o argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="False">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression False { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression False" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> com o valor booliano <see langword="false" />.</summary>
        <value>Um <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> com o valor booliano <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Filter (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Filter(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Uma expressão de associação que especifica o conjunto de entrada.</param>
        <param name="predicate">Uma expressão que representa um predicado a ser avaliada para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> que filtra os elementos na entrada fornecida definido usando o predicado especificado.</summary>
        <returns>Um novo DbFilterExpression que produz o conjunto filtrado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="predicate" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" />não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto à esquerda.</param>
        <param name="right">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o direito de define o argumento.</param>
        <param name="joinCondition">Um método que representa a condição na qual se unir. Esse método deve produzir uma expressão com um tipo de resultado booleano que fornece a lógica da condição de junção.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas expressões esquerdas e direita, da condição de junção especificada, usando FullOuterJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de FullOuterJoin, que representa a operação de junção externa completa aplicada aos conjuntos de entrada à esquerda e direito sob a condição de junção especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="joinCondition" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="joinCondition" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o argumento de conjunto à esquerda.</param>
        <param name="right">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o direito de define o argumento.</param>
        <param name="joinCondition">Uma expressão que especifica a condição na qual se unir.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas esquerda e direita associações de expressão, da condição de junção especificada, usando FullOuterJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de FullOuterJoin, que representa a operação de junção externa completa aplicada aos conjuntos de entrada à esquerda e direito sob a condição de junção especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> ou <paramref name="joinCondition" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="joinCondition" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntityRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbEntityRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">A expressão que fornece a entidade. Essa expressão deve ter um tipo de resultado da entidade.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression" /> que recupera a referência da entidade especificada no formulário estrutural.</summary>
        <returns>Um novo DbEntityRefExpression que recupera uma referência para a entidade especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado da entidade.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRefKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefKeyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">A expressão que fornece a referência. Essa expressão deve ter um tipo com um tipo de elemento de entidade de referência.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression" /> que recupera os valores de chave da referência especificada no formulário estrutural.</summary>
        <returns>Um novo DbRefKeyExpression que recupera os valores de chave de referência especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado de referência.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina se o argumento esquerdo é maior que o argumento da direita.</summary>
        <returns>Um novo DbComparisonExpression que representa o maior-comparação de.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado comparável por ordem comuns entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina se o argumento esquerdo for maior que ou igual ao argumento direito.</summary>
        <returns>Um novo DbComparisonExpression que representa a comparação maior que-ou-igual a.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado comparável por ordem comuns entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">A expressão para associar.</param>
        <summary>Cria uma nova associação de expressão de grupo que usa a variável gerada e nomes de variáveis de grupo para associar a expressão especificada.</summary>
        <returns>Uma nova associação de expressão de grupo com a expressão especificada e um nome de variável gerado e o nome de variável de grupo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs(System.Data.Common.CommandTrees.DbExpression,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
        <Parameter Name="groupVarName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A expressão para associar.</param>
        <param name="varName">O nome da variável deve ser usado para a associação.</param>
        <param name="groupVarName">O nome da variável deve ser usado para fazer referência ao grupo quando a nova associação de expressão de grupo é usada em uma expressão group by.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> que usa o nome de variável especificado e os nomes de variável de grupo para associar a expressão especificada.</summary>
        <returns>Uma nova associação de expressão de grupo com a expressão especificada, o nome da variável e o nome de variável de grupo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="varName" /> ou <paramref name="groupVarName" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupByExpression GroupBy (this System.Data.Common.CommandTrees.DbGroupExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupByExpression GroupBy(class System.Data.Common.CommandTrees.DbGroupExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy(System.Data.Common.CommandTrees.DbGroupExpressionBinding,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbAggregate}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupByExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbGroupExpressionBinding" RefType="this" />
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
        <Parameter Name="aggregates" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Um <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> que especifica o conjunto de entrada.</param>
        <param name="keys">Uma lista de pares de expressão de cadeia de caracteres que definem as colunas de agrupamento.</param>
        <param name="aggregates">Uma lista de expressões que especificam agregações para aplicar.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbGroupByExpression" /> que agrupa os elementos de entrada definida de acordo com as chaves de grupo especificado e aplica as agregações determinadas.</summary>
        <returns>Uma novo DbGroupByExpression com o conjunto de entrada especificado, as chaves de agrupamento e agregações.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbGroupByExpression permite que a lista de chaves ou a lista de agregações em branco, mas não ambos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="keys" /> ou <paramref name="aggregates" /> for nulo, <paramref name="keys" /> contém uma chave nula de coluna ou expressão, ou <paramref name="aggregates" /> contém um nome de coluna agregada nulo ou uma agregação.</exception>
        <exception cref="T:System.ArgumentException">Ambos <paramref name="keys" /> e <paramref name="aggregates" /> está vazio ou inválido ou nome de coluna duplicado foi especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto à esquerda.</param>
        <param name="right">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o direito de define o argumento.</param>
        <param name="joinCondition">Um método que representa a condição na qual se unir. Esse método deve produzir uma expressão com um tipo de resultado booleano que fornece a lógica da condição de junção.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas expressões esquerdas e direita, da condição de junção especificada, usando InnerJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa a operação de junção interna aplicada aos conjuntos de entrada à esquerda e direito sob a condição de junção especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="joinCondition" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="joinCondition" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o argumento de conjunto à esquerda.</param>
        <param name="right">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o direito de define o argumento.</param>
        <param name="joinCondition">Uma expressão que especifica a condição na qual se unir.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas esquerda e direita associações de expressão, da condição de junção especificada, usando InnerJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa a operação de junção interna aplicada aos conjuntos de entrada à esquerda e direito sob a condição de junção especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> ou <paramref name="joinCondition" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" />não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIntersectExpression Intersect (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIntersectExpression Intersect(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIntersectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que define esquerda defina um argumento.</param>
        <param name="right">Uma expressão que define o direito de define o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbIntersectExpression" /> que calcula a interseção de esquerda e direita definir argumentos.</summary>
        <returns>Um novo DbIntersectExpression que representa a interseção dos argumentos esquerdos e direito.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado de coleção comuns entre <paramref name="left" /> ou <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="lambda">Um <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> instância que representa a função Lambda para aplicar.</param>
        <param name="arguments">Uma lista de expressões que forneça os argumentos.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> que representa o aplicativo da função Lambda especificado para argumentos determinados.</summary>
        <returns>Um novo DbLambdaExpression que representa o aplicativo de função Lambda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> ou <paramref name="arguments" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="arguments" /> não é igual ao número de variáveis declaradas por <paramref name="lambda" />, ou <paramref name="arguments" /> contém uma expressão que tem um tipo de resultado que não seja igual ou passível de promoção para o tipo de variável correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="lambda">Um <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> instância que representa a função Lambda para aplicar.</param>
        <param name="arguments">Expressões que fornecem os argumentos.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> que representa o aplicativo da função Lambda especificado para argumentos determinados.</summary>
        <returns>Um novo DbLambdaExpression que representa o aplicativo de função Lambda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> ou <paramref name="arguments" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="arguments" /> não é igual ao número de variáveis declaradas por <paramref name="lambda" />, ou <paramref name="arguments" /> contém uma expressão que tem um tipo de resultado que não seja igual ou passível de promoção para o tipo de variável correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Metadados para a função para chamar.</param>
        <param name="arguments">Uma lista de expressões que forneça os argumentos para a função.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" /> que representa a chamada da função especificada com argumentos determinados.</summary>
        <returns>Um novo DbFunctionExpression representando a invocação de função.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" />é nulo, ou <paramref name="arguments" /> é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="arguments" /> não é igual ao número de parâmetros declarados por <paramref name="function" />, ou <paramref name="arguments" /> contém uma expressão que tem um tipo de resultado que não seja igual ou passível de promoção para o tipo de parâmetro de função correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="function">Metadados para a função para chamar.</param>
        <param name="arguments">Expressões que fornecem os argumentos para a função.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" /> que representa a chamada da função especificada com argumentos determinados.</summary>
        <returns>Um novo DbFunctionExpression representando a invocação de função.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" />é nulo, ou <paramref name="arguments" /> é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">A contagem de <paramref name="arguments" /> não é igual ao número de parâmetros declarados por <paramref name="function" />, ou <paramref name="arguments" /> contém uma expressão que tem um tipo de resultado que não seja igual ou passível de promoção para o tipo de parâmetro de função correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsEmptyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica o conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> que determina se o argumento do conjunto especificado é um conjunto vazio.</summary>
        <returns>Um novo DbIsEmptyExpression com o argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsNullExpression IsNull (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsNullExpression IsNull(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression" /> que determina se o argumento especificado é nulo.</summary>
        <returns>Um novo DbIsNullExpression com o argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />tem um tipo de resultado da coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOf">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOf (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOf(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a instância.</param>
        <param name="type">Metadados do tipo que especifica o tipo que o tipo de resultado da instância deve ser comparado ao.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> que determina se o argumento fornecido é do tipo especificado ou um subtipo.</summary>
        <returns>Um novo DbIsOfExpression com a instância especificada e o tipo e DbExpressionKind IsOf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression requer que `argument` tem um tipo de resultado polimórfico e que `type` é um tipo de hierarquia de tipo como esse tipo de resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="type" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />não está na mesma hierarquia de tipo como o tipo de resultado de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOfOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a instância.</param>
        <param name="type">Metadados do tipo que especifica o tipo que o tipo de resultado da instância deve ser comparado ao.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> expressão que determina se o argumento fornecido é do tipo especificado e somente esse tipo (não é um subtipo).</summary>
        <returns>Um novo DbIsOfExpression com a instância especificada e o tipo e DbExpressionKind IsOfOnly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression requer que `argument` tem um tipo de resultado polimórfico e que `type` é um tipo de hierarquia de tipo como esse tipo de resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="type" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />não está na mesma hierarquia de tipo como o tipo de resultado de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression Join (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression Join(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="outer">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto externo.</param>
        <param name="inner">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto interno.</param>
        <param name="outerKey">Um método que especifica como o valor de chave externo deve ser derivado de um elemento da coleção externa.</param>
        <param name="innerKey">Um método que especifica como o valor de chave interno deve ser derivado de um elemento da coleção interna.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas expressões internas e externas, em uma condição de igualdade entre as chaves internas e externas especificadas, usando InnerJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa a operação de junção interna aplicada aos conjuntos de entrada à esquerda e à direito em uma condição de junção que compara os valores de chave externos e internos, para fins de igualdade.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão produzida por <paramref name="outerKey" /> ou <paramref name="innerKey" /> é nula.</exception>
        <exception cref="T:System.ArgumentException">As expressões são produzidos por <paramref name="outerKey" /> e <paramref name="innerKey" /> não são comparáveis para igualdade.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join``1(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">O tipo do <c>seletor</c>.</typeparam>
        <param name="outer">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto externo.</param>
        <param name="inner">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto interno.</param>
        <param name="outerKey">Um método que especifica como o valor de chave externo deve ser derivado de um elemento da coleção externa.</param>
        <param name="innerKey">Um método que especifica como o valor de chave interno deve ser derivado de um elemento da coleção interna.</param>
        <param name="selector">Um método que especifica como um elemento do conjunto de resultados deve ser derivado de elementos dos conjuntos interno e externo. Esse método deve produzir uma instância de um tipo compatível com Join e pode ser resolvido em um <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Os requisitos de compatibilidade para <c>TSelector</c> são descritas em comentários.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que projeta o seletor especificado nos conjuntos especificados pelas expressões externas e internas, reunidas em uma condição de igualdade entre as chaves externas e internas especificadas usando InnerJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Um novo DbProjectExpression com o seletor especificado como sua projeção e uma novo DbJoinExpression como sua entrada. A entrada DbJoinExpression é criada com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa a operação de junção interna aplicada aos conjuntos de entrada esquerdo e direito em uma condição de junção que compara os valores de chave externo e interno com relação à igualdade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para ser compatível com junção, `TSelector` deve ser derivado de <xref:System.Data.Common.CommandTrees.DbExpression>, ou deve ser um tipo anônimo com propriedades derivadas de DbExpression. Os seguintes são exemplos de tipos com suporte para `TSelector`:  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => o.Property("Name"))  
```  
  
 (`TSelector` é <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => new { OName = o.Property("Name"), IName = i.Property("Name") })  
```  
  
 (`TSelector` é um tipo anônimo com propriedades derivadas de DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O resultado de <paramref name="selector" /> é nulo após a conversão para DbExpression.</exception>
        <exception cref="T:System.ArgumentException">O resultado de <paramref name="Selector" /> não é compatível com SelectMany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbVariableReferenceExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Uma expressão que define a lógica da função Lambda.</param>
        <param name="variables">Uma coleção de <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> que representa os parâmetros formais para a função Lambda. Essas variáveis são válidas para uso na expressão do <c>corpo</c>.</param>
        <summary>Cria um <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> com a implementação da função Lambda embutida e parâmetros formais especificados.</summary>
        <returns>Um novo DbLambda que descreve uma função Lambda com os parâmetros formais e um corpo especificado em linha.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" />é nulo ou contém nulo, ou <paramref name="body" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" />contém mais de um elemento com o mesmo nome de variável.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, params System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbVariableReferenceExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Data.Common.CommandTrees.DbVariableReferenceExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Uma expressão que define a lógica da função Lambda.</param>
        <param name="variables">Uma coleção de <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> que representa os parâmetros formais para a função Lambda. Essas variáveis são válidas para uso na expressão do <c>corpo</c>.</param>
        <summary>Cria um <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> com a implementação da função Lambda embutida e parâmetros formais especificados.</summary>
        <returns>Um novo DbLambda que descreve uma função Lambda com os parâmetros formais e um corpo especificado em linha.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" />é nulo ou contém nulo, ou <paramref name="body" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" />contém mais de um elemento com o mesmo nome de variável.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o argumento de conjunto à esquerda.</param>
        <param name="right">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o direito de define o argumento.</param>
        <param name="joinCondition">Um método que representa a condição na qual se unir. Esse método deve produzir uma expressão com um tipo de resultado booleano que fornece a lógica da condição de junção.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas expressões esquerdas e direita, da condição de junção especificada, usando LeftOuterJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de LeftOuterJoin, que representa a operação de junção externa esquerda aplicada aos conjuntos de entrada à esquerda e direito sob a condição de junção especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="joinCondition" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="joinCondition" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o argumento de conjunto à esquerda.</param>
        <param name="right">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o direito de define o argumento.</param>
        <param name="joinCondition">Uma expressão que especifica a condição na qual se unir.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que une os conjuntos especificados pelas esquerda e direita associações de expressão, da condição de junção especificada, usando LeftOuterJoin como o <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Uma nova DbJoinExpression, com um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de LeftOuterJoin, que representa a operação de junção externa esquerda aplicada aos conjuntos de entrada à esquerda e direito sob a condição de junção especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> ou <paramref name="joinCondition" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" />não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina se o argumento esquerdo for menor que o argumento da direita.</summary>
        <returns>Um novo DbComparisonExpression que representa o menor-comparação de.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado comparável por ordem comuns entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina se o argumento esquerdo for menor ou igual ao argumento direito.</summary>
        <returns>Um novo DbComparisonExpression que representa a comparação menor que-ou-igual a.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado comum que é ambos os igualdade - e comparável por ordem entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a cadeia de caracteres de entrada.</param>
        <param name="pattern">Uma expressão que especifica a cadeia de caracteres padrão.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> que compara a cadeia de caracteres de entrada especificada para o padrão fornecido.</summary>
        <returns>Um novo DbLikeExpression com a entrada especificada, padrão e um escape nulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> ou <paramref name="pattern" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="Argument" />ou <paramref name="pattern" /> não tem um tipo de resultado de cadeia de caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern, System.Data.Common.CommandTrees.DbExpression escape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern, class System.Data.Common.CommandTrees.DbExpression escape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="escape" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a cadeia de caracteres de entrada.</param>
        <param name="pattern">Uma expressão que especifica a cadeia de caracteres padrão.</param>
        <param name="escape">Uma expressão opcional que especifica a cadeia de caracteres de escape.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> que compara a cadeia de caracteres de entrada especificada para o padrão de determinado usando o escape opcional.</summary>
        <returns>Um novo DbLikeExpression com a entrada especificada, o padrão e o escape.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" />, <paramref name="pattern" /> ou <paramref name="escape" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />, <paramref name="pattern" /> ou <paramref name="escape" /> não tem um tipo de resultado de cadeia de caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="Limit">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Limit (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Limit(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a coleção de entrada.</param>
        <param name="count">Uma expressão que especifica o valor de limite.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> que restringe o número de elementos na coleção de argumento para a contagem especificada, o valor de limite. Resultados associados não estão incluídos na saída.</summary>
        <returns>Um novo DbLimitExpression com o argumento especificado e os valores de limite de contagem que não inclua ligado resultados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="count" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado de coleção ou <paramref name="count" /> não tem um tipo de resultado é igual ou passível de promoção para um tipo inteiro de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="Minus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Minus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Minus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que subtrai o argumento da direita do argumento à esquerda.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação de subtração.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico comum entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Modulo (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Modulo(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que calcula o restante do argumento da esquerda dividido pelo argumento da direita.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação do módulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico comum entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Multiply (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Multiply(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que multiplica o argumento da esquerda, o argumento da direita.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação de multiplicação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico comum entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Common.CommandTrees.DbExpression navigateFrom, System.Data.Metadata.Edm.RelationshipEndMember fromEnd, System.Data.Metadata.Edm.RelationshipEndMember toEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Common.CommandTrees.DbExpression navigateFrom, class System.Data.Metadata.Edm.RelationshipEndMember fromEnd, class System.Data.Metadata.Edm.RelationshipEndMember toEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="fromEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
        <Parameter Name="toEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="navigateFrom">Uma expressão que especifica a instância na qual a navegação deve ocorrer.</param>
        <param name="fromEnd">Metadados para a propriedade que representa o fim da relação do qual a navegação deve ocorrer.</param>
        <param name="toEnd">Metadados para a propriedade que representa o fim da relação para o qual a navegação deve ocorrer.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> que representa o painel de navegação de uma relação de composição ou associação.</summary>
        <returns>Um novo DbRelationshipNavigationExpression que representa a navegação especificada de e para extremidades da relação do tipo de relação especificado da instância de origem de navegação especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression>requer a ocorrência de navegação sempre de uma referência e isso `navigateFrom` deve sempre ter um tipo de resultado de referência.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fromEnd" />, <paramref name="toEnd" /> ou <paramref name="navigateFrom" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromEnd" />e <paramref name="toEnd" /> não está declarado pelo mesmo tipo de relação, ou <paramref name="navigateFrom" /> tem um tipo de resultado que não é compatível com o tipo de propriedade de <paramref name="fromEnd" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, System.Data.Common.CommandTrees.DbExpression navigateFrom);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, class System.Data.Common.CommandTrees.DbExpression navigateFrom) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Metadata.Edm.RelationshipType,System.String,System.String,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.RelationshipType" RefType="this" />
        <Parameter Name="fromEndName" Type="System.String" />
        <Parameter Name="toEndName" Type="System.String" />
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="type">Metadados para o tipo de relação que representa a relação.</param>
        <param name="fromEndName">O nome da propriedade do tipo de relação que representa o fim da relação do qual a navegação deve ocorrer.</param>
        <param name="toEndName">O nome da propriedade do tipo de relação que representa o fim da relação para o qual a navegação deve ocorrer.</param>
        <param name="navigateFrom">Uma expressão de Especifica a instância na qual naviagtion deve ocorrer.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> que representa o painel de navegação de uma relação de composição ou associação.</summary>
        <returns>Um novo DbRelationshipNavigationExpression que representa a navegação especificada de e para extremidades da relação do tipo de relação especificado da instância de origem de navegação especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression>requer a ocorrência de navegação sempre de uma referência e isso `navigateFrom` deve sempre ter um tipo de resultado de referência.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />, <paramref name="fromEndName" />, <paramref name="toEndName" /> ou <paramref name="navigateFrom" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />não está associado ao espaço de trabalho de metadados da árvore de comandos ou <paramref name="navigateFrom" /> está associado uma árvore de comandos diferentes ou <paramref name="type" /> não declara uma propriedade de end de relação com o nome <paramref name="toEndName" /> ou <paramref name="fromEndName" />, ou <paramref name="navigateFrom" /> tem um tipo de resultado que não é compatível com o tipo de propriedade da propriedade de end de relação com o nome <paramref name="fromEndName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Negate (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Negate(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que nega o valor do argumento.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação de negação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico para <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="instanceType">O tipo da nova instância.</param>
        <param name="arguments">Expressões que especificam valores de novas instâncias, interpretadas de acordo com o tipo da instância.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Se o argumento de tipo é um tipo de coleção, os argumentos especificam os elementos da coleção. Caso contrário, os argumentos são usados como valores de propriedade ou coluna na nova instância.</summary>
        <returns>Um novo DbNewInstanceExpression com os argumentos e o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `instanceType` é um uma coleção de tipo, em seguida, cada expressão no `arguments` devem ter um tipo de resultado é passível de promoção ao tipo de elemento do `instanceType`. Se `instanceType` é um tipo de linha, `arguments` devem conter tantas expressões como há colunas no tipo de linha e o tipo de resultado de cada expressão deve ser igual ou passível de promoção ao tipo da coluna correspondente. Um tipo de linha que não declarar todas as colunas é inválido. Se `instanceType` é um tipo de entidade `arguments` deve conter muitas expressões quanto são propriedades definidas pelo tipo e o tipo de resultado de cada expressão deve ser igual ou passível de promoção ao tipo da propriedade correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" />ou <paramref name="arguments" /> é nulo, ou <paramref name="arguments" /> contiver null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" />está vazio ou os tipos de resultados de independente expressões não coincidem com os requisitos de <paramref name="instanceType" /> (conforme explicado na seção comentários).</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instanceType">O tipo da nova instância.</param>
        <param name="arguments">Expressões que especificam valores de novas instâncias, interpretadas de acordo com o tipo da instância.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Se o argumento de tipo é um tipo de coleção, os argumentos especificam os elementos da coleção. Caso contrário, os argumentos são usados como valores de propriedade ou coluna na nova instância.</summary>
        <returns>Um novo DbNewInstanceExpression com os argumentos e o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `instanceType` é um uma coleção de tipo, em seguida, cada expressão no `arguments` devem ter um tipo de resultado é passível de promoção ao tipo de elemento do `instanceType`. Se `instanceType` é um tipo de linha, `arguments` devem conter tantas expressões como há colunas no tipo de linha e o tipo de resultado de cada expressão deve ser igual ou passível de promoção ao tipo da coluna correspondente. Um tipo de linha que não declarar todas as colunas é inválido. Se `instanceType` é um tipo de entidade `arguments` deve conter muitas expressões quanto são propriedades definidas pelo tipo e o tipo de resultado de cada expressão deve ser igual ou passível de promoção ao tipo da propriedade correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" />ou <paramref name="arguments" /> é nulo, ou <paramref name="arguments" /> contiver null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" />está vazio ou os tipos de resultados de independente expressões não coincidem com os requisitos de <paramref name="instanceType" /> (conforme explicado na seção comentários).</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="elements">Uma lista de expressões que fornecem os elementos da coleção.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que constrói uma coleção que contém os elementos especificados. O tipo de coleção é baseado no tipo dos elementos comuns. Se não existe nenhum tipo de elemento comum uma exceção será lançada.</summary>
        <returns>Um novo DbNewInstanceExpression com os argumentos e o tipo de coleção especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" />é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" />está vazio ou contém expressões para o qual não existe nenhum tipo de resultado comum.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (params System.Data.Common.CommandTrees.DbExpression[] elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Data.Common.CommandTrees.DbExpression[] elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elements">Uma lista de expressões que fornecem os elementos da coleção.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que constrói uma coleção que contém os elementos especificados. O tipo de coleção é baseado no tipo dos elementos comuns. Se não existe nenhum tipo de elemento comum uma exceção será lançada.</summary>
        <returns>Um novo DbNewInstanceExpression com os argumentos e o tipo de coleção especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" />é nulo ou contém um nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" />está vazio ou contém expressões para o qual não existe nenhum tipo de resultado comum.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewEmptyCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection (this System.Data.Metadata.Edm.TypeUsage collectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection(class System.Data.Metadata.Edm.TypeUsage collectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="collectionType">Os metadados de tipo de coleção para criar</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que constrói uma coleção vazia do tipo de coleção especificada.</summary>
        <returns>Um novo DbNewInstanceExpression com o tipo de coleção especificada e vazio <paramref name="Arguments" /> lista.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionType" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionType" />não é um tipo de coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="columnValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="columnValues">Uma lista de pares chave-valor de cadeia de caracteres DbExpression que define a estrutura e os valores da linha.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que produz uma linha com os valores fornecidos, especificados como expressões e a chamada colunas especificados.</summary>
        <returns>Um novo DbNewInstanceExpression que representa a construção da linha.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="columnValues" />é nulo ou contém um elemento com um nome de coluna nulo ou uma expressão.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="columnValues" />está vazio ou contém um nome de coluna duplicados ou inválidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNotExpression Not (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNotExpression Not(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNotExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão booleana que especifica o argumento.</param>
        <summary>Cria um <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> que executa a negação lógica do argumento fornecido.</summary>
        <returns>Um novo DbNotExpression com o argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression NotEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression NotEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que compara os argumentos esquerdos e direito de desigualdade.</summary>
        <returns>Um novo DbComparisonExpression que representa a comparação de desigualdade.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado comparável por igualdade comuns entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNullExpression Null (this System.Data.Metadata.Edm.TypeUsage nullType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNullExpression Null(class System.Data.Metadata.Edm.TypeUsage nullType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nullType">O tipo de valor nulo.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbNullExpression" />, que representa um valor null digitado.</summary>
        <returns>Uma instância de DbNullExpression.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nullType" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfType (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfType(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o conjunto de entrada.</param>
        <param name="type">Tipo de metadados para o tipo de elementos do conjunto de entrada devem ter para ser incluído no conjunto resultante.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> que produz um conjunto consiste em elementos de entrada determinado conjunto que são do tipo especificado.</summary>
        <returns>Um novo DbOfTypeExpression com o conjunto especificado e tipo e um ExpressionKind de <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression requer que `argument` tem uma coleção de tipo de resultado com um tipo de elemento polimórfico e que `type` é um tipo de hierarquia de tipo como esse tipo de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="type" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado de coleção ou <paramref name="type" /> não é um tipo na mesma hierarquia de tipo como o tipo de elemento do tipo de resultado de coleção de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfTypeOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o conjunto de entrada.</param>
        <param name="type">Tipo de metadados para o tipo de elementos do conjunto de entrada devem corresponder exatamente a ser incluído no conjunto resultante.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> que produz um conjunto consiste em elementos de entrada determinado conjunto que são exatamente o tipo especificado.</summary>
        <returns>Um novo DbOfTypeExpression com o conjunto especificado e tipo e um ExpressionKind de <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfTypeOnly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression requer que `argument` tem uma coleção de tipo de resultado com um tipo de elemento polimórfico e que `type` é um tipo de hierarquia de tipo como esse tipo de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="type" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado de coleção ou <paramref name="type" /> não é um tipo na mesma hierarquia de tipo como o tipo de elemento do tipo de resultado de coleção de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOrExpression Or (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOrExpression Or(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOrExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão booleana que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão booleana que especifica o argumento da direita.</param>
        <summary>Cria um <see cref="T:System.Data.Common.CommandTrees.DbOrExpression" /> que executa a lógica ou os argumentos esquerdo e direito.</summary>
        <returns>Um novo DbOrExpression com os argumentos especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />ou <paramref name="right" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que classifica a entrada especificada, definida pela chave de classificação especificados com o crescente de classificação ordem e o agrupamento padrão.</summary>
        <returns>Um novo DbSortExpression que representa a operação order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <param name="collation">O agrupamento para classificar em.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que classifica a entrada especificada, definida pela chave de classificação especificados com o crescente, ordem de classificação e o agrupamento especificado.</summary>
        <returns>Um novo DbSortExpression que representa a operação order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado de cadeia de caracteres comparável por ordem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />está vazio ou contém apenas caracteres de espaço.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que classifica a entrada especificada, definida pela chave de classificação especificados com decrescente de classificação ordem e o agrupamento padrão.</summary>
        <returns>Um novo DbSortExpression que representa a operação order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <param name="collation">O agrupamento para classificar em.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que classifica a entrada especificada, definida pela chave de classificação especificados com decrescente a ordem de classificação e o agrupamento especificado.</summary>
        <returns>Um novo DbSortExpression que representa a operação order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado de cadeia de caracteres comparável por ordem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />está vazio ou contém apenas caracteres de espaço.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o conjunto de entrada.</param>
        <param name="apply">Um método que especifica a lógica para avaliar uma vez para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que avalia a determinado <paramref name="apply" /> expressão uma vez para cada elemento de uma determinada entrada definida, produzindo um conjunto de linhas com entradas correspondentes e se aplicam a colunas. Linhas para as quais <paramref name="apply" /> é avaliada para um conjunto vazio tem um valor de coluna aplicar de <see langword="null" />.</summary>
        <returns>Um novo DbApplyExpression com especificado de entrada e aplicação de associações e um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O resultado de <paramref name="apply" /> contém um nome ou uma expressão que é nulo.</exception>
        <exception cref="T:System.ArgumentException">O resultado de <paramref name="apply" /> contém um nome ou uma expressão que não é válido em uma associação de expressão.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica o conjunto de entrada.</param>
        <param name="apply">Um <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica a lógica para avaliar uma vez para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que avalia a determinado <paramref name="apply" /> expressão uma vez para cada elemento de uma determinada entrada definida, produzindo um conjunto de linhas com entradas correspondentes e se aplicam a colunas. Linhas para as quais <paramref name="apply" /> é avaliada para um conjunto vazio tem um valor de coluna aplicar de <see langword="null" />.</summary>
        <returns>Um novo DbApplyExpression com especificado de entrada e aplicação de associações e um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="apply" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbParameterReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do parâmetro referenciado.</param>
        <param name="name">O nome do parâmetro referenciado.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> que faz referência a um parâmetro com o nome e tipo especificados.</summary>
        <returns>Uma DbParameterReferenceExpression que representa uma referência a um parâmetro com o nome e tipo especificados. O tipo de resultado da expressão será o mesmo que <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Plus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Plus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que especifica o argumento da esquerda.</param>
        <param name="right">Uma expressão que especifica o argumento da direita.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que adiciona o argumento da esquerda para o argumento da direita.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação de adição.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico comum entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Project (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Project(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="projection" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Uma expressão de associação que especifica o conjunto de entrada.</param>
        <param name="projection">Uma expressão para o projeto no conjunto.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que projeta a expressão especificada no determinado conjunto de entrada.</summary>
        <returns>Um novo DbProjectExpression que representa a operação de projeção.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="projection" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.EdmProperty propertyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.EdmProperty propertyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EdmProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyMetadata" Type="System.Data.Metadata.Edm.EdmProperty" />
      </Parameters>
      <Docs>
        <param name="instance">A instância da qual recuperar a propriedade. Pode ser nulo se a propriedade é estática.</param>
        <param name="propertyMetadata">Metadados para a propriedade a serem recuperados.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa a recuperação da propriedade especificada.</summary>
        <returns>Um novo DbPropertyExpression que representa a recuperação de propriedade.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyMetadata" />é nulo ou <paramref name="instance" /> é nulo e a propriedade não é estática.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.NavigationProperty navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.NavigationProperty navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.NavigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="navigationProperty" Type="System.Data.Metadata.Edm.NavigationProperty" />
      </Parameters>
      <Docs>
        <param name="instance">A instância da qual recuperar a propriedade de navegação.</param>
        <param name="navigationProperty">Metadados para a propriedade de navegação a serem recuperados.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa a recuperação de propriedade de navegação especificada.</summary>
        <returns>Um novo DbPropertyExpression que representa a recuperação de propriedade de navegação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigationProperty" /> ou <paramref name="instance" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="relationshipEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="instance">A instância da qual recuperar o membro de término do relacionamento.</param>
        <param name="relationshipEnd">Metadados para o membro de end de relação recuperar.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa a recuperação do membro de end da relação especificada.</summary>
        <returns>Um novo DbPropertyExpression que representa a recuperação de membro de end de relação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipEnd" />é nulo ou <paramref name="instance" /> é nulo e a propriedade não é estática.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">A instância da qual recuperar a propriedade.</param>
        <param name="propertyName">O nome da propriedade a ser recuperada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa a recuperação de propriedade da instância com o nome especificado da instância fornecida.</summary>
        <returns>Um novo DbPropertyExpression que representa a recuperação de propriedade.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyName" />é nulo ou <paramref name="instance" /> é nulo e a propriedade não é estática.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nenhuma propriedade com o nome especificado é declarada pelo tipo de <paramref name="instance" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="entitySet">O conjunto de entidades no qual reside o elemento referenciado.</param>
        <param name="keyRow">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que constrói um registro com colunas correspondentes (em número, tipo e ordem) as propriedades de chave do tipo de entidade referenciada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica uma referência a uma entidade específica com base em valores de chave.</summary>
        <returns>Um novo DbRefExpression que referencia o elemento com os valores de chave especificados no conjunto de entidades determinado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow`deve ser uma expressão que especifica os valores de chave que identificam a entidade referenciada dentro de determinada entidade definida. O tipo de resultado de `keyRow` deve conter uma coluna correspondente para cada propriedade de chave definida pelo `entitySet's` tipo de entidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> ou <paramref name="keyRow" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyRow" />não tem um tipo de registro de resultado que corresponde a propriedades de chave do tipo de entidade do conjunto de entidade referenciada.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow, System.Data.Metadata.Edm.EntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow, class System.Data.Metadata.Edm.EntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
      </Parameters>
      <Docs>
        <param name="entitySet">O conjunto de entidades no qual reside o elemento referenciado.</param>
        <param name="keyRow">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que constrói um registro com colunas correspondentes (em número, tipo e ordem) as propriedades de chave do tipo de entidade referenciada.</param>
        <param name="entityType">O tipo de entidade que a referência deve consultar.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica uma referência a uma entidade específica com base em valores de chave.</summary>
        <returns>Um novo DbRefExpression que referencia o elemento com os valores de chave especificados no conjunto de entidades determinado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow`deve ser uma expressão que especifica os valores de chave que identificam a entidade referenciada dentro de determinada entidade definida. O tipo de resultado de `keyRow` deve conter uma coluna correspondente para cada propriedade de chave definida pelo `entitySet's` tipo de entidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />, <paramref name="keyRow" /> ou <paramref name="entityType" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entityType" />não está na mesma hierarquia de tipo como tipo de entidade do conjunto de entidades, ou <paramref name="keyRow" /> não tem um tipo de registro de resultado que corresponde a propriedades de chave do tipo de entidade do conjunto de entidade referenciada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbScanExpression Scan (this System.Data.Metadata.Edm.EntitySetBase targetSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbScanExpression Scan(class System.Data.Metadata.Edm.EntitySetBase targetSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan(System.Data.Metadata.Edm.EntitySetBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbScanExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSet" Type="System.Data.Metadata.Edm.EntitySetBase" RefType="this" />
      </Parameters>
      <Docs>
        <param name="targetSet">Metadados para o conjunto de entidade ou a relação de referência.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbScanExpression" /> que referencia o conjunto de entidade ou a relação especificado.</summary>
        <returns>Um novo DbScanExpression com base no conjunto de entidade ou a relação especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetSet" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TProjection&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt; projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, !!TProjection&gt; projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProjection" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="projection" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProjection">O tipo de resultado do método de <c>projeção</c>.</typeparam>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="projection">Um método que especifica como derivar a expressão projetada considerando um membro do conjunto de entrada. Esse método deve produzir uma instância de um tipo que é compatível com selecione e pode ser resolvida como um <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Os requisitos de compatibilidade para <c>TProjection</c> são descritas em comentários.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que seleciona a expressão especificada no determinado conjunto de entrada.</summary>
        <returns>Um novo DbProjectExpression que representa a operação select.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para ser compatível com Select, `TProjection` deve ser derivado de <xref:System.Data.Common.CommandTrees.DbExpression>, ou deve ser um tipo anônimo com propriedades derivadas de DbExpression. Os seguintes são exemplos de tipos com suporte para `TProjection`:  
  
```  
source.Select(x => x.Property("Name"))  
```  
  
 `TProjection`is <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.Select(x => new { Name = x.Property("Name") })  
```  
  
 (`TProjection` é um tipo anônimo com uma propriedade derivado de DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O resultado de <paramref name="projection" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o conjunto de entrada.</param>
        <param name="apply">Um método que representa a lógica para avaliar uma vez para cada membro do conjunto de entrada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que avalia a determinado <paramref name="apply" /> expressão uma vez para cada elemento de uma determinada entrada definida, produzindo um conjunto de linhas com entradas correspondentes e se aplicam a colunas. Linhas para as quais <paramref name="apply" /> é avaliada para um conjunto vazio não são incluídos. Um <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> é criado que seleciona o <paramref name="apply" /> coluna de cada linha, produzindo geral da coleção de <paramref name="apply" /> resultados.</summary>
        <returns>Um novo DbProjectExpression que seleciona a coluna de aplicação de DbApplyExpression um novo com as associações de entrada e aplicar especificadas e um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="apply" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="apply" /> não tem um tipo de coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">O tipo de resultado do método de <c>seletor</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica o conjunto de entrada.</param>
        <param name="apply">Um método que representa a lógica para avaliar uma vez para cada membro do conjunto de entrada.</param>
        <param name="selector">Um método que especifica como um elemento do resultado definido deve ser derivada a partir de um elemento de entrada e aplicar conjuntos. Este método deve produzir uma instância de um tipo que é compatível com SelectMany e pode ser resolvido como um <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Os requisitos de compatibilidade para <c>TSelector</c> são descritas em comentários.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que avalia a determinado <paramref name="apply" /> expressão uma vez para cada elemento de uma determinada entrada definida, produzindo um conjunto de linhas com entradas correspondentes e se aplicam a colunas. Linhas para as quais <paramref name="apply" /> é avaliada para um conjunto vazio não são incluídos. Um <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> é criado que seleciona especificado <paramref name="selector" /> em cada linha, produzindo geral da coleção de resultados.</summary>
        <returns>Um novo DbProjectExpression seleciona o resultado do seletor de determinado de um novo DbApplyExpression com a entrada especificada e aplicar associações e um <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para ser compatível com SelectMany, `TSelector` deve ser derivado de <xref:System.Data.Common.CommandTrees.DbExpression>, ou deve ser um tipo anônimo com propriedades derivadas de DbExpression. Os seguintes são exemplos de tipos com suporte para `TSelector`:  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => apply.Property("Name"))  
```  
  
 (`TSelector` é <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => new { SourceName = source.Property("Name"), RelatedName = apply.Property("Name") })  
```  
  
 (`TSelector` é um tipo anônimo com propriedades derivadas de DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O resultado de <paramref name="selector" /> for nulo na conversão em DbExpression.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="apply" /> não tem um tipo de coleção. não tem um tipo de coleção.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbSortExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbSortExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbSortExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Um <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que especifica o conjunto de entrada classificado.</param>
        <param name="count">Uma expressão de Especifica quantos elementos do conjunto ordenado para ignorar.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> que ignora o número especificado de elementos do conjunto de entrada classificado determinado.</summary>
        <returns>Um novo DbSkipExpression que representa a operação de ignorar.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="count" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" />não é <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> ou <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> ou tem um tipo de resultado que não é passível de promoção ou igual a um tipo de inteiro de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Uma expressão de associação que especifica o conjunto de entrada.</param>
        <param name="sortOrder">Uma lista de especificações de classificação que determinam como os elementos do conjunto de entrada devem ser classificados.</param>
        <param name="count">Uma expressão de Especifica quantos elementos do conjunto ordenado para ignorar.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> que classifica a entrada especificada definida pelas especificações de classificação fornecida antes de ignorar o número especificado de elementos.</summary>
        <returns>Um novo DbSkipExpression que representa a operação de ignorar.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="sortOrder" /> ou <paramref name="count" /> é nulo, ou <paramref name="sortOrder" /> contiver null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" />está vazio, ou <paramref name="count" /> não é <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> ou <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> ou tem um tipo de resultado que não é passível de promoção ou igual a um tipo de inteiro de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression Sort (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression Sort(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Uma expressão de associação que especifica o conjunto de entrada.</param>
        <param name="sortOrder">Uma lista de especificações de classificação que determinam como os elementos do conjunto de entrada devem ser classificados.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que classifica a entrada especificada definida pelas especificações de classificação especificados.</summary>
        <returns>Um novo DbSortExpression que representa a operação de classificação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />ou <paramref name="sortOrder" /> é nulo, ou <paramref name="sortOrder" /> contiver null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" /> está vazio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Take (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Take(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a coleção de entrada.</param>
        <param name="count">Uma expressão que especifica o valor de limite.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> que restringe o número de elementos na coleção de argumento para a contagem especificada, o valor de limite. Resultados associados não estão incluídos na saída.</summary>
        <returns>Um novo DbLimitExpression com o argumento especificado e os valores de limite de contagem que não inclua ligado resultados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="count" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />não tem um tipo de resultado de coleção, <paramref name="count" /> não tem um tipo de resultado é igual ou passível de promoção para um tipo inteiro de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Um DbSortExpression que especifica o conjunto ordenado de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação adicional fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que, com uma ordem de classificação que inclui a ordem de classificação da ordem de determinado conjunto junto com a chave de classificação especificada em ordem de classificação crescente e com o agrupamento padrão de entrada.</summary>
        <returns>Um novo DbSortExpression que representa a nova ordem por operação total.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortKey" />não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Um DbSortExpression que especifica o conjunto ordenado de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação adicional fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <param name="collation">O agrupamento para classificar em.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que, com uma ordem de classificação que inclui a ordem de classificação da ordem de determinada entrada conjunto junto com a chave de classificação especificada em ordem de classificação crescente e com o agrupamento especificado.</summary>
        <returns>Um novo DbSortExpression que representa a nova ordem por operação total.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado de cadeia de caracteres comparável por ordem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />está vazio ou contém apenas caracteres de espaço.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Um DbSortExpression que especifica o conjunto ordenado de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação adicional fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que, com uma ordem de classificação que inclui a ordem de classificação da ordem de determinado conjunto junto com a chave de classificação especificada em ordem de classificação decrescente e com o agrupamento padrão de entrada.</summary>
        <returns>Um novo DbSortExpression que representa a nova ordem por operação total.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Um DbSortExpression que especifica o conjunto ordenado de entrada.</param>
        <param name="sortKey">Um método que especifica como derivar a expressão de chave de classificação adicional fornecida a um membro do conjunto de entrada. Esse método deve produzir uma expressão com um tipo comparável por ordem de resultado que fornece a classificação de definição de chave.</param>
        <param name="collation">O agrupamento para classificar em.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que, com uma ordem de classificação que inclui a ordem de classificação da ordem de determinada entrada conjunto junto com a chave de classificação especificada em ordem de classificação decrescente e com o agrupamento especificado.</summary>
        <returns>Um novo DbSortExpression que representa a nova ordem por operação total.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="sortKey" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="sortKey" /> não tem um tipo de resultado de cadeia de caracteres comparável por ordem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />está vazio ou contém apenas caracteres de espaço.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">A expressão que define a chave de classificação.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> com um agrupamento de ordem e o padrão de classificação crescente.</summary>
        <returns>Uma nova cláusula de classificação com a chave de classificação fornecida e a ordem de classificação crescente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">A expressão que define a chave de classificação.</param>
        <param name="collation">O agrupamento para classificar em.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> com uma ordem de classificação crescente e o agrupamento especificado.</summary>
        <returns>Uma nova cláusula de classificação com a chave de classificação fornecida e o agrupamento e a ordem de classificação crescente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />está vazio ou contém apenas caracteres de espaço.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">A expressão que define a chave de classificação.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> com um agrupamento de ordem e o padrão de classificação decrescente.</summary>
        <returns>Uma nova cláusula de classificação com a chave de classificação fornecida e a ordem de classificação decrescente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">A expressão que define a chave de classificação.</param>
        <param name="collation">O agrupamento para classificar em.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> com uma ordem de classificação decrescente e o agrupamento especificado.</summary>
        <returns>Uma nova cláusula de classificação com a chave de classificação fornecida e o agrupamento e a ordem de classificação decrescente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />está vazio ou contém apenas caracteres de espaço.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />não tem um tipo de resultado comparável por ordem.</exception>
      </Docs>
    </Member>
    <Member MemberName="TreatAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbTreatExpression TreatAs (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage treatType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbTreatExpression TreatAs(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage treatType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbTreatExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="treatType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica a instância.</param>
        <param name="treatType">Tipo de metadados para a tratar-como tipo.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression" />.</summary>
        <returns>Um novo DbTreatExpression com o argumento especificado e o tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbTreatExpression requer que `argument` tem um tipo de resultado polimórfico e que `treatType` é um tipo de hierarquia de tipo como esse tipo de resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ou <paramref name="treatType" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="treatType" />não está na mesma hierarquia de tipo como o tipo de resultado de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="True">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression True { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression True" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> com o valor booliano <see langword="true" />.</summary>
        <value>Um <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> com o valor booliano <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnaryMinus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Uma expressão que especifica o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que nega o valor do argumento.</summary>
        <returns>Um novo DbArithmeticExpression que representa a operação de negação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado numérico para <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Union (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Union(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que define esquerda defina um argumento.</param>
        <param name="right">Uma expressão que define o direito de define o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que calcula a união de esquerda e direita definir argumentos com as duplicatas removidas.</summary>
        <returns>Um novo DbExpression que calcula a união, sem duplicatas, do os argumentos esquerdo e direito.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado de coleção comuns com um tipo de elemento comparável por igualdade entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnionAll">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbUnionAllExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Uma expressão que define esquerda defina um argumento.</param>
        <param name="right">Uma expressão que define o direito de define o argumento.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbUnionAllExpression" /> que calcula a união dos argumentos esquerdo e direito conjunto e não remove duplicatas.</summary>
        <returns>Um novo DbUnionAllExpression dessa união, incluindo duplicatas dos argumentos esquerdos e direito.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> ou <paramref name="right" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">Não existe nenhum tipo de resultado de coleção comuns com um tipo de elemento comparável por igualdade entre <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbVariableReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo da variável referenciada.</param>
        <param name="name">O nome da variável referenciada.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> que faz referência a uma variável com o nome e tipo especificados.</summary>
        <returns>Um DbVariableReferenceExpression que representa uma referência a uma variável com o nome e tipo especificados. O tipo de resultado da expressão será o mesmo que <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Where (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Where(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Uma expressão que especifica o conjunto de entrada.</param>
        <param name="predicate">Um método que representa o predicado a ser avaliada para cada membro do conjunto de entrada.    Esse método deve produzir uma expressão com um tipo de resultado booleano que fornece a lógica de predicado.</param>
        <summary>Cria um novo <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> que filtra os elementos na entrada fornecida definido usando o predicado especificado.</summary>
        <returns>Um novo DbQuantifierExpression que representa a qualquer operação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A expressão é produzido pelo <paramref name="predicate" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A expressão é produzido pelo <paramref name="predicate" /> não tem um tipo de resultado booliano.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
