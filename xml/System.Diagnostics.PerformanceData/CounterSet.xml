<Type Name="CounterSet" FullName="System.Diagnostics.PerformanceData.CounterSet">
  <TypeSignature Language="C#" Value="public class CounterSet : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CounterSet extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceData.CounterSet" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Define um conjunto de contadores lógicos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Diagnostics.PerformanceData.CounterSet.Dispose%2A> método quando tiver terminado a remoção de registro do provedor e para liberar todos os recursos gerenciados e.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CounterSet (Guid providerGuid, Guid counterSetGuid, System.Diagnostics.PerformanceData.CounterSetInstanceType instanceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid, valuetype System.Guid counterSetGuid, valuetype System.Diagnostics.PerformanceData.CounterSetInstanceType instanceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.#ctor(System.Guid,System.Guid,System.Diagnostics.PerformanceData.CounterSetInstanceType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
        <Parameter Name="counterSetGuid" Type="System.Guid" />
        <Parameter Name="instanceType" Type="System.Diagnostics.PerformanceData.CounterSetInstanceType" />
      </Parameters>
      <Docs>
        <param name="providerGuid">GUID que identifica exclusivamente o provedor de dados do contador. Use o Guid especificado no manifesto.</param>
        <param name="counterSetGuid">GUID que identifica exclusivamente o contador definido para um provedor. Use o Guid especificado no manifesto.</param>
        <param name="instanceType">Identifica o tipo de conjunto de contadores, por exemplo, se o conjunto de contadores é um conjunto de contadores de instância único ou vários.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.PerformanceData.CounterSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registra o provedor. Chamar o <xref:System.Diagnostics.PerformanceData.CounterSet.Dispose%2A> método Remove o registro.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">Não há memória suficiente está disponível para concluir a operação.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Não tem suporte anterior ao Windows Vista.</exception>
        <exception cref="T:System.ArgumentException">Um dos parâmetros é nulo ou não é válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Falha em uma chamada de função do Win32 subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddCounter">
      <MemberSignature Language="C#" Value="public void AddCounter (int counterId, System.Diagnostics.PerformanceData.CounterType counterType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCounter(int32 counterId, valuetype System.Diagnostics.PerformanceData.CounterType counterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.AddCounter(System.Int32,System.Diagnostics.PerformanceData.CounterType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterId" Type="System.Int32" />
        <Parameter Name="counterType" Type="System.Diagnostics.PerformanceData.CounterType" />
      </Parameters>
      <Docs>
        <param name="counterId">Identifica o contador. Use o mesmo valor usado no manifesto para definir o contador.</param>
        <param name="counterType">Identifica o tipo de contador. O tipo de contador determina como os dados do contador são calculados, calculados e exibidos.</param>
        <summary>Adiciona um contador para o contador definido usando o identificador do contador especificado e o tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve adicionar contadores para o contador definido antes de criar uma instância do conjunto de contadores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O identificador do contador já existe no conjunto ou for negativo, ou o tipo de contador é nulo ou não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Você não pode adicionar contadores para o contador definido após a criação de uma instância do contador definido.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddCounter">
      <MemberSignature Language="C#" Value="public void AddCounter (int counterId, System.Diagnostics.PerformanceData.CounterType counterType, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCounter(int32 counterId, valuetype System.Diagnostics.PerformanceData.CounterType counterType, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.AddCounter(System.Int32,System.Diagnostics.PerformanceData.CounterType,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterId" Type="System.Int32" />
        <Parameter Name="counterType" Type="System.Diagnostics.PerformanceData.CounterType" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterId">Identifica o contador. Use o mesmo valor usado no manifesto para definir o contador.</param>
        <param name="counterType">Identifica o tipo de contador. O tipo de contador determina como os dados do contador são calculados, calculados e exibidos.</param>
        <param name="counterName">Nome do contador. Você pode usar esse nome para o contador na instância de conjunto de contadores de índice. (Consulte <see cref="P:System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet.Item(System.String)" />.)</param>
        <summary>Adiciona um contador para o contador definido usando o identificador do contador especificado e o tipo e um nome para exibição para o contador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve adicionar contadores para o contador definido antes de criar uma instância do conjunto de contadores.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O identificador do contador já existe no conjunto ou for negativo, ou o tipo de contador é nulo ou não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Você não pode adicionar contadores para o contador definido após a criação de uma instância do contador definido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCounterSetInstance">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceData.CounterSetInstance CreateCounterSetInstance (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceData.CounterSetInstance CreateCounterSetInstance(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.CreateCounterSetInstance(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceData.CounterSetInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Nome da instância. O nome deve ser exclusivo.</param>
        <summary>Cria uma instância do conjunto de contador.</summary>
        <returns>Uma instância do conjunto de contadores que conterá os dados do contador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame este método uma vez para conjuntos de contadores de instância única e uma ou mais vezes para conjuntos de contadores de várias instâncias.  
  
 O provedor determina quando ele cria uma instância. Se os dados do contador serão mais estáticos, o provedor pode criar uma instância no momento da inicialização. Por exemplo, o número de processadores em um computador seria considerado estático, portanto, um provedor que fornece dados do contador para processadores pode criar uma instância para cada processador no computador no momento da inicialização. Para os contadores que são mais dinâmicos, como disco ou contadores de processo, os provedores deve criar novas instâncias em resposta a um novo dispositivo USB que está sendo adicionado ou um novo processo que está sendo criado.  
  
 O provedor deve manter o contador de dados atualizados em todos os momentos.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome da instância é NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Você deve adicionar contadores para o contador definido antes de criar uma instância do conjunto de contadores.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos não gerenciados usados por este objeto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="True" />Se isso foi chamado o método Dispose, <see langword="False" /> se chamado do finalizador.</param>
        <summary>Versões de todos os recursos não gerenciados usados por este objeto e, opcionalmente, liberar os recursos gerenciados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CounterSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera os recursos antes do objeto é recuperado pela coleta de lixo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado automaticamente pelo tempo de execução.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
