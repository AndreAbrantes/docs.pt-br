<Type Name="ITextRangeProvider" FullName="System.Windows.Automation.Provider.ITextRangeProvider">
  <TypeSignature Language="C#" Value="public interface ITextRangeProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITextRangeProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("5347ad7b-c355-46f8-aff5-909033582f63")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expõe métodos e propriedades para oferecer suporte a acesso de cliente de automação de interface do usuário para um intervalo de texto contínuo em um contêiner de texto que implementa <see cref="T:System.Windows.Automation.Provider.ITextProvider" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementado em um provedor de automação de interface do usuário que deve dar suporte a <xref:System.Windows.Automation.TextPattern> padrão de controle.  
  
 Um <xref:System.Windows.Automation.Text.TextPatternRange> pode representar um ponto de inserção, um subconjunto ou todo o texto em uma <xref:System.Windows.Automation.TextPattern> contêiner.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adiciona à coleção do texto realçado em um contêiner de texto que dá suporte a vários, seleções de separação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Move o ponto de inserção de texto para a área da nova seleção.  
  
 Fornece um intervalo de texto degenerado move o ponto de inserção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o provedor de texto não oferece suporte a várias seleções de disjunção (ou seja, <see cref="P:System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection" /> deve ter um valor de <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um novo <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> idêntico ao valor original <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> e herança de todas as propriedades do original.</summary>
        <returns>O novo intervalo de texto. Uma referência nula (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]) nunca é retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O novo intervalo de pode ser manipulado de forma independente do original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Provider.ITextRangeProvider range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Compare(class System.Windows.Automation.Provider.ITextRangeProvider range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Compare(System.Windows.Automation.Provider.ITextRangeProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
      </Parameters>
      <Docs>
        <param name="range">Um intervalo de texto a ser comparado</param>
        <summary>Retorna um valor que indica se o alcance (o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ponto de extremidade para o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> ponto de extremidade) de um texto intervalo for igual a outro intervalo de texto.</summary>
        <returns>
          <see langword="true" />Se o alcance dos dois intervalos de texto é idêntico; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Se o intervalo que estão sendo comparado não são provenientes do mesmo fornecedor de texto.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">O <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> ponto de extremidade do chamador.</param>
        <param name="targetRange">O intervalo de destino para comparação.</param>
        <param name="targetEndpoint">O <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> ponto de extremidade de destino.</param>
        <summary>Retorna um valor que especifica se os dois intervalos de texto têm pontos de extremidade idênticos.</summary>
        <returns>Retorna um valor negativo se o ponto de extremidade do chamador ocorre anteriormente no texto que o ponto de extremidade de destino.  
  
 Retorna zero se o ponto de extremidade do chamador está no mesmo local que o ponto de extremidade de destino.  
  
 Retorna um valor positivo se o ponto de extremidade do chamador ocorre posteriormente no texto que o ponto de extremidade de destino.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Se <paramref name="targetRange" /> é de um provedor de texto diferente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">A unidade textual.</param>
        <summary>Expande o intervalo de texto para a unidade de texto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o intervalo já tiver uma quantidade exata das unidades especificadas permanece inalterado.  
  
 Há uma série de etapas envolvidas em segundo plano para que o <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> método seja executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto" onde "{" e "}" é pontos de extremidade do intervalo de texto.  
  
2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> para o início da solicitados `unit` limite.  
  
3.  O intervalo é movido para frente ou para trás no <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> pelo número solicitado de `unit` limites.  
  
4.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por solicitado `unit` limite.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
> [!NOTE]
>  Essas etapas são necessárias porque é comum para leitores de tela ler uma palavra, frase ou todo o parágrafo em qualquer posição de cursor virtual ou o ponto de inserção.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A>respeita texto oculto e visível.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A>transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é suportado pelo controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindAttribute (int attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindAttribute(int32 attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(System.Int32,System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">O atributo a ser pesquisado.</param>
        <param name="value">O valor do atributo a ser pesquisado. Esse valor deve corresponder ao tipo especificado para o atributo.</param>
        <param name="backward">
          <see langword="true" />Se o último intervalo de texto que está ocorrendo deve ser retornado em vez da primeira. Caso contrário, <see langword="false" />.</param>
        <summary>Retorna um subconjunto do intervalo de texto que tem o valor de atributo especificado.</summary>
        <returns>Um intervalo de texto com um atributo correspondente e um valor de atributo; Caso contrário, nulo (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">A cadeia de caracteres de texto a ser pesquisado.</param>
        <param name="backward">
          <see langword="true" />Se o último intervalo de texto que está ocorrendo deve ser retornado em vez da primeira. Caso contrário, <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" />Se o caso deve ser ignorado; Caso contrário, <see langword="false" />.</param>
        <summary>Retorna um subconjunto do intervalo de texto que contém o texto especificado.</summary>
        <returns>Um intervalo de texto o texto especificado; correspondente Caso contrário, nulo (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (int attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAttributeValue(int32 attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attribute">O atributo de texto.</param>
        <summary>Recupera o valor do atributo especificado no intervalo de texto.</summary>
        <returns>Recupera um objeto que representa o valor do atributo especificado. Por exemplo, <c>GetAttributeValue(TextPattern.FontNameAttribute)</c> retorna uma cadeia de caracteres que representa o nome da fonte do intervalo de texto ao <c>GetAttributeValue(TextPattern.IsItalicAttribute)</c> Retorna um valor do tipo <see cref="T:System.Boolean" />.  
  
 Retorna <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> se o valor do atributo especificado varia ao longo do intervalo de texto.  
  
 Retorna <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> se o atributo especificado não é compatível com o provedor ou o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se o atributo especificado não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public double[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção de delimitadora retângulos para cada linha total ou parcialmente visível de texto em um intervalo de texto.</summary>
        <returns>Uma matriz de delimitadora retângulos para cada linha de total ou parcial de texto em um intervalo de texto.  
  
 Uma matriz vazia para um intervalo degenerado.  
  
 Uma matriz vazia para um intervalo de texto que tem as coordenadas da tela colocá-lo completamente fora da tela, rolado para fora da exibição ou obscurecida por uma janela de sobreposição.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção de todos os objetos inseridos que estão dentro do intervalo de texto.</summary>
        <returns>Uma coleção de objetos filho que estão dentro do intervalo. Também serão incluídos na coleção de filhos que sobrepõem o intervalo de texto, mas não são totalmente delimitados por ele.  
  
 Retorna uma coleção vazia se não houver nenhum objeto filho.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o controle mais interno que inclui o intervalo de texto.</summary>
        <returns>O controle delimitador, normalmente o provedor de texto que fornece o intervalo de texto. No entanto, se o provedor de texto oferece suporte a elementos filho, como tabelas ou hiperlinks, o elemento de fechamento pode ser um descendente do provedor de texto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetText(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">O comprimento máximo da cadeia de caracteres para retornar. Use <c>-1</c> se nenhum limite é necessário.</param>
        <summary>Recupera o texto sem formatação do intervalo.</summary>
        <returns>O texto sem formatação do intervalo de texto, possivelmente truncado em especificado <paramref name="maxLength" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A>respeita texto oculto e visível.  
  
 Se `maxLength` for maior que o comprimento da extensão de texto do chamador, a cadeia de caracteres retornada será o texto sem formatação do intervalo de texto.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A>não serão afetados pela ordem de pontos de extremidade no fluxo de texto; sempre retornará o texto entre os pontos de extremidade de início e término do intervalo de texto na ordem de fluxo lógico de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="maxLength" /> é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">O limite de unidade de texto.</param>
        <param name="count">O número de unidades de texto para mover.  
  
 Um valor positivo avança o intervalo de texto, um valor negativo move o intervalo de texto com versões anteriores e 0 não tem nenhum efeito.</param>
        <summary>Move o intervalo de texto, o número especificado de unidades de texto.</summary>
        <returns>O número de unidades realmente movido. Isso pode ser menor que o número solicitado se qualquer um dos pontos de extremidade de intervalo de texto novo é maior ou menor do que o <see cref="P:System.Windows.Automation.Provider.ITextProvider.DocumentRange" /> pontos de extremidade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas em segundo plano para que o <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> método seja executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto" onde "{" e "}" é pontos de extremidade do intervalo de texto.  
  
2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> para o início da solicitados `unit` limite.  
  
3.  O intervalo é movido para frente ou para trás no <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> pelo número solicitado de `unit` limites.  
  
4.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por solicitado `unit` limite.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
 O conteúdo textual (ou texto interno) de um recipiente de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto único e contínuo em visualização de controle e exibição de conteúdo de [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] árvore; objeto limites são ignorados.  
  
 ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto abrangidos por objetos inseridos.")  
Exemplo de um fluxo de texto com objetos inseridos e seus intervalos abrangentes  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A>respeita texto oculto e visível.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A>transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é suportado pelo controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 O texto não é alterado de alguma forma, o intervalo de texto abrange apenas uma parte diferente do texto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade para mover.</param>
        <param name="targetRange">Outro intervalo do mesmo provedor de texto.</param>
        <param name="targetEndpoint">Um ponto de extremidade no outro intervalo.</param>
        <summary>Move um ponto de extremidade de um intervalo de texto para o ponto de extremidade especificado de um segundo intervalo de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o ponto de extremidade que está sendo movido cruza o outro ponto de extremidade do mesmo intervalo de texto e outro ponto de extremidade é movido também, resultando em um intervalo degenerado e garantir que a ordenação correta dos pontos de extremidade (ou seja, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> sempre é menor ou igual a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade para mover.</param>
        <param name="unit">A unidade textual para mover.</param>
        <param name="count">O número de unidades a serem movidas. Um valor positivo avança o ponto de extremidade. Um valor negativo move para trás. Um valor de 0 não tem nenhum efeito.</param>
        <summary>Move um ponto de extremidade do intervalo de texto, o número especificado de unidades de texto dentro do intervalo do documento.</summary>
        <returns>O número de unidades realmente movidos, que pode ser menor que o número solicitado se mover que o ponto de extremidade é executado no início ou no final do documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas em segundo plano para que o <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> método seja executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto" onde "{" e "}" é pontos de extremidade do intervalo de texto.  
  
2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> para o início da solicitados `unit` limite.  
  
3.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por solicitado `unit` limite.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit%2A>transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é suportado pelo controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove uma seção realçada de texto correspondente para o chamador <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> pontos de extremidade, da coleção de texto realçado em um contêiner de texto que dá suporte a várias seleções de separação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ponto de inserção de texto será movido para a área do realce removido.  
  
 Fornece um intervalo de texto degenerado moverá o ponto de inserção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o provedor de texto não oferece suporte a várias seleções de disjunção (por exemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> deve ter um valor de <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" />Se o controle de texto deve ser rolado para que o intervalo de texto é alinhado com a parte superior do visor; <see langword="false" /> se ele deve ser alinhado com a parte inferior do visor.</param>
        <summary>Faz com que o controle de texto rolar verticalmente até que o intervalo de texto é visível no visor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView%2A>respeita texto oculto e visível.  
  
 Se o intervalo de texto está oculto, o controle de texto será rolada somente se o texto oculto tem uma âncora no visor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Realça o texto no controle de texto correspondente ao intervalo de texto <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> pontos de extremidade.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um intervalo de texto degenerado for fornecido, o ponto de inserção de texto será movido para o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade do intervalo de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ocorre quando a seleção de texto não é suportada pelo controle de texto.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
