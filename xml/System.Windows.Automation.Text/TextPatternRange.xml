<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa um intervalo de texto contínuo em uma <see cref="T:System.Windows.Automation.TextPattern" /> contêiner.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Automation.Text.TextPatternRange> pode representar um ponto de inserção, um subconjunto ou todo o texto em uma <xref:System.Windows.Automation.TextPattern> contêiner.  
  
 Um <xref:System.Windows.Automation.Text.TextPatternRange> se tornarão inválidos se ocorrer um dos seguintes: o texto no <xref:System.Windows.Automation.TextPattern> alterações contêiner devido a alguma atividade de usuário, ou o <xref:System.Windows.Automation.ValuePattern.SetValue%2A> método de <xref:System.Windows.Automation.ValuePattern> é usado para alterar programaticamente o valor do texto no <xref:System.Windows.Automation.TextPattern> contêiner.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adiciona à coleção do texto realçado em um contêiner de texto que dá suporte a vários, seleções de separação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Move o ponto de inserção de texto para a área da nova seleção.  
  
 Fornece um intervalo de texto degenerado move o ponto de inserção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o provedor de texto não oferece suporte a várias seleções de disjunção (por exemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> deve ter um valor de <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um novo <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> idêntico ao valor original <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> e herança de todas as propriedades do original.</summary>
        <returns>O novo intervalo de texto. Uma referência nula (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]) nunca é retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como alternativa, crie um novo <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> do <xref:System.Windows.Automation.TextPattern> e mover os dois pontos de extremidade para corresponder com os pontos de extremidade do intervalo de texto original.  
  
 O novo intervalo de pode ser manipulado de forma independente do original.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">Um intervalo de texto a ser comparado.</param>
        <summary>Retorna um <see cref="T:System.Boolean" /> valor que indica se o alcance (o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ponto de extremidade para o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> ponto de extremidade) de um texto intervalo for igual a outro intervalo de texto.</summary>
        <returns>
          <see langword="true" />Se o alcance dos dois intervalos de texto é idêntico; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se o intervalo que estão sendo comparado não são provenientes do mesmo fornecedor de texto.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">O <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> ponto de extremidade do chamador.</param>
        <param name="targetRange">O intervalo de destino para comparação.</param>
        <param name="targetEndpoint">O <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> ponto de extremidade de destino.</param>
        <summary>Retorna um <see cref="T:System.Int32" /> que indica se dois intervalos de texto têm pontos de extremidade idênticos.</summary>
        <returns>Retorna um valor negativo se o ponto de extremidade do chamador ocorre anteriormente no texto que o ponto de extremidade de destino.  
  
 Retorna zero se o ponto de extremidade do chamador está no mesmo local que o ponto de extremidade de destino.  
  
 Retorna um valor positivo se o ponto de extremidade do chamador ocorre posteriormente no texto que o ponto de extremidade de destino.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comparando os pontos de extremidade iniciais e final do mesmo intervalo de texto, você pode identificar se um intervalo de texto é degenerado ou se os pontos de extremidade estão na ordem de fluxo lógico de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se o intervalo for uma referência nula (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</exception>
        <exception cref="T:System.ArgumentException">Se o intervalo é de outro contêiner.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">A unidade textual.</param>
        <summary>Expande o intervalo de texto especificado <see cref="T:System.Windows.Automation.Text.TextUnit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o intervalo já tiver uma quantidade exata das unidades especificadas permanece inalterado.  
  
 Para que o <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> método seja executado com êxito, uma sequência de ações é executada em segundo plano.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, tornando o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto" onde "{" e "}" é pontos de extremidade do intervalo de texto.  
  
2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para o início da solicitados `unit` limite.  
  
3.  O intervalo é movido para frente ou para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pelo número solicitado de `unit` limites.  
  
4.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por solicitado `unit` limite.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
> [!NOTE]
>  Essas etapas são necessárias porque é comum para leitores de tela ler uma palavra, frase ou todo o parágrafo em qualquer posição de cursor virtual ou o ponto de inserção.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A>respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidade do texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A>transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é suportado pelo controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">O atributo a ser pesquisado.</param>
        <param name="value">O valor do atributo a ser pesquisado. Esse valor deve corresponder ao tipo especificado para o atributo.</param>
        <param name="backward">
          <see langword="true" />Se o último intervalo de texto que está ocorrendo deve ser retornado em vez da primeira. Caso contrário, <see langword="false" />.</param>
        <summary>Retorna um subconjunto do intervalo de texto que tem o valor de atributo especificado.</summary>
        <returns>Um intervalo de texto com um atributo correspondente e um valor de atributo; Caso contrário, nulo (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para verificar a visibilidade do texto.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para pesquisar todo o documento.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">A cadeia de caracteres de texto a ser pesquisado.</param>
        <param name="backward">
          <see langword="true" />Se o último intervalo de texto que está ocorrendo deve ser retornado em vez da primeira. Caso contrário, <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" />Se o caso deve ser ignorado; Caso contrário, <see langword="false" />.</param>
        <summary>Retorna um subconjunto do intervalo de texto que contém o texto especificado.</summary>
        <returns>Um intervalo de texto o texto especificado; correspondente Caso contrário, nulo (<see langword="Nothing" /> em [!INCLUDE[TLA#tla_visualbnet](~/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para verificar a visibilidade do texto.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para pesquisar todo o documento.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">O atributo de texto.</param>
        <summary>Retorna o valor do atributo especificado no intervalo de texto completo.</summary>
        <returns>Retorna o valor do atributo especificado. Por exemplo, GetAttributeValue(TextPattern.FontNameAttribute) retornaria uma cadeia de caracteres que representa o nome da fonte, se exclusivo do intervalo de texto ao GetAttributeValue(TextPattern.IsItalicAttribute) retornaria um valor booleano.  
  
 Retorna <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> se o valor do atributo especificado varia ao longo do intervalo de texto.  
  
 Retorna <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> se o atributo especificado não é compatível com o provedor ou o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para verificar a visibilidade do texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se o atributo especificado não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção de delimitadora retângulos para cada linha total ou parcialmente visível de texto em um intervalo de texto.</summary>
        <returns>Uma matriz de delimitadora retângulos para cada linha de total ou parcial de texto em um intervalo de texto.  
  
 Uma matriz vazia para um intervalo de texto de degeneração.  
  
 Uma matriz vazia para um intervalo de texto que tem as coordenadas da tela colocá-lo completamente fora da tela, rolado para fora da exibição ou obscurecida por uma janela de sobreposição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção de todos os objetos inseridos que estão dentro do intervalo de texto.</summary>
        <returns>Uma coleção de todos os objetos filho que estão dentro do intervalo. Também serão incluídos na coleção de filhos que sobrepõem o intervalo, mas não são totalmente delimitados por ele.  
  
 Retorna uma coleção vazia se não houver nenhum objeto filho.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o mais interno <see cref="T:System.Windows.Automation.AutomationElement" /> que inclui o intervalo de texto.</summary>
        <returns>O elemento interno colocar o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delimitador <xref:System.Windows.Automation.AutomationElement>, normalmente o provedor de texto que fornece o intervalo de texto. No entanto, se o provedor de texto oferece suporte a elementos filho, como tabelas ou hiperlinks, o elemento de fechamento pode ser um descendente do provedor de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">O comprimento máximo da cadeia de caracteres para retornar. Use <c>-1</c> se nenhum limite é necessário.</param>
        <summary>Retorna o texto sem formatação do intervalo de texto.</summary>
        <returns>O texto sem formatação do intervalo de texto, possivelmente truncado em especificado <paramref name="maxLength" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A>respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidade do texto.  
  
 Se `maxLength` for maior que o comprimento da extensão de texto do chamador, a cadeia de caracteres retornada será o texto sem formatação do intervalo de texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A>não serão afetados pela ordem de pontos de extremidade no fluxo de texto; sempre retornará o texto entre os pontos de extremidade de início e término do intervalo de texto na ordem de fluxo lógico de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="maxLength" /> é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">O limite de unidade de texto.</param>
        <param name="count">O número de unidades de texto para mover. Um valor positivo avança o intervalo de texto, um valor negativo move o intervalo de texto com versões anteriores e 0 não tem nenhum efeito.</param>
        <summary>Move o intervalo de texto, o número especificado de unidades de texto.</summary>
        <returns>O número de unidades realmente movido. Isso pode ser menor que o número solicitado se qualquer um dos pontos de extremidade de intervalo de texto novo é maior ou menor do que o <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" /> pontos de extremidade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas em segundo plano para que o <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> método seja executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto" onde "{" e "}" é pontos de extremidade do intervalo de texto.  
  
2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para o início da solicitados `unit` limite.  
  
3.  O intervalo é movido para frente ou para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pelo número solicitado de `unit` limites.  
  
4.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por solicitado `unit` limite.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
 O conteúdo textual (ou texto interno) de um recipiente de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto único e contínuo em visualização de controle e exibição de conteúdo de [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] árvore; objeto limites são ignorados. Se um cliente de automação de interface do usuário estiver recuperando o texto com a finalidade de citar, interpretar, ou analisar de alguma maneira, o intervalo de texto deve ser verificado para casos especiais, como uma tabela com textuais conteúdos ou outros objetos inseridos. Isso pode ser conseguido chamando <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> para obter um <xref:System.Windows.Automation.AutomationElement> cada Embedded objeto e, em seguida, chamar <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> para obter um intervalo de texto para cada elemento; isso é feito de forma recursiva até que todo o conteúdo textual tiver sido recuperado.  
  
 ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto abrangidos por objetos inseridos.")  
Exemplo de um fluxo de texto com objetos inseridos e seus intervalos abrangentes  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidade do texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é suportado pelo controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  O texto não é alterado de alguma forma, como o intervalo de texto abrange apenas uma parte diferente do texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade para mover.</param>
        <param name="targetRange">Outro intervalo do mesmo provedor de texto.</param>
        <param name="targetEndpoint">Um ponto de extremidade no outro intervalo.</param>
        <summary>Move um ponto de extremidade de um intervalo de texto para o ponto de extremidade especificado de um segundo intervalo de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o ponto de extremidade que está sendo movido cruza o outro ponto de extremidade do mesmo intervalo de texto e outro ponto de extremidade é movido também, resultando em um intervalo degenerado e garantir que a ordenação correta dos pontos de extremidade (ou seja, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> sempre é menor ou igual a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade para mover.</param>
        <param name="unit">A unidade textual para mover.</param>
        <param name="count">O número de unidades a serem movidas. Uma contagem positiva avança o ponto de extremidade. Uma contagem negativa move para trás. Uma contagem de 0 não tem nenhum efeito.</param>
        <summary>Move um ponto de extremidade do texto variar o número especificado de <see cref="T:System.Windows.Automation.Text.TextUnit" />s dentro do intervalo do documento.</summary>
        <returns>O número de unidades realmente movidos, que pode ser menor que o número solicitado se mover que o ponto de extremidade é executado no início ou no final do documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas em segundo plano para que o <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> método seja executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto" onde "{" e "}" é pontos de extremidade do intervalo de texto.  
  
2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para o início da solicitados `unit` limite.  
  
3.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por solicitado `unit` limite.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
 O conteúdo textual (ou texto interno) de um recipiente de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto único e contínuo em visualização de controle e exibição de conteúdo de [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] árvore; objeto limites são ignorados. Se um cliente de automação de interface do usuário estiver recuperando o texto com a finalidade de citar, interpretar, ou analisar de alguma maneira, o intervalo de texto deve ser verificado para casos especiais, como uma tabela com textuais conteúdos ou outros objetos inseridos. Isso pode ser conseguido chamando <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> para obter um <xref:System.Windows.Automation.AutomationElement> cada Embedded objeto e, em seguida, chamar <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> para obter um intervalo de texto para cada elemento; isso é feito de forma recursiva até que todo o conteúdo textual tiver sido recuperado.  
  
 ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto abrangidos por objetos inseridos.")  
Exemplo de um fluxo de texto com objetos inseridos e seus intervalos abrangentes  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A>transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é suportado pelo controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove uma seção realçada de texto, correspondente ao intervalo de texto chamada <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> pontos de extremidade de uma coleção existente do texto realçado em um contêiner de texto que dá suporte a várias seleções de separação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ponto de inserção de texto será movido para a área do realce removido.  
  
 Fornece um intervalo de texto degenerado moverá o ponto de inserção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o provedor de texto não oferece suporte a várias seleções de disjunção (por exemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> deve ter um valor de <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" />Se o controle de texto deve ser rolado para que o intervalo de texto é alinhado com a parte superior do visor; <see langword="false" /> se ele deve ser alinhado com a parte inferior do visor.</param>
        <summary>Faz com que o controle de texto rolar verticalmente até que o intervalo de texto é visível no visor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A>respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidade do texto. Se o intervalo de texto está oculto, o controle de texto será rolada somente se o texto oculto tem uma âncora no visor.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o controle não tem suporte a rolagem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Realça o texto no controle de texto correspondente ao intervalo de texto <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> pontos de extremidade.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um intervalo de texto degenerado for fornecido, o ponto de inserção de texto será movido para o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade do intervalo de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ocorre quando a seleção de texto não é suportada pelo controle de texto.</exception>
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.Automation.TextPattern" /> associado ao intervalo de texto.</summary>
        <value>O provedor de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
