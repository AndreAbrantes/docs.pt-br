<Type Name="WebContentTypeMapper" FullName="System.ServiceModel.Channels.WebContentTypeMapper">
  <TypeSignature Language="C#" Value="public abstract class WebContentTypeMapper" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WebContentTypeMapper extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.WebContentTypeMapper" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Web</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Especifica o formato para o qual o tipo de conteúdo de uma mensagem de entrada é mapeado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse é um ponto de extensibilidade no modelo de programação que é usado pelo codificador de mensagem da Web para substituir como conteúdo tipos são mapeados para formatos. Para implementar essa classe, substituir o <xref:System.ServiceModel.Channels.WebContentTypeMapper.GetMessageFormatForContentType%28System.String%29> método.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WebContentTypeMapper ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.WebContentTypeMapper.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ServiceModel.Channels.WebContentTypeMapper" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageFormatForContentType">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.WebContentFormat GetMessageFormatForContentType (string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.ServiceModel.Channels.WebContentFormat GetMessageFormatForContentType(string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.WebContentTypeMapper.GetMessageFormatForContentType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.WebContentFormat</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">O tipo de conteúdo que indica o tipo MIME dos dados deve ser interpretado.</param>
        <summary>Quando substituído em uma classe derivada, retorna o formato de mensagem usado para um tipo de conteúdo especificado.</summary>
        <returns>O <see cref="T:System.ServiceModel.Channels.WebContentFormat" /> que especifica o formato que o tipo de conteúdo da mensagem é mapeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso serve para ser um mecanismo de extensibilidade que pode ser usado para substituir os tipos de conteúdo como são mapeados para formatos de conteúdo da Web. Por exemplo, se todas as mensagens recebidas são processadas como "dados binários brutos" sem nunca fazer análise de XML ou JSON, você pode implementar um <xref:System.ServiceModel.Channels.WebContentTypeMapper> que sempre retornado <xref:System.ServiceModel.Channels.WebContentFormat.Raw> independentemente do tipo de conteúdo que foi passado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
