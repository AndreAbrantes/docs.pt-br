<Type Name="CommittableTransaction" FullName="System.Transactions.CommittableTransaction">
  <TypeSignature Language="C#" Value="public sealed class CommittableTransaction : System.Transactions.Transaction, IAsyncResult, IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit CommittableTransaction extends System.Transactions.Transaction implements class System.IAsyncResult, class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Transactions.CommittableTransaction" />
  <AssemblyInfo>
    <AssemblyName>System.Transactions</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Transactions.Local</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Transactions.Transaction</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Descreve uma transação pode ser confirmada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Transactions.CommittableTransaction> classe fornece um modo explícito para os aplicativos que usam uma transação, em vez de usar o <xref:System.Transactions.TransactionScope> classe implicitamente. Ao contrário do <xref:System.Transactions.TransactionScope> classe, o criador do aplicativo precisa chamar especificamente o <xref:System.Transactions.CommittableTransaction.Commit%2A> e <xref:System.Transactions.Transaction.Rollback%2A> métodos para confirmar ou anular a transação. No entanto, somente o criador de uma transação pode confirmar a transação. Portanto, as cópias de uma transação pode ser confirmada, obtidos por meio de <xref:System.Transactions.Transaction.Clone%2A> método não são pode ser confirmada.  
  
> [!NOTE]
>  É recomendável que você crie transações implícitas usando o <xref:System.Transactions.TransactionScope> de classe, para que o contexto de transação de ambiente é gerenciado automaticamente para você. Você também deve usar o <xref:System.Transactions.TransactionScope> e <xref:System.Transactions.DependentTransaction> classe para aplicativos que exigem o uso da mesma transação em várias chamadas de função ou várias chamadas do thread. Para obter mais informações sobre esse modelo, consulte o [implementando um implícita transação usando o escopo da transação](~/docs/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope.md) tópico.  
  
 Criando um <xref:System.Transactions.CommittableTransaction> não define automaticamente a transação de ambiente, que é a transação é executado em seu código. Você pode obter ou definir a transação de ambiente chamando estático <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> propriedade global <xref:System.Transactions.Transaction> objeto. Para obter mais informações sobre transações de ambiente, consulte a seção "Gerenciando transações fluxo usando TransactionScopeOption" o [implementando um implícita transação usando o escopo da transação](~/docs/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope.md) tópico. Se a transação de ambiente não for definida, qualquer operação em um Gerenciador de recursos não é parte da transação. Você precisa definir explicitamente e redefinir a transação de ambiente para garantir que os gerenciadores de recursos operam sob o contexto de transação à direita.  
  
 Até que um <xref:System.Transactions.CommittableTransaction> tiver sido confirmada, todos os recursos envolvidos na transação ainda estão bloqueados.  
  
 Um <xref:System.Transactions.CommittableTransaction> objeto não pode ser reutilizado. Depois que ele tiver sido confirmado ou revertido, ele não pode ser usado novamente em uma transação ou definido como o contexto de transação de ambiente atual.  
  
   
  
## Examples  
 O exemplo a seguir cria duas novas instâncias de <xref:System.Transactions.CommittableTransaction>, confirma e passa-los novamente respectivamente.  
  
  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CommittableTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Transactions.CommittableTransaction" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria uma nova instância da <xref:System.Transactions.CommittableTransaction> e confirma a ele.  
  
 [!code-csharp[Tx_CommittableTx#1](~/samples/snippets/csharp/VS_Snippets_CFX/tx_committabletx/cs/committabletxwithsql.cs#1)]
 [!code-vb[Tx_CommittableTx#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/tx_committabletx/vb/committabletxwithsql.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Uma tentativa de criar uma transação em Windows 98, Windows 98 Segunda edição ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CommittableTransaction (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.#ctor(System.TimeSpan)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A quantidade máxima de tempo que a transação pode existir, antes de ela será anulada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Transactions.CommittableTransaction" /> com o valor <paramref name="timeout" /> especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Uma tentativa de criar uma transação em Windows 98, Windows 98 Segunda edição ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CommittableTransaction (System.Transactions.TransactionOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Transactions.TransactionOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="options" Type="System.Transactions.TransactionOptions" />
      </Parameters>
      <Docs>
        <param name="options">Um <see cref="T:System.Transactions.TransactionOptions" /> estrutura que descreve as opções de transação a ser usado para a nova transação.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Transactions.CommittableTransaction" /> classe com as opções de transação especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria uma nova instância da <xref:System.Transactions.CommittableTransaction> com opções e anula a ele.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Uma tentativa de criar uma transação em Windows 98, Windows 98 Segunda edição ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCommit">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCommit (AsyncCallback callback, object user_defined_state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCommit(class System.AsyncCallback callback, object user_defined_state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="user_defined_state">To be added.</param>
        <summary>Começa uma tentativa de confirmar a transação de forma assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> interface que pode ser usada pelo chamador para verificar o status da operação assíncrona, ou aguardar a conclusão da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna imediatamente, antes da transação foi concluída. A transação e confirmações em um thread diferente e o `asyncCallback` delegado é invocado quando ele for concluído. Depois que este método é chamado, você não recebe o resultado da transação até que você chame <xref:System.Transactions.CommittableTransaction.EndCommit%2A>.  
  
> [!NOTE]
>  O processo de confirmação pode concluído de forma síncrona dentro esta chamada de método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Commit">
      <MemberSignature Language="C#" Value="public void Commit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Commit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.Commit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tenta confirmar a transação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando este método é chamado, todos os objetos que foram registrados para participar de transações são pesquisados e independentemente podem indicar seu voto para confirmar ou reverter a transação. Se qualquer participante votos para reverter a transação, ela será revertida e este método lança um <xref:System.Transactions.TransactionException> exceção. Essa é uma ocorrência normal de uma transação e seu código deve detectar e processar essas exceções.  
  
 <xref:System.Transactions.CommittableTransaction.Commit%2A>e <xref:System.Transactions.CommittableTransaction.EndCommit%2A> bloqueado até que a primeira fase de processamento de transação é concluída. A primeira fase termina após todos os gerenciadores de recursos e inscrições na transação tem votou o resultado da transação e o <xref:System.Transactions.TransactionManager> decidiu muito tempo confirmar ou anular a transação. A segunda fase de processamento é sempre assíncrona. Portanto, não há nenhuma garantia de que dados confirmados apenas de dentro de uma determinada transação estarão imediatamente disponíveis posteriormente quando não estiver usando outra transação para exibir esses dados.  
  
 Como blocos este método até que a primeira fase de processamento de transação seja concluída, seja extremamente cauteloso ao usar esse método em um aplicativo Windows Form (WinForm) ou um deadlock podem ocorrer. Se você chamar esse método dentro de um evento de controle do WinForm (por exemplo, clicar em um botão) e usar o síncrona <xref:System.Windows.Forms.Control.Invoke%2A> método para direcionar o controle para executar algumas tarefas de interface do usuário (por exemplo, altera cores) no meio de processamento de transação, ocorrerá um deadlock. Isso ocorre porque o <xref:System.Windows.Forms.Control.Invoke%2A> método é síncrono e bloqueia o thread de trabalho até que o thread de interface do usuário de seu trabalho seja concluído. No entanto, em nosso cenário, o thread de interface do usuário também está esperando para o thread de trabalho confirmar a transação. O resultado é que nenhum é capaz de continuar e o escopo aguardará indefinidamente para conclusão da confirmação. Você deve usar <xref:System.Windows.Forms.Control.BeginInvoke%2A> em vez de <xref:System.Windows.Forms.Control.Invoke%2A> sempre que possível, porque ele é assíncrona e, portanto, menos propenso a deadlocks.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Transactions.TransactionInDoubtException">
          <see cref="M:System.Transactions.CommittableTransaction.Commit" /> é chamado em uma transação e a transação se torna <see cref="F:System.Transactions.TransactionStatus.InDoubt" />.</exception>
        <exception cref="T:System.Transactions.TransactionAbortedException">
          <see cref="M:System.Transactions.CommittableTransaction.Commit" /> é chamado e a transação é revertida pela primeira vez.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCommit">
      <MemberSignature Language="C#" Value="public void EndCommit (IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndCommit(class System.IAsyncResult ar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="ar">To be added.</param>
        <summary>Termina uma tentativa de confirmar a transação de forma assíncrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar esse método em que o representante de retorno de chamada especificado como um parâmetro para o <xref:System.Transactions.CommittableTransaction.BeginCommit%2A> método, quando você terminar de qualquer trabalho de limpeza associado com a confirmação assíncrona. Você também pode chamar esse método antecipada sem esperar que o delegado. Se, no momento em que você chamar esse método, a transação não foi concluída, esse método aguarda sua conclusão.  
  
> [!CAUTION]
>  O <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornada pelo `asyncResult` é sempre `false`, mesmo que a operação é concluída de forma síncrona.  
  
 <xref:System.Transactions.CommittableTransaction.Commit%2A>e <xref:System.Transactions.CommittableTransaction.EndCommit%2A> bloqueado até que a primeira fase de processamento de transação é concluída. A primeira fase termina após todos os gerenciadores de recursos e inscrições na transação tem votou o resultado da transação e o <xref:System.Transactions.TransactionManager> decidiu muito tempo confirmar ou anular a transação. A segunda fase de processamento é sempre assíncrona. Portanto, não há nenhuma garantia de que dados confirmados apenas de dentro de uma determinada transação estarão imediatamente disponíveis posteriormente quando não estiver usando outra transação para exibir esses dados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Transactions.TransactionAbortedException">
          <see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /> é chamado e a transação é revertida pela primeira vez.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncState">
      <MemberSignature Language="C#" Value="object System.IAsyncResult.AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.IAsyncResult.AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Transactions.CommittableTransaction.System#IAsyncResult#AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto fornecido como o último parâmetro do <see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /> chamada de método.</summary>
        <value>O objeto fornecido como o último parâmetro do <see cref="M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)" /> chamada de método.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Transactions.CommittableTransaction.System#IAsyncResult#AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Threading.WaitHandle" /> que é usado para aguardar a conclusão de uma operação assíncrona.</summary>
        <value>Um <see cref="T:System.Threading.WaitHandle" /> que é usado para aguardar a conclusão de uma operação assíncrona.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Transactions.CommittableTransaction.System#IAsyncResult#CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma indicação se a operação de confirmação assíncrona concluída sincronicamente.</summary>
        <value>
          <see langword="true" />Se a operação de confirmação assíncrona é concluída de forma síncrona; Caso contrário, <see langword="false" />. Essa propriedade sempre retorna <see langword="false" /> mesmo se a operação é concluída de forma síncrona.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.IsCompleted">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Transactions.CommittableTransaction.System#IAsyncResult#IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma indicação se a operação de confirmação assíncrona foi concluída.</summary>
        <value>
          <see langword="true" /> se a operação for concluída; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.CommittableTransaction.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
