<Type Name="EncryptedKeyIdentifierClause" FullName="System.IdentityModel.Tokens.EncryptedKeyIdentifierClause">
  <TypeSignature Language="C#" Value="public sealed class EncryptedKeyIdentifierClause : System.IdentityModel.Tokens.BinaryKeyIdentifierClause" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EncryptedKeyIdentifierClause extends System.IdentityModel.Tokens.BinaryKeyIdentifierClause" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.BinaryKeyIdentifierClause</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa uma cláusula de identificador de chave que identifica uma chave criptografada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, o <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause> não precisa ser usada, diferente de quando um serviço de token de segurança personalizada é criado. Quando um serviço de token de segurança retorna um token de segurança, o token de segurança emitido contém referências aos tokens de segurança anexados ou não. Consultem referências associadas aos tokens de segurança que estão contidos dentro do cabeçalho de segurança de uma mensagem SOAP e referências não são tokens de segurança que não estão incluídas no cabeçalho de segurança de uma mensagem SOAP. Normalmente, essas referências confirmar a autenticidade do token de segurança emitido. Use o <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause> classe para fazer referência a uma chave criptografada. O <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey%2A> método retorna a chave criptografada.  
  
 [!INCLUDE[indigo2](~/includes/indigo2-md.md)]aceita encapsuladas chaves são bem formadas em relação ao formato de conexão. O algoritmo de codificação de chave especificado na conexão é aceita e usado. Não é verificado para ser compatível com o <xref:System.ServiceModel.Security.SecurityAlgorithmSuite> especificado pelo ponto de extremidade.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EncryptedKeyIdentifierClause (byte[] encryptedKey, string encryptionMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] encryptedKey, string encryptionMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.#ctor(System.Byte[],System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encryptedKey" Type="System.Byte[]" />
        <Parameter Name="encryptionMethod" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="encryptedKey">Uma matriz de <see cref="T:System.Byte" /> que contém uma chave é criptografada. Define o valor que é retornado o <see cref="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey" /> método.</param>
        <param name="encryptionMethod">O algoritmo de criptografia que é usado para criptografar a chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause" /> usando a chave especificada é criptografada e o algoritmo de criptografia usado para criptografar a chave de classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use a constante de estática cadeias de caracteres no <xref:System.IdentityModel.Tokens.SecurityAlgorithms> para especificar o algoritmo de criptografia para o `encryptionMethod` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="encryptionMethod" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="encryptedKey" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="encryptedKey" /> tem tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EncryptedKeyIdentifierClause (byte[] encryptedKey, string encryptionMethod, System.IdentityModel.Tokens.SecurityKeyIdentifier identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] encryptedKey, string encryptionMethod, class System.IdentityModel.Tokens.SecurityKeyIdentifier identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.#ctor(System.Byte[],System.String,System.IdentityModel.Tokens.SecurityKeyIdentifier)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encryptedKey" Type="System.Byte[]" />
        <Parameter Name="encryptionMethod" Type="System.String" />
        <Parameter Name="encryptingKeyIdentifier" Type="System.IdentityModel.Tokens.SecurityKeyIdentifier" />
      </Parameters>
      <Docs>
        <param name="encryptedKey">Uma matriz de <see cref="T:System.Byte" /> que contém uma chave é criptografada. Define o valor que é retornado o <see cref="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey" /> método.</param>
        <param name="encryptionMethod">O algoritmo de criptografia que é usado para criptografar a chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod" />.</param>
        <param name="identifier">To be added.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause" /> classe usando a chave especificada é criptografada, o algoritmo de criptografia usada para criptografar a chave e um identificador de chave para a chave de criptografia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use a constante de estática cadeias de caracteres no <xref:System.IdentityModel.Tokens.SecurityAlgorithms> para especificar o algoritmo de criptografia para o `encryptionMethod` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="encryptionMethod" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="encryptedKey" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="encryptedKey" /> tem tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EncryptedKeyIdentifierClause (byte[] encryptedKey, string encryptionMethod, System.IdentityModel.Tokens.SecurityKeyIdentifier identifier, string carriedKeyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] encryptedKey, string encryptionMethod, class System.IdentityModel.Tokens.SecurityKeyIdentifier identifier, string carriedKeyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.#ctor(System.Byte[],System.String,System.IdentityModel.Tokens.SecurityKeyIdentifier,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encryptedKey" Type="System.Byte[]" />
        <Parameter Name="encryptionMethod" Type="System.String" />
        <Parameter Name="encryptingKeyIdentifier" Type="System.IdentityModel.Tokens.SecurityKeyIdentifier" />
        <Parameter Name="carriedKeyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="encryptedKey">Uma matriz de <see cref="T:System.Byte" /> que contém uma chave é criptografada. Define o valor que é retornado o <see cref="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey" /> método.</param>
        <param name="encryptionMethod">O algoritmo de criptografia que é usado para criptografar a chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod" />.</param>
        <param name="identifier">To be added.</param>
        <param name="carriedKeyName">Um nome legível do usuário que está associado com a chave especificada no <c>encryptedKey</c> parâmetro. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.CarriedKeyName" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause" /> classe usando a chave especificada é criptografada, o algoritmo de criptografia usada para criptografar a chave, um identificador de chave para a chave de criptografia e um nome legível do usuário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use a constante de estática cadeias de caracteres no <xref:System.IdentityModel.Tokens.SecurityAlgorithms> para especificar o algoritmo de criptografia para o `encryptionMethod` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="encryptionMethod" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="encryptedKey" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="encryptedKey" /> tem tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EncryptedKeyIdentifierClause (byte[] encryptedKey, string encryptionMethod, System.IdentityModel.Tokens.SecurityKeyIdentifier identifier, string carriedKeyName, byte[] derivationNonce, int derivationLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] encryptedKey, string encryptionMethod, class System.IdentityModel.Tokens.SecurityKeyIdentifier identifier, string carriedKeyName, unsigned int8[] derivationNonce, int32 derivationLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.#ctor(System.Byte[],System.String,System.IdentityModel.Tokens.SecurityKeyIdentifier,System.String,System.Byte[],System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encryptedKey" Type="System.Byte[]" />
        <Parameter Name="encryptionMethod" Type="System.String" />
        <Parameter Name="encryptingKeyIdentifier" Type="System.IdentityModel.Tokens.SecurityKeyIdentifier" />
        <Parameter Name="carriedKeyName" Type="System.String" />
        <Parameter Name="derivationNonce" Type="System.Byte[]" />
        <Parameter Name="derivationLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="encryptedKey">Uma matriz de <see cref="T:System.Byte" /> que contém uma chave é criptografada. Define o valor que é retornado o <see cref="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey" /> método.</param>
        <param name="encryptionMethod">O algoritmo de criptografia que é usado para criptografar a chave. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod" />.</param>
        <param name="identifier">To be added.</param>
        <param name="carriedKeyName">Um nome legível do usuário que está associado com a chave especificada no <c>encryptedKey</c> parâmetro. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.CarriedKeyName" />.</param>
        <param name="derivationNonce">Uma matriz de <see cref="T:System.Byte" /> que contém o valor de uso único que foi usado para criar uma chave derivada. Define o valor retornado pelo <see cref="M:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.GetDerivationNonce" /> método.</param>
        <param name="derivationLength">O tamanho da chave derivada. Define o valor da propriedade <see cref="P:System.IdentityModel.Tokens.SecurityKeyIdentifierClause.DerivationLength" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause" /> classe usando a chave especificada é criptografada, o algoritmo de criptografia usada para criptografar a chave, um identificador de chave para a chave e um nome de usuário legível.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o `derivationNonce` e `derivationLength` são especificados a chave derivada implícita é usada em vez da chave de segurança direta do token.  
  
 Use a constante de estática cadeias de caracteres no <xref:System.IdentityModel.Tokens.SecurityAlgorithms> para especificar o algoritmo de criptografia para o `encryptionMethod` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="encryptionMethod" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="encryptedKey" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="encryptedKey" /> tem tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CarriedKeyName">
      <MemberSignature Language="C#" Value="public string CarriedKeyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CarriedKeyName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.CarriedKeyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um nome legível do usuário que está associado com a chave criptografada.</summary>
        <value>Um nome legível do usuário que está associado com a chave criptografada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.CarriedKeyName%2A> propriedade é serializada em XML, ele é colocado do <`CarriedKeyName`> elemento. Para as chaves criptografadas, o <`CarriedKeyName`> é um elemento opcional que associa um nome legível do usuário com um valor de chave. Esse nome, em seguida, pode ser usado para fazer referência a chave usando o <`KeyName`> elemento dentro do <`KeyInfo`> elemento. O mesmo <`CarriedKeyName`> valor do elemento, ao contrário de um valor de ID, pode ocorrer várias vezes em um único documento. O valor da chave deve ser a mesma em todos os <`EncryptedKey`> identificados com o mesmo de elementos <`CarriedKeyName`> nome dentro de um documento XML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptingKeyIdentifier">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityKeyIdentifier EncryptingKeyIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityKeyIdentifier EncryptingKeyIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptingKeyIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um identificador de chave para a chave de criptografia.</summary>
        <value>Um <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" /> que representa o identificador de chave para a chave de criptografia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptionMethod">
      <MemberSignature Language="C#" Value="public string EncryptionMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncryptionMethod" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o algoritmo de criptografia que é usado para criptografar a chave.</summary>
        <value>O algoritmo de criptografia que é usado para criptografar a chave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, o valor da <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod%2A> propriedade é uma das cadeias de caracteres constantes estáticas no <xref:System.IdentityModel.Tokens.SecurityAlgorithms> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEncryptedKey">
      <MemberSignature Language="C#" Value="public byte[] GetEncryptedKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetEncryptedKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém a chave criptografada.</summary>
        <returns>Uma matriz de <see cref="T:System.Byte" /> que contém a chave criptografada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz retornada pelo <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey%2A> método é um clone da chave criptografada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public override bool Matches (System.IdentityModel.Tokens.SecurityKeyIdentifierClause clause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Matches(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause clause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.Matches(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="clause">To be added.</param>
        <summary>Retorna um valor que indica se o identificador de chave para essa instância é equivalente à cláusula do identificador de chave especificado.</summary>
        <returns>
          <see langword="true" />Se <paramref name="clause" /> é do tipo <see cref="T:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause" /> e tem o mesmo criptografados chave, o método de criptografia e o nome legível pelo usuário como a instância atual; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clause" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public bool Matches (byte[] encryptedKey, string encryptionMethod, string carriedKeyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Matches(unsigned int8[] encryptedKey, string encryptionMethod, string carriedKeyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.Matches(System.Byte[],System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encryptedKey" Type="System.Byte[]" />
        <Parameter Name="encryptionMethod" Type="System.String" />
        <Parameter Name="carriedKeyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="encryptedKey">Uma matriz de <see cref="T:System.Byte" /> que contém uma chave é criptografada.</param>
        <param name="encryptionMethod">O algoritmo de criptografia que é usado para criptografar a chave.</param>
        <param name="carriedKeyName">Um nome legível do usuário que está associado com a chave criptografada.</param>
        <summary>Retorna um valor que indica se o identificador de chave para essa instância é equivalente a chave criptografada especificada, o método de criptografia e o nome legível do usuário.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="encryptedKey" />, <paramref name="encryptionMethod" /> e <paramref name="carriedKeyName" /> parâmetros têm os mesmos valores retornados pelo <see cref="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.GetEncryptedKey" /> método e o <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.EncryptionMethod" /> e <see cref="P:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.CarriedKeyName" /> propriedades, respectivamente; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o objeto atual.</summary>
        <returns>O objeto atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Tokens.EncryptedKeyIdentifierClause.ToString%2A> método retorna uma cadeia de caracteres que contém a chave e o algoritmo de criptografia que é usado para criptografar a chave.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
