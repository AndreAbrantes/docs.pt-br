<Type Name="ModuleBuilder" FullName="System.Reflection.Emit.ModuleBuilder">
  <TypeSignature Language="C#" Value="public class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ModuleBuilder extends System.Reflection.Module implements class System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ModuleBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Module</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ModuleBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ModuleBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define e representa um módulo em um assembly dinâmico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma instância de <xref:System.Reflection.Emit.ModuleBuilder>, use o <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de `ModuleBuilder` para criar um módulo dinâmico. Observe que o ModuleBuilder é criado chamando <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> em <xref:System.Reflection.Emit.AssemblyBuilder>, em vez de por meio de um construtor.  
  
 [!code-cpp[ModuleBuilder_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_Class/CPP/modulebuilder.cpp#1)]
 [!code-csharp[ModuleBuilder_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_Class/CS/modulebuilder.cs#1)]
 [!code-vb[ModuleBuilder_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_Class/VB/modulebuilder.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ModuleBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o assembly dinâmico definido nesta instância do <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <value>O assembly dinâmico que definiu o módulo dinâmico atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Assembly> objeto que é retornado é o <xref:System.Reflection.Emit.AssemblyBuilder> que definido nesta instância do <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGlobalFunctions">
      <MemberSignature Language="C#" Value="public void CreateGlobalFunctions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateGlobalFunctions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conclui a definições de função global e dados globais para esse módulo dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método deve ser chamado quando o usuário é feito com a definição de todas as funções globais dentro deste módulo dinâmico. Depois de chamar essa função, não há mais novas funções globais ou novos dados globais são permitidos.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `CreateGlobalFunctions` para criar um método estático global de um <xref:System.Reflection.Emit.MethodBuilder> implementado com <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#2)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#2)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">A URL para o documento.</param>
        <param name="language">O GUID que identifica o idioma do documento. Ele pode ser <see cref="F:System.Guid.Empty" />.</param>
        <param name="languageVendor">O GUID que identifica o fornecedor de idioma do documento. Ele pode ser <see cref="F:System.Guid.Empty" />.</param>
        <param name="documentType">O GUID que identifica o tipo de documento. Ele pode ser <see cref="F:System.Guid.Empty" />.</param>
        <summary>Define um documento de origem.</summary>
        <returns>O documento definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Versões anteriores do .NET Framework lançam <xref:System.ArgumentException> em vez de <xref:System.ArgumentNullException> quando `url` é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de `DefineDocument` para anexar um documento de símbolo externo (no caso, um IL arquivo bruto) a um módulo dinâmico.  
  
 [!code-cpp[ModuleBuilder_DefineDocument#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CPP/modulebuilder_definedocument.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineDocument#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CS/modulebuilder_definedocument.cs#1)]
 [!code-vb[ModuleBuilder_DefineDocument#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineDocument/VB/modulebuilder_definedocument.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> é <see langword="null" />. Essa é uma alteração de versões anteriores do .NET Framework.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método é chamado em um módulo dinâmico não é um módulo de depuração.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEnum">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EnumBuilder DefineEnum (string name, System.Reflection.TypeAttributes visibility, Type underlyingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EnumBuilder DefineEnum(string name, valuetype System.Reflection.TypeAttributes visibility, class System.Type underlyingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EnumBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="visibility" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="underlyingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo de enumeração. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="visibility">Os atributos de tipo de enumeração. Os atributos são qualquer bit definido pelo <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
        <param name="underlyingType">O tipo subjacente para a enumeração. Isso deve ser um tipo inteiro interno.</param>
        <summary>Define um tipo de enumeração que é um tipo de valor com um único campo de não-estático chamado <paramref name="value__" /> do tipo especificado.</summary>
        <returns>A enumeração definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A enumeração definida é uma classe derivada de <xref:System.Enum>. O `value__` campo tem <xref:System.Reflection.FieldAttributes.Private> e <xref:System.Reflection.FieldAttributes.SpecialName> conjunto de atributos.  
  
 Para obter mais informações sobre os tipos de inteiro interno que pode ser especificado como os tipos subjacentes de enumerações, consulte [visão geral da biblioteca de classe](~/docs/standard/class-library-overview.md).  
  
> [!NOTE]
>  Em versões do .NET Framework 1.0 e 1.1, é necessário definir enumerações usando <xref:System.Reflection.Emit.TypeBuilder> porque <xref:System.Reflection.Emit.EnumBuilder> emite enumerações cujos elementos são do tipo <xref:System.Int32> em vez do tipo de enumeração. No .NET Framework versão 2.0, <xref:System.Reflection.Emit.EnumBuilder> emite enumerações cujos elementos têm o tipo correto.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `DefineEnum` para implementar uma classe de enumeração em um módulo dinâmico. O exemplo define uma enumeração denominada `Elevation` que tem um tipo subjacente de <xref:System.Int32>e cria dois elementos: `Low`, com um valor de 0, e `High`, com um valor de 1. Depois que o tipo tiver sido criado, o assembly é salvo com o nome `TempAssembly.dll`. Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o conteúdo deste assembly.  
  
> [!NOTE]
>  Antes do .NET Framework versão 2.0, este exemplo de código não produz uma enumeração correta.  
  
 [!code-cpp[ModuleBuilder_DefineEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CPP/modulebuilder_defineenum.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CS/modulebuilder_defineenum.cs#1)]
 [!code-vb[ModuleBuilder_DefineEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineEnum/VB/modulebuilder_defineenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Atributos que não sejam os atributos de visibilidade são fornecidos.  
  
 -ou-  
  
 Uma enumeração com o nome especificado existe no assembly pai deste módulo.  
  
 -ou-  
  
 Os atributos de visibilidade não coincidem com o escopo da enumeração. Por exemplo, <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> é especificado para <paramref name="visibility" />, mas a enumeração não é um tipo aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método. <c>atributos</c> devem incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <summary>Define um método global com o nome especificado, atributos, tipo de retorno e os tipos de parâmetro.</summary>
        <returns>O método global definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método global que define este método não é utilizável até que você chame <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `DefineGlobalMethod` para criar um método independente de tipo associado ao atual <xref:System.Reflection.Emit.ModuleBuilder>. Depois de criar o método global, <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> deve ser chamado para concluí-la.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> é igual a zero  
  
 -ou-  
  
 Um elemento de <see cref="T:System.Type" /> matriz é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método. <c>atributos</c> devem incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">A convenção de chamada para o método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <summary>Define um método global com o nome especificado, atributos, convenção de chamada, tipo de retorno e tipos de parâmetro.</summary>
        <returns>O método global definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não pode usar o método global que este método define até que você chame <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de `DefineGlobalMethod` para criar um método independente de tipo associado ao atual <xref:System.Reflection.Emit.ModuleBuilder>. Depois de criar o método global, <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> deve ser chamado para concluí-la.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
 -ou-  
  
 Um elemento de <see cref="T:System.Type" /> matriz é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] requiredReturnTypeCustomModifiers, class System.Type[] optionalReturnTypeCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] requiredParameterTypeCustomModifiers, class System.Type[][] optionalParameterTypeCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="requiredReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredParameterTypeCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalParameterTypeCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter caracteres nulos inseridos.</param>
        <param name="attributes">Os atributos do método. <c>atributos</c> devem incluir <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">A convenção de chamada para o método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="requiredReturnTypeCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados necessários para o tipo de retorno, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
        <param name="optionalReturnTypeCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais para o tipo de retorno, como <see cref="T:System.Runtime.CompilerServices.IsConst" /> ou <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <param name="requiredParameterTypeCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados necessários para o parâmetro correspondente do método global. Se um argumento específico não tiver nenhum modificadores personalizados necessários, especifique <see langword="null" /> em vez de uma matriz de tipos. Se o método global não possui argumentos, ou se nenhum dos argumentos exigi modificadores personalizados, especificar <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="optionalParameterTypeCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente. Especifique se um argumento específico não opcionais modificadores personalizados <see langword="null" /> em vez de uma matriz de tipos. Se o método global não possui argumentos, ou se nenhum dos argumentos tem modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <summary>Define um método global com o nome especificado, atributos, chamando convenção, tipo de retorno modificadores personalizados para o tipo de retorno, os tipos de parâmetro e os modificadores personalizados para os tipos de parâmetro.</summary>
        <returns>O método global definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para os designers de compiladores gerenciados.  
  
 Você não pode usar o método global que este método define até que você chame <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático. Ou seja, <paramref name="attributes" /> não inclui <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
 -ou-  
  
 Um elemento de <see cref="T:System.Type" /> matriz é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> método foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome usado para fazer referência aos dados. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="data">O objeto binário grande (BLOB) de dados.</param>
        <param name="attributes">Os atributos do campo. O padrão é <see langword="Static" />.</param>
        <summary>Define um campo de dados inicializado na seção .sdata o arquivo executável portátil (PE).</summary>
        <returns>Um campo de dados de referência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static>é incluído automaticamente no `attributes`.  
  
 Os dados definidos por este método não são criados até que o <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> método é chamado.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> método para definir um campo de dados inicializado no `.sdata` seção do arquivo PE (executável portátil).  
  
 [!code-cpp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CPP/modulebuilder_defineinitializeddata.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CS/modulebuilder_defineinitializeddata.cs#1)]
 [!code-vb[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/VB/modulebuilder_defineinitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tamanho de <paramref name="data" /> é menor ou igual a zero ou maior que ou igual a 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineManifestResource">
      <MemberSignature Language="C#" Value="public void DefineManifestResource (string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineManifestResource(string name, class System.IO.Stream stream, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome diferencia maiusculas de minúsculas para o recurso.</param>
        <param name="stream">Um fluxo que contém os bytes para o recurso.</param>
        <param name="attribute">Um valor de enumeração que especifica se o recurso é pública ou privada.</param>
        <summary>Define um objeto binário grande (BLOB) que representa um recurso de manifesto a ser inserido no assembly dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recursos que são registrados no manifesto do assembly podem ser recursos gerenciados ou BLOBs do recurso de manifesto, e cada um deles pode ser incluída no assembly, vinculando ou incorporando. Todos os quatro cenários há suporte para assemblies dinâmicos.  
  
-   Esse método permite que você insira um recurso de manifesto BLOB em um assembly dinâmico.  
  
-   Para inserir um recurso gerenciado em um módulo de manifesto de um assembly dinâmico ou um módulo de satélite, use o <xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType> método para obter um gravador de recurso e usar o <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> para adicionar o recurso.  
  
-   Para vincular um recurso gerenciado em um assembly dinâmico, use o <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType> método para obter um gravador de recurso e usar o <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> para adicionar o recurso vinculado.  
  
-   Para vincular um recurso de manifesto BLOB em um assembly dinâmico, use o <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType> método para adicionar o recurso vinculado.  
  
 Além disso, um único recurso do Win32 pode ser anexado a um assembly usando o <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> método ou o <xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> método. Este recurso não aparecem no manifesto do assembly.  
  
   
  
## Examples  
 O exemplo a seguir gera e salva um assembly dinâmico chamado `EmittedManifestResourceAssembly.exe`, que contém um embedded recurso não gerenciado. O exemplo cria o assembly, que consiste em um módulo e abre um fluxo de memória para conter o recurso não gerenciado. O código, em seguida, chama o <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> método para definir o recurso.  
  
> [!NOTE]
>  Você pode usar qualquer tipo de fluxo para o recurso; Por exemplo, você pode ler os dados binários não gerenciados de um arquivo.  
  
 O exemplo define um tipo no módulo dinâmico com um `Main` método e gera o MSIL para o corpo do método. Após o corpo para o `Main` método foi gerado e o tipo tenha sido criado, o exemplo de código grava cinco bytes no fluxo associado com o recurso de manifesto. Quando o assembly for salvo, o recurso é anexado a ele.  
  
 Depois de executar o exemplo, você pode executar o assembly emitido. O código do assembly emitido `Main` método lê o recurso de manifesto inserido e imprime os valores de byte para o console. Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para exibir as informações no manifesto do assembly.  
  
 [!code-csharp[DefineManifestResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineManifestResource/cs/source.cs#1)]
 [!code-vb[DefineManifestResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineManifestResource/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="stream" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de comprimento zero.</exception>
        <exception cref="T:System.InvalidOperationException">O assembly dinâmico que contém o módulo atual é transitório; ou seja, nenhum nome de arquivo foi especificado quando <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /> foi chamado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método <see langword="PInvoke" />. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <param name="nativeCallConv">A convenção de chamada nativa.</param>
        <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
        <summary>Define uma <see langword="PInvoke" /> método com o nome especificado, o nome da DLL no qual o método é definido, os atributos de método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e o <see langword="PInvoke" /> sinalizadores.</summary>
        <returns>O método <see langword="PInvoke" /> definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns atributos de importação DLL (consulte a descrição do DllImportAttribute) não podem ser especificados como argumentos para esse método. Esses atributos devem ser definidos pelo emissor de um atributo personalizado para o método. Por exemplo, o atributo de importação de DLL `PreserveSig` é definido pelo emissor de um atributo personalizado.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do `DefinePInvokeMethod` método para criar um <xref:System.Reflection.Emit.MethodBuilder> para um método externo não gerenciado, `MessageBoxA`, na API do Win32. O exemplo exibe uma caixa de mensagem com **novamente** e **Cancelar** botões e exibe o valor de retorno da caixa de mensagem.  
  
> [!IMPORTANT]
>  Para obter um valor de retorno diferente de zero, você deve adicionar <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático ou se o tipo de conteúdo é uma interface.  
  
 -ou-  
  
 O método é abstrato.  
  
 -ou-  
  
 O método foi definido anteriormente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando o<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método <see langword="PInvoke" />. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
        <param name="entryName">O nome do ponto de entrada na DLL.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <param name="nativeCallConv">A convenção de chamada nativa.</param>
        <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
        <summary>Define uma <see langword="PInvoke" /> método com o nome especificado, o nome da DLL no qual o método é definido, os atributos de método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e o <see langword="PInvoke" /> sinalizadores.</summary>
        <returns>O método <see langword="PInvoke" /> definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método. Esses atributos devem ser definidos pelo emissor de um atributo personalizado para o método. Por exemplo, o atributo de importação de DLL `PreserveSig` é definido pelo emissor de um atributo personalizado.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do `DefinePInvokeMethod` método para criar um <xref:System.Reflection.Emit.MethodBuilder> para um método externo não gerenciado, `MessageBoxA`, na API do Win32. O exemplo exibe uma caixa de mensagem com **novamente** e **Cancelar** botões e exibe o valor de retorno da caixa de mensagem.  
  
> [!IMPORTANT]
>  Para obter um valor de retorno diferente de zero, você deve adicionar <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.  
  
 Este exemplo usa uma sobrecarga diferente de <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A> método, mas a técnica é o mesmo.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático ou se o tipo de conteúdo é uma interface ou se o método é abstract se o método foi definido anteriormente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando o<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do recurso. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="description">A descrição do recurso.</param>
        <summary>Define o recurso inserido gerenciado nomeado a ser armazenado neste módulo.</summary>
        <returns>Um gravador de recurso para o recurso definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O chamador não deve chamar o `ResourceWriter.Generate()` e `ResourceWriter.Close()` métodos, porque esses métodos são chamados pelo `ModuleBuilder.Save` quando o assembly dinâmico é gravado no disco.  
  
 Use esse método para inserir um recurso gerenciado. Para incorporar um blob de recurso de manifesto, use o <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> método. Para obter um resumo de incorporação e a vinculação de recursos gerenciados e blobs de recurso de manifesto, consulte o <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> método.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `DefineResource` para adicionar um recurso externo ao atual <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CPP/modulebuilder_defineresource1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CS/modulebuilder_defineresource1.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource1/VB/modulebuilder_defineresource1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Esse módulo é transitório.  
  
 -ou-  
  
 O assembly que o contém não é persistente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome do recurso. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="description">A descrição do recurso.</param>
        <param name="attribute">Os atributos de recursos.</param>
        <summary>Define o gerenciadas incorporado recurso denominado com determinados atributos que deve ser armazenado neste módulo.</summary>
        <returns>Um gravador de recurso para o recurso definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O chamador não deve chamar o `ResourceWriter.Generate()` e `ResourceWriter.Close()` métodos, porque esses métodos são chamados pelo `ModuleBuilder.Save` quando o assembly dinâmico é gravado no disco.  
  
 Use esse método para inserir um recurso gerenciado. Para incorporar um blob de recurso de manifesto, use o <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> método. Para obter um resumo de incorporação e a vinculação de recursos gerenciados e blobs de recurso de manifesto, consulte o <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> método.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de DefineResource para adicionar um recurso externo ao atual <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CPP/modulebuilder_defineresource2.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CS/modulebuilder_defineresource2.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource2/VB/modulebuilder_defineresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Esse módulo é transitório.  
  
 -ou-  
  
 O assembly que o contém não é persistente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo, incluindo o namespace. <c>nome</c> não pode conter nulos incorporados.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> para um tipo particular com o nome especificado neste módulo.</summary>
        <returns>Um tipo particular com o nome especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo definido.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> considerando o nome do tipo e os atributos de tipo.</summary>
        <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos requeridos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">O atributo a ser associado ao tipo.</param>
        <param name="parent">O tipo que estende o tipo definido.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> fornecido o nome do tipo, seus atributos e o tipo que estende o tipo definido.</summary>
        <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos requeridos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo definido.</param>
        <param name="parent">O tipo que estende o tipo definido.</param>
        <param name="typesize">O tamanho total do tipo.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que estende o tipo definido e o tamanho total do tipo.</summary>
        <returns>Um objeto <see langword="TypeBuilder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. É proibido têm dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packsize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packsize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packsize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo definido.</param>
        <param name="parent">O tipo que estende o tipo definido.</param>
        <param name="packsize">O tamanho de remessa do tipo.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, os atributos, o tipo que estende o tipo definido e o tamanho de remessa do tipo.</summary>
        <returns>Um objeto <see langword="TypeBuilder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos a ser associado ao tipo.</param>
        <param name="parent">O tipo que estende o tipo definido.</param>
        <param name="interfaces">A lista de interfaces que implementa o tipo.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, atributos, o tipo que estende o tipo definido e as interfaces que implementa o tipo definido.</summary>
        <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos requeridos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packingSize, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packingSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">O caminho completo do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo definido.</param>
        <param name="parent">O tipo que estende o tipo definido.</param>
        <param name="packingSize">O tamanho de remessa do tipo.</param>
        <param name="typesize">O tamanho total do tipo.</param>
        <summary>Constrói um <see langword="TypeBuilder" /> dado o nome do tipo, atributos, o tipo que estende o tipo definido, o tamanho de remessa do tipo definido e o tamanho total do tipo definido.</summary>
        <returns>Um <see langword="TypeBuilder" /> criado com todos os atributos requeridos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nomes de tipo devem ser exclusivos dentro de um assembly. Você não pode ter dois tipos com o mesmo nome em dois módulos diferentes de um assembly.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.Emit.TypeBuilder> no módulo dinâmico atual usando `CreateType`, compilações e conclui o tipo e salva o assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Existe um tipo com o nome especificado no assembly pai deste módulo.  
  
 -ou-  
  
 Atributos de tipo aninhado são definidos em um tipo que não esteja aninhado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome usado para fazer referência aos dados. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="size">O tamanho do campo de dados.</param>
        <param name="attributes">Os atributos do campo.</param>
        <summary>Define um campo de dados não inicializado na seção .sdata o arquivo executável portátil (PE).</summary>
        <returns>Um campo de dados de referência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static>é incluído automaticamente no `attributes`.  
  
 Os dados definidos por este método não são criados até que o <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> método é chamado.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 <paramref name="size" />é menor ou igual a zero, ou maior que ou igual a 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">Um BLOB opaco que representa um recurso não gerenciado</param>
        <summary>Define um recurso incorporado não gerenciado recebe um opaco objeto binário grande (BLOB) de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um assembly pode ser associado a apenas um recurso não gerenciado. Isso significa que a chamada `DefineVersionInfoResource` ou `DefineUnmanagedResource` após um um dos métodos foi chamado anteriormente gera <xref:System.ArgumentException>. Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o common language runtime).  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um recurso não gerenciado já foi definido no assembly do módulo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">O nome do arquivo de recurso não gerenciado.</param>
        <summary>Define um recurso não gerenciado, considerando o nome do arquivo de recurso Win32.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um assembly pode ser associado a apenas um recurso não gerenciado. Isso significa que a chamada `DefineVersionInfoResource` ou `DefineUnmanagedResource` após um um dos métodos foi chamado anteriormente gera <xref:System.ArgumentException>. Vários recursos não gerenciados precisam ser mesclada com uma ferramenta como o utilitário Microsoft ResMerge (não é fornecido com o common language runtime).  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um recurso não gerenciado já foi definido no assembly do módulo.  
  
 -ou-  
  
 <paramref name="resourceFileName" /> é a cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> não foi encontrado.  
  
 -ou-  
  
 <paramref name="resourceFileName" /> é um diretório.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
        <summary>Retorna um valor que indica se esta instância é igual ao objeto especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public override string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see langword="String" /> que representa o nome totalmente qualificado e o caminho para este módulo.</summary>
        <value>O nome do módulo totalmente qualificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter o nome sem o caminho, use `Name`.  
  
> [!NOTE]
>  No caso de um nome de módulo é dependente de plataforma.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Acessa informações no caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetArrayMethod (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetArrayMethod(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">Uma classe de matriz.</param>
        <param name="methodName">O nome de um método na classe de matriz.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <summary>Retorna o método chamado em uma classe de matriz.</summary>
        <returns>O método chamado em uma classe de matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetArrayMethod`é útil quando você tem uma matriz de um tipo cuja definição não foi concluída e você deseja acessar métodos definidos no <xref:System.Array>. Por exemplo, você pode definir um tipo e deseja definir um método que usa uma matriz do tipo como um parâmetro. Para acessar os elementos da matriz, você precisará chamar métodos do <xref:System.Array> classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> para obter o <xref:System.Reflection.MethodInfo> correspondente a um método que retorna um valor de matriz.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#1)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#1)]
 [!code-vb[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" />não é uma matriz.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetArrayMethodToken (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetArrayMethodToken(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">O objeto para a matriz.</param>
        <param name="methodName">Uma cadeia de caracteres que contém o nome do método.</param>
        <param name="callingConvention">A convenção de chamada para o método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
        <summary>Retorna o token para o método chamado em uma classe de matriz.</summary>
        <returns>O token para o método nomeado em uma classe de matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é semelhante ao <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>, exceto que ele retorna o token do método de matriz em vez do método em si.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> para obter o <xref:System.Reflection.Emit.MethodToken> correspondente a um método que retorna um valor de matriz.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#2)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#2)]
 [!code-vb[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" />não é uma matriz.  
  
 -ou-  
  
 O comprimento de <paramref name="methodName" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> ou <paramref name="methodName" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="con">O construtor para obter um token.</param>
        <summary>Retorna o token usado para identificar o construtor especificado neste módulo.</summary>
        <returns>O token usado para identificar o construtor especificado neste módulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">O construtor para obter um token.</param>
        <param name="optionalParameterTypes">Uma coleção de tipos dos parâmetros opcionais para o construtor.</param>
        <summary>Retorna o token usado para identificar o construtor que tem os atributos especificados e tipos de parâmetro neste módulo.</summary>
        <returns>O token usado para identificar o construtor especificado neste módulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
        <summary>Retorna todos os atributos personalizados que foram aplicados ao atual <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <returns>Uma matriz que contém os atributos personalizados; a matriz está vazia se não houver nenhum atributo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">O tipo base da qual derivam de atributos.</param>
        <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
        <summary>Retorna todos os atributos personalizados que foram aplicados ao atual <see cref="T:System.Reflection.Emit.ModuleBuilder" />, e que derivam de um tipo de atributo especificado.</summary>
        <returns>Uma matriz que contém os atributos personalizados que são derivados, em qualquer nível de <paramref name="attributeType" />; a matriz está vazia se não houver nenhum esses atributos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />não é um <see cref="T:System.Type" /> objeto fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Emit.ModuleBuilder" /> atual, expressos como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
        <returns>Uma lista genérica de <see cref="T:System.Reflection.CustomAttributeData" /> objetos que representam dados sobre os atributos que foram aplicados ao módulo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para examinar os atributos personalizados de código no contexto exclusivo de reflexão, em casos onde os atributos personalizados próprios são definidos no código que é carregado no contexto exclusivo de reflexão. Métodos como <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> não pode ser usado em tais casos, porque eles criar instâncias dos atributos. O código no contexto exclusivo de reflexão não pode ser executado. Para obter mais informações e como código, consulte o <xref:System.Reflection.CustomAttributeData> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">O nome do campo.</param>
        <param name="bindingAttr">Uma combinação da <see langword="BindingFlags" /> bit sinalizadores usados para controlar a pesquisa.</param>
        <summary>Retorna um campo de nível de módulo, definido na região de .sdata o arquivo executável portátil (PE), que tem o nome especificado e os atributos de associação.</summary>
        <returns>Um campo que tem o nome especificado e os atributos de associação, ou <see langword="null" /> se o campo não existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você emite assemblies dinâmicos, os campos na região .sdata do arquivo PE (executável portátil) são definidos usando o <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> ou <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> métodos.  
  
> [!IMPORTANT]
>  Campos de nível de módulo não podem ser recuperados até depois que o <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> método foi chamado para o módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Uma combinação da <see langword="BindingFlags" /> bit sinalizadores usados para controlar a pesquisa.</param>
        <summary>Retorna todos os campos definidos na região .sdata do arquivo PE (executável portátil) que correspondem os sinalizadores de associação especificada.</summary>
        <returns>Uma matriz de campos que coincidam com os sinalizadores especificados; a matriz está vazia se não existir nenhum esse campo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você emite assemblies dinâmicos, os campos na região .sdata do arquivo PE (executável portátil) são definidos usando o <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> ou <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> métodos.  
  
> [!IMPORTANT]
>  Campos de nível de módulo não podem ser recuperados até depois que o <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> método foi chamado para o módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldToken GetFieldToken (System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.FieldToken GetFieldToken(class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="field">O campo para obter um token.</param>
        <summary>Retorna o token usado para identificar o campo especificado neste módulo.</summary>
        <returns>O token usado para identificar o campo especificado neste módulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método.</param>
        <param name="bindingAttr">Uma combinação de <see langword="BindingFlags" /> bit sinalizadores usados para controlar a pesquisa.</param>
        <param name="binder">Um objeto que implementa <see langword="Binder" />, contendo as propriedades relacionadas a este método.</param>
        <param name="callConvention">A convenção de chamada para o método.</param>
        <param name="types">Os tipos de parâmetro do método.</param>
        <param name="modifiers">Uma matriz de modificadores de parâmetro usados para fazer a associação funcionar com assinaturas de parâmetro nos quais os tipos foram modificados.</param>
        <summary>Retorna o método de nível de módulo que corresponde aos critérios especificados.</summary>
        <returns>Um método que é definido no nível de módulo e corresponde aos critérios especificados; ou <see langword="null" /> se tal método não existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fornece a implementação para todas as sobrecargas do herdadas <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> método. Use o herdadas <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> método para obter os métodos que foram declarados no nível de módulo. Métodos de nível de módulo são definidos no código emitido por meio de <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> método.  
  
> [!IMPORTANT]
>  Métodos de nível de módulo não podem ser recuperados até depois que o <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> método foi chamado para o módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or an element of <paramref name="types" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Uma combinação de <see langword="BindingFlags" /> bit sinalizadores usados para controlar a pesquisa.</param>
        <summary>Retorna todos os métodos que foram definidos no nível de módulo atual <see cref="T:System.Reflection.Emit.ModuleBuilder" />, e que corresponde os sinalizadores de associação especificada.</summary>
        <returns>Uma matriz que contém todos os métodos de nível de módulo que correspondem a <paramref name="bindingFlags" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Métodos de nível de módulo são definidos no código emitido por meio de <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> método.  
  
> [!IMPORTANT]
>  Métodos de nível de módulo não podem ser recuperados até depois que o <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> método foi chamado para o módulo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="method">O método para obter um token.</param>
        <summary>Retorna o token usado para identificar o método especificado neste módulo.</summary>
        <returns>O token usado para identificar o método especificado neste módulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo de declaração para o método não é neste módulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="method">O método para obter um token.</param>
        <param name="optionalParameterTypes">Uma coleção dos tipos de parâmetros opcionais para o método.</param>
        <summary>Retorna o token usado para identificar o método que tem os atributos especificados e os tipos de parâmetro neste módulo.</summary>
        <returns>O token usado para identificar o método especificado neste módulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo de declaração para o método não é neste módulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public override void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">Quando este método retorna, uma combinação dos valores <see cref="T:System.Reflection.PortableExecutableKinds" /> indicando a natureza do código no módulo.</param>
        <param name="machine">Quando este método retorna, um dos valores <see cref="T:System.Reflection.ImageFileMachine" /> indicando a plataforma de destino no módulo.</param>
        <summary>Obtém um par de valores que indica a natureza do código em um módulo e a plataforma de destino do módulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para módulos dinâmicos, `peKind` é sempre <xref:System.Reflection.PortableExecutableKinds?displayProperty=nameWithType> e `machine` é sempre 0 (zero).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (System.Reflection.Emit.SignatureHelper sigHelper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(class System.Reflection.Emit.SignatureHelper sigHelper) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigHelper" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="sigHelper">A assinatura.</param>
        <summary>Define um token para a assinatura que é definido por especificado <see cref="T:System.Reflection.Emit.SignatureHelper" />.</summary>
        <returns>Um token para a assinatura definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método define um token de metadados para a assinatura descrito pelo `sigHelper`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigHelper" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (byte[] sigBytes, int sigLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(unsigned int8[] sigBytes, int32 sigLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigBytes" Type="System.Byte[]" />
        <Parameter Name="sigLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sigBytes">O assinatura objeto binário grande (BLOB).</param>
        <param name="sigLength">O comprimento da assinatura de BLOB.</param>
        <summary>Define um token para a assinatura que tem o comprimento de matriz e assinatura do caractere especificado.</summary>
        <returns>Um token para a assinatura especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigBytes" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> objeto correspondente ao certificado incluído na assinatura Authenticode do assembly do qual este módulo pertence. Se o assembly não foi assinado, por Authenticode <see langword="null" /> é retornado.</summary>
        <returns>Um certificado ou <see langword="null" /> se o assembly ao qual pertence este módulo não foi assinado por Authenticode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStringConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.StringToken GetStringConstant (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.StringToken GetStringConstant(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.StringToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres a serem adicionados ao pool de constante do módulo.</param>
        <summary>Retorna o token de cadeia de caracteres especificada no pool de constante do módulo.</summary>
        <returns>O token da cadeia de caracteres no pool de constante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `str` já foi definido, o token existente será retornado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSymWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o gravador de símbolo associado a esse módulo dinâmico.</summary>
        <returns>O gravador de símbolo associado a esse módulo dinâmico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">O nome do <see cref="T:System.Type" /> obter.</param>
        <summary>Obtém o tipo nomeado definido no módulo.</summary>
        <returns>O tipo solicitado, se o tipo é definido neste módulo; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use esse método para gerar tipos de matriz, tipos de ponteiro ou tipos byref. Use o <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> métodos em vez disso.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">A solicitação <see cref="T:System.Type" /> é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para mostrar os objetos não-públicos fora do assembly atual.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">Um erro ao carregar o <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">O nome do <see cref="T:System.Type" /> obter.</param>
        <param name="ignoreCase">Se <see langword="true" />, a pesquisa diferencia maiusculas de minúsculas. Se <see langword="false" />, a pesquisa diferencia maiusculas de minúsculas.</param>
        <summary>Obtém o tipo nomeado definido no módulo, opcionalmente, ignorando maiusculas do nome do tipo.</summary>
        <returns>O tipo solicitado, se o tipo é definido neste módulo; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use esse método para gerar tipos de matriz, tipos de ponteiro ou tipos byref. Use o <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> métodos em vez disso.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">A solicitação <see cref="T:System.Type" /> é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para mostrar os objetos não-públicos fora do assembly atual.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">O nome do <see cref="T:System.Type" /> obter.</param>
        <param name="throwOnError">
          <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</param>
        <param name="ignoreCase">Se <see langword="true" />, a pesquisa diferencia maiusculas de minúsculas. Se <see langword="false" />, a pesquisa diferencia maiusculas de minúsculas.</param>
        <summary>Obtém o tipo nomeado definido no módulo, opcionalmente, ignorando maiusculas do nome do tipo. Opcionalmente, gera uma exceção se o tipo não for encontrado.</summary>
        <returns>O tipo especificado, se o tipo é declarado neste módulo; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `throwOnError` parâmetro afeta somente o que acontece quando o tipo não foi encontrado. Ele não afeta todas as exceções que podem ser geradas. Em particular, se o tipo é encontrado, mas não pode ser carregado, <xref:System.TypeLoadException> pode ser acionada mesmo se `throwOnError` é `false`.  
  
 Não use esse método para gerar tipos de matriz, tipos de ponteiro ou tipos byref. Use o <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> métodos em vez disso.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Comprimento de <paramref name="className" /> é igual a zero ou maior que 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">A solicitação <see cref="T:System.Type" /> é não público e o chamador não tem <see cref="T:System.Security.Permissions.ReflectionPermission" /> para mostrar os objetos não-públicos fora do assembly atual.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />é <see langword="true" /> e o tipo especificado não foi encontrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todas as classes definidas neste módulo.</summary>
        <returns>Uma matriz que contém os tipos definidos dentro do módulo que é refletido por esta instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException`é uma exceção de carregamento de classe especial. O `ReflectionTypeLoadException.Types` propriedade contém a matriz de classes que foram definidos no módulo e carregados. Esta matriz pode conter alguns valores nulos. O `ReflectionTypeLoadException.LoaderExceptions` propriedade é uma matriz de exceções que representam as exceções que foram lançadas pelo carregador de classes. Falhas na matriz de classe alinharem com as exceções.  
  
 Por exemplo, se os inicializadores de classe de uma das classes de lançar uma exceção enquanto ele está sendo carregado, um `TargetInvocationException` é armazenado no elemento correspondente a `LoaderExceptions` matriz.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Uma ou mais classes em um módulo não puderam ser carregadas.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome da classe, incluindo o namespace.</param>
        <summary>Retorna o token usado para identificar o tipo com o nome especificado.</summary>
        <returns>O token usado para identificar o tipo com o nome especificado neste módulo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é útil para clientes de <xref:System.Reflection.Emit.MethodRental> classe que deseja modificar diretamente o corpo de um método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é a cadeia de caracteres vazia ("").  
  
 -ou-  
  
 <paramref name="name" />representa um <see langword="ByRef" /> tipo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 O tipo especificado pelo <paramref name="name" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.InvalidOperationException">Este é um módulo não temporário que faz referência a um módulo temporário.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O objeto de tipo que representa o tipo de classe.</param>
        <summary>Retorna o token usado para identificar o tipo especificado neste módulo.</summary>
        <returns>O token usado para identificar o tipo fornecido neste módulo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokens são usados nas instruções de linguagem intermediária (MSIL) da Microsoft para identificar objetos. Tokens são relativas ao módulo no qual elas são contidas. Por exemplo, o valor do token para `String` provavelmente será diferente para cada módulo. Quando `GetTypeToken` é invocado, uma referência é adicionada para o módulo. A referência se torna parte permanente do módulo; várias chamadas com o mesmo argumento não têm nenhum efeito adicional.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> é um tipo <see langword="ByRef" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Este é um módulo não temporário que faz referência a um módulo temporário.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">O tipo de atributo personalizado para testar.</param>
        <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
        <summary>Retorna um valor que indica se o tipo de atributo especificado foi aplicado a este módulo.</summary>
        <returns>
          <see langword="true" />Se uma ou mais instâncias de <paramref name="attributeType" /> foram aplicadas a este módulo; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />não é um <see cref="T:System.Type" /> objeto fornecido pelo tempo de execução. Por exemplo, <paramref name="attributeType" /> é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public override bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se o objeto é um recurso.</summary>
        <returns>
          <see langword="true" />Se o objeto é um recurso. Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransient">
      <MemberSignature Language="C#" Value="public bool IsTransient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsTransient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsTransient" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se este módulo dinâmico é transitório.</summary>
        <returns>
          <see langword="true" />Se esse módulo dinâmico é transitório; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public override int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a versão de fluxo de metadados.</summary>
        <value>Um inteiro de 32 bits que representa a versão de fluxo de metadados. Os dois bytes de ordem superior representam o número de versão principal e as ordem inferior dois bytes representam o número de versão secundária.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter mais informações sobre o cabeçalho de metadados, consulte "Partição II: metadados definição e semântica" na documentação do Common Language Infrastructure (CLI). A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um token que identifica o módulo dinâmico atual nos metadados.</summary>
        <value>Um token de número inteiro que identifica o módulo atual nos metadados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os símbolos obtidos usando essa propriedade podem ser passados para a API não gerenciada de reflexão. Para obter mais informações, consulte [API não gerenciada de reflexão](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).  
  
> [!NOTE]
>  Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public override Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um UUID (identificador universal exclusivo) que pode ser usado para distinguir entre duas versões de um módulo.</summary>
        <value>Um <see cref="T:System.Guid" /> que pode ser usado para distinguir entre duas versões de um módulo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em metadados não gerenciado, o GUID retornado pelo <xref:System.Reflection.Module.ModuleVersionId%2A> propriedade é conhecida como o `mvid`e é armazenado no heap de GUID.  
  
> [!NOTE]
>  Para obter mais informações sobre metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uma cadeia de caracteres que indica que este é um módulo de memória.</summary>
        <value>Texto que indica que este é um módulo de memória.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não é possível obter o nome de um módulo dinâmico até que o módulo foi salvo e recarregado do disco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Um token de metadados que identifica um campo no módulo.</param>
        <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
        <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
        <summary>Retorna o campo identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificado.</summary>
        <returns>Um <see cref="T:System.Reflection.FieldInfo" /> objeto que representa o campo que é identificado pelo token de metadados especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método do tipo onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. Use o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método no método onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.  
  
> [!NOTE]
>  Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />não é um token para um campo no escopo do módulo atual.  
  
 -ou-  
  
 <paramref name="metadataToken" />identifica um campo cujo pai <see langword="TypeSpec" /> tem uma assinatura que contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico), e os argumentos de tipo genérico necessários não foram fornecidos para um ou ambos <paramref name="genericTypeArguments" /> e <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Um token de metadados que identifica um tipo ou membro no módulo.</param>
        <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
        <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
        <summary>Retorna o tipo ou membro identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificado.</summary>
        <returns>Um <see cref="T:System.Reflection.MemberInfo" /> objeto que representa o tipo ou membro que é identificado pelo token de metadados especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método do tipo onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. Use o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método no método onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.  
  
> [!NOTE]
>  Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />não é um token para um tipo ou membro no escopo do módulo atual.  
  
 -ou-  
  
 <paramref name="metadataToken" />é um <see langword="MethodSpec" /> ou <see langword="TypeSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico), e os argumentos de tipo genérico necessários não foram fornecidos para um ou ambos <paramref name="genericTypeArguments" /> e <paramref name="genericMethodArguments" />.  
  
 -ou-  
  
 <paramref name="metadataToken" />identifica uma propriedade ou evento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Um token de metadados que identifica um método ou um construtor no módulo.</param>
        <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
        <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
        <summary>Retorna o método ou o construtor identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificados.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.MethodBase" /> que representa o método que é identificado pelo token de metadados especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método do tipo onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. Use o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método no método onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericMethodArguments`. É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.  
  
> [!NOTE]
>  Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> não é um token de um método ou construtor no escopo do módulo atual.  
  
 -ou-  
  
 <paramref name="metadataToken" /> é um <see langword="MethodSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" />, ou para ambos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public override byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Um token de metadados que identifica uma assinatura no módulo.</param>
        <summary>Retorna o blob de assinatura identificado por um token de metadados.</summary>
        <returns>Uma matriz de bytes que representa o blob de assinatura.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informações sobre assinaturas e tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />não é válido <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, assinatura, ou <see langword="FieldDef" /> token no escopo do módulo atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public override string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Um token de metadados que identifica uma cadeia de caracteres no heap de cadeia de caracteres do módulo.</param>
        <summary>Retorna a cadeia de caracteres identificada pelo token de metadados especificado.</summary>
        <returns>Um <see cref="T:System.String" /> que contém um valor de cadeia de caracteres do heap de cadeia de caracteres de metadados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />não é um token para uma cadeia de caracteres no escopo do módulo atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public override Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Um token de metadados que identifica um tipo no módulo.</param>
        <param name="genericTypeArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do tipo em que o token está no escopo ou <see langword="null" /> se esse tipo não for genérico.</param>
        <param name="genericMethodArguments">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo genérico do método em que o token está no escopo ou <see langword="null" /> se esse método não for genérico.</param>
        <summary>Retorna o tipo identificado pelo token de metadados especificado, no contexto definido pelos parâmetros de tipo genérico especificado.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa o tipo que é identificado pelo token de metadados especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método do tipo onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. Use o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> método no método onde `metadataToken` está no escopo para obter uma matriz de argumentos de tipo genérico para `genericTypeArguments`. É sempre seguro fornecer esses argumentos, mesmo quando eles não são necessários.  
  
> [!NOTE]
>  Informações sobre tokens de metadados podem ser encontradas na documentação do Common Language Infrastructure (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Web de ECMA.  
  
 Para o código que demonstra a resolução de token usando o contexto genérico (ou seja, os parâmetros de tipo genérico do tipo genérico e/ou o método genérico na qual o token é incorporado) consulte o <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />não é um token para um tipo no escopo do módulo atual.  
  
 -ou-  
  
 <paramref name="metadataToken" /> é um <see langword="TypeSpec" /> cuja assinatura contém o tipo de elemento <see langword="var" /> (um parâmetro de tipo de um tipo genérico) ou <see langword="mvar" /> (um parâmetro de tipo de um método genérico) e os argumentos de tipo genérico necessários não foram fornecidos para <paramref name="genericTypeArguments" /> ou <paramref name="genericMethodArguments" />, ou para ambos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> não é um token válido no escopo do módulo atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public override string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma cadeia de caracteres que representa o nome do módulo dinâmico.</summary>
        <value>O nome do módulo dinâmico.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Uma instância de uma classe auxiliar que especifica o atributo personalizado para aplicar.</param>
        <summary>Aplica-se um atributo personalizado para esse módulo usando um construtor de atributo personalizado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">O construtor para o atributo personalizado.</param>
        <param name="binaryAttribute">Um blob que representa o atributo.</param>
        <summary>Aplica-se um atributo personalizado para esse módulo usando um especificado objeto binário grande (BLOB) que representa o atributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como formatar `binaryAttribute`, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do atributo personalizado</param>
        <param name="data">Um opaco objeto binário grande (BLOB) de bytes que representa o valor do atributo personalizado.</param>
        <summary>Esse método não fará nada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não fará nada.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public void SetUserEntryPoint (System.Reflection.MethodInfo entryPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetUserEntryPoint(class System.Reflection.MethodInfo entryPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryPoint" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryPoint">O ponto de entrada do usuário.</param>
        <summary>Define o ponto de entrada do usuário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O compilador pode gerar um stub de inicialização antes de chamar o usuário principal. O stub de inicialização será o ponto de entrada. Enquanto o usuário principal será o ponto de entrada do usuário para que o depurador não irá passar para o ponto de entrada do compilador.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryPoint" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método é chamado em um módulo dinâmico não é um módulo de depuração.  
  
 -ou-  
  
 <paramref name="entryPoint" />não é contido neste módulo dinâmico.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Reflection.Emit.ModuleBuilder> é convertida em uma interface de <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">O método é chamado de associação tardia usando o COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Reflection.Emit.ModuleBuilder> é convertida em uma interface de <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">O método é chamado de associação tardia usando o COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">O local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Reflection.Emit.ModuleBuilder> é convertida em uma interface de <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">O método é chamado de associação tardia usando o COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">A ID do membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Reflection.Emit.ModuleBuilder> é convertida em uma interface de <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">O método é chamado de associação tardia usando o COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
