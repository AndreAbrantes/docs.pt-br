<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um armazenamento estruturado em log.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Log.LogRecordSequence> classe fornece uma implementação da interface de sequência do registro na parte superior de um log de sistema de arquivos de Log comuns (CLFS). Ele funciona com o <xref:System.IO.Log.LogStore> classe, que fornece uma interface para diretamente manipular e gerenciando um CLFS o arquivo de log. Um repositório de log fornece armazenamento somente de acréscimo em um conjunto de extensões do disco. O <xref:System.IO.Log.LogStore> classe representa o armazenamento e fornece métodos para adicionar e remover contêineres, configuração de política e criando arquivos. Ele não fornece métodos para leitura e gravação para o armazenamento; Esses métodos são fornecidos pelo <xref:System.IO.Log.LogRecordSequence> classe.  
  
 A relação entre o <xref:System.IO.Log.LogStore> classe e o <xref:System.IO.Log.LogRecordSequence> classe é semelhante à relação entre um arquivo de disco e um <xref:System.IO.FileStream> objeto. O arquivo de disco fornece o armazenamento real e tem atributos como comprimento e a hora do último acesso, enquanto o <xref:System.IO.FileStream> objeto fornece uma exibição no arquivo que pode ser usado para lê-lo e gravar nele. Da mesma forma, o <xref:System.IO.Log.LogStore> classe tem atributos como uma diretiva e uma coleção de extensões do disco e o <xref:System.IO.Log.LogRecordSequence> classe fornece um mecanismo orientado por registro para ler e gravar dados.  
  
 Ao contrário a sequência de registro de arquivo representada pelo <xref:System.IO.Log.FileRecordSequence> classe, uma <xref:System.IO.Log.LogStore> instância armazena seus dados em uma coleção de extensões do disco, representado pelo <xref:System.IO.Log.LogExtent> instâncias. As extensões em um determinado <xref:System.IO.Log.LogStore> instância são de tamanho uniforme, e espaço é adicionado a e removido de um <xref:System.IO.Log.LogStore> instância em incrementos de extensão. Para adicionar e remover extensões de log, use o <xref:System.IO.Log.LogExtentCollection.Add%2A> e <xref:System.IO.Log.LogExtentCollection.Remove%2A> métodos do <xref:System.IO.Log.LogExtentCollection> objeto, que pode ser retornado pelo <xref:System.IO.Log.LogStore.Extents%2A> propriedade.  
  
 Um <xref:System.IO.Log.LogStore> instância pode ter políticas associadas a ele. Esses são representados pelo <xref:System.IO.Log.LogPolicy> instâncias que podem ser retornadas pelo <xref:System.IO.Log.LogStore.Policy%2A> propriedade. Uma política impõe regras que o log tentará a seguir, como o número máximo de extensões e o tamanho mínimo e instruções sobre aumentando ou diminuindo o <xref:System.IO.Log.LogStore> sob determinadas condições. Além disso, você pode especificar se um <xref:System.IO.Log.LogStore> instância pode ser arquivada. Políticas são definidas por log e são voláteis, o que significa que quando cada identificador para o log é fechada, a política não existe mais.  
  
   
  
## Examples  
 O exemplo a seguir mostra como arquivar um <xref:System.IO.Log.LogStore> para um documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o log de arquivo atual <see cref="T:System.IO.Log.LogStore" /> encapsula o objeto.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.Log.LogStore" /> classe para o identificador especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">O identificador do log não pôde ser associado ao pool de threads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir.</param>
        <param name="mode">Uma da <see cref="T:System.IO.FileMode" /> valores que determina como abrir ou criar o repositório.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.Log.LogStore" /> classe com o caminho especificado e o modo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor para abrir um repositório de log com o caminho especificado e o modo. O armazenamento é aberto com acesso de leitura/gravação e compartilha o acesso de leitura.  
  
 O `path` parâmetro deve usar a seguinte sintaxe:  
  
 `log:<physical log name>[::<log client name>]`  
  
 onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.  
  
 Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
 -ou-  
  
 <paramref name="path" />contém somente espaços em branco.  
  
 -ou-  
  
 <paramref name="path" />contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao abrir o armazenamento de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" />não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <see cref="T:System.IO.Log.FileRecordSequence" /> classe em vez disso.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir.</param>
        <param name="mode">Uma da <see cref="T:System.IO.FileMode" /> valores que determina como abrir ou criar o repositório.</param>
        <param name="access">Uma da <see cref="T:System.IO.FileAccess" /> valores que determina como o arquivo pode ser acessado pelo <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.Log.LogStore" /> classe com o caminho especificado, o modo e o acesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor para abrir um novo armazenamento de log com o caminho especificado, o modo e o acesso. O armazenamento é aberto com o compartilhamento de acesso de leitura.  
  
 O `path` parâmetro deve usar a seguinte sintaxe:  
  
 `log:<physical log name>[::<log client name>]`  
  
 onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.  
  
 Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
 -ou-  
  
 <paramref name="path" />contém somente espaços em branco.  
  
 -ou-  
  
 <paramref name="path" />contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.  
  
 -ou  
  
 <paramref name="access" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao abrir o armazenamento de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" />não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <see cref="T:System.IO.Log.FileRecordSequence" /> classe em vez disso.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir.</param>
        <param name="mode">Uma da <see cref="T:System.IO.FileMode" /> valores que determina como abrir ou criar o repositório.</param>
        <param name="access">Uma da <see cref="T:System.IO.FileAccess" /> valores que determina como o arquivo pode ser acessado pelo <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Uma da <see cref="T:System.IO.FileShare" /> valores que determina como o armazenamento de log será compartilhado entre processos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um novo <xref:System.IO.Log.LogStore> objeto que ele é aberto com o caminho especificado, o modo e o acesso. O armazenamento é aberto com o compartilhamento de acesso especificado.  
  
 O `path` parâmetro deve usar a seguinte sintaxe:  
  
 `log:<physical log name>[::<log client name>]`  
  
 onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.  
  
 Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
 -ou-  
  
 <paramref name="path" />contém somente espaços em branco.  
  
 -ou-  
  
 <paramref name="path" />contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.  
  
 -ou  
  
 <paramref name="access" /> contém um valor inválido.  
  
 -ou-  
  
 <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao abrir o armazenamento de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" />não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <see cref="T:System.IO.Log.FileRecordSequence" /> classe em vez disso.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir.</param>
        <param name="mode">Uma da <see cref="T:System.IO.FileMode" /> valores que determina como abrir ou criar o repositório.</param>
        <param name="access">Uma da <see cref="T:System.IO.FileAccess" /> valores que determina como o arquivo pode ser acessado pelo <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Uma da <see cref="T:System.IO.FileShare" /> valores que determina como o armazenamento de log será compartilhado entre processos.</param>
        <param name="fileSecurity">Uma da <see cref="T:System.Security.AccessControl.FileSecurity" /> valor que especifica a segurança definida no repositório de recém-criado se o repositório deve ser criado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um novo <xref:System.IO.Log.LogStore> objeto que ele é aberto com o caminho especificado, o modo e o acesso. O armazenamento é aberto com o compartilhamento de acesso especificado. O `path` parâmetro deve seguir a sintaxe a seguir:  
  
 `log:<physical log name>[::<log client name>]`  
  
 onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.  
  
 Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do arquivo de armazenamento de log especificado pelo <paramref name="path" /> não é válido.  
  
 -ou-  
  
 <paramref name="Mode" />é <see langword="CreateNew" />, que não pode ser usado sem acesso de gravação.  
  
 -ou-  
  
 <paramref name="Mode" />é <see langword="OpenOrCreate" />, que não pode ser usado sem acesso de gravação.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.  
  
 -ou  
  
 <paramref name="access" /> contém um valor inválido.  
  
 -ou-  
  
 <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao abrir o armazenamento de log.  
  
 O arquivo especificado por <paramref name="path" /> não pode ser acessado porque está em uso por outro processo.  
  
 -ou-  
  
 O arquivo especificado por <paramref name="path" /> não pode ser criado porque o arquivo ou diretório já existe.  
  
 -ou-  
  
 O identificador do log não pôde ser associado ao pool de threads.  
  
 -ou-  
  
 A versão ou o formato de arquivo de log especificado é inválido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" />não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <see cref="T:System.IO.Log.FileRecordSequence" /> classe em vez disso.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro está cheia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este <see cref="T:System.IO.Log.LogStore" /> instância pode ser arquivada.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.IO.Log.LogStore" /> instância pode ser arquivado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um <xref:System.IO.Log.LogStore> não é arquivável, chamadas para o <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> e <xref:System.IO.Log.LogStore.SetArchiveTail%2A> métodos resultam em um <xref:System.NotSupportedException> que está sendo gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de sequência mais baixo que corresponde a um registro válido neste <see cref="T:System.IO.Log.LogStore" /> instância.</summary>
        <value>O número de sequência mais baixo que corresponde a um registro válido neste <see cref="T:System.IO.Log.LogStore" /> instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números de sequência são maiores que ou igual a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tira um instantâneo do estado do repositório de log para fazer um backup.</summary>
        <returns>Um <see cref="T:System.IO.Log.LogArchiveSnapshot" /> objeto que contém o estado necessário para tornar um arquivo morto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como arquivar um <xref:System.IO.Log.LogStore> para um documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O armazenamento de log não é arquivável.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao criar o instantâneo de arquivo.</exception>
        <exception cref="T:System.ArgumentException">Um argumento não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi executada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro está cheia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">O sequência número inicial no intervalo para arquivamento.</param>
        <param name="last">O sequência número final no intervalo para arquivar.</param>
        <summary>Tira um instantâneo do estado do repositório de log entre os números de sequência especificado para fazer um backup.</summary>
        <returns>Um <see cref="T:System.IO.Log.LogArchiveSnapshot" /> objeto que contém o estado necessário para tornar um arquivo morto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O instantâneo de arquivo retornado deste método abrange informações sobre o número de sequência de base ou o número de sequência de arquivo, o que for menor, para o último número de sequência. Não é inclusivo para o último número de sequência, o que significa que o arquivo contém somente registros até, mas não incluindo a última. Além disso, ao usar esse método, o início SequenceNumber deve ser igual de BaseSequenceNumber para que o arquivo para ser consistente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="first" />ou <paramref name="last" /> não está entre os números de base e última sequência dessa sequência.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="first" /> é maior que <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi executada.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao criar o instantâneo de arquivo.</exception>
        <exception cref="T:System.NotSupportedException">O armazenamento de log não é arquivável.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro está cheia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para remover.</param>
        <summary>Remove o armazenamento de log.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
 -ou-  
  
 <paramref name="path" />contém somente espaços em branco.  
  
 -ou-  
  
 <paramref name="path" />contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao abrir o armazenamento de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.IO.Log.LogStore.Dispose%2A> quando terminar de usar o <xref:System.IO.Log.LogStore>. O <xref:System.IO.Log.LogStore.Dispose%2A> método deixa o <xref:System.IO.Log.LogStore> em um estado inutilizável. Depois de chamar <xref:System.IO.Log.LogStore.Dispose%2A> , você deve liberar todas as referências para o <xref:System.IO.Log.LogStore> para o coletor de lixo possa recuperar a memória que o <xref:System.IO.Log.LogStore> estava ocupando.  
  
> [!NOTE]
>  Sempre chamar <xref:System.IO.Log.LogStore.Dispose%2A> antes de liberar sua última referência para o <xref:System.IO.Log.LogStore>. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.IO.Log.LogStore> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de extensões de log que contêm os dados para este armazenamento de log.</summary>
        <value>Um <see cref="T:System.IO.Log.LogExtentCollection" /> instância que contém a coleção de extensões de log que encapsula dados para este armazenamento de log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.IO.Log.LogStore> instância armazena seus dados em uma coleção de extensões do disco, representado pelo <xref:System.IO.Log.LogExtent> instâncias. As extensões em um determinado <xref:System.IO.Log.LogStore> instância são de tamanho uniforme, e espaço é adicionado a e removido de um <xref:System.IO.Log.LogStore> instância em incrementos de extensão. Para adicionar e remover extensões de log, use o <xref:System.IO.Log.LogExtentCollection.Add%2A> e <xref:System.IO.Log.LogExtentCollection.Remove%2A> métodos do <xref:System.IO.Log.LogExtentCollection> objeto, que é retornado por essa propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de bytes disponíveis no armazenamento de log.</summary>
        <value>O número de bytes disponíveis no armazenamento de log.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de arquivo do sistema operacional para o arquivo de log que atual <see cref="T:System.IO.Log.LogStore" /> instância encapsula.</summary>
        <value>O identificador de arquivo do sistema operacional para o log de arquivo atual <see cref="T:System.IO.Log.LogStore" /> instância encapsula.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o número de sequência do próximo registro a ser anexado ao armazenamento de log.</summary>
        <value>O número de sequência do próximo registro a ser anexado ao armazenamento de log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números de sequência são maiores que ou igual a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho do armazenamento de log, em bytes.</summary>
        <value>O tamanho do armazenamento de log, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do armazenamento de log é a soma dos tamanhos das extensões do log.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a política associada a este armazenamento de log.</summary>
        <value>Um <see cref="T:System.IO.Log.LogPolicy" /> instância que representa a política associada a este armazenamento de log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.IO.Log.LogPolicy> instância retornada por esta propriedade para examinar e manipular a diretiva de log associada a esta <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">O número de sequência de final do arquivo.</param>
        <summary>Define o número de sequência de final do arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O menor o número de sequência de base e o final do arquivo determina o final do log.  
  
   
  
## Examples  
 O exemplo a seguir mostra como arquivar um <xref:System.IO.Log.LogStore> para um documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" />não está entre os números de base e última sequência dessa sequência.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="archiveTail" />não é válido para essa sequência.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi executada.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de e/s ao criar o instantâneo de arquivo.</exception>
        <exception cref="T:System.NotSupportedException">O armazenamento de log não é arquivável.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso para o armazenamento de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de fluxos de log nesse armazenamento de log.</summary>
        <value>O número de fluxos de log nesse armazenamento de log.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
